indexvar i, j ::= {{ com indices }}

grammar

T {{tex \tau }} :: 'tt_' ::= {{ com MiniJS type indices }}
  | Base    ::  :: base  {{ com base type }} {{ tex \mathbb{B} }}
  | -> T    ::  :: arrow {{ com function type }} {{ tex \overrightarrow{[[T]]} }}
  | T1 & T2 ::  :: and   {{ com intersection type }}
  | | A |   :: M:: translation {{ tex |[[A]]| }}
  | ( A )   :: S:: paren

E {{ tex \epsilon }}, V {{ tex \alpha }} :: 'ee_' ::= {{ com MiniJS expressions }}
  | b                ::  :: base   {{ com base literal }} {{ tex b }}
  | x                ::  :: var    {{ com variable }}
  | fix x . E        ::  :: fix    {{ com fixpoint }} {{ tex [[fix]]\,[[x]].\ [[E]] }}
  | \ x . E          ::  :: abs    {{ com abstraction }} {{ tex [[\]][[x]].\ [[E]] }}
  | E1 $ E2          ::  :: app    {{ com application }}
  | E1 ++ E2         ::  :: append {{ com appending }}
  | co E             ::  :: co     {{ com coercion }}
  | { </ Ti |-> Ei // ; // i /> }
                     ::  :: obj    {{ com object }}
  | {</ T |-> E />}  :: M:: obj1   {{ tex \{\overline{[[T]][[|->]][[E]]}\} }}
  | {</ T1 |-> E1 />;</ T2 |-> E2 />}
                     :: M:: obj2   {{ tex \{\overline{[[T1]][[|->]][[E1]]};\overline{[[T2]][[|->]][[E2]]}\} }}
  | {</ T1 |-> E1 />;</ T2 |-> E2 />;</ T3 |-> E3 />}
                     :: M:: obj3   {{ tex \{\overline{[[T1]][[|->]][[E1]]};[[T2]][[|->]][[E2]];\overline{[[T3]][[|->]][[E3]]}\} }}
  | E1 [ x ~> E2 ]   :: M:: subst
  | ( E )            :: S:: paren

co :: 'co_' ::= {{ com coercion }}
  | identity         ::  :: identity
  | clear            ::  :: clear
  | becard T co1 co2 ::  :: becard   {{ tex [[becard]]_{[[T]]}\,[[co1]]\,[[co2]] }}
  | proj T           ::  :: project  {{ tex \Pi_{[[T]]} }}
  | co1 <> co2       ::  :: append   {{ tex [[co1]]\diamond[[co2]] }}
  | co2 . co1        ::  :: compose  {{ tex [[co2]]\circ[[co1]] }}
  | ( co )           :: S:: paren



defns
Coercion :: '' ::=

defn
A <: B ~~> co :: :: cosub :: CS_
{{ com Coercive subtyping }}
{{ tex [[A]][[<:]][[B]]\;\colorbox{lightgray}{$[[~~>]][[co]]$} }}
by


------------------- :: refl
A <: A ~~> identity


toplike B
---------------- :: top
A <: B ~~> clear


B1 <: A1 ~~> co1
A2 <: B2 ~~> co2
-------------------------------------------- :: arrow
A1 -> A2 <: B1 -> B2 ~~> becard |B2| co1 co2


A <: C ~~> co
---------------------------- :: andLL
A & B <: C ~~> co . proj |A|


B <: C ~~> co
---------------------------- :: andLR
A & B <: C ~~> co . proj |B|


A <: B ~~> co1
A <: C ~~> co2
------------------------- :: andR
A <: B & C ~~> co1 <> co2


defn
co E ==> V :: :: coeval :: CE_
{{ com Coercion evaluation }}
by


E ==> V
---------------- :: identity
identity E ==> V


-------------- :: clear
clear E ==> {}


-------------------------------------------------------- :: becard
(becard T co1 co2) E ==> { ->T |-> \x. co2 (E $ co1 x) }


E ==> {</ Ti |-> Ei />;</ T |-> E' />;</ Tj |-> Ej />}
----------------------------------------------------- :: project
proj T E ==> { T |-> E' }


co1 E ==> V1
co2 E ==> V2
--------------------------- :: append
(co1 <> co2) E ==> V1 ++ V2


co1 E ==> V1
co2 V1 ==> V2
-------------------- :: compose
(co2 . co1) E ==> V2



defns
Compilation :: '' ::=

defn
G |- e mode A ~~> E :: :: compile :: T_
{{ com Type-directed compilation }}
{{ tex [[G]][[|-]][[e]][[mode]][[A]]\;\colorbox{lightgray}{$[[~~>]][[E]]$} }}
by


--------------------- :: top
G |- () => Top ~~> {}


--------------------------------- :: base
G |- b => Base ~~> { Base |-> b }


x : A in G
----------------- :: var
G |- x => A ~~> x


G, x:A |- e <= A ~~> E
--------------------------------- :: fix
G |- fix x:A. e => A ~~> fix x. E


not toplike B
G, x:A |- e <= B ~~> E
---------------------------------------------- :: abs
G |- \x:A. e:B => A->B ~~> { ->|B| |-> \x. E }


toplike B
----------------------------- :: absTop
G |- \x:A. e:B => A->B ~~> {}


G |- e1 => A -> B ~~> E1
G |- e2 <= A ~~> E2
--------------------------- :: app
G |- e1 e2 => B ~~> E1 $ E2


G |- e1 => Top ~~> {}
------------------------ :: appTop
G |- e1 e2 => Top ~~> {}


G |- e1 => A ~~> E1
G |- e2 => B ~~> E2
A * B
----------------------------------- :: merge
G |- e1 ,, e2 => A & B ~~> E1 ++ E2


G |- e <= A ~~> E
------------------- :: anno
G |- e:A => A ~~> E


G |- e => A ~~> E
A <: B ~~> co
-------------------- :: sub
G |- e <= B ~~> co E



defn
E ==> V :: :: eval :: E_
{{ com Big-step operational semantics }}
by


E [x ~> fix x. E] ==> V
----------------------- :: fix
fix x. E ==> V


E1 ==> { ->T |-> \x. E1' }
E2 ==> V2
E1' [x ~> V2] ==> V
-------------------------- :: app
E1 $ E2 ==> V


E1 ==> {}
-------------- :: appTop
E1 $ E2 ==> {}


E1 ==> {</ Ti |-> Ei />}
E2 ==> {</ Tj |-> Ej />}
---------------------------------------------- :: merge
E1 ++ E2 ==> {</ Ti |-> Ei />;</ Tj |-> Ej />}
