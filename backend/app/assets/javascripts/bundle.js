/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var bundle;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./.spago/arrays/v6.0.1/src/Data/Array.js":
/*!************************************************!*\
  !*** ./.spago/arrays/v6.0.1/src/Data/Array.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n//------------------------------------------------------------------------------\n// Array creation --------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.range = function (start) {\n  return function (end) {\n    var step = start > end ? -1 : 1;\n    var result = new Array(step * (end - start) + 1);\n    var i = start, n = 0;\n    while (i !== end) {\n      result[n++] = i;\n      i += step;\n    }\n    result[n] = i;\n    return result;\n  };\n};\n\nvar replicateFill = function (count) {\n  return function (value) {\n    if (count < 1) {\n      return [];\n    }\n    var result = new Array(count);\n    return result.fill(value);\n  };\n};\n\nvar replicatePolyfill = function (count) {\n  return function (value) {\n    var result = [];\n    var n = 0;\n    for (var i = 0; i < count; i++) {\n      result[n++] = value;\n    }\n    return result;\n  };\n};\n\n// In browsers that have Array.prototype.fill we use it, as it's faster.\nexports.replicate = typeof Array.prototype.fill === \"function\" ? replicateFill : replicatePolyfill;\n\nexports.fromFoldableImpl = (function () {\n  function Cons(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n  var emptyList = {};\n\n  function curryCons(head) {\n    return function (tail) {\n      return new Cons(head, tail);\n    };\n  }\n\n  function listToArray(list) {\n    var result = [];\n    var count = 0;\n    var xs = list;\n    while (xs !== emptyList) {\n      result[count++] = xs.head;\n      xs = xs.tail;\n    }\n    return result;\n  }\n\n  return function (foldr) {\n    return function (xs) {\n      return listToArray(foldr(curryCons)(emptyList)(xs));\n    };\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Array size ------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.length = function (xs) {\n  return xs.length;\n};\n\n//------------------------------------------------------------------------------\n// Non-indexed reads -----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.unconsImpl = function (empty) {\n  return function (next) {\n    return function (xs) {\n      return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Indexed operations ----------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.indexImpl = function (just) {\n  return function (nothing) {\n    return function (xs) {\n      return function (i) {\n        return i < 0 || i >= xs.length ? nothing :  just(xs[i]);\n      };\n    };\n  };\n};\n\nexports.findMapImpl = function (nothing) {\n  return function (isJust) {\n    return function (f) {\n      return function (xs) {\n        for (var i = 0; i < xs.length; i++) {\n          var result = f(xs[i]);\n          if (isJust(result)) return result;\n        }\n        return nothing;\n      };\n    };\n  };\n};\n\nexports.findIndexImpl = function (just) {\n  return function (nothing) {\n    return function (f) {\n      return function (xs) {\n        for (var i = 0, l = xs.length; i < l; i++) {\n          if (f(xs[i])) return just(i);\n        }\n        return nothing;\n      };\n    };\n  };\n};\n\nexports.findLastIndexImpl = function (just) {\n  return function (nothing) {\n    return function (f) {\n      return function (xs) {\n        for (var i = xs.length - 1; i >= 0; i--) {\n          if (f(xs[i])) return just(i);\n        }\n        return nothing;\n      };\n    };\n  };\n};\n\nexports._insertAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (a) {\n        return function (l) {\n          if (i < 0 || i > l.length) return nothing;\n          var l1 = l.slice();\n          l1.splice(i, 0, a);\n          return just(l1);\n        };\n      };\n    };\n  };\n};\n\nexports._deleteAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (l) {\n        if (i < 0 || i >= l.length) return nothing;\n        var l1 = l.slice();\n        l1.splice(i, 1);\n        return just(l1);\n      };\n    };\n  };\n};\n\nexports._updateAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (a) {\n        return function (l) {\n          if (i < 0 || i >= l.length) return nothing;\n          var l1 = l.slice();\n          l1[i] = a;\n          return just(l1);\n        };\n      };\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Transformations -------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.reverse = function (l) {\n  return l.slice().reverse();\n};\n\nexports.concat = function (xss) {\n  if (xss.length <= 10000) {\n    // This method is faster, but it crashes on big arrays.\n    // So we use it when can and fallback to simple variant otherwise.\n    return Array.prototype.concat.apply([], xss);\n  }\n\n  var result = [];\n  for (var i = 0, l = xss.length; i < l; i++) {\n    var xs = xss[i];\n    for (var j = 0, m = xs.length; j < m; j++) {\n      result.push(xs[j]);\n    }\n  }\n  return result;\n};\n\nexports.filter = function (f) {\n  return function (xs) {\n    return xs.filter(f);\n  };\n};\n\nexports.partition = function (f) {\n  return function (xs) {\n    var yes = [];\n    var no  = [];\n    for (var i = 0; i < xs.length; i++) {\n      var x = xs[i];\n      if (f(x))\n        yes.push(x);\n      else\n        no.push(x);\n    }\n    return { yes: yes, no: no };\n  };\n};\n\nexports.scanl = function (f) {\n  return function (b) {\n    return function (xs) {\n      var len = xs.length;\n      var acc = b;\n      var out = new Array(len);\n      for (var i = 0; i < len; i++) {\n        acc = f(acc)(xs[i]);\n        out[i] = acc;\n      }\n      return out;\n    };\n  };\n};\n\nexports.scanr = function (f) {\n  return function (b) {\n    return function (xs) {\n      var len = xs.length;\n      var acc = b;\n      var out = new Array(len);\n      for (var i = len - 1; i >= 0; i--) {\n        acc = f(xs[i])(acc);\n        out[i] = acc;\n      }\n      return out;\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Sorting ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      }\n      else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare) {\n    return function (fromOrdering) {\n      return function (xs) {\n        var out;\n\n        if (xs.length < 2) return xs;\n\n        out = xs.slice(0);\n        mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);\n\n        return out;\n      };\n    };\n  };\n})();\n\n//------------------------------------------------------------------------------\n// Subarrays -------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.slice = function (s) {\n  return function (e) {\n    return function (l) {\n      return l.slice(s, e);\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Zipping ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.zipWith = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var l = xs.length < ys.length ? xs.length : ys.length;\n      var result = new Array(l);\n      for (var i = 0; i < l; i++) {\n        result[i] = f(xs[i])(ys[i]);\n      }\n      return result;\n    };\n  };\n};\n\n//------------------------------------------------------------------------------\n// Folding ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.any = function (p) {\n  return function (xs) {\n    var len = xs.length;\n    for (var i = 0; i < len; i++) {\n      if (p(xs[i])) return true;\n    }\n    return false;\n  };\n};\n\nexports.all = function (p) {\n  return function (xs) {\n    var len = xs.length;\n    for (var i = 0; i < len; i++) {\n      if (!p(xs[i])) return false;\n    }\n    return true;\n  };\n};\n\n//------------------------------------------------------------------------------\n// Partial ---------------------------------------------------------------------\n//------------------------------------------------------------------------------\n\nexports.unsafeIndexImpl = function (xs) {\n  return function (n) {\n    return xs[n];\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/arrays/v6.0.1/src/Data/Array.js?");

/***/ }),

/***/ "./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty/Internal.js":
/*!******************************************************************!*\
  !*** ./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty/Internal.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.foldr1Impl = function (f) {\n  return function (xs) {\n    var acc = xs[xs.length - 1];\n    for (var i = xs.length - 2; i >= 0; i--) {\n      acc = f(xs[i])(acc);\n    }\n    return acc;\n  };\n};\n\nexports.foldl1Impl = function (f) {\n  return function (xs) {\n    var acc = xs[0];\n    var len = xs.length;\n    for (var i = 1; i < len; i++) {\n      acc = f(acc)(xs[i]);\n    }\n    return acc;\n  };\n};\n\nexports.traverse1Impl = function () {\n  function Cont(fn) {\n    this.fn = fn;\n  }\n\n  var emptyList = {};\n\n  var ConsCell = function (head, tail) {\n    this.head = head;\n    this.tail = tail;\n  };\n\n  function finalCell(head) {\n    return new ConsCell(head, emptyList);\n  }\n\n  function consList(x) {\n    return function (xs) {\n      return new ConsCell(x, xs);\n    };\n  }\n\n  function listToArray(list) {\n    var arr = [];\n    var xs = list;\n    while (xs !== emptyList) {\n      arr.push(xs.head);\n      xs = xs.tail;\n    }\n    return arr;\n  }\n\n  return function (apply) {\n    return function (map) {\n      return function (f) {\n        var buildFrom = function (x, ys) {\n          return apply(map(consList)(f(x)))(ys);\n        };\n\n        var go = function (acc, currentLen, xs) {\n          if (currentLen === 0) {\n            return acc;\n          } else {\n            var last = xs[currentLen - 1];\n            return new Cont(function () {\n              var built = go(buildFrom(last, acc), currentLen - 1, xs);\n              return built;\n            });\n          }\n        };\n\n        return function (array) {\n          var acc = map(finalCell)(f(array[array.length - 1]));\n          var result = go(acc, array.length - 1, array);\n          while (result instanceof Cont) {\n            result = result.fn();\n          }\n\n          return map(listToArray)(result);\n        };\n      };\n    };\n  };\n}();\n\n\n//# sourceURL=webpack://bundle/./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty/Internal.js?");

/***/ }),

/***/ "./.spago/arrays/v6.0.1/src/Data/Array/ST.js":
/*!***************************************************!*\
  !*** ./.spago/arrays/v6.0.1/src/Data/Array/ST.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports[\"new\"] = function () {\n  return [];\n};\n\nexports.peekImpl = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (xs) {\n        return function () {\n          return i >= 0 && i < xs.length ? just(xs[i]) : nothing;\n        };\n      };\n    };\n  };\n};\n\nexports.poke = function (i) {\n  return function (a) {\n    return function (xs) {\n      return function () {\n        var ret = i >= 0 && i < xs.length;\n        if (ret) xs[i] = a;\n        return ret;\n      };\n    };\n  };\n};\n\nexports.popImpl = function (just) {\n  return function (nothing) {\n    return function (xs) {\n      return function () {\n        return xs.length > 0 ? just(xs.pop()) : nothing;\n      };\n    };\n  };\n};\n\nexports.pushAll = function (as) {\n  return function (xs) {\n    return function () {\n      return xs.push.apply(xs, as);\n    };\n  };\n};\n\nexports.shiftImpl = function (just) {\n  return function (nothing) {\n    return function (xs) {\n      return function () {\n        return xs.length > 0 ? just(xs.shift()) : nothing;\n      };\n    };\n  };\n};\n\nexports.unshiftAll = function (as) {\n  return function (xs) {\n    return function () {\n      return xs.unshift.apply(xs, as);\n    };\n  };\n};\n\nexports.splice = function (i) {\n  return function (howMany) {\n    return function (bs) {\n      return function (xs) {\n        return function () {\n          return xs.splice.apply(xs, [i, howMany].concat(bs));\n        };\n      };\n    };\n  };\n};\n\nexports.unsafeFreeze = function (xs) {\n  return function () {\n    return xs;\n  };\n};\n\nexports.unsafeThaw = function (xs) {\n  return function () {\n    return xs;\n  };\n};\n\nfunction copyImpl(xs) {\n  return function () {\n    return xs.slice();\n  };\n}\n\nexports.freeze = copyImpl;\n\nexports.thaw = copyImpl;\n\nexports.sortByImpl = (function () {\n  function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {\n    var mid;\n    var i;\n    var j;\n    var k;\n    var x;\n    var y;\n    var c;\n\n    mid = from + ((to - from) >> 1);\n    if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);\n    if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);\n\n    i = from;\n    j = mid;\n    k = from;\n    while (i < mid && j < to) {\n      x = xs2[i];\n      y = xs2[j];\n      c = fromOrdering(compare(x)(y));\n      if (c > 0) {\n        xs1[k++] = y;\n        ++j;\n      }\n      else {\n        xs1[k++] = x;\n        ++i;\n      }\n    }\n    while (i < mid) {\n      xs1[k++] = xs2[i++];\n    }\n    while (j < to) {\n      xs1[k++] = xs2[j++];\n    }\n  }\n\n  return function (compare) {\n    return function (fromOrdering) {\n      return function (xs) {\n        return function () {\n          if (xs.length < 2) return xs;\n\n          mergeFromTo(compare, fromOrdering, xs, xs.slice(0), 0, xs.length);\n\n          return xs;\n        };\n      };\n    };\n  };\n})();\n\nexports.toAssocArray = function (xs) {\n  return function () {\n    var n = xs.length;\n    var as = new Array(n);\n    for (var i = 0; i < n; i++) as[i] = { value: xs[i], index: i };\n    return as;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/arrays/v6.0.1/src/Data/Array/ST.js?");

/***/ }),

/***/ "./.spago/console/v5.0.0/src/Effect/Console.js":
/*!*****************************************************!*\
  !*** ./.spago/console/v5.0.0/src/Effect/Console.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.log = function (s) {\n  return function () {\n    console.log(s);\n  };\n};\n\nexports.warn = function (s) {\n  return function () {\n    console.warn(s);\n  };\n};\n\nexports.error = function (s) {\n  return function () {\n    console.error(s);\n  };\n};\n\nexports.info = function (s) {\n  return function () {\n    console.info(s);\n  };\n};\n\nexports.time = function (s) {\n  return function () {\n    console.time(s);\n  };\n};\n\nexports.timeLog = function (s) {\n  return function () {\n    console.timeLog(s);\n  };\n};\n\nexports.timeEnd = function (s) {\n  return function () {\n    console.timeEnd(s);\n  };\n};\n\nexports.clear = function () {\n  console.clear();\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/console/v5.0.0/src/Effect/Console.js?");

/***/ }),

/***/ "./.spago/control/v5.0.0/src/Control/Extend.js":
/*!*****************************************************!*\
  !*** ./.spago/control/v5.0.0/src/Control/Extend.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.arrayExtend = function(f) {\n  return function(xs) {\n    return xs.map(function (_, i, xs) {\n      return f(xs.slice(i));\n    });\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/control/v5.0.0/src/Control/Extend.js?");

/***/ }),

/***/ "./.spago/effect/v3.0.0/src/Effect.js":
/*!********************************************!*\
  !*** ./.spago/effect/v3.0.0/src/Effect.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.pureE = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexports.bindE = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexports.untilE = function (f) {\n  return function () {\n    while (!f());\n  };\n};\n\nexports.whileE = function (f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n};\n\nexports.forE = function (lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n};\n\nexports.foreachE = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/effect/v3.0.0/src/Effect.js?");

/***/ }),

/***/ "./.spago/enums/v5.0.0/src/Data/Enum.js":
/*!**********************************************!*\
  !*** ./.spago/enums/v5.0.0/src/Data/Enum.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.toCharCode = function (c) {\n  return c.charCodeAt(0);\n};\n\nexports.fromCharCode = function (c) {\n  return String.fromCharCode(c);\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/enums/v5.0.0/src/Data/Enum.js?");

/***/ }),

/***/ "./.spago/exceptions/v5.0.0/src/Effect/Exception.js":
/*!**********************************************************!*\
  !*** ./.spago/exceptions/v5.0.0/src/Effect/Exception.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.showErrorImpl = function (err) {\n  return err.stack || err.toString();\n};\n\nexports.error = function (msg) {\n  return new Error(msg);\n};\n\nexports.message = function (e) {\n  return e.message;\n};\n\nexports.name = function (e) {\n  return e.name || \"Error\";\n};\n\nexports.stackImpl = function (just) {\n  return function (nothing) {\n    return function (e) {\n      return e.stack ? just(e.stack) : nothing;\n    };\n  };\n};\n\nexports.throwException = function (e) {\n  return function () {\n    throw e;\n  };\n};\n\nexports.catchException = function (c) {\n  return function (t) {\n    return function () {\n      try {\n        return t();\n      } catch (e) {\n        if (e instanceof Error || Object.prototype.toString.call(e) === \"[object Error]\") {\n          return c(e)();\n        } else {\n          return c(new Error(e.toString()))();\n        }\n      }\n    };\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/exceptions/v5.0.0/src/Effect/Exception.js?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.js":
/*!*****************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.foldrArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = len - 1; i >= 0; i--) {\n        acc = f(xs[i])(acc);\n      }\n      return acc;\n    };\n  };\n};\n\nexports.foldlArray = function (f) {\n  return function (init) {\n    return function (xs) {\n      var acc = init;\n      var len = xs.length;\n      for (var i = 0; i < len; i++) {\n        acc = f(acc)(xs[i]);\n      }\n      return acc;\n    };\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.js?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.js":
/*!*************************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.mapWithIndexArray = function (f) {\n  return function (xs) {\n    var l = xs.length;\n    var result = Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(i)(xs[i]);\n    }\n    return result;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.js?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.js":
/*!********************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n// jshint maxparams: 3\n\nexports.traverseArrayImpl = (function () {\n  function array1(a) {\n    return [a];\n  }\n\n  function array2(a) {\n    return function (b) {\n      return [a, b];\n    };\n  }\n\n  function array3(a) {\n    return function (b) {\n      return function (c) {\n        return [a, b, c];\n      };\n    };\n  }\n\n  function concat2(xs) {\n    return function (ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  return function (apply) {\n    return function (map) {\n      return function (pure) {\n        return function (f) {\n          return function (array) {\n            function go(bot, top) {\n              switch (top - bot) {\n              case 0: return pure([]);\n              case 1: return map(array1)(f(array[bot]));\n              case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));\n              case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));\n              default:\n                // This slightly tricky pivot selection aims to produce two\n                // even-length partitions where possible.\n                var pivot = bot + Math.floor((top - bot) / 4) * 2;\n                return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));\n              }\n            }\n            return go(0, array.length);\n          };\n        };\n      };\n    };\n  };\n})();\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.js?");

/***/ }),

/***/ "./.spago/integers/v5.0.0/src/Data/Int.js":
/*!************************************************!*\
  !*** ./.spago/integers/v5.0.0/src/Data/Int.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.fromNumberImpl = function (just) {\n  return function (nothing) {\n    return function (n) {\n      /* jshint bitwise: false */\n      return (n | 0) === n ? just(n) : nothing;\n    };\n  };\n};\n\nexports.toNumber = function (n) {\n  return n;\n};\n\nexports.fromStringAsImpl = function (just) {\n  return function (nothing) {\n    return function (radix) {\n      var digits;\n      if (radix < 11) {\n        digits = \"[0-\" + (radix - 1).toString() + \"]\";\n      } else if (radix === 11) {\n        digits = \"[0-9a]\";\n      } else {\n        digits = \"[0-9a-\" + String.fromCharCode(86 + radix) + \"]\";\n      }\n      var pattern = new RegExp(\"^[\\\\+\\\\-]?\" + digits + \"+$\", \"i\");\n\n      return function (s) {\n        /* jshint bitwise: false */\n        if (pattern.test(s)) {\n          var i = parseInt(s, radix);\n          return (i | 0) === i ? just(i) : nothing;\n        } else {\n          return nothing;\n        }\n      };\n    };\n  };\n};\n\nexports.toStringAs = function (radix) {\n  return function (i) {\n    return i.toString(radix);\n  };\n};\n\n\nexports.quot = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x / y | 0;\n  };\n};\n\nexports.rem = function (x) {\n  return function (y) {\n    return x % y;\n  };\n};\n\nexports.pow = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return Math.pow(x,y) | 0;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/integers/v5.0.0/src/Data/Int.js?");

/***/ }),

/***/ "./.spago/lazy/v5.0.0/src/Data/Lazy.js":
/*!*********************************************!*\
  !*** ./.spago/lazy/v5.0.0/src/Data/Lazy.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.defer = function (thunk) {\n  var v = null;\n  return function() {\n    if (thunk === undefined) return v;\n\n    v = thunk();\n    thunk = undefined; // eslint-disable-line no-param-reassign\n    return v;\n  };\n};\n\nexports.force = function (l) {\n  return l();\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/lazy/v5.0.0/src/Data/Lazy.js?");

/***/ }),

/***/ "./.spago/math/v3.0.0/src/Math.js":
/*!****************************************!*\
  !*** ./.spago/math/v3.0.0/src/Math.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n// module Math\n\nexports.abs = Math.abs;\n\nexports.acos = Math.acos;\n\nexports.asin = Math.asin;\n\nexports.atan = Math.atan;\n\nexports.atan2 = function (y) {\n  return function (x) {\n    return Math.atan2(y, x);\n  };\n};\n\nexports.ceil = Math.ceil;\n\nexports.cos = Math.cos;\n\nexports.exp = Math.exp;\n\nexports.floor = Math.floor;\n\nfunction nativeImul(a) {\n  return function (b) {\n    return Math.imul(a, b);\n  };\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\nfunction emulatedImul(a) {\n  /*jshint bitwise: false*/\n  return function (b) {\n    var ah = a >>> 16 & 0xffff;\n    var al = a & 0xffff;\n    var bh = b >>> 16 & 0xffff;\n    var bl = b & 0xffff;\n    // the shift by 0 fixes the sign on the high part\n    // the final |0 converts the unsigned value into a signed value\n    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;\n  };\n}\n\nexports.imul = Math.imul ? nativeImul : emulatedImul;\n\nexports.trunc = Math.trunc || function (n) {\n  return n < 0 ? Math.ceil(n) : Math.floor(n);\n};\n\nexports.log = Math.log;\n\nexports.max = function (n1) {\n  return function (n2) {\n    return Math.max(n1, n2);\n  };\n};\n\nexports.min = function (n1) {\n  return function (n2) {\n    return Math.min(n1, n2);\n  };\n};\n\nexports.pow = function (n) {\n  return function (p) {\n    return Math.pow(n, p);\n  };\n};\n\nexports.remainder = function (n) {\n  return function (m) {\n    return n % m;\n  };\n};\n\nexports.round = Math.round;\n\nexports.sin = Math.sin;\n\nexports.sqrt = Math.sqrt;\n\nexports.tan = Math.tan;\n\nexports.e = Math.E;\n\nexports.ln2 = Math.LN2;\n\nexports.ln10 = Math.LN10;\n\nexports.log2e = Math.LOG2E;\n\nexports.log10e = Math.LOG10E;\n\nexports.pi = Math.PI;\n\nexports.tau = 2 * Math.PI;\n\nexports.sqrt1_2 = Math.SQRT1_2;\n\nexports.sqrt2 = Math.SQRT2;\n\n\n//# sourceURL=webpack://bundle/./.spago/math/v3.0.0/src/Math.js?");

/***/ }),

/***/ "./.spago/numbers/v8.0.0/src/Data/Number.js":
/*!**************************************************!*\
  !*** ./.spago/numbers/v8.0.0/src/Data/Number.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/* globals exports */\n\n\nexports.nan = NaN;\n\nexports.isNaN = isNaN;\n\nexports.infinity = Infinity;\n\nexports.isFinite = isFinite;\n\nexports.fromStringImpl = function(str, isFinite, just, nothing) {\n  var num = parseFloat(str);\n  if (isFinite(num)) {\n    return just(num);\n  } else {\n    return nothing;\n  }\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/numbers/v8.0.0/src/Data/Number.js?");

/***/ }),

/***/ "./.spago/partial/v3.0.0/src/Partial.js":
/*!**********************************************!*\
  !*** ./.spago/partial/v3.0.0/src/Partial.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n// module Partial\n\nexports._crashWith = function (msg) {\n  throw new Error(msg);\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/partial/v3.0.0/src/Partial.js?");

/***/ }),

/***/ "./.spago/partial/v3.0.0/src/Partial/Unsafe.js":
/*!*****************************************************!*\
  !*** ./.spago/partial/v3.0.0/src/Partial/Unsafe.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n// module Partial.Unsafe\n\nexports._unsafePartial = function (f) {\n  return f();\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/partial/v3.0.0/src/Partial/Unsafe.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Control/Apply.js":
/*!****************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Control/Apply.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.arrayApply = function (fs) {\n  return function (xs) {\n    var l = fs.length;\n    var k = xs.length;\n    var result = new Array(l*k);\n    var n = 0;\n    for (var i = 0; i < l; i++) {\n      var f = fs[i];\n      for (var j = 0; j < k; j++) {\n        result[n++] = f(xs[j]);\n      }\n    }\n    return result;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Control/Apply.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Control/Bind.js":
/*!***************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Control/Bind.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.arrayBind = function (arr) {\n  return function (f) {\n    var result = [];\n    for (var i = 0, l = arr.length; i < l; i++) {\n      Array.prototype.push.apply(result, f(arr[i]));\n    }\n    return result;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Control/Bind.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Bounded.js":
/*!***************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Bounded.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.topInt = 2147483647;\nexports.bottomInt = -2147483648;\n\nexports.topChar = String.fromCharCode(65535);\nexports.bottomChar = String.fromCharCode(0);\n\nexports.topNumber = Number.POSITIVE_INFINITY;\nexports.bottomNumber = Number.NEGATIVE_INFINITY;\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Bounded.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Eq.js":
/*!**********************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Eq.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nvar refEq = function (r1) {\n  return function (r2) {\n    return r1 === r2;\n  };\n};\n\nexports.eqBooleanImpl = refEq;\nexports.eqIntImpl = refEq;\nexports.eqNumberImpl = refEq;\nexports.eqCharImpl = refEq;\nexports.eqStringImpl = refEq;\n\nexports.eqArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      if (xs.length !== ys.length) return false;\n      for (var i = 0; i < xs.length; i++) {\n        if (!f(xs[i])(ys[i])) return false;\n      }\n      return true;\n    };\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Eq.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/EuclideanRing.js":
/*!*********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/EuclideanRing.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.intDegree = function (x) {\n  return Math.min(Math.abs(x), 2147483647);\n};\n\n// See the Euclidean definition in\n// https://en.m.wikipedia.org/wiki/Modulo_operation.\nexports.intDiv = function (x) {\n  return function (y) {\n    if (y === 0) return 0;\n    return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);\n  };\n};\n\nexports.intMod = function (x) {\n  return function (y) {\n    if (y === 0) return 0;\n    var yy = Math.abs(y);\n    return ((x % yy) + yy) % yy;\n  };\n};\n\nexports.numDiv = function (n1) {\n  return function (n2) {\n    return n1 / n2;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/EuclideanRing.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Functor.js":
/*!***************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Functor.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.arrayMap = function (f) {\n  return function (arr) {\n    var l = arr.length;\n    var result = new Array(l);\n    for (var i = 0; i < l; i++) {\n      result[i] = f(arr[i]);\n    }\n    return result;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Functor.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.js":
/*!**********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.boolConj = function (b1) {\n  return function (b2) {\n    return b1 && b2;\n  };\n};\n\nexports.boolDisj = function (b1) {\n  return function (b2) {\n    return b1 || b2;\n  };\n};\n\nexports.boolNot = function (b) {\n  return !b;\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Ord.js":
/*!***********************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Ord.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nvar unsafeCompareImpl = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (x) {\n        return function (y) {\n          return x < y ? lt : x === y ? eq : gt;\n        };\n      };\n    };\n  };\n};\n\nexports.ordBooleanImpl = unsafeCompareImpl;\nexports.ordIntImpl = unsafeCompareImpl;\nexports.ordNumberImpl = unsafeCompareImpl;\nexports.ordStringImpl = unsafeCompareImpl;\nexports.ordCharImpl = unsafeCompareImpl;\n\nexports.ordArrayImpl = function (f) {\n  return function (xs) {\n    return function (ys) {\n      var i = 0;\n      var xlen = xs.length;\n      var ylen = ys.length;\n      while (i < xlen && i < ylen) {\n        var x = xs[i];\n        var y = ys[i];\n        var o = f(x)(y);\n        if (o !== 0) {\n          return o;\n        }\n        i++;\n      }\n      if (xlen === ylen) {\n        return 0;\n      } else if (xlen > ylen) {\n        return -1;\n      } else {\n        return 1;\n      }\n    };\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Ord.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Ring.js":
/*!************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Ring.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.intSub = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x - y | 0;\n  };\n};\n\nexports.numSub = function (n1) {\n  return function (n2) {\n    return n1 - n2;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Ring.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Semigroup.js":
/*!*****************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Semigroup.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.concatString = function (s1) {\n  return function (s2) {\n    return s1 + s2;\n  };\n};\n\nexports.concatArray = function (xs) {\n  return function (ys) {\n    if (xs.length === 0) return ys;\n    if (ys.length === 0) return xs;\n    return xs.concat(ys);\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Semigroup.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Semiring.js":
/*!****************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Semiring.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.intAdd = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x + y | 0;\n  };\n};\n\nexports.intMul = function (x) {\n  return function (y) {\n    /* jshint bitwise: false */\n    return x * y | 0;\n  };\n};\n\nexports.numAdd = function (n1) {\n  return function (n2) {\n    return n1 + n2;\n  };\n};\n\nexports.numMul = function (n1) {\n  return function (n2) {\n    return n1 * n2;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Semiring.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Show.js":
/*!************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Show.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.showIntImpl = function (n) {\n  return n.toString();\n};\n\nexports.showNumberImpl = function (n) {\n  var str = n.toString();\n  return isNaN(str + \".0\") ? str : str + \".0\";\n};\n\nexports.showCharImpl = function (c) {\n  var code = c.charCodeAt(0);\n  if (code < 0x20 || code === 0x7F) {\n    switch (c) {\n      case \"\\x07\": return \"'\\\\a'\";\n      case \"\\b\": return \"'\\\\b'\";\n      case \"\\f\": return \"'\\\\f'\";\n      case \"\\n\": return \"'\\\\n'\";\n      case \"\\r\": return \"'\\\\r'\";\n      case \"\\t\": return \"'\\\\t'\";\n      case \"\\v\": return \"'\\\\v'\";\n    }\n    return \"'\\\\\" + code.toString(10) + \"'\";\n  }\n  return c === \"'\" || c === \"\\\\\" ? \"'\\\\\" + c + \"'\" : \"'\" + c + \"'\";\n};\n\nexports.showStringImpl = function (s) {\n  var l = s.length;\n  return \"\\\"\" + s.replace(\n    /[\\0-\\x1F\\x7F\"\\\\]/g, // eslint-disable-line no-control-regex\n    function (c, i) {\n      switch (c) {\n        case \"\\\"\":\n        case \"\\\\\":\n          return \"\\\\\" + c;\n        case \"\\x07\": return \"\\\\a\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\f\": return \"\\\\f\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\v\": return \"\\\\v\";\n      }\n      var k = i + 1;\n      var empty = k < l && s[k] >= \"0\" && s[k] <= \"9\" ? \"\\\\&\" : \"\";\n      return \"\\\\\" + c.charCodeAt(0).toString(10) + empty;\n    }\n  ) + \"\\\"\";\n};\n\nexports.showArrayImpl = function (f) {\n  return function (xs) {\n    var ss = [];\n    for (var i = 0, l = xs.length; i < l; i++) {\n      ss[i] = f(xs[i]);\n    }\n    return \"[\" + ss.join(\",\") + \"]\";\n  };\n};\n\nexports.cons = function (head) {\n  return function (tail) {\n    return [head].concat(tail);\n  };\n};\n\nexports.join = function (separator) {\n  return function (xs) {\n    return xs.join(separator);\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Show.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Show/Generic.js":
/*!********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Show/Generic.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.intercalate = function (separator) {\n  return function (xs) {\n    var len = xs.length;\n    if (len === 0) return \"\";\n\n    var res = xs[0];\n    for (var i = 1; i < len; i++) {\n      res = res + separator + xs[i];\n    }\n    return res;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Show/Generic.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Symbol.js":
/*!**************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Symbol.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n// module Data.Symbol\n\nexports.unsafeCoerce = function (arg) {\n  return arg;\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Symbol.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Unit.js":
/*!************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Unit.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.unit = {};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Unit.js?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Record/Unsafe.js":
/*!****************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Record/Unsafe.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.unsafeHas = function (label) {\n  return function (rec) {\n    return {}.hasOwnProperty.call(rec, label);\n  };\n};\n\nexports.unsafeGet = function (label) {\n  return function (rec) {\n    return rec[label];\n  };\n};\n\nexports.unsafeSet = function (label) {\n  return function (value) {\n    return function (rec) {\n      var copy = {};\n      for (var key in rec) {\n        if ({}.hasOwnProperty.call(rec, key)) {\n          copy[key] = rec[key];\n        }\n      }\n      copy[label] = value;\n      return copy;\n    };\n  };\n};\n\nexports.unsafeDelete = function (label) {\n  return function (rec) {\n    var copy = {};\n    for (var key in rec) {\n      if (key !== label && {}.hasOwnProperty.call(rec, key)) {\n        copy[key] = rec[key];\n      }\n    }\n    return copy;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Record/Unsafe.js?");

/***/ }),

/***/ "./.spago/refs/v5.0.0/src/Effect/Ref.js":
/*!**********************************************!*\
  !*** ./.spago/refs/v5.0.0/src/Effect/Ref.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports[\"new\"] = function (val) {\n  return function () {\n    return { value: val };\n  };\n};\n\nexports.newWithSelf = function (f) {\n  return function () {\n    var ref = { value: null };\n    ref.value = f(ref);\n    return ref;\n  };\n};\n\nexports.read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexports.modifyImpl = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexports.write = function (val) {\n  return function (ref) {\n    return function () {\n      ref.value = val;\n    };\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/refs/v5.0.0/src/Effect/Ref.js?");

/***/ }),

/***/ "./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.js":
/*!***********************************************************!*\
  !*** ./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.map_ = function (f) {\n  return function (a) {\n    return function () {\n      return f(a());\n    };\n  };\n};\n\nexports.pure_ = function (a) {\n  return function () {\n    return a;\n  };\n};\n\nexports.bind_ = function (a) {\n  return function (f) {\n    return function () {\n      return f(a())();\n    };\n  };\n};\n\nexports.run = function (f) {\n  return f();\n};\n\nexports[\"while\"] = function (f) {\n  return function (a) {\n    return function () {\n      while (f()) {\n        a();\n      }\n    };\n  };\n};\n\nexports[\"for\"] = function (lo) {\n  return function (hi) {\n    return function (f) {\n      return function () {\n        for (var i = lo; i < hi; i++) {\n          f(i)();\n        }\n      };\n    };\n  };\n};\n\nexports.foreach = function (as) {\n  return function (f) {\n    return function () {\n      for (var i = 0, l = as.length; i < l; i++) {\n        f(as[i])();\n      }\n    };\n  };\n};\n\nexports[\"new\"] = function (val) {\n  return function () {\n    return { value: val };\n  };\n};\n\nexports.read = function (ref) {\n  return function () {\n    return ref.value;\n  };\n};\n\nexports.modifyImpl = function (f) {\n  return function (ref) {\n    return function () {\n      var t = f(ref.value);\n      ref.value = t.state;\n      return t.value;\n    };\n  };\n};\n\nexports.write = function (a) {\n  return function (ref) {\n    return function () {\n      return ref.value = a; // eslint-disable-line no-return-assign\n    };\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.js?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/CodePoints.js":
/*!*************************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/CodePoints.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* global Symbol */\n\nvar hasArrayFrom = typeof Array.from === \"function\";\nvar hasStringIterator =\n  typeof Symbol !== \"undefined\" &&\n  Symbol != null &&\n  typeof Symbol.iterator !== \"undefined\" &&\n  typeof String.prototype[Symbol.iterator] === \"function\";\nvar hasFromCodePoint = typeof String.prototype.fromCodePoint === \"function\";\nvar hasCodePointAt = typeof String.prototype.codePointAt === \"function\";\n\nexports._unsafeCodePointAt0 = function (fallback) {\n  return hasCodePointAt\n    ? function (str) { return str.codePointAt(0); }\n    : fallback;\n};\n\nexports._codePointAt = function (fallback) {\n  return function (Just) {\n    return function (Nothing) {\n      return function (unsafeCodePointAt0) {\n        return function (index) {\n          return function (str) {\n            var length = str.length;\n            if (index < 0 || index >= length) return Nothing;\n            if (hasStringIterator) {\n              var iter = str[Symbol.iterator]();\n              for (var i = index;; --i) {\n                var o = iter.next();\n                if (o.done) return Nothing;\n                if (i === 0) return Just(unsafeCodePointAt0(o.value));\n              }\n            }\n            return fallback(index)(str);\n          };\n        };\n      };\n    };\n  };\n};\n\nexports._countPrefix = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasStringIterator) {\n      return function (pred) {\n        return function (str) {\n          var iter = str[Symbol.iterator]();\n          for (var cpCount = 0; ; ++cpCount) {\n            var o = iter.next();\n            if (o.done) return cpCount;\n            var cp = unsafeCodePointAt0(o.value);\n            if (!pred(cp)) return cpCount;\n          }\n        };\n      };\n    }\n    return fallback;\n  };\n};\n\nexports._fromCodePointArray = function (singleton) {\n  return hasFromCodePoint\n    ? function (cps) {\n      // Function.prototype.apply will fail for very large second parameters,\n      // so we don't use it for arrays with 10,000 or more entries.\n      if (cps.length < 10e3) {\n        return String.fromCodePoint.apply(String, cps);\n      }\n      return cps.map(singleton).join(\"\");\n    }\n    : function (cps) {\n      return cps.map(singleton).join(\"\");\n    };\n};\n\nexports._singleton = function (fallback) {\n  return hasFromCodePoint ? String.fromCodePoint : fallback;\n};\n\nexports._take = function (fallback) {\n  return function (n) {\n    if (hasStringIterator) {\n      return function (str) {\n        var accum = \"\";\n        var iter = str[Symbol.iterator]();\n        for (var i = 0; i < n; ++i) {\n          var o = iter.next();\n          if (o.done) return accum;\n          accum += o.value;\n        }\n        return accum;\n      };\n    }\n    return fallback(n);\n  };\n};\n\nexports._toCodePointArray = function (fallback) {\n  return function (unsafeCodePointAt0) {\n    if (hasArrayFrom) {\n      return function (str) {\n        return Array.from(str, unsafeCodePointAt0);\n      };\n    }\n    return fallback;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/CodePoints.js?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/CodeUnits.js":
/*!************************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/CodeUnits.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.fromCharArray = function (a) {\n  return a.join(\"\");\n};\n\nexports.toCharArray = function (s) {\n  return s.split(\"\");\n};\n\nexports.singleton = function (c) {\n  return c;\n};\n\nexports._charAt = function (just) {\n  return function (nothing) {\n    return function (i) {\n      return function (s) {\n        return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;\n      };\n    };\n  };\n};\n\nexports._toChar = function (just) {\n  return function (nothing) {\n    return function (s) {\n      return s.length === 1 ? just(s) : nothing;\n    };\n  };\n};\n\nexports.length = function (s) {\n  return s.length;\n};\n\nexports.countPrefix = function (p) {\n  return function (s) {\n    var i = 0;\n    while (i < s.length && p(s.charAt(i))) i++;\n    return i;\n  };\n};\n\nexports._indexOf = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (s) {\n        var i = s.indexOf(x);\n        return i === -1 ? nothing : just(i);\n      };\n    };\n  };\n};\n\nexports._indexOfStartingAt = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (startAt) {\n        return function (s) {\n          if (startAt < 0 || startAt > s.length) return nothing;\n          var i = s.indexOf(x, startAt);\n          return i === -1 ? nothing : just(i);\n        };\n      };\n    };\n  };\n};\n\nexports._lastIndexOf = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (s) {\n        var i = s.lastIndexOf(x);\n        return i === -1 ? nothing : just(i);\n      };\n    };\n  };\n};\n\nexports._lastIndexOfStartingAt = function (just) {\n  return function (nothing) {\n    return function (x) {\n      return function (startAt) {\n        return function (s) {\n          var i = s.lastIndexOf(x, startAt);\n          return i === -1 ? nothing : just(i);\n        };\n      };\n    };\n  };\n};\n\nexports.take = function (n) {\n  return function (s) {\n    return s.substr(0, n);\n  };\n};\n\nexports.drop = function (n) {\n  return function (s) {\n    return s.substring(n);\n  };\n};\n\nexports._slice = function (b) {\n  return function (e) {\n    return function (s) {\n      return s.slice(b,e);\n    };\n  };\n};\n\nexports.splitAt = function (i) {\n  return function (s) {\n    return { before: s.substring(0, i), after: s.substring(i) };\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/CodeUnits.js?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/Common.js":
/*!*********************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/Common.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports._localeCompare = function (lt) {\n  return function (eq) {\n    return function (gt) {\n      return function (s1) {\n        return function (s2) {\n          var result = s1.localeCompare(s2);\n          return result < 0 ? lt : result > 0 ? gt : eq;\n        };\n      };\n    };\n  };\n};\n\nexports.replace = function (s1) {\n  return function (s2) {\n    return function (s3) {\n      return s3.replace(s1, s2);\n    };\n  };\n};\n\nexports.replaceAll = function (s1) {\n  return function (s2) {\n    return function (s3) {\n      return s3.replace(new RegExp(s1.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), \"g\"), s2); // eslint-disable-line no-useless-escape\n    };\n  };\n};\n\nexports.split = function (sep) {\n  return function (s) {\n    return s.split(sep);\n  };\n};\n\nexports.toLower = function (s) {\n  return s.toLowerCase();\n};\n\nexports.toUpper = function (s) {\n  return s.toUpperCase();\n};\n\nexports.trim = function (s) {\n  return s.trim();\n};\n\nexports.joinWith = function (s) {\n  return function (xs) {\n    return xs.join(s);\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/Common.js?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/Regex.js":
/*!********************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/Regex.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.showRegexImpl = function (r) {\n  return \"\" + r;\n};\n\nexports.regexImpl = function (left) {\n  return function (right) {\n    return function (s1) {\n      return function (s2) {\n        try {\n          return right(new RegExp(s1, s2));\n        } catch (e) {\n          return left(e.message);\n        }\n      };\n    };\n  };\n};\n\nexports.source = function (r) {\n  return r.source;\n};\n\nexports.flagsImpl = function (r) {\n  return {\n    multiline: r.multiline,\n    ignoreCase: r.ignoreCase,\n    global: r.global,\n    dotAll: r.dotAll,\n    sticky: !!r.sticky,\n    unicode: !!r.unicode\n  };\n};\n\nexports.test = function (r) {\n  return function (s) {\n    var lastIndex = r.lastIndex;\n    var result = r.test(s);\n    r.lastIndex = lastIndex;\n    return result;\n  };\n};\n\nexports._match = function (just) {\n  return function (nothing) {\n    return function (r) {\n      return function (s) {\n        var m = s.match(r);\n        if (m == null || m.length === 0) {\n          return nothing;\n        } else {\n          for (var i = 0; i < m.length; i++) {\n            m[i] = m[i] == null ? nothing : just(m[i]);\n          }\n          return just(m);\n        }\n      };\n    };\n  };\n};\n\nexports.replace = function (r) {\n  return function (s1) {\n    return function (s2) {\n      return s2.replace(r, s1);\n    };\n  };\n};\n\nexports._replaceBy = function (just) {\n  return function (nothing) {\n    return function (r) {\n      return function (f) {\n        return function (s) {\n          return s.replace(r, function (match) {\n            var groups = [];\n            var group, i = 1;\n            while (typeof (group = arguments[i++]) !== \"number\") {\n              groups.push(group == null ? nothing : just(group));\n            }\n            return f(match)(groups);\n          });\n        };\n      };\n    };\n  };\n};\n\nexports._search = function (just) {\n  return function (nothing) {\n    return function (r) {\n      return function (s) {\n        var result = s.search(r);\n        return result === -1 ? nothing : just(result);\n      };\n    };\n  };\n};\n\nexports.split = function (r) {\n  return function (s) {\n    return s.split(r);\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/Regex.js?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/Unsafe.js":
/*!*********************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/Unsafe.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.charAt = function (i) {\n  return function (s) {\n    if (i >= 0 && i < s.length) return s.charAt(i);\n    throw new Error(\"Data.String.Unsafe.charAt: Invalid index.\");\n  };\n};\n\nexports.char = function (s) {\n  if (s.length === 1) return s.charAt(0);\n  throw new Error(\"Data.String.Unsafe.char: Expected string of length 1.\");\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/Unsafe.js?");

/***/ }),

/***/ "./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.js":
/*!*********************************************************!*\
  !*** ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.unfoldrArrayImpl = function (isNothing) {\n  return function (fromJust) {\n    return function (fst) {\n      return function (snd) {\n        return function (f) {\n          return function (b) {\n            var result = [];\n            var value = b;\n            while (true) { // eslint-disable-line no-constant-condition\n              var maybe = f(value);\n              if (isNothing(maybe)) return result;\n              var tuple = fromJust(maybe);\n              result.push(fst(tuple));\n              value = snd(tuple);\n            }\n          };\n        };\n      };\n    };\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.js?");

/***/ }),

/***/ "./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.js":
/*!**********************************************************!*\
  !*** ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.unfoldr1ArrayImpl = function (isNothing) {\n  return function (fromJust) {\n    return function (fst) {\n      return function (snd) {\n        return function (f) {\n          return function (b) {\n            var result = [];\n            var value = b;\n            while (true) { // eslint-disable-line no-constant-condition\n              var tuple = f(value);\n              result.push(fst(tuple));\n              var maybe = snd(tuple);\n              if (isNothing(maybe)) return result;\n              value = fromJust(maybe);\n            }\n          };\n        };\n      };\n    };\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.js?");

/***/ }),

/***/ "./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.js":
/*!**********************************************************!*\
  !*** ./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n// module Unsafe.Coerce\n\nexports.unsafeCoerce = function (x) {\n  return x;\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.js?");

/***/ }),

/***/ "./ZordParser/ZordASTMaker.js":
/*!************************************!*\
  !*** ./ZordParser/ZordASTMaker.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ZordASTMaker)\n/* harmony export */ });\n/* harmony import */ var antlr4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! antlr4 */ \"./node_modules/antlr4/src/antlr4/index.js\");\n/* harmony import */ var _ZordLexer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ZordLexer.js */ \"./ZordParser/ZordLexer.js\");\n/* harmony import */ var _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ZordParser.js */ \"./ZordParser/ZordParser.js\");\n/* harmony import */ var _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ZordParserVisitor.js */ \"./ZordParser/ZordParserVisitor.js\");\n/* harmony import */ var _src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/CP/Syntax/Source.purs */ \"./src/CP/Syntax/Source.purs\");\n/* harmony import */ var _src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/CP/Syntax/Common.purs */ \"./src/CP/Syntax/Common.purs\");\n/* harmony import */ var _src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _spago_either_v5_0_0_src_Data_Either_purs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\n/* harmony import */ var _spago_either_v5_0_0_src_Data_Either_purs__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_spago_either_v5_0_0_src_Data_Either_purs__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\n/* harmony import */ var _spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _spago_tuples_v6_0_1_src_Data_Tuple_purs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\n/* harmony import */ var _spago_tuples_v6_0_1_src_Data_Tuple_purs__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_spago_tuples_v6_0_1_src_Data_Tuple_purs__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _spago_lists_v6_0_1_src_Data_List_Types_purs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\n/* harmony import */ var _spago_lists_v6_0_1_src_Data_List_Types_purs__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_spago_lists_v6_0_1_src_Data_List_Types_purs__WEBPACK_IMPORTED_MODULE_9__);\n\n\n\n\n\n\n\n\n\n\n\nclass ZordASTMaker extends _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n\n    // Convert array to list\n    listify(array) {\n        let list = (_spago_lists_v6_0_1_src_Data_List_Types_purs__WEBPACK_IMPORTED_MODULE_9___default().Nil.value);\n        for (let each of array.reverse()){\n            list = new (_spago_lists_v6_0_1_src_Data_List_Types_purs__WEBPACK_IMPORTED_MODULE_9___default().Cons)(each, list);\n        }\n        return list;\n    }\n\n\n    // Visit a parse tree produced by ZordParser#program.\n\tvisitProgram(ctx) {\n        const expression = ctx.expression();\n        const definitions = ctx.definition();\n        let program = this.visitExpression(expression);\n        for(let i = definitions.length - 1; i>=0; i--){\n            program = this.visitDefinition(definitions[i], program);\n        }\n        return program;\n    } \n  \n  \n    // Visit a parse tree produced by ZordParser#open.\n    visitOpen(ctx) {\n        return null;\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#definition.\n    visitDefinition(ctx, program) {\n        const typeDef = ctx.typeDef();\n        const termDef = ctx.termDef();\n        if(typeDef !== null)\n            return this.visitTypeDef(typeDef, program);\n        else\n            return this.visitTermDef(termDef, program);\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#typeDef.\n    visitTypeDef(ctx, p) {\n        const typeNameDecls = ctx.typeNameDecl();\n        const angleTNDCount = ctx.Less().length;\n        const type = ctx.type();\n        const a = this.visitTypeNameDecl(typeNameDecls[0]);\n        const sorts = this.listify(typeNameDecls.slice(1, angleTNDCount+1).map(this.visitTypeNameDecl, this));\n        const parms = this.listify(typeNameDecls.slice(angleTNDCount + 1).map(this.visitTypeNameDecl, this));\n        const t = this.visitType(type);\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmType)(a, sorts, parms, t, p);\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#termDef.\n    visitTermDef(ctx, p) {\n        const x = this.visitTermNameDecl(ctx.termNameDecl());\n        const tys = this.listify(ctx.typeParam().map(this.visitTypeParam, this));\n        const tms = this.listify(ctx.termParam().map(this.visitTermParam, this));\n        const t = ctx.type() === null ? (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value) : new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitType(ctx.type()));\n        const e = this.visitExpression(ctx.expression());\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmDef)(x, tys, tms, t, e, p);\n    }\n\n\n    // Visit a parse tree produced by ZordParser#type.\n    visitType(ctx) {\n        if (ctx.btype() !== null) {\n            return this.visitBtype(ctx.btype());\n        } else if (ctx.Intersect() !== null) {\n            return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyAnd)(this.visitType(ctx.type(0)), this.visitType(ctx.type(1)));\n        } else if (ctx.Arrow() !== null) {\n            return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyArrow)(this.visitType(ctx.type(0)), this.visitType(ctx.type(1)));\n        } else {\n            console.error(\"Error at type\");\n        }\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#btype.\n    visitBtype(ctx) {\n        if (ctx.ForAll() !== null) {\n            return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyForall)(this.listify(ctx.typeParam().map(this.visitTypeParam, this)), this.visitType(ctx.type(0)));\n        }\n        else if (ctx.TraitCaps() !== null){\n            if (ctx.TraitArrow() === null){\n                const ti = (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value);\n                const to = this.visitType(ctx.type(0));\n                return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyTrait)(ti, to);\n            } else {\n                const ti = new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitType(ctx.type(0)));\n                const to = this.visitType(ctx.type(1));\n                return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyTrait)(ti, to);\n            };\n        } else if (ctx.Mu() !== null) {\n            return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyRec)(\n                this.visitTypeNameDecl(ctx.typeNameDecl()),\n                this.visitType(ctx.type())\n            );\n        } else {\n            let btype = this.visitAtype(ctx.getChild(0));\n            for(let i=1; i<ctx.getChildCount();i++){\n                const child = ctx.getChild(i);\n                if (child.ruleIndex === undefined){\n                    continue;\n                } else if (child.ruleIndex === _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_sort){\n                    btype = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyApp)(btype, this.visitSort(child));\n                } else if (child.ruleIndex === _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_atype){\n                    btype = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyApp)(btype, this.visitAtype(child));\n                } else {\n                    console.error(\"Error at btype\");\n                }\n            }\n            return btype;\n        }\n    }\n\n\n    // Visit a parse tree produced by ZordParser#atype.\n\tvisitAtype(ctx) {\n        if (ctx.getChild(0).symbol === undefined){\n            switch (ctx.getChild(0).ruleIndex) {\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_typeName:\n                    return this.visitTypeName(ctx.typeName());\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_recordType:\n                    return this.visitRecordType(ctx.recordType());\n                default:\n                    console.error(\"Error at Atype\");\n            }\n        } else {\n            switch (ctx.getChild(0).symbol.type) {\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Int :\n                    return (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyInt.value);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Double :\n                    return (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyDouble.value);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Bool :\n                    return (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyBool.value);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].StringType :\n                    return (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyString.value);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Top :\n                    return (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyTop.value);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Bot :\n                    return (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyBot.value);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].BracketOpen :\n                    return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyArray)(\n                        this.visitType(ctx.type())\n                    );\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ParenOpen :\n                    return this.visitType(ctx.type());\n                default:\n                    console.error(\"Error at Atype\");\n            }\n        }\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#recordType.\n    visitRecordType(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyRcd)(this.listify(ctx.recordTypeElement().map(this.visitRecordTypeElement, this)));\n    }\n\n    // Visit a parse tree produced by ZordParser#recordTypeElement.\n\tvisitRecordTypeElement(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().RcdTy)(\n            this.visitLabelDecl(ctx.labelDecl()),\n            this.visitType(ctx.type()),\n            ctx.Question() !== null\n        );\n    }\n\n\n    // Visit a parse tree produced by ZordParser#expression.\n    visitExpression(ctx) {\n        const position = {line: ctx.start.line, column: ctx.start.column};\n        const opexpr = this.visitOpexpr(ctx.opexpr());\n        let colonexpr = null;\n        if (ctx.Colon() !== null) {\n            colonexpr = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmAnno)(\n                opexpr,\n                this.visitType(ctx.type())\n            );\n        } else if (ctx.Backslash() !== null) {\n            colonexpr = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmExclude)(\n                opexpr,\n                this.visitType(ctx.type())\n            );\n        } else {\n            colonexpr = opexpr;\n        }\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmPos)(position, colonexpr);\n    }\n\n    // Visit a parse tree produced by ZordParser#opexpr.\n\tvisitOpexpr(ctx) {\n        const count = ctx.getChildCount();\n        let op = null\n        switch (count) {\n            case 1:\n                return this.visitLexpr(ctx.lexpr());\n            case 2:\n                const opexpr = this.visitOpexpr(ctx.opexpr(0));\n                switch (ctx.getChild(0).symbol.type) {\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Minus:\n                        op = (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Neg.value);\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Not:\n                        op = (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Not.value);\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Length:\n                        op = (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Len.value);\n                        break;\n                    default:\n                        console.error(\"Error at Unary Opexpr\");\n                }\n                return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmUnary)(op, opexpr);\n            default:\n                const opexpr1 = this.visitOpexpr(ctx.opexpr(0));\n                const opexpr2 = this.visitOpexpr(ctx.opexpr(1));\n                switch (ctx.getChild(1).symbol.type) {\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Index:\n                        op = (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Index.value);\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Modulo:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Arith)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Mod.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Divide:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Arith)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Div.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Star:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Arith)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Mul.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Minus:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Arith)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Sub.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Plus:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Arith)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Add.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Append:\n                        op = (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Append.value);\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Less:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Comp)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Lt.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Greater:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Comp)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Gt.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].LessEqual:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Comp)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Le.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].GreaterEqual:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Comp)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Ge.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Equal:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Comp)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Eql.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].NotEqual:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Comp)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Neq.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].And:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Logic)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().And.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Or:\n                        op = new (_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Logic)((_src_CP_Syntax_Common_purs__WEBPACK_IMPORTED_MODULE_5___default().Or.value));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Forward:\n                        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmForward)(opexpr1, opexpr2);\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Merge:\n                        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmMerge)(opexpr1, opexpr2);\n                    default:\n                        console.error(\"Error in Binary Opexpr\");\n                }\n                return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmBinary)(op, opexpr1, opexpr2);\n        }\n\n    }\n\n\t// Visit a parse tree produced by ZordParser#lexpr.\n\tvisitLexpr(ctx) {\n        switch (ctx.getChild(0).ruleIndex) {\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_fexpr:\n                return this.visitFexpr(ctx.fexpr());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_lambda:\n                return this.visitLambda(ctx.lambda());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_bigLambda:\n                return this.visitBigLambda(ctx.bigLambda());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_let_:\n                return this.visitLet_(ctx.let_());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_letRec:\n                return this.visitLetRec(ctx.letRec());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_open_:\n                return this.visitOpen_(ctx.open_());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_ifElse:\n                return this.visitIfElse(ctx.ifElse());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_trait:\n                return this.visitTrait(ctx.trait());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_new_:\n                return this.visitNew_(ctx.new_());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_toString_:\n                return this.visitToString_(ctx.toString_());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_fold:\n                return this.visitFold(ctx.fold());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_unfold:\n                return this.visitUnfold(ctx.unfold());\n            default:\n                console.error(\"Error in Lexpr\");\n        }\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#lambda.\n    visitLambda(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmAbs)(\n            this.listify(ctx.termParam().map(this.visitTermParam, this)),\n            this.visitExpression(ctx.expression())\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#bigLambda.\n    visitBigLambda(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmTAbs)(\n            this.listify(ctx.typeParam().map(this.visitTypeParam, this)),\n            this.visitExpression(ctx.expression())\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#let_.\n    visitLet_(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmLet)(\n            this.visitTermNameDecl(ctx.termNameDecl()),\n            this.listify(ctx.typeParam().map(this.visitTypeParam, this)),\n            this.listify(ctx.termParam().map(this.visitTermParam, this)),\n            this.visitExpression(ctx.expression(0)),\n            this.visitExpression(ctx.expression(1))\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#letRec.\n    visitLetRec(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmLetrec)(\n            this.visitTermNameDecl(ctx.termNameDecl()),\n            this.listify(ctx.typeParam().map(this.visitTypeParam, this)),\n            this.listify(ctx.termParam().map(this.visitTermParam, this)),\n            this.visitType(ctx.type()),\n            this.visitExpression(ctx.expression(0)),\n            this.visitExpression(ctx.expression(1))\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#open_.\n    visitOpen_(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmOpen)(\n            this.visitExpression(ctx.expression(0)),\n            this.visitExpression(ctx.expression(1))\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#ifElse.\n    visitIfElse(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmIf)(\n            this.visitExpression(ctx.expression(0)),\n            this.visitExpression(ctx.expression(1)),\n            this.visitExpression(ctx.expression(2))\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#trait.\n    visitTrait(ctx) {\n        let x = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmTrait)(\n            ctx.selfAnno() === null ? (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value) : new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitSelfAnno(ctx.selfAnno())),\n            ctx.type() === null ? (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value) : new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitType(ctx.type())),\n            ctx.opexpr().length === 2 ? new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitOpexpr(ctx.opexpr(0))) : (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value),\n            ctx.opexpr().length === 2 ? this.visitOpexpr(ctx.opexpr(1)) : this.visitOpexpr(ctx.opexpr(0))\n        );\n        console.log(x);\n        return x;\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#new_.\n    visitNew_(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmNew)(\n            this.visitOpexpr(ctx.opexpr())\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#toString_.\n    visitToString_(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmToString)(\n            this.visitDotexpr(ctx.dotexpr())\n        );\n    }\n\n\n    // Visit a parse tree produced by ZordParser#fold.\n\tvisitFold(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmFold)(\n            this.visitAtype(ctx.atype()),\n            this.visitDotexpr(ctx.dotexpr())\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#unfold.\n    visitUnfold(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmUnfold)(\n            this.visitAtype(ctx.atype()),\n            this.visitDotexpr(ctx.dotexpr())\n        );\n    }\n\n\n    // Visit a parse tree produced by ZordParser#fexpr.\n    visitFexpr(ctx) {\n        const c = ctx.getChild(0);\n        let fexpr = undefined;\n        let isCtor = undefined;\n        switch(c.ruleIndex){\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_typeNameDecl:\n                fexpr = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmVar)(this.visitTypeNameDecl(c));\n                isCtor = true;\n                break;\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_dotexpr:\n                fexpr = this.visitDotexpr(c);\n                isCtor = false;\n                break;\n            default:\n                console.error(\"Error at Fexpr\");\n        }\n        for(let i = 1; i<ctx.getChildCount(); i++){\n            let child = ctx.getChild(i);\n            if (child.ruleIndex === undefined){\n                continue;\n            } else if (child.ruleIndex === _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_dotexpr) {\n                fexpr = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmApp)(fexpr, this.visitDotexpr(child));\n            } else if (child.ruleIndex === _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_atype) {\n                fexpr = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmTApp)(fexpr, this.visitAtype(child));\n            } else {\n                console.error(\"Error at fexpr\");\n            }\n        }\n        if (isCtor){\n            return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmNew)(fexpr);\n        } else {\n            return fexpr;\n        }\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#dotexpr.\n    visitDotexpr(ctx) {\n        let dotexpr = this.visitAexpr(ctx.aexpr());\n        for (let i = 0;i<ctx.label().length; i++){\n            dotexpr = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmPrj)(dotexpr, this.visitLabel(ctx.label(i)));\n        }\n        return dotexpr;\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#aexpr.\n    visitAexpr(ctx) {\n        let child = ctx.getChild(0);\n        if (child.ruleIndex === undefined){\n            switch (child.symbol.type){\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Number:\n                    let num = child.getText();\n                    if (num.includes('.') || num.includes('e') || num.includes('E')){\n                        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmDouble)(parseFloat(num));\n                    } else if ('Xx'.includes(num[1])){\n                        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmInt)(parseInt(num.slice(2), 16));\n                    } else if ('Oo'.includes(num[1])){\n                        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmInt)(parseInt(num.slice(2), 8));\n                    } else {\n                        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmInt)(parseInt(num));\n                    }\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].String:\n                    let s = child.getText().slice(1,-1);\n                    let s_ = \"\";\n                    for (let i=0;i<s.length;i++){\n                        if(s[i]=='\\\\'){\n                            i++;\n                            let chars = \"\\'\\\"\\\\bfnrtv\";\n                            let escs  = \"\\'\\\"\\\\\\b\\f\\n\\r\\t\\v\";\n                            for(let j=0;j<chars.length;j++){\n                                if(s[i] === chars[j])\n                                    s_ += escs[j]\n                            }\n                        } else {\n                            s_ += s[i]\n                        }\n                    }\n                    return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmString)(s_);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Unit:\n                    return (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmUnit.value);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].True_:\n                    return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmBool)(true);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].False_:\n                    return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmBool)(false);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Undefined_:\n                    return (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmUndefined.value);\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Dollar:\n                    return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmVar)(this.visitTypeNameDecl(ctx.typeNameDecl()));\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ParenOpen:\n                    return this.visitExpression(ctx.expression());\n                default:\n                    console.error(\"error at aexpr\");\n            }\n        } else {\n            switch (child.ruleIndex){\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_termName:\n                    return this.visitTermName(ctx.termName());\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_document:\n                    return this.visitDocument(ctx.document());\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_array:\n                    return this.visitArray(ctx.array());\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_record:\n                    return this.visitRecord(ctx.record());\n                case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_recordUpdate:\n                    return this.visitRecordUpdate(ctx.recordUpdate());\n                default:\n                    console.error(\"Error at Aexpr\");\n            }\n        }\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#array.\n    visitArray(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmArray)(\n            ctx.expression().map(this.visitExpression, this)\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#record.\n    visitRecord(ctx) {\n        const record = [];\n        for(let i = 0; i<ctx.getChildCount(); i++) {\n            let child = ctx.getChild(i);\n            if(child.ruleIndex === undefined){\n                continue;\n            } else {\n                switch (child.ruleIndex) {\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_recordField:\n                        record.push(this.visitRecordField(child));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_methodPattern:\n                        record.push(this.visitMethodPattern(child));\n                        break;\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_defaultPattern:\n                        record.push(this.visitDefaultPattern(child));\n                        break;\n                    default:\n                        console.error(\"Error in record\");\n                }\n            }\n        }\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmRcd)(this.listify(record));\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#recordField.\n    visitRecordField(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().RcdField)(\n            ctx.Override() !== null,\n            this.visitLabelDecl(ctx.labelDecl()),\n            this.listify(ctx.termParam().map(this.visitTermParam, this)),\n            new (_spago_either_v5_0_0_src_Data_Either_purs__WEBPACK_IMPORTED_MODULE_6___default().Left)(this.visitExpression(ctx.expression()))\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#recordUpdate.\n    visitRecordUpdate(ctx) {\n        const fields = [];\n        for (let i=0;i<ctx.labelDecl().length;i++){\n            fields.push(new (_spago_tuples_v6_0_1_src_Data_Tuple_purs__WEBPACK_IMPORTED_MODULE_8___default().Tuple)(\n                this.visitLabelDecl(ctx.labelDecl(i)),\n                this.visitExpression(ctx.expression(i+1))\n            ));\n        }\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmUpdate)(\n            this.visitExpression(ctx.expression(0)), this.listify(fields)\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#methodPattern.\n    visitMethodPattern(ctx) {\n        const params = [];\n        const params_ = [];\n        let j = 0;\n        for (let i = 0;i<ctx.getChildCount();i++){\n            if(ctx.getChild(i).ruleIndex === _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_termParam){\n                if (j == 0)\n                    params.push(this.visitTermParam(ctx.getChild(i)));\n                else\n                    params_.push(this.visitTermParam(ctx.getChild(i)));\n            } else {\n                if (i > 0 && ctx.getChild(i-1).ruleIndex === _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_termParam){\n                    j++;\n                }\n            }\n        }\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().RcdField)(\n            ctx.Override() !== null,\n            this.visitLabelDecl(ctx.labelDecl(0)),\n            this.listify(params),\n            new (_spago_either_v5_0_0_src_Data_Either_purs__WEBPACK_IMPORTED_MODULE_6___default().Right)(new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().MethodPattern)(\n                ctx.selfAnno() === null? (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value) : new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitSelfAnno(ctx.selfAnno())),\n                this.visitLabelDecl(ctx.labelDecl(1)),\n                this.listify(params_),\n                this.visitExpression(ctx.expression())\n            ))\n        );\n    }\n  \n\n\t// Visit a parse tree produced by ZordParser#defaultPattern.\n\tvisitDefaultPattern(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().DefaultPattern)(\n            new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().MethodPattern)(\n                ctx.selfAnno() === null? (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value) : new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitSelfAnno(ctx.selfAnno())),\n                this.visitLabelDecl(ctx.labelDecl()),\n                this.listify(ctx.termParam().map(this.visitTermParam, this)),\n                this.visitExpression(ctx.expression())\n            )\n        );\n    }\n\n  \n    // Visit a parse tree produced by ZordParser#typeParam.\n    visitTypeParam(ctx) {\n        return new (_spago_tuples_v6_0_1_src_Data_Tuple_purs__WEBPACK_IMPORTED_MODULE_8___default().Tuple)(\n            this.visitTypeNameDecl(ctx.typeNameDecl()),\n            ctx.type() === null? (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value) : new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitType(ctx.type()))\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#termParam.\n    visitTermParam(ctx) {\n        switch (ctx.getChildCount()){\n            case 1:\n                switch (ctx.getChild(0).ruleIndex){\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_termId:\n                        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmParam)(\n                            this.visitTermId(ctx.termId()),\n                            (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value)\n                        );\n                    case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_wildcard:\n                        return this.visitWildcard(ctx.wildcard());\n                    default:\n                        console.error(\"Error at TermParam\");\n                        break;\n                }\n            case 5:\n                return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmParam)(\n                    this.visitTermId(ctx.termId()),\n                    new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitType(ctx.type()))\n                );\n            default:\n                console.error(\"Error at TermParam\");\n\n        }\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#termId.\n    visitTermId(ctx) {\n        return ctx.getText();\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#wildcard.\n    visitWildcard(ctx) {\n        const labelDecls = ctx.labelDecl().map(this.visitLabelDecl, this);\n        const expressions = ctx.expression().map(this.visitExpression, this);\n        const defaultFields = [];\n        for (let i = 0; i<labelDecls.length; i++){\n            defaultFields.push(new (_spago_tuples_v6_0_1_src_Data_Tuple_purs__WEBPACK_IMPORTED_MODULE_8___default().Tuple)(labelDecls[i], expressions[i]));\n        }\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().WildCard)(this.listify(defaultFields));\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#selfAnno.\n    visitSelfAnno(ctx) {\n        return new (_spago_tuples_v6_0_1_src_Data_Tuple_purs__WEBPACK_IMPORTED_MODULE_8___default().Tuple)(\n            this.visitTermNameDecl(ctx.termNameDecl()),\n            ctx.type() === null ? (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value) : new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitType(ctx.type()))\n        );\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#sort.\n    visitSort(ctx) {\n        if (ctx.TraitArrow() === null){\n            const ti = this.visitType(ctx.type(0));\n            const to = (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Nothing.value);\n            return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TySort)(ti, to);\n        } else {\n            const ti = this.visitType(ctx.type(0));\n            const to = new (_spago_maybe_v5_0_0_src_Data_Maybe_purs__WEBPACK_IMPORTED_MODULE_7___default().Just)(this.visitType(ctx.type(1)));\n            return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TySort)(ti, to);\n        };\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#typeNameDecl.\n    visitTypeNameDecl(ctx) {\n        return ctx.getText();\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#typeName.\n    visitTypeName(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TyVar)(ctx.getText());\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#termNameDecl.\n    visitTermNameDecl(ctx) {\n        return ctx.getText();\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#termName.\n    visitTermName(ctx) {\n        switch (ctx.getChild(0).symbol.type){\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Lowerid:\n                return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmVar)(ctx.getText());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Upperid:\n                return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmNew)(new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmVar)(ctx.getText()));\n            default:\n                console.error(\"Error in termName\");\n        }\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#labelDecl.\n    visitLabelDecl(ctx) {\n        return ctx.getText();\n    }\n  \n  \n    // Visit a parse tree produced by ZordParser#label.\n    visitLabel(ctx) {\n        return ctx.getText();\n    }\n  \n\n    // Visit a parse tree produced by ZordParser#document.\n\tvisitDocument(ctx) {\n        const position = {line: ctx.start.line, column: ctx.start.column};\n        const docs = ctx.docElement();\n        let foldedDocs = undefined;\n        if (docs.length === 0){\n            foldedDocs = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmNew)(new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmApp)(\n                new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmVar)(\"Str\"),\n                new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmString)(\"\")\n            ));\n        } else {\n            foldedDocs = this.visitDocElement(docs[0]);\n            for (let each of docs.slice(1)){\n                console.log(\"Heyy\");\n                foldedDocs = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmNew)(new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmApp)(\n                    new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmApp)(new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmVar)(\"Comp\"), foldedDocs),\n                    this.visitDocElement(each)\n                ));\n            }\n        }\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmPos)(\n            position,\n            new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmDoc)(\n                foldedDocs\n            )\n        );\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#docElement.\n\tvisitDocElement(ctx) {\n        const child = ctx.getChild(0);\n        switch (child.ruleIndex){\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_command:\n                return this.visitCommand(child);\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_interpolation:\n                return this.visitInterpolation(child);\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_newline:\n                return this.visitNewline(child);\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RULE_plaintext:\n                return this.visitPlaintext(child);\n            default:\n                console.error(\"Error ar DocElement\");\n        }\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#command.\n\tvisitCommand(ctx) {\n        const position = {line: ctx.start.line, column: ctx.start.column};\n\t    const cmd = ctx.getChild(0).getText().slice(1);\n        const args = ctx.arg().map(this.visitArg, this);\n        //foldl\n        let folded = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmVar)(cmd);\n        for (let arg of args){\n            folded = new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmApp)(folded, arg)\n        }\n        if (cmd[0].toUpperCase() === cmd[0]){\n            return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmPos)(position, new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmNew)(folded));\n        } else {\n            return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmPos)(position, folded);\n        }\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#interpolation.\n\tvisitInterpolation(ctx) {\n\t    return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmNew)(new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmApp)(\n            new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmVar)(\"Str\"),\n            new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmToString)(this.visitExpression(ctx.expression()))\n        ));\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#newline.\n\tvisitNewline(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmNew)(new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmVar)(\"Endl\"));\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#plaintext.\n\tvisitPlaintext(ctx) {\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmNew)(new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmApp)(\n            new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmVar)(\"Str\"),\n            new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmString)(ctx.getText())\n        ));\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#arg.\n\tvisitArg(ctx) {\n\t    switch(ctx.getChild(0).symbol.type){\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ParenOpenInTag:\n                return this.visitExpression(ctx.expression());\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].BraceOpenInTag:\n                return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().TmRcd)(this.listify(\n                    ctx.recordArgField().map(this.visitRecordArgField, this)\n                ));\n            case _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].BracketOpenInTag:\n                return this.visitDocument(ctx);\n            default:\n                console.error(\"Error in Arg\");\n        };\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#recordArgField.\n\tvisitRecordArgField(ctx) {\n\t    const params = this.listify(ctx.termParam().map(this.visitTermParam, this));\n        return new (_src_CP_Syntax_Source_purs__WEBPACK_IMPORTED_MODULE_4___default().RcdField)(\n            false,\n            this.visitLabelDecl(ctx.labelDecl()),\n            params,\n            new (_spago_either_v5_0_0_src_Data_Either_purs__WEBPACK_IMPORTED_MODULE_6___default().Left)(this.visitExpression(ctx.expression()))\n        );\n\t}\n\n}\n\n\n//# sourceURL=webpack://bundle/./ZordParser/ZordASTMaker.js?");

/***/ }),

/***/ "./ZordParser/ZordLexer.js":
/*!*********************************!*\
  !*** ./ZordParser/ZordLexer.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ZordLexer)\n/* harmony export */ });\n/* harmony import */ var antlr4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! antlr4 */ \"./node_modules/antlr4/src/antlr4/index.js\");\n// Generated from ZordLexer.g4 by ANTLR 4.9.2\n// jshint ignore: start\n\n\n\n\nconst serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\",\n    \"\\u5964\\u0002_\\u02a0\\b\\u0001\\b\\u0001\\b\\u0001\\u0004\\u0002\\t\\u0002\\u0004\",\n    \"\\u0003\\t\\u0003\\u0004\\u0004\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\",\n    \"\\u0006\\u0004\\u0007\\t\\u0007\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\",\n    \"\\u000b\\t\\u000b\\u0004\\f\\t\\f\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\",\n    \"\\t\\u000f\\u0004\\u0010\\t\\u0010\\u0004\\u0011\\t\\u0011\\u0004\\u0012\\t\\u0012\",\n    \"\\u0004\\u0013\\t\\u0013\\u0004\\u0014\\t\\u0014\\u0004\\u0015\\t\\u0015\\u0004\\u0016\",\n    \"\\t\\u0016\\u0004\\u0017\\t\\u0017\\u0004\\u0018\\t\\u0018\\u0004\\u0019\\t\\u0019\",\n    \"\\u0004\\u001a\\t\\u001a\\u0004\\u001b\\t\\u001b\\u0004\\u001c\\t\\u001c\\u0004\\u001d\",\n    \"\\t\\u001d\\u0004\\u001e\\t\\u001e\\u0004\\u001f\\t\\u001f\\u0004 \\t \\u0004!\\t\",\n    \"!\\u0004\\\"\\t\\\"\\u0004#\\t#\\u0004$\\t$\\u0004%\\t%\\u0004&\\t&\\u0004\\'\\t\\'\\u0004\",\n    \"(\\t(\\u0004)\\t)\\u0004*\\t*\\u0004+\\t+\\u0004,\\t,\\u0004-\\t-\\u0004.\\t.\\u0004\",\n    \"/\\t/\\u00040\\t0\\u00041\\t1\\u00042\\t2\\u00043\\t3\\u00044\\t4\\u00045\\t5\\u0004\",\n    \"6\\t6\\u00047\\t7\\u00048\\t8\\u00049\\t9\\u0004:\\t:\\u0004;\\t;\\u0004<\\t<\\u0004\",\n    \"=\\t=\\u0004>\\t>\\u0004?\\t?\\u0004@\\t@\\u0004A\\tA\\u0004B\\tB\\u0004C\\tC\\u0004\",\n    \"D\\tD\\u0004E\\tE\\u0004F\\tF\\u0004G\\tG\\u0004H\\tH\\u0004I\\tI\\u0004J\\tJ\\u0004\",\n    \"K\\tK\\u0004L\\tL\\u0004M\\tM\\u0004N\\tN\\u0004O\\tO\\u0004P\\tP\\u0004Q\\tQ\\u0004\",\n    \"R\\tR\\u0004S\\tS\\u0004T\\tT\\u0004U\\tU\\u0004V\\tV\\u0004W\\tW\\u0004X\\tX\\u0004\",\n    \"Y\\tY\\u0004Z\\tZ\\u0004[\\t[\\u0004\\\\\\t\\\\\\u0004]\\t]\\u0004^\\t^\\u0004_\\t_\\u0004\",\n    \"`\\t`\\u0004a\\ta\\u0003\\u0002\\u0006\\u0002\\u00c7\\n\\u0002\\r\\u0002\\u000e\\u0002\",\n    \"\\u00c8\\u0003\\u0002\\u0003\\u0002\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\",\n    \"\\u0003\\u0006\\u0003\\u00d1\\n\\u0003\\r\\u0003\\u000e\\u0003\\u00d2\\u0003\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0007\\u0004\",\n    \"\\u00db\\n\\u0004\\f\\u0004\\u000e\\u0004\\u00de\\u000b\\u0004\\u0003\\u0004\\u0003\",\n    \"\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0004\\u0003\\u0005\\u0003\\u0005\\u0003\",\n    \"\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\\u0006\\u0003\\u0006\\u0003\\u0006\\u0003\",\n    \"\\u0006\\u0003\\u0006\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0003\",\n    \"\\u0007\\u0003\\u0007\\u0003\\u0007\\u0003\\b\\u0003\\b\\u0003\\b\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\b\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\",\n    \"\\u000b\\u0003\\u000b\\u0003\\u000b\\u0003\\u000b\\u0003\\u000b\\u0003\\u000b\\u0003\",\n    \"\\u000b\\u0003\\f\\u0003\\f\\u0003\\f\\u0003\\f\\u0003\\f\\u0003\\f\\u0003\\f\\u0003\",\n    \"\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\u000e\\u0003\\u000e\\u0003\\u000e\",\n    \"\\u0003\\u000e\\u0003\\u000f\\u0003\\u000f\\u0003\\u000f\\u0003\\u000f\\u0003\\u0010\",\n    \"\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\\u0003\\u0011\\u0003\\u0011\\u0003\\u0011\",\n    \"\\u0003\\u0011\\u0003\\u0011\\u0003\\u0011\\u0003\\u0011\\u0003\\u0012\\u0003\\u0012\",\n    \"\\u0003\\u0012\\u0003\\u0013\\u0003\\u0013\\u0003\\u0013\\u0003\\u0014\\u0003\\u0014\",\n    \"\\u0003\\u0014\\u0003\\u0014\\u0003\\u0014\\u0003\\u0015\\u0003\\u0015\\u0003\\u0015\",\n    \"\\u0003\\u0015\\u0003\\u0015\\u0003\\u0016\\u0003\\u0016\\u0003\\u0016\\u0003\\u0016\",\n    \"\\u0003\\u0016\\u0003\\u0016\\u0003\\u0017\\u0003\\u0017\\u0003\\u0017\\u0003\\u0017\",\n    \"\\u0003\\u0017\\u0003\\u0017\\u0003\\u0017\\u0003\\u0017\\u0003\\u0017\\u0003\\u0017\",\n    \"\\u0003\\u0017\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\",\n    \"\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0019\\u0003\\u0019\",\n    \"\\u0003\\u0019\\u0003\\u0019\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\",\n    \"\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\\u0003\\u001b\",\n    \"\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0003\\u001c\\u0003\\u001c\",\n    \"\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001d\",\n    \"\\u0003\\u001d\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001e\",\n    \"\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\\u0003\\u001f\",\n    \"\\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003\",\n    \" \\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003!\\u0003\",\n    \"\\\"\\u0003\\\"\\u0003#\\u0003#\\u0003#\\u0003$\\u0003$\\u0003%\\u0003%\\u0007%\\u0195\",\n    \"\\n%\\f%\\u000e%\\u0198\\u000b%\\u0003&\\u0003&\\u0007&\\u019c\\n&\\f&\\u000e&\\u019f\",\n    \"\\u000b&\\u0003\\'\\u0003\\'\\u0003\\'\\u0005\\'\\u01a4\\n\\'\\u0003(\\u0006(\\u01a7\",\n    \"\\n(\\r(\\u000e(\\u01a8\\u0003(\\u0003(\\u0006(\\u01ad\\n(\\r(\\u000e(\\u01ae\\u0005\",\n    \"(\\u01b1\\n(\\u0003(\\u0003(\\u0005(\\u01b5\\n(\\u0003(\\u0006(\\u01b8\\n(\\r(\\u000e\",\n    \"(\\u01b9\\u0005(\\u01bc\\n(\\u0003(\\u0003(\\u0003(\\u0003(\\u0006(\\u01c2\\n(\",\n    \"\\r(\\u000e(\\u01c3\\u0003(\\u0003(\\u0003(\\u0003(\\u0006(\\u01ca\\n(\\r(\\u000e\",\n    \"(\\u01cb\\u0003(\\u0003(\\u0003(\\u0003(\\u0006(\\u01d2\\n(\\r(\\u000e(\\u01d3\",\n    \"\\u0003(\\u0003(\\u0003(\\u0003(\\u0006(\\u01da\\n(\\r(\\u000e(\\u01db\\u0005(\",\n    \"\\u01de\\n(\\u0003)\\u0003)\\u0003*\\u0005*\\u01e3\\n*\\u0003+\\u0003+\\u0003+\",\n    \"\\u0003+\\u0003,\\u0003,\\u0003,\\u0003,\\u0007,\\u01ed\\n,\\f,\\u000e,\\u01f0\",\n    \"\\u000b,\\u0003,\\u0003,\\u0003-\\u0003-\\u0003-\\u0003.\\u0003.\\u0003.\\u0003\",\n    \"/\\u0003/\\u0003/\\u00030\\u00030\\u00031\\u00031\\u00032\\u00032\\u00033\\u0003\",\n    \"3\\u00034\\u00034\\u00035\\u00035\\u00036\\u00036\\u00037\\u00037\\u00037\\u0003\",\n    \"8\\u00038\\u00038\\u00039\\u00039\\u00039\\u0003:\\u0003:\\u0003;\\u0003;\\u0003\",\n    \"<\\u0003<\\u0003<\\u0003=\\u0003=\\u0003=\\u0003>\\u0003>\\u0003>\\u0003?\\u0003\",\n    \"?\\u0003?\\u0003@\\u0003@\\u0003A\\u0003A\\u0003B\\u0003B\\u0003B\\u0003C\\u0003\",\n    \"C\\u0003D\\u0003D\\u0003E\\u0003E\\u0005E\\u0231\\nE\\u0003E\\u0005E\\u0234\\n\",\n    \"E\\u0003E\\u0003E\\u0003F\\u0003F\\u0003G\\u0003G\\u0003H\\u0003H\\u0003H\\u0003\",\n    \"H\\u0003I\\u0003I\\u0003I\\u0003I\\u0003J\\u0003J\\u0003J\\u0003J\\u0003K\\u0003\",\n    \"K\\u0003K\\u0003K\\u0003L\\u0003L\\u0003M\\u0003M\\u0003N\\u0003N\\u0003O\\u0003\",\n    \"O\\u0003O\\u0003P\\u0003P\\u0003Q\\u0003Q\\u0003R\\u0003R\\u0003S\\u0003S\\u0003\",\n    \"S\\u0003S\\u0003T\\u0003T\\u0003T\\u0003T\\u0003U\\u0003U\\u0003U\\u0003V\\u0003\",\n    \"V\\u0003V\\u0005V\\u0269\\nV\\u0003V\\u0003V\\u0003W\\u0003W\\u0003W\\u0003W\\u0003\",\n    \"W\\u0003X\\u0006X\\u0273\\nX\\rX\\u000eX\\u0274\\u0003Y\\u0003Y\\u0003Y\\u0003\",\n    \"Y\\u0003Z\\u0003Z\\u0003Z\\u0003Z\\u0003[\\u0003[\\u0003[\\u0003[\\u0003\\\\\\u0006\",\n    \"\\\\\\u0284\\n\\\\\\r\\\\\\u000e\\\\\\u0285\\u0003\\\\\\u0003\\\\\\u0003]\\u0003]\\u0003]\",\n    \"\\u0003]\\u0003]\\u0003^\\u0003^\\u0003^\\u0003^\\u0003^\\u0003_\\u0003_\\u0003\",\n    \"_\\u0005_\\u0297\\n_\\u0003`\\u0003`\\u0003`\\u0003a\\u0003a\\u0003a\\u0003a\\u0003\",\n    \"a\\u0004\\u00dc\\u01ee\\u0002b\\u0005\\u0003\\u0007\\u0004\\t\\u0005\\u000b\\u0006\",\n    \"\\r\\u0007\\u000f\\b\\u0011\\t\\u0013\\n\\u0015\\u000b\\u0017\\f\\u0019\\r\\u001b\\u000e\",\n    \"\\u001d\\u000f\\u001f\\u0010!\\u0011#\\u0012%\\u0013\\'\\u0014)\\u0015+\\u0016\",\n    \"-\\u0017/\\u00181\\u00193\\u001a5\\u001b7\\u001c9\\u001d;\\u001e=\\u001f? A!\",\n    \"C\\\"E#G$I%K&M\\'O\\u0002Q(S\\u0002U\\u0002W)Y*[+],_-a.c/e0g1i2k3m4o5q6s7\",\n    \"u8w9y:{;}<\\u007f=\\u0081>\\u0083?\\u0085@\\u0087A\\u0089B\\u008bC\\u008dD\\u008f\",\n    \"E\\u0091F\\u0093G\\u0095H\\u0097I\\u0099J\\u009bK\\u009dL\\u009fM\\u00a1N\\u00a3\",\n    \"O\\u00a5P\\u00a7Q\\u00a9R\\u00abS\\u00adT\\u00afU\\u00b1V\\u00b3W\\u00b5X\\u00b7\",\n    \"Y\\u00b9Z\\u00bb[\\u00bd\\\\\\u00bf]\\u00c1^\\u00c3_\\u0005\\u0002\\u0003\\u0004\",\n    \"\\u000f\\u0004\\u0002\\u000b\\u000b\\\"\\\"\\u0003\\u0002\\f\\f\\u0003\\u0002c|\\u0003\",\n    \"\\u0002C\\\\\\u0005\\u00022;C\\\\c|\\u0003\\u00022;\\u0004\\u0002GGgg\\u0004\\u0002\",\n    \"--//\\u0003\\u000229\\u0005\\u00022;CHch\\u0006\\u0002\\f\\f\\u000f\\u000f$$^\",\n    \"^\\u0004\\u0002^_bb\\u0006\\u0002**]_bb}}\\u0002\\u02b7\\u0002\\u0005\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002\\u0007\\u0003\\u0002\\u0002\\u0002\\u0002\\t\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002\\u000b\\u0003\\u0002\\u0002\\u0002\\u0002\\r\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002\\u000f\\u0003\\u0002\\u0002\\u0002\\u0002\\u0011\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002\\u0013\\u0003\\u0002\\u0002\\u0002\\u0002\\u0015\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002\\u0017\\u0003\\u0002\\u0002\\u0002\\u0002\\u0019\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002\\u001b\\u0003\\u0002\\u0002\\u0002\\u0002\\u001d\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002\\u001f\\u0003\\u0002\\u0002\\u0002\\u0002!\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002#\\u0003\\u0002\\u0002\\u0002\\u0002%\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002\\'\\u0003\\u0002\\u0002\\u0002\\u0002)\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002+\\u0003\\u0002\\u0002\\u0002\\u0002-\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002/\\u0003\\u0002\\u0002\\u0002\\u00021\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"3\\u0003\\u0002\\u0002\\u0002\\u00025\\u0003\\u0002\\u0002\\u0002\\u00027\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00029\\u0003\\u0002\\u0002\\u0002\\u0002;\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002=\\u0003\\u0002\\u0002\\u0002\\u0002?\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002A\\u0003\\u0002\\u0002\\u0002\\u0002C\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002E\\u0003\\u0002\\u0002\\u0002\\u0002G\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"I\\u0003\\u0002\\u0002\\u0002\\u0002K\\u0003\\u0002\\u0002\\u0002\\u0002M\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002Q\\u0003\\u0002\\u0002\\u0002\\u0002W\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002Y\\u0003\\u0002\\u0002\\u0002\\u0002[\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002]\\u0003\\u0002\\u0002\\u0002\\u0002_\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002a\\u0003\\u0002\\u0002\\u0002\\u0002c\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"e\\u0003\\u0002\\u0002\\u0002\\u0002g\\u0003\\u0002\\u0002\\u0002\\u0002i\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0002k\\u0003\\u0002\\u0002\\u0002\\u0002m\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0002o\\u0003\\u0002\\u0002\\u0002\\u0002q\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0002s\\u0003\\u0002\\u0002\\u0002\\u0002u\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0002w\\u0003\\u0002\\u0002\\u0002\\u0002y\\u0003\\u0002\\u0002\\u0002\\u0002\",\n    \"{\\u0003\\u0002\\u0002\\u0002\\u0002}\\u0003\\u0002\\u0002\\u0002\\u0002\\u007f\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0002\\u0081\\u0003\\u0002\\u0002\\u0002\\u0002\\u0083\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0002\\u0085\\u0003\\u0002\\u0002\\u0002\\u0002\\u0087\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0002\\u0089\\u0003\\u0002\\u0002\\u0002\\u0002\\u008b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0002\\u008d\\u0003\\u0002\\u0002\\u0002\\u0002\\u008f\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0002\\u0091\\u0003\\u0002\\u0002\\u0002\\u0002\\u0093\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0002\\u0095\\u0003\\u0002\\u0002\\u0002\\u0002\\u0097\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0002\\u0099\\u0003\\u0002\\u0002\\u0002\\u0002\\u009b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0002\\u009d\\u0003\\u0002\\u0002\\u0002\\u0002\\u009f\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0002\\u00a1\\u0003\\u0002\\u0002\\u0002\\u0002\\u00a3\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0002\\u00a5\\u0003\\u0002\\u0002\\u0002\\u0003\\u00a7\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0003\\u00a9\\u0003\\u0002\\u0002\\u0002\\u0003\\u00ab\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0003\\u00ad\\u0003\\u0002\\u0002\\u0002\\u0003\\u00af\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0003\\u00b1\\u0003\\u0002\\u0002\\u0002\\u0004\\u00b3\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0004\\u00b5\\u0003\\u0002\\u0002\\u0002\\u0004\\u00b7\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0004\\u00b9\\u0003\\u0002\\u0002\\u0002\\u0004\\u00bb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0004\\u00bd\\u0003\\u0002\\u0002\\u0002\\u0004\\u00bf\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0004\\u00c1\\u0003\\u0002\\u0002\\u0002\\u0004\\u00c3\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0005\\u00c6\\u0003\\u0002\\u0002\\u0002\\u0007\\u00cc\",\n    \"\\u0003\\u0002\\u0002\\u0002\\t\\u00d6\\u0003\\u0002\\u0002\\u0002\\u000b\\u00e4\",\n    \"\\u0003\\u0002\\u0002\\u0002\\r\\u00e9\\u0003\\u0002\\u0002\\u0002\\u000f\\u00ee\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0011\\u00f5\\u0003\\u0002\\u0002\\u0002\\u0013\\u00fb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0015\\u00fe\\u0003\\u0002\\u0002\\u0002\\u0017\\u0102\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0019\\u0109\\u0003\\u0002\\u0002\\u0002\\u001b\\u0110\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u001d\\u0115\\u0003\\u0002\\u0002\\u0002\\u001f\\u0119\",\n    \"\\u0003\\u0002\\u0002\\u0002!\\u011d\\u0003\\u0002\\u0002\\u0002#\\u0121\\u0003\",\n    \"\\u0002\\u0002\\u0002%\\u0128\\u0003\\u0002\\u0002\\u0002\\'\\u012b\\u0003\\u0002\",\n    \"\\u0002\\u0002)\\u012e\\u0003\\u0002\\u0002\\u0002+\\u0133\\u0003\\u0002\\u0002\",\n    \"\\u0002-\\u0138\\u0003\\u0002\\u0002\\u0002/\\u013e\\u0003\\u0002\\u0002\\u0002\",\n    \"1\\u0149\\u0003\\u0002\\u0002\\u00023\\u0152\\u0003\\u0002\\u0002\\u00025\\u0156\",\n    \"\\u0003\\u0002\\u0002\\u00027\\u015f\\u0003\\u0002\\u0002\\u00029\\u0164\\u0003\",\n    \"\\u0002\\u0002\\u0002;\\u016b\\u0003\\u0002\\u0002\\u0002=\\u016d\\u0003\\u0002\",\n    \"\\u0002\\u0002?\\u0172\\u0003\\u0002\\u0002\\u0002A\\u0178\\u0003\\u0002\\u0002\",\n    \"\\u0002C\\u0182\\u0003\\u0002\\u0002\\u0002E\\u018b\\u0003\\u0002\\u0002\\u0002\",\n    \"G\\u018d\\u0003\\u0002\\u0002\\u0002I\\u0190\\u0003\\u0002\\u0002\\u0002K\\u0192\",\n    \"\\u0003\\u0002\\u0002\\u0002M\\u0199\\u0003\\u0002\\u0002\\u0002O\\u01a3\\u0003\",\n    \"\\u0002\\u0002\\u0002Q\\u01dd\\u0003\\u0002\\u0002\\u0002S\\u01df\\u0003\\u0002\",\n    \"\\u0002\\u0002U\\u01e2\\u0003\\u0002\\u0002\\u0002W\\u01e4\\u0003\\u0002\\u0002\",\n    \"\\u0002Y\\u01e8\\u0003\\u0002\\u0002\\u0002[\\u01f3\\u0003\\u0002\\u0002\\u0002\",\n    \"]\\u01f6\\u0003\\u0002\\u0002\\u0002_\\u01f9\\u0003\\u0002\\u0002\\u0002a\\u01fc\",\n    \"\\u0003\\u0002\\u0002\\u0002c\\u01fe\\u0003\\u0002\\u0002\\u0002e\\u0200\\u0003\",\n    \"\\u0002\\u0002\\u0002g\\u0202\\u0003\\u0002\\u0002\\u0002i\\u0204\\u0003\\u0002\",\n    \"\\u0002\\u0002k\\u0206\\u0003\\u0002\\u0002\\u0002m\\u0208\\u0003\\u0002\\u0002\",\n    \"\\u0002o\\u020a\\u0003\\u0002\\u0002\\u0002q\\u020d\\u0003\\u0002\\u0002\\u0002\",\n    \"s\\u0210\\u0003\\u0002\\u0002\\u0002u\\u0213\\u0003\\u0002\\u0002\\u0002w\\u0215\",\n    \"\\u0003\\u0002\\u0002\\u0002y\\u0217\\u0003\\u0002\\u0002\\u0002{\\u021a\\u0003\",\n    \"\\u0002\\u0002\\u0002}\\u021d\\u0003\\u0002\\u0002\\u0002\\u007f\\u0220\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0081\\u0223\\u0003\\u0002\\u0002\\u0002\\u0083\\u0225\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0085\\u0227\\u0003\\u0002\\u0002\\u0002\\u0087\\u022a\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0089\\u022c\\u0003\\u0002\\u0002\\u0002\\u008b\\u0233\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u008d\\u0237\\u0003\\u0002\\u0002\\u0002\\u008f\\u0239\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0091\\u023b\\u0003\\u0002\\u0002\\u0002\\u0093\\u023f\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0095\\u0243\\u0003\\u0002\\u0002\\u0002\\u0097\\u0247\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0099\\u024b\\u0003\\u0002\\u0002\\u0002\\u009b\\u024d\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u009d\\u024f\\u0003\\u0002\\u0002\\u0002\\u009f\\u0251\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00a1\\u0254\\u0003\\u0002\\u0002\\u0002\\u00a3\\u0256\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00a5\\u0258\\u0003\\u0002\\u0002\\u0002\\u00a7\\u025a\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00a9\\u025e\\u0003\\u0002\\u0002\\u0002\\u00ab\\u0262\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00ad\\u0265\\u0003\\u0002\\u0002\\u0002\\u00af\\u026c\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00b1\\u0272\\u0003\\u0002\\u0002\\u0002\\u00b3\\u0276\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00b5\\u027a\\u0003\\u0002\\u0002\\u0002\\u00b7\\u027e\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00b9\\u0283\\u0003\\u0002\\u0002\\u0002\\u00bb\\u0289\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00bd\\u028e\\u0003\\u0002\\u0002\\u0002\\u00bf\\u0293\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00c1\\u0298\\u0003\\u0002\\u0002\\u0002\\u00c3\\u029b\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00c5\\u00c7\\t\\u0002\\u0002\\u0002\\u00c6\\u00c5\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00c7\\u00c8\\u0003\\u0002\\u0002\\u0002\\u00c8\\u00c6\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00c8\\u00c9\\u0003\\u0002\\u0002\\u0002\\u00c9\\u00ca\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00ca\\u00cb\\b\\u0002\\u0002\\u0002\\u00cb\\u0006\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00cc\\u00cd\\u0007/\\u0002\\u0002\\u00cd\\u00ce\\u0007\",\n    \"/\\u0002\\u0002\\u00ce\\u00d0\\u0003\\u0002\\u0002\\u0002\\u00cf\\u00d1\\n\\u0003\",\n    \"\\u0002\\u0002\\u00d0\\u00cf\\u0003\\u0002\\u0002\\u0002\\u00d1\\u00d2\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00d2\\u00d0\\u0003\\u0002\\u0002\\u0002\\u00d2\\u00d3\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00d3\\u00d4\\u0003\\u0002\\u0002\\u0002\\u00d4\\u00d5\\b\\u0003\",\n    \"\\u0002\\u0002\\u00d5\\b\\u0003\\u0002\\u0002\\u0002\\u00d6\\u00d7\\u0007}\\u0002\",\n    \"\\u0002\\u00d7\\u00d8\\u0007/\\u0002\\u0002\\u00d8\\u00dc\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00d9\\u00db\\u000b\\u0002\\u0002\\u0002\\u00da\\u00d9\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00db\\u00de\\u0003\\u0002\\u0002\\u0002\\u00dc\\u00dd\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00dc\\u00da\\u0003\\u0002\\u0002\\u0002\\u00dd\\u00df\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00de\\u00dc\\u0003\\u0002\\u0002\\u0002\\u00df\\u00e0\\u0007/\\u0002\",\n    \"\\u0002\\u00e0\\u00e1\\u0007\\u007f\\u0002\\u0002\\u00e1\\u00e2\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00e2\\u00e3\\b\\u0004\\u0002\\u0002\\u00e3\\n\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00e4\\u00e5\\u0007q\\u0002\\u0002\\u00e5\\u00e6\\u0007r\\u0002\\u0002\\u00e6\",\n    \"\\u00e7\\u0007g\\u0002\\u0002\\u00e7\\u00e8\\u0007p\\u0002\\u0002\\u00e8\\f\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00e9\\u00ea\\u0007v\\u0002\\u0002\\u00ea\\u00eb\\u0007\",\n    \"{\\u0002\\u0002\\u00eb\\u00ec\\u0007r\\u0002\\u0002\\u00ec\\u00ed\\u0007g\\u0002\",\n    \"\\u0002\\u00ed\\u000e\\u0003\\u0002\\u0002\\u0002\\u00ee\\u00ef\\u0007h\\u0002\",\n    \"\\u0002\\u00ef\\u00f0\\u0007q\\u0002\\u0002\\u00f0\\u00f1\\u0007t\\u0002\\u0002\",\n    \"\\u00f1\\u00f2\\u0007c\\u0002\\u0002\\u00f2\\u00f3\\u0007n\\u0002\\u0002\\u00f3\",\n    \"\\u00f4\\u0007n\\u0002\\u0002\\u00f4\\u0010\\u0003\\u0002\\u0002\\u0002\\u00f5\",\n    \"\\u00f6\\u0007V\\u0002\\u0002\\u00f6\\u00f7\\u0007t\\u0002\\u0002\\u00f7\\u00f8\",\n    \"\\u0007c\\u0002\\u0002\\u00f8\\u00f9\\u0007k\\u0002\\u0002\\u00f9\\u00fa\\u0007\",\n    \"v\\u0002\\u0002\\u00fa\\u0012\\u0003\\u0002\\u0002\\u0002\\u00fb\\u00fc\\u0007\",\n    \"o\\u0002\\u0002\\u00fc\\u00fd\\u0007w\\u0002\\u0002\\u00fd\\u0014\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00fe\\u00ff\\u0007K\\u0002\\u0002\\u00ff\\u0100\\u0007p\\u0002\",\n    \"\\u0002\\u0100\\u0101\\u0007v\\u0002\\u0002\\u0101\\u0016\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0102\\u0103\\u0007F\\u0002\\u0002\\u0103\\u0104\\u0007q\\u0002\\u0002\",\n    \"\\u0104\\u0105\\u0007w\\u0002\\u0002\\u0105\\u0106\\u0007d\\u0002\\u0002\\u0106\",\n    \"\\u0107\\u0007n\\u0002\\u0002\\u0107\\u0108\\u0007g\\u0002\\u0002\\u0108\\u0018\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0109\\u010a\\u0007U\\u0002\\u0002\\u010a\\u010b\",\n    \"\\u0007v\\u0002\\u0002\\u010b\\u010c\\u0007t\\u0002\\u0002\\u010c\\u010d\\u0007\",\n    \"k\\u0002\\u0002\\u010d\\u010e\\u0007p\\u0002\\u0002\\u010e\\u010f\\u0007i\\u0002\",\n    \"\\u0002\\u010f\\u001a\\u0003\\u0002\\u0002\\u0002\\u0110\\u0111\\u0007D\\u0002\",\n    \"\\u0002\\u0111\\u0112\\u0007q\\u0002\\u0002\\u0112\\u0113\\u0007q\\u0002\\u0002\",\n    \"\\u0113\\u0114\\u0007n\\u0002\\u0002\\u0114\\u001c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0115\\u0116\\u0007V\\u0002\\u0002\\u0116\\u0117\\u0007q\\u0002\\u0002\\u0117\",\n    \"\\u0118\\u0007r\\u0002\\u0002\\u0118\\u001e\\u0003\\u0002\\u0002\\u0002\\u0119\",\n    \"\\u011a\\u0007D\\u0002\\u0002\\u011a\\u011b\\u0007q\\u0002\\u0002\\u011b\\u011c\",\n    \"\\u0007v\\u0002\\u0002\\u011c \\u0003\\u0002\\u0002\\u0002\\u011d\\u011e\\u0007\",\n    \"n\\u0002\\u0002\\u011e\\u011f\\u0007g\\u0002\\u0002\\u011f\\u0120\\u0007v\\u0002\",\n    \"\\u0002\\u0120\\\"\\u0003\\u0002\\u0002\\u0002\\u0121\\u0122\\u0007n\\u0002\\u0002\",\n    \"\\u0122\\u0123\\u0007g\\u0002\\u0002\\u0123\\u0124\\u0007v\\u0002\\u0002\\u0124\",\n    \"\\u0125\\u0007t\\u0002\\u0002\\u0125\\u0126\\u0007g\\u0002\\u0002\\u0126\\u0127\",\n    \"\\u0007e\\u0002\\u0002\\u0127$\\u0003\\u0002\\u0002\\u0002\\u0128\\u0129\\u0007\",\n    \"k\\u0002\\u0002\\u0129\\u012a\\u0007p\\u0002\\u0002\\u012a&\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u012b\\u012c\\u0007k\\u0002\\u0002\\u012c\\u012d\\u0007h\\u0002\\u0002\",\n    \"\\u012d(\\u0003\\u0002\\u0002\\u0002\\u012e\\u012f\\u0007v\\u0002\\u0002\\u012f\",\n    \"\\u0130\\u0007j\\u0002\\u0002\\u0130\\u0131\\u0007g\\u0002\\u0002\\u0131\\u0132\",\n    \"\\u0007p\\u0002\\u0002\\u0132*\\u0003\\u0002\\u0002\\u0002\\u0133\\u0134\\u0007\",\n    \"g\\u0002\\u0002\\u0134\\u0135\\u0007n\\u0002\\u0002\\u0135\\u0136\\u0007u\\u0002\",\n    \"\\u0002\\u0136\\u0137\\u0007g\\u0002\\u0002\\u0137,\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0138\\u0139\\u0007v\\u0002\\u0002\\u0139\\u013a\\u0007t\\u0002\\u0002\\u013a\",\n    \"\\u013b\\u0007c\\u0002\\u0002\\u013b\\u013c\\u0007k\\u0002\\u0002\\u013c\\u013d\",\n    \"\\u0007v\\u0002\\u0002\\u013d.\\u0003\\u0002\\u0002\\u0002\\u013e\\u013f\\u0007\",\n    \"k\\u0002\\u0002\\u013f\\u0140\\u0007o\\u0002\\u0002\\u0140\\u0141\\u0007r\\u0002\",\n    \"\\u0002\\u0141\\u0142\\u0007n\\u0002\\u0002\\u0142\\u0143\\u0007g\\u0002\\u0002\",\n    \"\\u0143\\u0144\\u0007o\\u0002\\u0002\\u0144\\u0145\\u0007g\\u0002\\u0002\\u0145\",\n    \"\\u0146\\u0007p\\u0002\\u0002\\u0146\\u0147\\u0007v\\u0002\\u0002\\u0147\\u0148\",\n    \"\\u0007u\\u0002\\u0002\\u01480\\u0003\\u0002\\u0002\\u0002\\u0149\\u014a\\u0007\",\n    \"k\\u0002\\u0002\\u014a\\u014b\\u0007p\\u0002\\u0002\\u014b\\u014c\\u0007j\\u0002\",\n    \"\\u0002\\u014c\\u014d\\u0007g\\u0002\\u0002\\u014d\\u014e\\u0007t\\u0002\\u0002\",\n    \"\\u014e\\u014f\\u0007k\\u0002\\u0002\\u014f\\u0150\\u0007v\\u0002\\u0002\\u0150\",\n    \"\\u0151\\u0007u\\u0002\\u0002\\u01512\\u0003\\u0002\\u0002\\u0002\\u0152\\u0153\",\n    \"\\u0007p\\u0002\\u0002\\u0153\\u0154\\u0007g\\u0002\\u0002\\u0154\\u0155\\u0007\",\n    \"y\\u0002\\u0002\\u01554\\u0003\\u0002\\u0002\\u0002\\u0156\\u0157\\u0007v\\u0002\",\n    \"\\u0002\\u0157\\u0158\\u0007q\\u0002\\u0002\\u0158\\u0159\\u0007U\\u0002\\u0002\",\n    \"\\u0159\\u015a\\u0007v\\u0002\\u0002\\u015a\\u015b\\u0007t\\u0002\\u0002\\u015b\",\n    \"\\u015c\\u0007k\\u0002\\u0002\\u015c\\u015d\\u0007p\\u0002\\u0002\\u015d\\u015e\",\n    \"\\u0007i\\u0002\\u0002\\u015e6\\u0003\\u0002\\u0002\\u0002\\u015f\\u0160\\u0007\",\n    \"h\\u0002\\u0002\\u0160\\u0161\\u0007q\\u0002\\u0002\\u0161\\u0162\\u0007n\\u0002\",\n    \"\\u0002\\u0162\\u0163\\u0007f\\u0002\\u0002\\u01638\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0164\\u0165\\u0007w\\u0002\\u0002\\u0165\\u0166\\u0007p\\u0002\\u0002\\u0166\",\n    \"\\u0167\\u0007h\\u0002\\u0002\\u0167\\u0168\\u0007q\\u0002\\u0002\\u0168\\u0169\",\n    \"\\u0007n\\u0002\\u0002\\u0169\\u016a\\u0007f\\u0002\\u0002\\u016a:\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u016b\\u016c\\u0007B\\u0002\\u0002\\u016c<\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u016d\\u016e\\u0007v\\u0002\\u0002\\u016e\\u016f\\u0007t\\u0002\\u0002\",\n    \"\\u016f\\u0170\\u0007w\\u0002\\u0002\\u0170\\u0171\\u0007g\\u0002\\u0002\\u0171\",\n    \">\\u0003\\u0002\\u0002\\u0002\\u0172\\u0173\\u0007h\\u0002\\u0002\\u0173\\u0174\",\n    \"\\u0007c\\u0002\\u0002\\u0174\\u0175\\u0007n\\u0002\\u0002\\u0175\\u0176\\u0007\",\n    \"u\\u0002\\u0002\\u0176\\u0177\\u0007g\\u0002\\u0002\\u0177@\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0178\\u0179\\u0007w\\u0002\\u0002\\u0179\\u017a\\u0007p\\u0002\\u0002\",\n    \"\\u017a\\u017b\\u0007f\\u0002\\u0002\\u017b\\u017c\\u0007g\\u0002\\u0002\\u017c\",\n    \"\\u017d\\u0007h\\u0002\\u0002\\u017d\\u017e\\u0007k\\u0002\\u0002\\u017e\\u017f\",\n    \"\\u0007p\\u0002\\u0002\\u017f\\u0180\\u0007g\\u0002\\u0002\\u0180\\u0181\\u0007\",\n    \"f\\u0002\\u0002\\u0181B\\u0003\\u0002\\u0002\\u0002\\u0182\\u0183\\u0007q\\u0002\",\n    \"\\u0002\\u0183\\u0184\\u0007x\\u0002\\u0002\\u0184\\u0185\\u0007g\\u0002\\u0002\",\n    \"\\u0185\\u0186\\u0007t\\u0002\\u0002\\u0186\\u0187\\u0007t\\u0002\\u0002\\u0187\",\n    \"\\u0188\\u0007k\\u0002\\u0002\\u0188\\u0189\\u0007f\\u0002\\u0002\\u0189\\u018a\",\n    \"\\u0007g\\u0002\\u0002\\u018aD\\u0003\\u0002\\u0002\\u0002\\u018b\\u018c\\u0007\",\n    \"~\\u0002\\u0002\\u018cF\\u0003\\u0002\\u0002\\u0002\\u018d\\u018e\\u00070\\u0002\",\n    \"\\u0002\\u018e\\u018f\\u00070\\u0002\\u0002\\u018fH\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0190\\u0191\\u0007a\\u0002\\u0002\\u0191J\\u0003\\u0002\\u0002\\u0002\\u0192\",\n    \"\\u0196\\t\\u0004\\u0002\\u0002\\u0193\\u0195\\u0005O\\'\\u0002\\u0194\\u0193\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0195\\u0198\\u0003\\u0002\\u0002\\u0002\\u0196\\u0194\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0196\\u0197\\u0003\\u0002\\u0002\\u0002\\u0197L\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0198\\u0196\\u0003\\u0002\\u0002\\u0002\\u0199\\u019d\\t\",\n    \"\\u0005\\u0002\\u0002\\u019a\\u019c\\u0005O\\'\\u0002\\u019b\\u019a\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u019c\\u019f\\u0003\\u0002\\u0002\\u0002\\u019d\\u019b\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u019d\\u019e\\u0003\\u0002\\u0002\\u0002\\u019eN\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u019f\\u019d\\u0003\\u0002\\u0002\\u0002\\u01a0\\u01a4\\t\\u0006\",\n    \"\\u0002\\u0002\\u01a1\\u01a4\\u0005I$\\u0002\\u01a2\\u01a4\\u0007)\\u0002\\u0002\",\n    \"\\u01a3\\u01a0\\u0003\\u0002\\u0002\\u0002\\u01a3\\u01a1\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a3\\u01a2\\u0003\\u0002\\u0002\\u0002\\u01a4P\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a5\\u01a7\\t\\u0007\\u0002\\u0002\\u01a6\\u01a5\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a7\\u01a8\\u0003\\u0002\\u0002\\u0002\\u01a8\\u01a6\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a8\\u01a9\\u0003\\u0002\\u0002\\u0002\\u01a9\\u01b0\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01aa\\u01ac\\u00070\\u0002\\u0002\\u01ab\\u01ad\\t\\u0007\\u0002\\u0002\\u01ac\",\n    \"\\u01ab\\u0003\\u0002\\u0002\\u0002\\u01ad\\u01ae\\u0003\\u0002\\u0002\\u0002\\u01ae\",\n    \"\\u01ac\\u0003\\u0002\\u0002\\u0002\\u01ae\\u01af\\u0003\\u0002\\u0002\\u0002\\u01af\",\n    \"\\u01b1\\u0003\\u0002\\u0002\\u0002\\u01b0\\u01aa\\u0003\\u0002\\u0002\\u0002\\u01b0\",\n    \"\\u01b1\\u0003\\u0002\\u0002\\u0002\\u01b1\\u01bb\\u0003\\u0002\\u0002\\u0002\\u01b2\",\n    \"\\u01b4\\t\\b\\u0002\\u0002\\u01b3\\u01b5\\t\\t\\u0002\\u0002\\u01b4\\u01b3\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01b4\\u01b5\\u0003\\u0002\\u0002\\u0002\\u01b5\\u01b7\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01b6\\u01b8\\t\\u0007\\u0002\\u0002\\u01b7\\u01b6\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01b8\\u01b9\\u0003\\u0002\\u0002\\u0002\\u01b9\\u01b7\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01b9\\u01ba\\u0003\\u0002\\u0002\\u0002\\u01ba\\u01bc\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01bb\\u01b2\\u0003\\u0002\\u0002\\u0002\\u01bb\\u01bc\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01bc\\u01de\\u0003\\u0002\\u0002\\u0002\\u01bd\\u01be\\u0007\",\n    \"2\\u0002\\u0002\\u01be\\u01bf\\u0007z\\u0002\\u0002\\u01bf\\u01c1\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01c0\\u01c2\\u0005U*\\u0002\\u01c1\\u01c0\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01c2\\u01c3\\u0003\\u0002\\u0002\\u0002\\u01c3\\u01c1\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01c3\\u01c4\\u0003\\u0002\\u0002\\u0002\\u01c4\\u01de\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01c5\\u01c6\\u00072\\u0002\\u0002\\u01c6\\u01c7\\u0007Z\\u0002\\u0002\",\n    \"\\u01c7\\u01c9\\u0003\\u0002\\u0002\\u0002\\u01c8\\u01ca\\u0005U*\\u0002\\u01c9\",\n    \"\\u01c8\\u0003\\u0002\\u0002\\u0002\\u01ca\\u01cb\\u0003\\u0002\\u0002\\u0002\\u01cb\",\n    \"\\u01c9\\u0003\\u0002\\u0002\\u0002\\u01cb\\u01cc\\u0003\\u0002\\u0002\\u0002\\u01cc\",\n    \"\\u01de\\u0003\\u0002\\u0002\\u0002\\u01cd\\u01ce\\u00072\\u0002\\u0002\\u01ce\",\n    \"\\u01cf\\u0007q\\u0002\\u0002\\u01cf\\u01d1\\u0003\\u0002\\u0002\\u0002\\u01d0\",\n    \"\\u01d2\\u0005S)\\u0002\\u01d1\\u01d0\\u0003\\u0002\\u0002\\u0002\\u01d2\\u01d3\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01d3\\u01d1\\u0003\\u0002\\u0002\\u0002\\u01d3\\u01d4\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01d4\\u01de\\u0003\\u0002\\u0002\\u0002\\u01d5\\u01d6\",\n    \"\\u00072\\u0002\\u0002\\u01d6\\u01d7\\u0007Q\\u0002\\u0002\\u01d7\\u01d9\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d8\\u01da\\u0005S)\\u0002\\u01d9\\u01d8\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01da\\u01db\\u0003\\u0002\\u0002\\u0002\\u01db\\u01d9\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01db\\u01dc\\u0003\\u0002\\u0002\\u0002\\u01dc\\u01de\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01dd\\u01a6\\u0003\\u0002\\u0002\\u0002\\u01dd\\u01bd\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01dd\\u01c5\\u0003\\u0002\\u0002\\u0002\\u01dd\\u01cd\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01dd\\u01d5\\u0003\\u0002\\u0002\\u0002\\u01deR\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01df\\u01e0\\t\\n\\u0002\\u0002\\u01e0T\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01e1\\u01e3\\t\\u000b\\u0002\\u0002\\u01e2\\u01e1\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01e3V\\u0003\\u0002\\u0002\\u0002\\u01e4\\u01e5\\u0007b\\u0002\\u0002\\u01e5\",\n    \"\\u01e6\\u0003\\u0002\\u0002\\u0002\\u01e6\\u01e7\\b+\\u0003\\u0002\\u01e7X\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01e8\\u01ee\\u0007$\\u0002\\u0002\\u01e9\\u01ed\\n\\f\\u0002\",\n    \"\\u0002\\u01ea\\u01eb\\u0007^\\u0002\\u0002\\u01eb\\u01ed\\u000b\\u0002\\u0002\",\n    \"\\u0002\\u01ec\\u01e9\\u0003\\u0002\\u0002\\u0002\\u01ec\\u01ea\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01ed\\u01f0\\u0003\\u0002\\u0002\\u0002\\u01ee\\u01ef\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01ee\\u01ec\\u0003\\u0002\\u0002\\u0002\\u01ef\\u01f1\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01f0\\u01ee\\u0003\\u0002\\u0002\\u0002\\u01f1\\u01f2\\u0007$\\u0002\",\n    \"\\u0002\\u01f2Z\\u0003\\u0002\\u0002\\u0002\\u01f3\\u01f4\\u0007*\\u0002\\u0002\",\n    \"\\u01f4\\u01f5\\u0007+\\u0002\\u0002\\u01f5\\\\\\u0003\\u0002\\u0002\\u0002\\u01f6\",\n    \"\\u01f7\\u0007/\\u0002\\u0002\\u01f7\\u01f8\\u0007@\\u0002\\u0002\\u01f8^\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01f9\\u01fa\\u0007?\\u0002\\u0002\\u01fa\\u01fb\\u0007\",\n    \"@\\u0002\\u0002\\u01fb`\\u0003\\u0002\\u0002\\u0002\\u01fc\\u01fd\\u0007(\\u0002\",\n    \"\\u0002\\u01fdb\\u0003\\u0002\\u0002\\u0002\\u01fe\\u01ff\\u0007-\\u0002\\u0002\",\n    \"\\u01ffd\\u0003\\u0002\\u0002\\u0002\\u0200\\u0201\\u0007/\\u0002\\u0002\\u0201\",\n    \"f\\u0003\\u0002\\u0002\\u0002\\u0202\\u0203\\u0007,\\u0002\\u0002\\u0203h\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0204\\u0205\\u00071\\u0002\\u0002\\u0205j\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0206\\u0207\\u0007\\'\\u0002\\u0002\\u0207l\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0208\\u0209\\u0007#\\u0002\\u0002\\u0209n\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u020a\\u020b\\u0007(\\u0002\\u0002\\u020b\\u020c\\u0007(\\u0002\\u0002\\u020c\",\n    \"p\\u0003\\u0002\\u0002\\u0002\\u020d\\u020e\\u0007~\\u0002\\u0002\\u020e\\u020f\",\n    \"\\u0007~\\u0002\\u0002\\u020fr\\u0003\\u0002\\u0002\\u0002\\u0210\\u0211\\u0007\",\n    \"-\\u0002\\u0002\\u0211\\u0212\\u0007-\\u0002\\u0002\\u0212t\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0213\\u0214\\u0007>\\u0002\\u0002\\u0214v\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0215\\u0216\\u0007@\\u0002\\u0002\\u0216x\\u0003\\u0002\\u0002\\u0002\\u0217\",\n    \"\\u0218\\u0007>\\u0002\\u0002\\u0218\\u0219\\u0007?\\u0002\\u0002\\u0219z\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u021a\\u021b\\u0007@\\u0002\\u0002\\u021b\\u021c\\u0007\",\n    \"?\\u0002\\u0002\\u021c|\\u0003\\u0002\\u0002\\u0002\\u021d\\u021e\\u0007?\\u0002\",\n    \"\\u0002\\u021e\\u021f\\u0007?\\u0002\\u0002\\u021f~\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0220\\u0221\\u0007#\\u0002\\u0002\\u0221\\u0222\\u0007?\\u0002\\u0002\\u0222\",\n    \"\\u0080\\u0003\\u0002\\u0002\\u0002\\u0223\\u0224\\u0007.\\u0002\\u0002\\u0224\",\n    \"\\u0082\\u0003\\u0002\\u0002\\u0002\\u0225\\u0226\\u0007`\\u0002\\u0002\\u0226\",\n    \"\\u0084\\u0003\\u0002\\u0002\\u0002\\u0227\\u0228\\u0007#\\u0002\\u0002\\u0228\",\n    \"\\u0229\\u0007#\\u0002\\u0002\\u0229\\u0086\\u0003\\u0002\\u0002\\u0002\\u022a\",\n    \"\\u022b\\u0007%\\u0002\\u0002\\u022b\\u0088\\u0003\\u0002\\u0002\\u0002\\u022c\",\n    \"\\u022d\\u0007?\\u0002\\u0002\\u022d\\u008a\\u0003\\u0002\\u0002\\u0002\\u022e\",\n    \"\\u0230\\u0007\\u000f\\u0002\\u0002\\u022f\\u0231\\u0007\\f\\u0002\\u0002\\u0230\",\n    \"\\u022f\\u0003\\u0002\\u0002\\u0002\\u0230\\u0231\\u0003\\u0002\\u0002\\u0002\\u0231\",\n    \"\\u0234\\u0003\\u0002\\u0002\\u0002\\u0232\\u0234\\u0007\\f\\u0002\\u0002\\u0233\",\n    \"\\u022e\\u0003\\u0002\\u0002\\u0002\\u0233\\u0232\\u0003\\u0002\\u0002\\u0002\\u0234\",\n    \"\\u0235\\u0003\\u0002\\u0002\\u0002\\u0235\\u0236\\bE\\u0002\\u0002\\u0236\\u008c\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0237\\u0238\\u0007]\\u0002\\u0002\\u0238\\u008e\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0239\\u023a\\u0007_\\u0002\\u0002\\u023a\\u0090\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u023b\\u023c\\u0007}\\u0002\\u0002\\u023c\\u023d\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u023d\\u023e\\bH\\u0004\\u0002\\u023e\\u0092\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u023f\\u0240\\u0007\\u007f\\u0002\\u0002\\u0240\\u0241\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0241\\u0242\\bI\\u0005\\u0002\\u0242\\u0094\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0243\\u0244\\u0007*\\u0002\\u0002\\u0244\\u0245\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0245\\u0246\\bJ\\u0004\\u0002\\u0246\\u0096\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0247\\u0248\\u0007+\\u0002\\u0002\\u0248\\u0249\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0249\\u024a\\bK\\u0005\\u0002\\u024a\\u0098\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u024b\\u024c\\u0007=\\u0002\\u0002\\u024c\\u009a\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u024d\\u024e\\u0007<\\u0002\\u0002\\u024e\\u009c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u024f\\u0250\\u0007^\\u0002\\u0002\\u0250\\u009e\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0251\\u0252\\u00071\\u0002\\u0002\\u0252\\u0253\\u0007^\\u0002\\u0002\\u0253\",\n    \"\\u00a0\\u0003\\u0002\\u0002\\u0002\\u0254\\u0255\\u00070\\u0002\\u0002\\u0255\",\n    \"\\u00a2\\u0003\\u0002\\u0002\\u0002\\u0256\\u0257\\u0007A\\u0002\\u0002\\u0257\",\n    \"\\u00a4\\u0003\\u0002\\u0002\\u0002\\u0258\\u0259\\u0007&\\u0002\\u0002\\u0259\",\n    \"\\u00a6\\u0003\\u0002\\u0002\\u0002\\u025a\\u025b\\u0007b\\u0002\\u0002\\u025b\",\n    \"\\u025c\\u0003\\u0002\\u0002\\u0002\\u025c\\u025d\\bS\\u0005\\u0002\\u025d\\u00a8\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u025e\\u025f\\u0007_\\u0002\\u0002\\u025f\\u0260\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0260\\u0261\\bT\\u0005\\u0002\\u0261\\u00aa\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0262\\u0263\\u0007^\\u0002\\u0002\\u0263\\u0264\\u0007\",\n    \"^\\u0002\\u0002\\u0264\\u00ac\\u0003\\u0002\\u0002\\u0002\\u0265\\u0268\\u0007\",\n    \"^\\u0002\\u0002\\u0266\\u0269\\u0005K%\\u0002\\u0267\\u0269\\u0005M&\\u0002\\u0268\",\n    \"\\u0266\\u0003\\u0002\\u0002\\u0002\\u0268\\u0267\\u0003\\u0002\\u0002\\u0002\\u0269\",\n    \"\\u026a\\u0003\\u0002\\u0002\\u0002\\u026a\\u026b\\bV\\u0006\\u0002\\u026b\\u00ae\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u026c\\u026d\\u0007^\\u0002\\u0002\\u026d\\u026e\",\n    \"\\u0007*\\u0002\\u0002\\u026e\\u026f\\u0003\\u0002\\u0002\\u0002\\u026f\\u0270\",\n    \"\\bW\\u0004\\u0002\\u0270\\u00b0\\u0003\\u0002\\u0002\\u0002\\u0271\\u0273\\n\\r\",\n    \"\\u0002\\u0002\\u0272\\u0271\\u0003\\u0002\\u0002\\u0002\\u0273\\u0274\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0274\\u0272\\u0003\\u0002\\u0002\\u0002\\u0274\\u0275\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0275\\u00b2\\u0003\\u0002\\u0002\\u0002\\u0276\\u0277\\u0007*\",\n    \"\\u0002\\u0002\\u0277\\u0278\\u0003\\u0002\\u0002\\u0002\\u0278\\u0279\\bY\\u0004\",\n    \"\\u0002\\u0279\\u00b4\\u0003\\u0002\\u0002\\u0002\\u027a\\u027b\\u0007}\\u0002\",\n    \"\\u0002\\u027b\\u027c\\u0003\\u0002\\u0002\\u0002\\u027c\\u027d\\bZ\\u0004\\u0002\",\n    \"\\u027d\\u00b6\\u0003\\u0002\\u0002\\u0002\\u027e\\u027f\\u0007]\\u0002\\u0002\",\n    \"\\u027f\\u0280\\u0003\\u0002\\u0002\\u0002\\u0280\\u0281\\b[\\u0003\\u0002\\u0281\",\n    \"\\u00b8\\u0003\\u0002\\u0002\\u0002\\u0282\\u0284\\n\\u000e\\u0002\\u0002\\u0283\",\n    \"\\u0282\\u0003\\u0002\\u0002\\u0002\\u0284\\u0285\\u0003\\u0002\\u0002\\u0002\\u0285\",\n    \"\\u0283\\u0003\\u0002\\u0002\\u0002\\u0285\\u0286\\u0003\\u0002\\u0002\\u0002\\u0286\",\n    \"\\u0287\\u0003\\u0002\\u0002\\u0002\\u0287\\u0288\\b\\\\\\u0005\\u0002\\u0288\\u00ba\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0289\\u028a\\u0007_\\u0002\\u0002\\u028a\\u028b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u028b\\u028c\\b]\\u0005\\u0002\\u028c\\u028d\\b]\\u0005\",\n    \"\\u0002\\u028d\\u00bc\\u0003\\u0002\\u0002\\u0002\\u028e\\u028f\\u0007b\\u0002\",\n    \"\\u0002\\u028f\\u0290\\u0003\\u0002\\u0002\\u0002\\u0290\\u0291\\b^\\u0005\\u0002\",\n    \"\\u0291\\u0292\\b^\\u0005\\u0002\\u0292\\u00be\\u0003\\u0002\\u0002\\u0002\\u0293\",\n    \"\\u0296\\u0007^\\u0002\\u0002\\u0294\\u0297\\u0005K%\\u0002\\u0295\\u0297\\u0005\",\n    \"M&\\u0002\\u0296\\u0294\\u0003\\u0002\\u0002\\u0002\\u0296\\u0295\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0297\\u00c0\\u0003\\u0002\\u0002\\u0002\\u0298\\u0299\\u0007^\",\n    \"\\u0002\\u0002\\u0299\\u029a\\u0007^\\u0002\\u0002\\u029a\\u00c2\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u029b\\u029c\\u0007^\\u0002\\u0002\\u029c\\u029d\\u0007*\\u0002\",\n    \"\\u0002\\u029d\\u029e\\u0003\\u0002\\u0002\\u0002\\u029e\\u029f\\ba\\u0004\\u0002\",\n    \"\\u029f\\u00c4\\u0003\\u0002\\u0002\\u0002\\u001f\\u0002\\u0003\\u0004\\u00c8\\u00d2\",\n    \"\\u00dc\\u0196\\u019d\\u01a3\\u01a8\\u01ae\\u01b0\\u01b4\\u01b9\\u01bb\\u01c3\\u01cb\",\n    \"\\u01d3\\u01db\\u01dd\\u01e2\\u01ec\\u01ee\\u0230\\u0233\\u0268\\u0274\\u0285\\u0296\",\n    \"\\u0007\\b\\u0002\\u0002\\u0007\\u0003\\u0002\\u0007\\u0002\\u0002\\u0006\\u0002\",\n    \"\\u0002\\u0007\\u0004\\u0002\"].join(\"\");\n\n\nconst atn = new antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATNDeserializer().deserialize(serializedATN);\n\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4__WEBPACK_IMPORTED_MODULE_0__.dfa.DFA(ds, index) );\n\nclass ZordLexer extends antlr4__WEBPACK_IMPORTED_MODULE_0__.Lexer {\n\n    static grammarFileName = \"ZordLexer.g4\";\n    static channelNames = [ \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\" ];\n\tstatic modeNames = [ \"DEFAULT_MODE\", \"DOC_MODE\", \"TAG_MODE\" ];\n\tstatic literalNames = [ null, null, null, null, \"'open'\", \"'type'\", \"'forall'\", \n                         \"'Trait'\", \"'mu'\", \"'Int'\", \"'Double'\", \"'String'\", \n                         \"'Bool'\", \"'Top'\", \"'Bot'\", \"'let'\", \"'letrec'\", \n                         \"'in'\", \"'if'\", \"'then'\", \"'else'\", \"'trait'\", \n                         \"'implements'\", \"'inherits'\", \"'new'\", \"'toString'\", \n                         \"'fold'\", \"'unfold'\", \"'@'\", \"'true'\", \"'false'\", \n                         \"'undefined'\", \"'override'\", \"'|'\", \"'..'\", \"'_'\", \n                         null, null, null, null, null, \"'()'\", \"'->'\", \"'=>'\", \n                         \"'&'\", \"'+'\", \"'-'\", \"'*'\", \"'/'\", \"'%'\", \"'!'\", \n                         \"'&&'\", \"'||'\", \"'++'\", \"'<'\", \"'>'\", null, null, \n                         \"'=='\", \"'!='\", \"','\", \"'^'\", \"'!!'\", \"'#'\", \"'='\", \n                         null, null, null, null, \"'}'\", null, \"')'\", \"';'\", \n                         \"':'\", \"'\\\\'\", \"'/\\\\'\", \"'.'\", \"'?'\", \"'$'\" ];\n\tstatic symbolicNames = [ null, \"Whitespaces\", \"LineComment\", \"BlockComment\", \n                          \"Open\", \"Type\", \"ForAll\", \"TraitCaps\", \"Mu\", \"Int\", \n                          \"Double\", \"StringType\", \"Bool\", \"Top\", \"Bot\", \n                          \"Let\", \"LetRec\", \"In\", \"If\", \"Then\", \"Else\", \"TraitSmall\", \n                          \"Implements\", \"Inherits\", \"New\", \"ToString\", \"Fold\", \n                          \"Unfold\", \"At\", \"True_\", \"False_\", \"Undefined_\", \n                          \"Override\", \"Stick\", \"DotDot\", \"Underscore\", \"Lowerid\", \n                          \"Upperid\", \"Number\", \"BacktickOpen\", \"String\", \n                          \"Unit\", \"Arrow\", \"TraitArrow\", \"Intersect\", \"Plus\", \n                          \"Minus\", \"Star\", \"Divide\", \"Modulo\", \"Not\", \"And\", \n                          \"Or\", \"Append\", \"Less\", \"Greater\", \"LessEqual\", \n                          \"GreaterEqual\", \"Equal\", \"NotEqual\", \"Merge\", \n                          \"Forward\", \"Index\", \"Length\", \"Assign\", \"Newline\", \n                          \"BracketOpen\", \"BracketClose\", \"BraceOpen\", \"BraceClose\", \n                          \"ParenOpen\", \"ParenClose\", \"Semicolon\", \"Colon\", \n                          \"Backslash\", \"SlashBackslash\", \"Dot\", \"Question\", \n                          \"Dollar\", \"BacktickClose\", \"BracketCloseInDoc\", \n                          \"LineBreak\", \"Tag\", \"BackslashParen\", \"Plaintext\", \n                          \"ParenOpenInTag\", \"BraceOpenInTag\", \"BracketOpenInTag\", \n                          \"PlaintextAfterTag\", \"BracketCloseAfterTag\", \"BacktickCloseAfterTag\", \n                          \"TagAfterTag\", \"LinebreakAfterTag\", \"BackslashParenAfterTag\" ];\n\tstatic ruleNames = [ \"Whitespaces\", \"LineComment\", \"BlockComment\", \"Open\", \n                      \"Type\", \"ForAll\", \"TraitCaps\", \"Mu\", \"Int\", \"Double\", \n                      \"StringType\", \"Bool\", \"Top\", \"Bot\", \"Let\", \"LetRec\", \n                      \"In\", \"If\", \"Then\", \"Else\", \"TraitSmall\", \"Implements\", \n                      \"Inherits\", \"New\", \"ToString\", \"Fold\", \"Unfold\", \"At\", \n                      \"True_\", \"False_\", \"Undefined_\", \"Override\", \"Stick\", \n                      \"DotDot\", \"Underscore\", \"Lowerid\", \"Upperid\", \"IdChar\", \n                      \"Number\", \"Octit\", \"Hexit\", \"BacktickOpen\", \"String\", \n                      \"Unit\", \"Arrow\", \"TraitArrow\", \"Intersect\", \"Plus\", \n                      \"Minus\", \"Star\", \"Divide\", \"Modulo\", \"Not\", \"And\", \n                      \"Or\", \"Append\", \"Less\", \"Greater\", \"LessEqual\", \"GreaterEqual\", \n                      \"Equal\", \"NotEqual\", \"Merge\", \"Forward\", \"Index\", \n                      \"Length\", \"Assign\", \"Newline\", \"BracketOpen\", \"BracketClose\", \n                      \"BraceOpen\", \"BraceClose\", \"ParenOpen\", \"ParenClose\", \n                      \"Semicolon\", \"Colon\", \"Backslash\", \"SlashBackslash\", \n                      \"Dot\", \"Question\", \"Dollar\", \"BacktickClose\", \"BracketCloseInDoc\", \n                      \"LineBreak\", \"Tag\", \"BackslashParen\", \"Plaintext\", \n                      \"ParenOpenInTag\", \"BraceOpenInTag\", \"BracketOpenInTag\", \n                      \"PlaintextAfterTag\", \"BracketCloseAfterTag\", \"BacktickCloseAfterTag\", \n                      \"TagAfterTag\", \"LinebreakAfterTag\", \"BackslashParenAfterTag\" ];\n\n    constructor(input) {\n        super(input)\n        this._interp = new antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4__WEBPACK_IMPORTED_MODULE_0__.PredictionContextCache());\n    }\n\n    get atn() {\n        return atn;\n    }\n}\n\nZordLexer.EOF = antlr4__WEBPACK_IMPORTED_MODULE_0__.Token.EOF;\nZordLexer.Whitespaces = 1;\nZordLexer.LineComment = 2;\nZordLexer.BlockComment = 3;\nZordLexer.Open = 4;\nZordLexer.Type = 5;\nZordLexer.ForAll = 6;\nZordLexer.TraitCaps = 7;\nZordLexer.Mu = 8;\nZordLexer.Int = 9;\nZordLexer.Double = 10;\nZordLexer.StringType = 11;\nZordLexer.Bool = 12;\nZordLexer.Top = 13;\nZordLexer.Bot = 14;\nZordLexer.Let = 15;\nZordLexer.LetRec = 16;\nZordLexer.In = 17;\nZordLexer.If = 18;\nZordLexer.Then = 19;\nZordLexer.Else = 20;\nZordLexer.TraitSmall = 21;\nZordLexer.Implements = 22;\nZordLexer.Inherits = 23;\nZordLexer.New = 24;\nZordLexer.ToString = 25;\nZordLexer.Fold = 26;\nZordLexer.Unfold = 27;\nZordLexer.At = 28;\nZordLexer.True_ = 29;\nZordLexer.False_ = 30;\nZordLexer.Undefined_ = 31;\nZordLexer.Override = 32;\nZordLexer.Stick = 33;\nZordLexer.DotDot = 34;\nZordLexer.Underscore = 35;\nZordLexer.Lowerid = 36;\nZordLexer.Upperid = 37;\nZordLexer.Number = 38;\nZordLexer.BacktickOpen = 39;\nZordLexer.String = 40;\nZordLexer.Unit = 41;\nZordLexer.Arrow = 42;\nZordLexer.TraitArrow = 43;\nZordLexer.Intersect = 44;\nZordLexer.Plus = 45;\nZordLexer.Minus = 46;\nZordLexer.Star = 47;\nZordLexer.Divide = 48;\nZordLexer.Modulo = 49;\nZordLexer.Not = 50;\nZordLexer.And = 51;\nZordLexer.Or = 52;\nZordLexer.Append = 53;\nZordLexer.Less = 54;\nZordLexer.Greater = 55;\nZordLexer.LessEqual = 56;\nZordLexer.GreaterEqual = 57;\nZordLexer.Equal = 58;\nZordLexer.NotEqual = 59;\nZordLexer.Merge = 60;\nZordLexer.Forward = 61;\nZordLexer.Index = 62;\nZordLexer.Length = 63;\nZordLexer.Assign = 64;\nZordLexer.Newline = 65;\nZordLexer.BracketOpen = 66;\nZordLexer.BracketClose = 67;\nZordLexer.BraceOpen = 68;\nZordLexer.BraceClose = 69;\nZordLexer.ParenOpen = 70;\nZordLexer.ParenClose = 71;\nZordLexer.Semicolon = 72;\nZordLexer.Colon = 73;\nZordLexer.Backslash = 74;\nZordLexer.SlashBackslash = 75;\nZordLexer.Dot = 76;\nZordLexer.Question = 77;\nZordLexer.Dollar = 78;\nZordLexer.BacktickClose = 79;\nZordLexer.BracketCloseInDoc = 80;\nZordLexer.LineBreak = 81;\nZordLexer.Tag = 82;\nZordLexer.BackslashParen = 83;\nZordLexer.Plaintext = 84;\nZordLexer.ParenOpenInTag = 85;\nZordLexer.BraceOpenInTag = 86;\nZordLexer.BracketOpenInTag = 87;\nZordLexer.PlaintextAfterTag = 88;\nZordLexer.BracketCloseAfterTag = 89;\nZordLexer.BacktickCloseAfterTag = 90;\nZordLexer.TagAfterTag = 91;\nZordLexer.LinebreakAfterTag = 92;\nZordLexer.BackslashParenAfterTag = 93;\n\nZordLexer.DOC_MODE = 1;\nZordLexer.TAG_MODE = 2;\n\n\n\n\n\n\n//# sourceURL=webpack://bundle/./ZordParser/ZordLexer.js?");

/***/ }),

/***/ "./ZordParser/ZordParser.js":
/*!**********************************!*\
  !*** ./ZordParser/ZordParser.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ZordParser)\n/* harmony export */ });\n/* harmony import */ var antlr4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! antlr4 */ \"./node_modules/antlr4/src/antlr4/index.js\");\n/* harmony import */ var _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ZordParserVisitor.js */ \"./ZordParser/ZordParserVisitor.js\");\n// Generated from ZordParser.g4 by ANTLR 4.9.2\n// jshint ignore: start\n\n\n\n\nconst serializedATN = [\"\\u0003\\u608b\\ua72a\\u8133\\ub9ed\\u417c\\u3be7\\u7786\",\n    \"\\u5964\\u0003_\\u02ff\\u0004\\u0002\\t\\u0002\\u0004\\u0003\\t\\u0003\\u0004\\u0004\",\n    \"\\t\\u0004\\u0004\\u0005\\t\\u0005\\u0004\\u0006\\t\\u0006\\u0004\\u0007\\t\\u0007\",\n    \"\\u0004\\b\\t\\b\\u0004\\t\\t\\t\\u0004\\n\\t\\n\\u0004\\u000b\\t\\u000b\\u0004\\f\\t\\f\",\n    \"\\u0004\\r\\t\\r\\u0004\\u000e\\t\\u000e\\u0004\\u000f\\t\\u000f\\u0004\\u0010\\t\\u0010\",\n    \"\\u0004\\u0011\\t\\u0011\\u0004\\u0012\\t\\u0012\\u0004\\u0013\\t\\u0013\\u0004\\u0014\",\n    \"\\t\\u0014\\u0004\\u0015\\t\\u0015\\u0004\\u0016\\t\\u0016\\u0004\\u0017\\t\\u0017\",\n    \"\\u0004\\u0018\\t\\u0018\\u0004\\u0019\\t\\u0019\\u0004\\u001a\\t\\u001a\\u0004\\u001b\",\n    \"\\t\\u001b\\u0004\\u001c\\t\\u001c\\u0004\\u001d\\t\\u001d\\u0004\\u001e\\t\\u001e\",\n    \"\\u0004\\u001f\\t\\u001f\\u0004 \\t \\u0004!\\t!\\u0004\\\"\\t\\\"\\u0004#\\t#\\u0004\",\n    \"$\\t$\\u0004%\\t%\\u0004&\\t&\\u0004\\'\\t\\'\\u0004(\\t(\\u0004)\\t)\\u0004*\\t*\\u0004\",\n    \"+\\t+\\u0004,\\t,\\u0004-\\t-\\u0004.\\t.\\u0004/\\t/\\u00040\\t0\\u00041\\t1\\u0004\",\n    \"2\\t2\\u00043\\t3\\u00044\\t4\\u00045\\t5\\u00046\\t6\\u0003\\u0002\\u0007\\u0002\",\n    \"n\\n\\u0002\\f\\u0002\\u000e\\u0002q\\u000b\\u0002\\u0003\\u0002\\u0007\\u0002t\",\n    \"\\n\\u0002\\f\\u0002\\u000e\\u0002w\\u000b\\u0002\\u0003\\u0002\\u0003\\u0002\\u0003\",\n    \"\\u0003\\u0003\\u0003\\u0003\\u0003\\u0007\\u0003~\\n\\u0003\\f\\u0003\\u000e\\u0003\",\n    \"\\u0081\\u000b\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0003\\u0004\\u0003\",\n    \"\\u0004\\u0005\\u0004\\u0088\\n\\u0004\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\",\n    \"\\u0003\\u0005\\u0003\\u0005\\u0003\\u0005\\u0007\\u0005\\u0090\\n\\u0005\\f\\u0005\",\n    \"\\u000e\\u0005\\u0093\\u000b\\u0005\\u0003\\u0005\\u0007\\u0005\\u0096\\n\\u0005\",\n    \"\\f\\u0005\\u000e\\u0005\\u0099\\u000b\\u0005\\u0003\\u0005\\u0003\\u0005\\u0003\",\n    \"\\u0005\\u0003\\u0005\\u0003\\u0006\\u0003\\u0006\\u0007\\u0006\\u00a1\\n\\u0006\",\n    \"\\f\\u0006\\u000e\\u0006\\u00a4\\u000b\\u0006\\u0003\\u0006\\u0007\\u0006\\u00a7\",\n    \"\\n\\u0006\\f\\u0006\\u000e\\u0006\\u00aa\\u000b\\u0006\\u0003\\u0006\\u0003\\u0006\",\n    \"\\u0005\\u0006\\u00ae\\n\\u0006\\u0003\\u0006\\u0003\\u0006\\u0003\\u0006\\u0003\",\n    \"\\u0006\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0003\",\n    \"\\u0007\\u0003\\u0007\\u0003\\u0007\\u0003\\u0007\\u0007\\u0007\\u00bd\\n\\u0007\",\n    \"\\f\\u0007\\u000e\\u0007\\u00c0\\u000b\\u0007\\u0003\\b\\u0003\\b\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\b\\u0003\\b\\u0007\\b\\u00c8\\n\\b\\f\\b\\u000e\\b\\u00cb\\u000b\\b\\u0003\",\n    \"\\b\\u0003\\b\\u0006\\b\\u00cf\\n\\b\\r\\b\\u000e\\b\\u00d0\\u0003\\b\\u0003\\b\\u0003\",\n    \"\\b\\u0003\\b\\u0003\\b\\u0003\\b\\u0003\\b\\u0003\\b\\u0005\\b\\u00db\\n\\b\\u0003\\b\",\n    \"\\u0003\\b\\u0003\\b\\u0003\\b\\u0003\\b\\u0003\\b\\u0003\\b\\u0005\\b\\u00e4\\n\\b\\u0003\",\n    \"\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\",\n    \"\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0003\\t\\u0005\\t\\u00f6\\n\\t\",\n    \"\\u0003\\n\\u0003\\n\\u0003\\n\\u0003\\n\\u0007\\n\\u00fc\\n\\n\\f\\n\\u000e\\n\\u00ff\",\n    \"\\u000b\\n\\u0003\\n\\u0005\\n\\u0102\\n\\n\\u0003\\n\\u0003\\n\\u0003\\u000b\\u0003\",\n    \"\\u000b\\u0005\\u000b\\u0108\\n\\u000b\\u0003\\u000b\\u0003\\u000b\\u0003\\u000b\",\n    \"\\u0003\\f\\u0003\\f\\u0003\\f\\u0003\\f\\u0003\\f\\u0005\\f\\u0112\\n\\f\\u0003\\r\\u0003\",\n    \"\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0005\\r\\u011c\\n\\r\",\n    \"\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\",\n    \"\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\",\n    \"\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\",\n    \"\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\",\n    \"\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\",\n    \"\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0003\\r\\u0007\\r\\u0151\\n\\r\",\n    \"\\f\\r\\u000e\\r\\u0154\\u000b\\r\\u0003\\u000e\\u0003\\u000e\\u0003\\u000e\\u0003\",\n    \"\\u000e\\u0003\\u000e\\u0003\\u000e\\u0003\\u000e\\u0003\\u000e\\u0003\\u000e\\u0003\",\n    \"\\u000e\\u0003\\u000e\\u0003\\u000e\\u0005\\u000e\\u0162\\n\\u000e\\u0003\\u000f\",\n    \"\\u0003\\u000f\\u0006\\u000f\\u0166\\n\\u000f\\r\\u000f\\u000e\\u000f\\u0167\\u0003\",\n    \"\\u000f\\u0003\\u000f\\u0003\\u000f\\u0003\\u0010\\u0003\\u0010\\u0006\\u0010\\u016f\",\n    \"\\n\\u0010\\r\\u0010\\u000e\\u0010\\u0170\\u0003\\u0010\\u0003\\u0010\\u0003\\u0010\",\n    \"\\u0003\\u0011\\u0003\\u0011\\u0003\\u0011\\u0007\\u0011\\u0179\\n\\u0011\\f\\u0011\",\n    \"\\u000e\\u0011\\u017c\\u000b\\u0011\\u0003\\u0011\\u0007\\u0011\\u017f\\n\\u0011\",\n    \"\\f\\u0011\\u000e\\u0011\\u0182\\u000b\\u0011\\u0003\\u0011\\u0003\\u0011\\u0003\",\n    \"\\u0011\\u0003\\u0011\\u0003\\u0011\\u0003\\u0012\\u0003\\u0012\\u0003\\u0012\\u0007\",\n    \"\\u0012\\u018c\\n\\u0012\\f\\u0012\\u000e\\u0012\\u018f\\u000b\\u0012\\u0003\\u0012\",\n    \"\\u0007\\u0012\\u0192\\n\\u0012\\f\\u0012\\u000e\\u0012\\u0195\\u000b\\u0012\\u0003\",\n    \"\\u0012\\u0003\\u0012\\u0003\\u0012\\u0003\\u0012\\u0003\\u0012\\u0003\\u0012\\u0003\",\n    \"\\u0012\\u0003\\u0013\\u0003\\u0013\\u0003\\u0013\\u0003\\u0013\\u0003\\u0013\\u0003\",\n    \"\\u0014\\u0003\\u0014\\u0003\\u0014\\u0003\\u0014\\u0003\\u0014\\u0003\\u0014\\u0003\",\n    \"\\u0014\\u0003\\u0015\\u0003\\u0015\\u0005\\u0015\\u01ac\\n\\u0015\\u0003\\u0015\",\n    \"\\u0003\\u0015\\u0005\\u0015\\u01b0\\n\\u0015\\u0003\\u0015\\u0003\\u0015\\u0005\",\n    \"\\u0015\\u01b4\\n\\u0015\\u0003\\u0015\\u0003\\u0015\\u0003\\u0015\\u0003\\u0015\",\n    \"\\u0005\\u0015\\u01ba\\n\\u0015\\u0003\\u0015\\u0003\\u0015\\u0005\\u0015\\u01be\",\n    \"\\n\\u0015\\u0003\\u0015\\u0003\\u0015\\u0005\\u0015\\u01c2\\n\\u0015\\u0003\\u0015\",\n    \"\\u0003\\u0015\\u0005\\u0015\\u01c6\\n\\u0015\\u0003\\u0016\\u0003\\u0016\\u0003\",\n    \"\\u0016\\u0003\\u0017\\u0003\\u0017\\u0003\\u0017\\u0003\\u0018\\u0003\\u0018\\u0003\",\n    \"\\u0018\\u0003\\u0018\\u0003\\u0018\\u0003\\u0019\\u0003\\u0019\\u0003\\u0019\\u0003\",\n    \"\\u0019\\u0003\\u0019\\u0003\\u001a\\u0003\\u001a\\u0005\\u001a\\u01da\\n\\u001a\",\n    \"\\u0003\\u001a\\u0003\\u001a\\u0003\\u001a\\u0007\\u001a\\u01df\\n\\u001a\\f\\u001a\",\n    \"\\u000e\\u001a\\u01e2\\u000b\\u001a\\u0003\\u001b\\u0003\\u001b\\u0003\\u001b\\u0007\",\n    \"\\u001b\\u01e7\\n\\u001b\\f\\u001b\\u000e\\u001b\\u01ea\\u000b\\u001b\\u0003\\u001c\",\n    \"\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\",\n    \"\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\",\n    \"\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0003\\u001c\\u0005\\u001c\\u01fd\\n\",\n    \"\\u001c\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0003\\u001d\\u0007\\u001d\\u0203\",\n    \"\\n\\u001d\\f\\u001d\\u000e\\u001d\\u0206\\u000b\\u001d\\u0003\\u001d\\u0005\\u001d\",\n    \"\\u0209\\n\\u001d\\u0003\\u001d\\u0003\\u001d\\u0003\\u001e\\u0003\\u001e\\u0003\",\n    \"\\u001e\\u0003\\u001e\\u0005\\u001e\\u0211\\n\\u001e\\u0003\\u001e\\u0003\\u001e\",\n    \"\\u0007\\u001e\\u0215\\n\\u001e\\f\\u001e\\u000e\\u001e\\u0218\\u000b\\u001e\\u0003\",\n    \"\\u001e\\u0003\\u001e\\u0003\\u001e\\u0005\\u001e\\u021d\\n\\u001e\\u0005\\u001e\",\n    \"\\u021f\\n\\u001e\\u0003\\u001e\\u0003\\u001e\\u0003\\u001f\\u0005\\u001f\\u0224\",\n    \"\\n\\u001f\\u0003\\u001f\\u0005\\u001f\\u0227\\n\\u001f\\u0003\\u001f\\u0003\\u001f\",\n    \"\\u0007\\u001f\\u022b\\n\\u001f\\f\\u001f\\u000e\\u001f\\u022e\\u000b\\u001f\\u0003\",\n    \"\\u001f\\u0003\\u001f\\u0003\\u001f\\u0003 \\u0003 \\u0003 \\u0003 \\u0003 \\u0003\",\n    \" \\u0003 \\u0003 \\u0003 \\u0007 \\u023c\\n \\f \\u000e \\u023f\\u000b \\u0003\",\n    \" \\u0003 \\u0003 \\u0003 \\u0005 \\u0245\\n \\u0003 \\u0003 \\u0003!\\u0005!\\u024a\",\n    \"\\n!\\u0003!\\u0003!\\u0003!\\u0005!\\u024f\\n!\\u0003!\\u0003!\\u0003!\\u0007\",\n    \"!\\u0254\\n!\\f!\\u000e!\\u0257\\u000b!\\u0003!\\u0003!\\u0003!\\u0003!\\u0007\",\n    \"!\\u025d\\n!\\f!\\u000e!\\u0260\\u000b!\\u0003!\\u0003!\\u0003!\\u0003\\\"\\u0005\",\n    \"\\\"\\u0266\\n\\\"\\u0003\\\"\\u0003\\\"\\u0005\\\"\\u026a\\n\\\"\\u0003\\\"\\u0003\\\"\\u0003\",\n    \"\\\"\\u0007\\\"\\u026f\\n\\\"\\f\\\"\\u000e\\\"\\u0272\\u000b\\\"\\u0003\\\"\\u0003\\\"\\u0003\",\n    \"\\\"\\u0003#\\u0003#\\u0003#\\u0003#\\u0003#\\u0003#\\u0003#\\u0005#\\u027e\\n#\",\n    \"\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\\u0003$\\u0005$\\u0288\",\n    \"\\n$\\u0003%\\u0003%\\u0005%\\u028c\\n%\\u0003&\\u0003&\\u0003&\\u0003&\\u0003\",\n    \"&\\u0003&\\u0003&\\u0007&\\u0295\\n&\\f&\\u000e&\\u0298\\u000b&\\u0003&\\u0003\",\n    \"&\\u0003&\\u0003&\\u0005&\\u029e\\n&\\u0003&\\u0003&\\u0003&\\u0003\\'\\u0003\\'\",\n    \"\\u0003\\'\\u0003\\'\\u0005\\'\\u02a7\\n\\'\\u0003\\'\\u0003\\'\\u0003(\\u0003(\\u0003\",\n    \"(\\u0005(\\u02ae\\n(\\u0003)\\u0003)\\u0003*\\u0003*\\u0003+\\u0003+\\u0003,\\u0003\",\n    \",\\u0003-\\u0003-\\u0003.\\u0003.\\u0003/\\u0003/\\u0007/\\u02be\\n/\\f/\\u000e\",\n    \"/\\u02c1\\u000b/\\u0003/\\u0003/\\u00030\\u00030\\u00030\\u00030\\u00050\\u02c9\",\n    \"\\n0\\u00031\\u00031\\u00071\\u02cd\\n1\\f1\\u000e1\\u02d0\\u000b1\\u00032\\u0003\",\n    \"2\\u00032\\u00032\\u00033\\u00033\\u00034\\u00034\\u00035\\u00035\\u00035\\u0003\",\n    \"5\\u00035\\u00035\\u00035\\u00035\\u00075\\u02e2\\n5\\f5\\u000e5\\u02e5\\u000b\",\n    \"5\\u00035\\u00055\\u02e8\\n5\\u00035\\u00035\\u00035\\u00075\\u02ed\\n5\\f5\\u000e\",\n    \"5\\u02f0\\u000b5\\u00035\\u00055\\u02f3\\n5\\u00036\\u00036\\u00076\\u02f7\\n6\",\n    \"\\f6\\u000e6\\u02fa\\u000b6\\u00036\\u00036\\u00036\\u00036\\u0002\\u0004\\f\\u0018\",\n    \"7\\u0002\\u0004\\u0006\\b\\n\\f\\u000e\\u0010\\u0012\\u0014\\u0016\\u0018\\u001a\",\n    \"\\u001c\\u001e \\\"$&(*,.02468:<>@BDFHJLNPRTVXZ\\\\^`bdfhj\\u0002\\t\\u0003\\u0002\",\n    \"&\\'\\u0004\\u0002QQ\\\\\\\\\\u0004\\u0002TT]]\\u0004\\u0002UU__\\u0004\\u0002SS\",\n    \"^^\\u0004\\u0002VVZZ\\u0004\\u0002RR[[\\u0002\\u034c\\u0002o\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0004z\\u0003\\u0002\\u0002\\u0002\\u0006\\u0087\\u0003\\u0002\\u0002\",\n    \"\\u0002\\b\\u0089\\u0003\\u0002\\u0002\\u0002\\n\\u009e\\u0003\\u0002\\u0002\\u0002\",\n    \"\\f\\u00b3\\u0003\\u0002\\u0002\\u0002\\u000e\\u00e3\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0010\\u00f5\\u0003\\u0002\\u0002\\u0002\\u0012\\u00f7\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0014\\u0105\\u0003\\u0002\\u0002\\u0002\\u0016\\u010c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0018\\u011b\\u0003\\u0002\\u0002\\u0002\\u001a\\u0161\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u001c\\u0163\\u0003\\u0002\\u0002\\u0002\\u001e\\u016c\\u0003\\u0002\\u0002\\u0002\",\n    \" \\u0175\\u0003\\u0002\\u0002\\u0002\\\"\\u0188\\u0003\\u0002\\u0002\\u0002$\\u019d\",\n    \"\\u0003\\u0002\\u0002\\u0002&\\u01a2\\u0003\\u0002\\u0002\\u0002(\\u01c5\\u0003\",\n    \"\\u0002\\u0002\\u0002*\\u01c7\\u0003\\u0002\\u0002\\u0002,\\u01ca\\u0003\\u0002\",\n    \"\\u0002\\u0002.\\u01cd\\u0003\\u0002\\u0002\\u00020\\u01d2\\u0003\\u0002\\u0002\",\n    \"\\u00022\\u01d9\\u0003\\u0002\\u0002\\u00024\\u01e3\\u0003\\u0002\\u0002\\u0002\",\n    \"6\\u01fc\\u0003\\u0002\\u0002\\u00028\\u01fe\\u0003\\u0002\\u0002\\u0002:\\u020c\",\n    \"\\u0003\\u0002\\u0002\\u0002<\\u0223\\u0003\\u0002\\u0002\\u0002>\\u0232\\u0003\",\n    \"\\u0002\\u0002\\u0002@\\u0249\\u0003\\u0002\\u0002\\u0002B\\u0265\\u0003\\u0002\",\n    \"\\u0002\\u0002D\\u027d\\u0003\\u0002\\u0002\\u0002F\\u0287\\u0003\\u0002\\u0002\",\n    \"\\u0002H\\u028b\\u0003\\u0002\\u0002\\u0002J\\u028d\\u0003\\u0002\\u0002\\u0002\",\n    \"L\\u02a2\\u0003\\u0002\\u0002\\u0002N\\u02aa\\u0003\\u0002\\u0002\\u0002P\\u02af\",\n    \"\\u0003\\u0002\\u0002\\u0002R\\u02b1\\u0003\\u0002\\u0002\\u0002T\\u02b3\\u0003\",\n    \"\\u0002\\u0002\\u0002V\\u02b5\\u0003\\u0002\\u0002\\u0002X\\u02b7\\u0003\\u0002\",\n    \"\\u0002\\u0002Z\\u02b9\\u0003\\u0002\\u0002\\u0002\\\\\\u02bb\\u0003\\u0002\\u0002\",\n    \"\\u0002^\\u02c8\\u0003\\u0002\\u0002\\u0002`\\u02ca\\u0003\\u0002\\u0002\\u0002\",\n    \"b\\u02d1\\u0003\\u0002\\u0002\\u0002d\\u02d5\\u0003\\u0002\\u0002\\u0002f\\u02d7\",\n    \"\\u0003\\u0002\\u0002\\u0002h\\u02f2\\u0003\\u0002\\u0002\\u0002j\\u02f4\\u0003\",\n    \"\\u0002\\u0002\\u0002ln\\u0005\\u0004\\u0003\\u0002ml\\u0003\\u0002\\u0002\\u0002\",\n    \"nq\\u0003\\u0002\\u0002\\u0002om\\u0003\\u0002\\u0002\\u0002op\\u0003\\u0002\\u0002\",\n    \"\\u0002pu\\u0003\\u0002\\u0002\\u0002qo\\u0003\\u0002\\u0002\\u0002rt\\u0005\\u0006\",\n    \"\\u0004\\u0002sr\\u0003\\u0002\\u0002\\u0002tw\\u0003\\u0002\\u0002\\u0002us\\u0003\",\n    \"\\u0002\\u0002\\u0002uv\\u0003\\u0002\\u0002\\u0002vx\\u0003\\u0002\\u0002\\u0002\",\n    \"wu\\u0003\\u0002\\u0002\\u0002xy\\u0005\\u0016\\f\\u0002y\\u0003\\u0003\\u0002\",\n    \"\\u0002\\u0002z\\u007f\\u0007\\u0006\\u0002\\u0002{|\\t\\u0002\\u0002\\u0002|~\",\n    \"\\u00072\\u0002\\u0002}{\\u0003\\u0002\\u0002\\u0002~\\u0081\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u007f}\\u0003\\u0002\\u0002\\u0002\\u007f\\u0080\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0080\\u0082\\u0003\\u0002\\u0002\\u0002\\u0081\\u007f\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0082\\u0083\\t\\u0002\\u0002\\u0002\\u0083\\u0084\\u0007J\\u0002\\u0002\",\n    \"\\u0084\\u0005\\u0003\\u0002\\u0002\\u0002\\u0085\\u0088\\u0005\\b\\u0005\\u0002\",\n    \"\\u0086\\u0088\\u0005\\n\\u0006\\u0002\\u0087\\u0085\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0087\\u0086\\u0003\\u0002\\u0002\\u0002\\u0088\\u0007\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0089\\u008a\\u0007\\u0007\\u0002\\u0002\\u008a\\u0091\\u0005P)\\u0002\\u008b\",\n    \"\\u008c\\u00078\\u0002\\u0002\\u008c\\u008d\\u0005P)\\u0002\\u008d\\u008e\\u0007\",\n    \"9\\u0002\\u0002\\u008e\\u0090\\u0003\\u0002\\u0002\\u0002\\u008f\\u008b\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0090\\u0093\\u0003\\u0002\\u0002\\u0002\\u0091\\u008f\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0091\\u0092\\u0003\\u0002\\u0002\\u0002\\u0092\\u0097\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0093\\u0091\\u0003\\u0002\\u0002\\u0002\\u0094\\u0096\\u0005\",\n    \"P)\\u0002\\u0095\\u0094\\u0003\\u0002\\u0002\\u0002\\u0096\\u0099\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0097\\u0095\\u0003\\u0002\\u0002\\u0002\\u0097\\u0098\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0098\\u009a\\u0003\\u0002\\u0002\\u0002\\u0099\\u0097\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u009a\\u009b\\u0007B\\u0002\\u0002\\u009b\\u009c\\u0005\\f\\u0007\",\n    \"\\u0002\\u009c\\u009d\\u0007J\\u0002\\u0002\\u009d\\t\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u009e\\u00a2\\u0005T+\\u0002\\u009f\\u00a1\\u0005D#\\u0002\\u00a0\\u009f\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00a1\\u00a4\\u0003\\u0002\\u0002\\u0002\\u00a2\\u00a0\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00a2\\u00a3\\u0003\\u0002\\u0002\\u0002\\u00a3\\u00a8\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00a4\\u00a2\\u0003\\u0002\\u0002\\u0002\\u00a5\\u00a7\\u0005\",\n    \"F$\\u0002\\u00a6\\u00a5\\u0003\\u0002\\u0002\\u0002\\u00a7\\u00aa\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00a8\\u00a6\\u0003\\u0002\\u0002\\u0002\\u00a8\\u00a9\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00a9\\u00ad\\u0003\\u0002\\u0002\\u0002\\u00aa\\u00a8\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00ab\\u00ac\\u0007K\\u0002\\u0002\\u00ac\\u00ae\\u0005\\f\\u0007\",\n    \"\\u0002\\u00ad\\u00ab\\u0003\\u0002\\u0002\\u0002\\u00ad\\u00ae\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u00ae\\u00af\\u0003\\u0002\\u0002\\u0002\\u00af\\u00b0\\u0007B\\u0002\",\n    \"\\u0002\\u00b0\\u00b1\\u0005\\u0016\\f\\u0002\\u00b1\\u00b2\\u0007J\\u0002\\u0002\",\n    \"\\u00b2\\u000b\\u0003\\u0002\\u0002\\u0002\\u00b3\\u00b4\\b\\u0007\\u0001\\u0002\",\n    \"\\u00b4\\u00b5\\u0005\\u000e\\b\\u0002\\u00b5\\u00be\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00b6\\u00b7\\f\\u0004\\u0002\\u0002\\u00b7\\u00b8\\u0007.\\u0002\\u0002\\u00b8\",\n    \"\\u00bd\\u0005\\f\\u0007\\u0005\\u00b9\\u00ba\\f\\u0003\\u0002\\u0002\\u00ba\\u00bb\",\n    \"\\u0007,\\u0002\\u0002\\u00bb\\u00bd\\u0005\\f\\u0007\\u0003\\u00bc\\u00b6\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00bc\\u00b9\\u0003\\u0002\\u0002\\u0002\\u00bd\\u00c0\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00be\\u00bc\\u0003\\u0002\\u0002\\u0002\\u00be\\u00bf\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00bf\\r\\u0003\\u0002\\u0002\\u0002\\u00c0\\u00be\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u00c1\\u00c9\\u0005\\u0010\\t\\u0002\\u00c2\\u00c8\\u0005\",\n    \"\\u0010\\t\\u0002\\u00c3\\u00c4\\u00078\\u0002\\u0002\\u00c4\\u00c5\\u0005N(\\u0002\",\n    \"\\u00c5\\u00c6\\u00079\\u0002\\u0002\\u00c6\\u00c8\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00c7\\u00c2\\u0003\\u0002\\u0002\\u0002\\u00c7\\u00c3\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00c8\\u00cb\\u0003\\u0002\\u0002\\u0002\\u00c9\\u00c7\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00c9\\u00ca\\u0003\\u0002\\u0002\\u0002\\u00ca\\u00e4\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00cb\\u00c9\\u0003\\u0002\\u0002\\u0002\\u00cc\\u00ce\\u0007\\b\\u0002\\u0002\",\n    \"\\u00cd\\u00cf\\u0005D#\\u0002\\u00ce\\u00cd\\u0003\\u0002\\u0002\\u0002\\u00cf\",\n    \"\\u00d0\\u0003\\u0002\\u0002\\u0002\\u00d0\\u00ce\\u0003\\u0002\\u0002\\u0002\\u00d0\",\n    \"\\u00d1\\u0003\\u0002\\u0002\\u0002\\u00d1\\u00d2\\u0003\\u0002\\u0002\\u0002\\u00d2\",\n    \"\\u00d3\\u0007N\\u0002\\u0002\\u00d3\\u00d4\\u0005\\f\\u0007\\u0002\\u00d4\\u00e4\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u00d5\\u00d6\\u0007\\t\\u0002\\u0002\\u00d6\\u00d7\",\n    \"\\u00078\\u0002\\u0002\\u00d7\\u00da\\u0005\\f\\u0007\\u0002\\u00d8\\u00d9\\u0007\",\n    \"-\\u0002\\u0002\\u00d9\\u00db\\u0005\\f\\u0007\\u0002\\u00da\\u00d8\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00da\\u00db\\u0003\\u0002\\u0002\\u0002\\u00db\\u00dc\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00dc\\u00dd\\u00079\\u0002\\u0002\\u00dd\\u00e4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u00de\\u00df\\u0007\\n\\u0002\\u0002\\u00df\\u00e0\\u0005P)\\u0002\",\n    \"\\u00e0\\u00e1\\u0007N\\u0002\\u0002\\u00e1\\u00e2\\u0005\\f\\u0007\\u0002\\u00e2\",\n    \"\\u00e4\\u0003\\u0002\\u0002\\u0002\\u00e3\\u00c1\\u0003\\u0002\\u0002\\u0002\\u00e3\",\n    \"\\u00cc\\u0003\\u0002\\u0002\\u0002\\u00e3\\u00d5\\u0003\\u0002\\u0002\\u0002\\u00e3\",\n    \"\\u00de\\u0003\\u0002\\u0002\\u0002\\u00e4\\u000f\\u0003\\u0002\\u0002\\u0002\\u00e5\",\n    \"\\u00f6\\u0007\\u000b\\u0002\\u0002\\u00e6\\u00f6\\u0007\\f\\u0002\\u0002\\u00e7\",\n    \"\\u00f6\\u0007\\r\\u0002\\u0002\\u00e8\\u00f6\\u0007\\u000e\\u0002\\u0002\\u00e9\",\n    \"\\u00f6\\u0007\\u000f\\u0002\\u0002\\u00ea\\u00f6\\u0007\\u0010\\u0002\\u0002\\u00eb\",\n    \"\\u00f6\\u0005R*\\u0002\\u00ec\\u00f6\\u0005\\u0012\\n\\u0002\\u00ed\\u00ee\\u0007\",\n    \"D\\u0002\\u0002\\u00ee\\u00ef\\u0005\\f\\u0007\\u0002\\u00ef\\u00f0\\u0007E\\u0002\",\n    \"\\u0002\\u00f0\\u00f6\\u0003\\u0002\\u0002\\u0002\\u00f1\\u00f2\\u0007H\\u0002\",\n    \"\\u0002\\u00f2\\u00f3\\u0005\\f\\u0007\\u0002\\u00f3\\u00f4\\u0007I\\u0002\\u0002\",\n    \"\\u00f4\\u00f6\\u0003\\u0002\\u0002\\u0002\\u00f5\\u00e5\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00f5\\u00e6\\u0003\\u0002\\u0002\\u0002\\u00f5\\u00e7\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00f5\\u00e8\\u0003\\u0002\\u0002\\u0002\\u00f5\\u00e9\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00f5\\u00ea\\u0003\\u0002\\u0002\\u0002\\u00f5\\u00eb\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00f5\\u00ec\\u0003\\u0002\\u0002\\u0002\\u00f5\\u00ed\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00f5\\u00f1\\u0003\\u0002\\u0002\\u0002\\u00f6\\u0011\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00f7\\u00fd\\u0007F\\u0002\\u0002\\u00f8\\u00f9\\u0005\\u0014\\u000b\\u0002\",\n    \"\\u00f9\\u00fa\\u0007J\\u0002\\u0002\\u00fa\\u00fc\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00fb\\u00f8\\u0003\\u0002\\u0002\\u0002\\u00fc\\u00ff\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00fd\\u00fb\\u0003\\u0002\\u0002\\u0002\\u00fd\\u00fe\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u00fe\\u0101\\u0003\\u0002\\u0002\\u0002\\u00ff\\u00fd\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0100\\u0102\\u0005\\u0014\\u000b\\u0002\\u0101\\u0100\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0101\\u0102\\u0003\\u0002\\u0002\\u0002\\u0102\\u0103\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0103\\u0104\\u0007G\\u0002\\u0002\\u0104\\u0013\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0105\\u0107\\u0005X-\\u0002\\u0106\\u0108\\u0007O\\u0002\\u0002\\u0107\\u0106\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0107\\u0108\\u0003\\u0002\\u0002\\u0002\\u0108\\u0109\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0109\\u010a\\u0007K\\u0002\\u0002\\u010a\\u010b\",\n    \"\\u0005\\f\\u0007\\u0002\\u010b\\u0015\\u0003\\u0002\\u0002\\u0002\\u010c\\u0111\",\n    \"\\u0005\\u0018\\r\\u0002\\u010d\\u010e\\u0007K\\u0002\\u0002\\u010e\\u0112\\u0005\",\n    \"\\f\\u0007\\u0002\\u010f\\u0110\\u0007L\\u0002\\u0002\\u0110\\u0112\\u0005\\f\\u0007\",\n    \"\\u0002\\u0111\\u010d\\u0003\\u0002\\u0002\\u0002\\u0111\\u010f\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0111\\u0112\\u0003\\u0002\\u0002\\u0002\\u0112\\u0017\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0113\\u0114\\b\\r\\u0001\\u0002\\u0114\\u011c\\u0005\\u001a\\u000e\\u0002\",\n    \"\\u0115\\u0116\\u00070\\u0002\\u0002\\u0116\\u011c\\u0005\\u0018\\r\\u0016\\u0117\",\n    \"\\u0118\\u00074\\u0002\\u0002\\u0118\\u011c\\u0005\\u0018\\r\\u0015\\u0119\\u011a\",\n    \"\\u0007A\\u0002\\u0002\\u011a\\u011c\\u0005\\u0018\\r\\u0014\\u011b\\u0113\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u011b\\u0115\\u0003\\u0002\\u0002\\u0002\\u011b\\u0117\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u011b\\u0119\\u0003\\u0002\\u0002\\u0002\\u011c\\u0152\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u011d\\u011e\\f\\u0013\\u0002\\u0002\\u011e\\u011f\\u0007\",\n    \"@\\u0002\\u0002\\u011f\\u0151\\u0005\\u0018\\r\\u0014\\u0120\\u0121\\f\\u0012\\u0002\",\n    \"\\u0002\\u0121\\u0122\\u00073\\u0002\\u0002\\u0122\\u0151\\u0005\\u0018\\r\\u0013\",\n    \"\\u0123\\u0124\\f\\u0011\\u0002\\u0002\\u0124\\u0125\\u00072\\u0002\\u0002\\u0125\",\n    \"\\u0151\\u0005\\u0018\\r\\u0012\\u0126\\u0127\\f\\u0010\\u0002\\u0002\\u0127\\u0128\",\n    \"\\u00071\\u0002\\u0002\\u0128\\u0151\\u0005\\u0018\\r\\u0011\\u0129\\u012a\\f\\u000f\",\n    \"\\u0002\\u0002\\u012a\\u012b\\u00070\\u0002\\u0002\\u012b\\u0151\\u0005\\u0018\",\n    \"\\r\\u0010\\u012c\\u012d\\f\\u000e\\u0002\\u0002\\u012d\\u012e\\u0007/\\u0002\\u0002\",\n    \"\\u012e\\u0151\\u0005\\u0018\\r\\u000f\\u012f\\u0130\\f\\r\\u0002\\u0002\\u0130\\u0131\",\n    \"\\u00077\\u0002\\u0002\\u0131\\u0151\\u0005\\u0018\\r\\u000e\\u0132\\u0133\\f\\f\",\n    \"\\u0002\\u0002\\u0133\\u0134\\u00078\\u0002\\u0002\\u0134\\u0151\\u0005\\u0018\",\n    \"\\r\\r\\u0135\\u0136\\f\\u000b\\u0002\\u0002\\u0136\\u0137\\u00079\\u0002\\u0002\",\n    \"\\u0137\\u0151\\u0005\\u0018\\r\\f\\u0138\\u0139\\f\\n\\u0002\\u0002\\u0139\\u013a\",\n    \"\\u0007:\\u0002\\u0002\\u013a\\u0151\\u0005\\u0018\\r\\u000b\\u013b\\u013c\\f\\t\",\n    \"\\u0002\\u0002\\u013c\\u013d\\u0007;\\u0002\\u0002\\u013d\\u0151\\u0005\\u0018\",\n    \"\\r\\n\\u013e\\u013f\\f\\b\\u0002\\u0002\\u013f\\u0140\\u0007<\\u0002\\u0002\\u0140\",\n    \"\\u0151\\u0005\\u0018\\r\\t\\u0141\\u0142\\f\\u0007\\u0002\\u0002\\u0142\\u0143\\u0007\",\n    \"=\\u0002\\u0002\\u0143\\u0151\\u0005\\u0018\\r\\b\\u0144\\u0145\\f\\u0006\\u0002\",\n    \"\\u0002\\u0145\\u0146\\u00075\\u0002\\u0002\\u0146\\u0151\\u0005\\u0018\\r\\u0006\",\n    \"\\u0147\\u0148\\f\\u0005\\u0002\\u0002\\u0148\\u0149\\u00076\\u0002\\u0002\\u0149\",\n    \"\\u0151\\u0005\\u0018\\r\\u0005\\u014a\\u014b\\f\\u0004\\u0002\\u0002\\u014b\\u014c\",\n    \"\\u0007?\\u0002\\u0002\\u014c\\u0151\\u0005\\u0018\\r\\u0005\\u014d\\u014e\\f\\u0003\",\n    \"\\u0002\\u0002\\u014e\\u014f\\u0007>\\u0002\\u0002\\u014f\\u0151\\u0005\\u0018\",\n    \"\\r\\u0004\\u0150\\u011d\\u0003\\u0002\\u0002\\u0002\\u0150\\u0120\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0150\\u0123\\u0003\\u0002\\u0002\\u0002\\u0150\\u0126\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0150\\u0129\\u0003\\u0002\\u0002\\u0002\\u0150\\u012c\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0150\\u012f\\u0003\\u0002\\u0002\\u0002\\u0150\\u0132\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0150\\u0135\\u0003\\u0002\\u0002\\u0002\\u0150\\u0138\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0150\\u013b\\u0003\\u0002\\u0002\\u0002\\u0150\\u013e\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0150\\u0141\\u0003\\u0002\\u0002\\u0002\\u0150\\u0144\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0150\\u0147\\u0003\\u0002\\u0002\\u0002\\u0150\\u014a\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0150\\u014d\\u0003\\u0002\\u0002\\u0002\\u0151\\u0154\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0152\\u0150\\u0003\\u0002\\u0002\\u0002\\u0152\\u0153\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0153\\u0019\\u0003\\u0002\\u0002\\u0002\\u0154\\u0152\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0155\\u0162\\u00052\\u001a\\u0002\\u0156\\u0162\\u0005\\u001c\",\n    \"\\u000f\\u0002\\u0157\\u0162\\u0005\\u001e\\u0010\\u0002\\u0158\\u0162\\u0005 \",\n    \"\\u0011\\u0002\\u0159\\u0162\\u0005\\\"\\u0012\\u0002\\u015a\\u0162\\u0005$\\u0013\",\n    \"\\u0002\\u015b\\u0162\\u0005&\\u0014\\u0002\\u015c\\u0162\\u0005(\\u0015\\u0002\",\n    \"\\u015d\\u0162\\u0005*\\u0016\\u0002\\u015e\\u0162\\u0005,\\u0017\\u0002\\u015f\",\n    \"\\u0162\\u0005.\\u0018\\u0002\\u0160\\u0162\\u00050\\u0019\\u0002\\u0161\\u0155\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0161\\u0156\\u0003\\u0002\\u0002\\u0002\\u0161\\u0157\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0161\\u0158\\u0003\\u0002\\u0002\\u0002\\u0161\\u0159\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0161\\u015a\\u0003\\u0002\\u0002\\u0002\\u0161\\u015b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0161\\u015c\\u0003\\u0002\\u0002\\u0002\\u0161\\u015d\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0161\\u015e\\u0003\\u0002\\u0002\\u0002\\u0161\\u015f\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0161\\u0160\\u0003\\u0002\\u0002\\u0002\\u0162\\u001b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0163\\u0165\\u0007L\\u0002\\u0002\\u0164\\u0166\",\n    \"\\u0005F$\\u0002\\u0165\\u0164\\u0003\\u0002\\u0002\\u0002\\u0166\\u0167\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0167\\u0165\\u0003\\u0002\\u0002\\u0002\\u0167\\u0168\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0168\\u0169\\u0003\\u0002\\u0002\\u0002\\u0169\\u016a\\u0007\",\n    \",\\u0002\\u0002\\u016a\\u016b\\u0005\\u0016\\f\\u0002\\u016b\\u001d\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u016c\\u016e\\u0007M\\u0002\\u0002\\u016d\\u016f\\u0005D#\\u0002\",\n    \"\\u016e\\u016d\\u0003\\u0002\\u0002\\u0002\\u016f\\u0170\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0170\\u016e\\u0003\\u0002\\u0002\\u0002\\u0170\\u0171\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0171\\u0172\\u0003\\u0002\\u0002\\u0002\\u0172\\u0173\\u0007N\\u0002\\u0002\",\n    \"\\u0173\\u0174\\u0005\\u0016\\f\\u0002\\u0174\\u001f\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0175\\u0176\\u0007\\u0011\\u0002\\u0002\\u0176\\u017a\\u0005T+\\u0002\\u0177\",\n    \"\\u0179\\u0005D#\\u0002\\u0178\\u0177\\u0003\\u0002\\u0002\\u0002\\u0179\\u017c\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u017a\\u0178\\u0003\\u0002\\u0002\\u0002\\u017a\\u017b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u017b\\u0180\\u0003\\u0002\\u0002\\u0002\\u017c\\u017a\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u017d\\u017f\\u0005F$\\u0002\\u017e\\u017d\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u017f\\u0182\\u0003\\u0002\\u0002\\u0002\\u0180\\u017e\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0180\\u0181\\u0003\\u0002\\u0002\\u0002\\u0181\\u0183\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0182\\u0180\\u0003\\u0002\\u0002\\u0002\\u0183\\u0184\\u0007\",\n    \"B\\u0002\\u0002\\u0184\\u0185\\u0005\\u0016\\f\\u0002\\u0185\\u0186\\u0007\\u0013\",\n    \"\\u0002\\u0002\\u0186\\u0187\\u0005\\u0016\\f\\u0002\\u0187!\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0188\\u0189\\u0007\\u0012\\u0002\\u0002\\u0189\\u018d\\u0005T+\\u0002\",\n    \"\\u018a\\u018c\\u0005D#\\u0002\\u018b\\u018a\\u0003\\u0002\\u0002\\u0002\\u018c\",\n    \"\\u018f\\u0003\\u0002\\u0002\\u0002\\u018d\\u018b\\u0003\\u0002\\u0002\\u0002\\u018d\",\n    \"\\u018e\\u0003\\u0002\\u0002\\u0002\\u018e\\u0193\\u0003\\u0002\\u0002\\u0002\\u018f\",\n    \"\\u018d\\u0003\\u0002\\u0002\\u0002\\u0190\\u0192\\u0005F$\\u0002\\u0191\\u0190\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0192\\u0195\\u0003\\u0002\\u0002\\u0002\\u0193\\u0191\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0193\\u0194\\u0003\\u0002\\u0002\\u0002\\u0194\\u0196\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0195\\u0193\\u0003\\u0002\\u0002\\u0002\\u0196\\u0197\",\n    \"\\u0007K\\u0002\\u0002\\u0197\\u0198\\u0005\\f\\u0007\\u0002\\u0198\\u0199\\u0007\",\n    \"B\\u0002\\u0002\\u0199\\u019a\\u0005\\u0016\\f\\u0002\\u019a\\u019b\\u0007\\u0013\",\n    \"\\u0002\\u0002\\u019b\\u019c\\u0005\\u0016\\f\\u0002\\u019c#\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u019d\\u019e\\u0007\\u0006\\u0002\\u0002\\u019e\\u019f\\u0005\\u0016\\f\",\n    \"\\u0002\\u019f\\u01a0\\u0007\\u0013\\u0002\\u0002\\u01a0\\u01a1\\u0005\\u0016\\f\",\n    \"\\u0002\\u01a1%\\u0003\\u0002\\u0002\\u0002\\u01a2\\u01a3\\u0007\\u0014\\u0002\",\n    \"\\u0002\\u01a3\\u01a4\\u0005\\u0016\\f\\u0002\\u01a4\\u01a5\\u0007\\u0015\\u0002\",\n    \"\\u0002\\u01a5\\u01a6\\u0005\\u0016\\f\\u0002\\u01a6\\u01a7\\u0007\\u0016\\u0002\",\n    \"\\u0002\\u01a7\\u01a8\\u0005\\u0016\\f\\u0002\\u01a8\\'\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u01a9\\u01ab\\u0007\\u0017\\u0002\\u0002\\u01aa\\u01ac\\u0005L\\'\\u0002\\u01ab\",\n    \"\\u01aa\\u0003\\u0002\\u0002\\u0002\\u01ab\\u01ac\\u0003\\u0002\\u0002\\u0002\\u01ac\",\n    \"\\u01af\\u0003\\u0002\\u0002\\u0002\\u01ad\\u01ae\\u0007\\u0018\\u0002\\u0002\\u01ae\",\n    \"\\u01b0\\u0005\\f\\u0007\\u0002\\u01af\\u01ad\\u0003\\u0002\\u0002\\u0002\\u01af\",\n    \"\\u01b0\\u0003\\u0002\\u0002\\u0002\\u01b0\\u01b3\\u0003\\u0002\\u0002\\u0002\\u01b1\",\n    \"\\u01b2\\u0007\\u0019\\u0002\\u0002\\u01b2\\u01b4\\u0005\\u0018\\r\\u0002\\u01b3\",\n    \"\\u01b1\\u0003\\u0002\\u0002\\u0002\\u01b3\\u01b4\\u0003\\u0002\\u0002\\u0002\\u01b4\",\n    \"\\u01b5\\u0003\\u0002\\u0002\\u0002\\u01b5\\u01b6\\u0007-\\u0002\\u0002\\u01b6\",\n    \"\\u01c6\\u0005\\u0018\\r\\u0002\\u01b7\\u01b9\\u0007\\u0017\\u0002\\u0002\\u01b8\",\n    \"\\u01ba\\u0005L\\'\\u0002\\u01b9\\u01b8\\u0003\\u0002\\u0002\\u0002\\u01b9\\u01ba\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01ba\\u01bd\\u0003\\u0002\\u0002\\u0002\\u01bb\\u01bc\",\n    \"\\u0007\\u0019\\u0002\\u0002\\u01bc\\u01be\\u0005\\u0018\\r\\u0002\\u01bd\\u01bb\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01bd\\u01be\\u0003\\u0002\\u0002\\u0002\\u01be\\u01c1\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01bf\\u01c0\\u0007\\u0018\\u0002\\u0002\\u01c0\\u01c2\",\n    \"\\u0005\\f\\u0007\\u0002\\u01c1\\u01bf\\u0003\\u0002\\u0002\\u0002\\u01c1\\u01c2\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u01c2\\u01c3\\u0003\\u0002\\u0002\\u0002\\u01c3\\u01c4\",\n    \"\\u0007-\\u0002\\u0002\\u01c4\\u01c6\\u0005\\u0018\\r\\u0002\\u01c5\\u01a9\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01c5\\u01b7\\u0003\\u0002\\u0002\\u0002\\u01c6)\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01c7\\u01c8\\u0007\\u001a\\u0002\\u0002\\u01c8\\u01c9\\u0005\",\n    \"\\u0018\\r\\u0002\\u01c9+\\u0003\\u0002\\u0002\\u0002\\u01ca\\u01cb\\u0007\\u001b\",\n    \"\\u0002\\u0002\\u01cb\\u01cc\\u00054\\u001b\\u0002\\u01cc-\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01cd\\u01ce\\u0007\\u001c\\u0002\\u0002\\u01ce\\u01cf\\u0007\\u001e\\u0002\",\n    \"\\u0002\\u01cf\\u01d0\\u0005\\u0010\\t\\u0002\\u01d0\\u01d1\\u00054\\u001b\\u0002\",\n    \"\\u01d1/\\u0003\\u0002\\u0002\\u0002\\u01d2\\u01d3\\u0007\\u001d\\u0002\\u0002\",\n    \"\\u01d3\\u01d4\\u0007\\u001e\\u0002\\u0002\\u01d4\\u01d5\\u0005\\u0010\\t\\u0002\",\n    \"\\u01d5\\u01d6\\u00054\\u001b\\u0002\\u01d61\\u0003\\u0002\\u0002\\u0002\\u01d7\",\n    \"\\u01da\\u0005P)\\u0002\\u01d8\\u01da\\u00054\\u001b\\u0002\\u01d9\\u01d7\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01d9\\u01d8\\u0003\\u0002\\u0002\\u0002\\u01da\\u01e0\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01db\\u01df\\u00054\\u001b\\u0002\\u01dc\\u01dd\\u0007\",\n    \"\\u001e\\u0002\\u0002\\u01dd\\u01df\\u0005\\u0010\\t\\u0002\\u01de\\u01db\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01de\\u01dc\\u0003\\u0002\\u0002\\u0002\\u01df\\u01e2\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01e0\\u01de\\u0003\\u0002\\u0002\\u0002\\u01e0\\u01e1\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01e13\\u0003\\u0002\\u0002\\u0002\\u01e2\\u01e0\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u01e3\\u01e8\\u00056\\u001c\\u0002\\u01e4\\u01e5\\u0007\",\n    \"N\\u0002\\u0002\\u01e5\\u01e7\\u0005Z.\\u0002\\u01e6\\u01e4\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01e7\\u01ea\\u0003\\u0002\\u0002\\u0002\\u01e8\\u01e6\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01e8\\u01e9\\u0003\\u0002\\u0002\\u0002\\u01e95\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u01ea\\u01e8\\u0003\\u0002\\u0002\\u0002\\u01eb\\u01fd\\u0005V,\\u0002\",\n    \"\\u01ec\\u01fd\\u0007(\\u0002\\u0002\\u01ed\\u01fd\\u0005\\\\/\\u0002\\u01ee\\u01fd\",\n    \"\\u0007*\\u0002\\u0002\\u01ef\\u01fd\\u0007+\\u0002\\u0002\\u01f0\\u01fd\\u0007\",\n    \"\\u001f\\u0002\\u0002\\u01f1\\u01fd\\u0007 \\u0002\\u0002\\u01f2\\u01fd\\u0007\",\n    \"!\\u0002\\u0002\\u01f3\\u01fd\\u00058\\u001d\\u0002\\u01f4\\u01fd\\u0005:\\u001e\",\n    \"\\u0002\\u01f5\\u01fd\\u0005> \\u0002\\u01f6\\u01f7\\u0007P\\u0002\\u0002\\u01f7\",\n    \"\\u01fd\\u0005P)\\u0002\\u01f8\\u01f9\\u0007H\\u0002\\u0002\\u01f9\\u01fa\\u0005\",\n    \"\\u0016\\f\\u0002\\u01fa\\u01fb\\u0007I\\u0002\\u0002\\u01fb\\u01fd\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01fc\\u01eb\\u0003\\u0002\\u0002\\u0002\\u01fc\\u01ec\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01fc\\u01ed\\u0003\\u0002\\u0002\\u0002\\u01fc\\u01ee\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01fc\\u01ef\\u0003\\u0002\\u0002\\u0002\\u01fc\\u01f0\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01fc\\u01f1\\u0003\\u0002\\u0002\\u0002\\u01fc\\u01f2\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01fc\\u01f3\\u0003\\u0002\\u0002\\u0002\\u01fc\\u01f4\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01fc\\u01f5\\u0003\\u0002\\u0002\\u0002\\u01fc\\u01f6\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01fc\\u01f8\\u0003\\u0002\\u0002\\u0002\\u01fd7\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u01fe\\u0204\\u0007D\\u0002\\u0002\\u01ff\\u0200\\u0005\\u0016\",\n    \"\\f\\u0002\\u0200\\u0201\\u0007J\\u0002\\u0002\\u0201\\u0203\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0202\\u01ff\\u0003\\u0002\\u0002\\u0002\\u0203\\u0206\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0204\\u0202\\u0003\\u0002\\u0002\\u0002\\u0204\\u0205\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0205\\u0208\\u0003\\u0002\\u0002\\u0002\\u0206\\u0204\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0207\\u0209\\u0005\\u0016\\f\\u0002\\u0208\\u0207\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0208\\u0209\\u0003\\u0002\\u0002\\u0002\\u0209\\u020a\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u020a\\u020b\\u0007E\\u0002\\u0002\\u020b9\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u020c\\u0216\\u0007F\\u0002\\u0002\\u020d\\u0211\\u0005<\\u001f\\u0002\\u020e\",\n    \"\\u0211\\u0005@!\\u0002\\u020f\\u0211\\u0005B\\\"\\u0002\\u0210\\u020d\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0210\\u020e\\u0003\\u0002\\u0002\\u0002\\u0210\\u020f\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0211\\u0212\\u0003\\u0002\\u0002\\u0002\\u0212\\u0213\\u0007J\",\n    \"\\u0002\\u0002\\u0213\\u0215\\u0003\\u0002\\u0002\\u0002\\u0214\\u0210\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0215\\u0218\\u0003\\u0002\\u0002\\u0002\\u0216\\u0214\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0216\\u0217\\u0003\\u0002\\u0002\\u0002\\u0217\\u021e\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u0218\\u0216\\u0003\\u0002\\u0002\\u0002\\u0219\\u021d\\u0005<\",\n    \"\\u001f\\u0002\\u021a\\u021d\\u0005@!\\u0002\\u021b\\u021d\\u0005B\\\"\\u0002\\u021c\",\n    \"\\u0219\\u0003\\u0002\\u0002\\u0002\\u021c\\u021a\\u0003\\u0002\\u0002\\u0002\\u021c\",\n    \"\\u021b\\u0003\\u0002\\u0002\\u0002\\u021d\\u021f\\u0003\\u0002\\u0002\\u0002\\u021e\",\n    \"\\u021c\\u0003\\u0002\\u0002\\u0002\\u021e\\u021f\\u0003\\u0002\\u0002\\u0002\\u021f\",\n    \"\\u0220\\u0003\\u0002\\u0002\\u0002\\u0220\\u0221\\u0007G\\u0002\\u0002\\u0221\",\n    \";\\u0003\\u0002\\u0002\\u0002\\u0222\\u0224\\u0007\\\"\\u0002\\u0002\\u0223\\u0222\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0223\\u0224\\u0003\\u0002\\u0002\\u0002\\u0224\\u0226\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0225\\u0227\\u0005L\\'\\u0002\\u0226\\u0225\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0226\\u0227\\u0003\\u0002\\u0002\\u0002\\u0227\\u0228\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u0228\\u022c\\u0005X-\\u0002\\u0229\\u022b\\u0005F$\\u0002\",\n    \"\\u022a\\u0229\\u0003\\u0002\\u0002\\u0002\\u022b\\u022e\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u022c\\u022a\\u0003\\u0002\\u0002\\u0002\\u022c\\u022d\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u022d\\u022f\\u0003\\u0002\\u0002\\u0002\\u022e\\u022c\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u022f\\u0230\\u0007B\\u0002\\u0002\\u0230\\u0231\\u0005\\u0016\\f\\u0002\\u0231\",\n    \"=\\u0003\\u0002\\u0002\\u0002\\u0232\\u0233\\u0007F\\u0002\\u0002\\u0233\\u0234\",\n    \"\\u0005\\u0016\\f\\u0002\\u0234\\u023d\\u0007#\\u0002\\u0002\\u0235\\u0236\\u0005\",\n    \"X-\\u0002\\u0236\\u0237\\u0007B\\u0002\\u0002\\u0237\\u0238\\u0005\\u0016\\f\\u0002\",\n    \"\\u0238\\u0239\\u0003\\u0002\\u0002\\u0002\\u0239\\u023a\\u0007J\\u0002\\u0002\",\n    \"\\u023a\\u023c\\u0003\\u0002\\u0002\\u0002\\u023b\\u0235\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u023c\\u023f\\u0003\\u0002\\u0002\\u0002\\u023d\\u023b\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u023d\\u023e\\u0003\\u0002\\u0002\\u0002\\u023e\\u0244\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u023f\\u023d\\u0003\\u0002\\u0002\\u0002\\u0240\\u0241\\u0005X-\\u0002\\u0241\",\n    \"\\u0242\\u0007B\\u0002\\u0002\\u0242\\u0243\\u0005\\u0016\\f\\u0002\\u0243\\u0245\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0244\\u0240\\u0003\\u0002\\u0002\\u0002\\u0244\\u0245\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0245\\u0246\\u0003\\u0002\\u0002\\u0002\\u0246\\u0247\",\n    \"\\u0007G\\u0002\\u0002\\u0247?\\u0003\\u0002\\u0002\\u0002\\u0248\\u024a\\u0007\",\n    \"\\\"\\u0002\\u0002\\u0249\\u0248\\u0003\\u0002\\u0002\\u0002\\u0249\\u024a\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u024a\\u024e\\u0003\\u0002\\u0002\\u0002\\u024b\\u024c\\u0005\",\n    \"L\\'\\u0002\\u024c\\u024d\\u0007\\u001e\\u0002\\u0002\\u024d\\u024f\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u024e\\u024b\\u0003\\u0002\\u0002\\u0002\\u024e\\u024f\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u024f\\u0250\\u0003\\u0002\\u0002\\u0002\\u0250\\u0251\\u0007H\",\n    \"\\u0002\\u0002\\u0251\\u0255\\u0005X-\\u0002\\u0252\\u0254\\u0005F$\\u0002\\u0253\",\n    \"\\u0252\\u0003\\u0002\\u0002\\u0002\\u0254\\u0257\\u0003\\u0002\\u0002\\u0002\\u0255\",\n    \"\\u0253\\u0003\\u0002\\u0002\\u0002\\u0255\\u0256\\u0003\\u0002\\u0002\\u0002\\u0256\",\n    \"\\u0258\\u0003\\u0002\\u0002\\u0002\\u0257\\u0255\\u0003\\u0002\\u0002\\u0002\\u0258\",\n    \"\\u0259\\u0007I\\u0002\\u0002\\u0259\\u025a\\u0007N\\u0002\\u0002\\u025a\\u025e\",\n    \"\\u0005X-\\u0002\\u025b\\u025d\\u0005F$\\u0002\\u025c\\u025b\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u025d\\u0260\\u0003\\u0002\\u0002\\u0002\\u025e\\u025c\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u025e\\u025f\\u0003\\u0002\\u0002\\u0002\\u025f\\u0261\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0260\\u025e\\u0003\\u0002\\u0002\\u0002\\u0261\\u0262\\u0007B\\u0002\",\n    \"\\u0002\\u0262\\u0263\\u0005\\u0016\\f\\u0002\\u0263A\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0264\\u0266\\u0007\\\"\\u0002\\u0002\\u0265\\u0264\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0265\\u0266\\u0003\\u0002\\u0002\\u0002\\u0266\\u0269\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0267\\u026a\\u0007%\\u0002\\u0002\\u0268\\u026a\\u0005L\\'\\u0002\\u0269\\u0267\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u0269\\u0268\\u0003\\u0002\\u0002\\u0002\\u026a\\u026b\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u026b\\u026c\\u0007N\\u0002\\u0002\\u026c\\u0270\",\n    \"\\u0005X-\\u0002\\u026d\\u026f\\u0005F$\\u0002\\u026e\\u026d\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u026f\\u0272\\u0003\\u0002\\u0002\\u0002\\u0270\\u026e\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0270\\u0271\\u0003\\u0002\\u0002\\u0002\\u0271\\u0273\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0272\\u0270\\u0003\\u0002\\u0002\\u0002\\u0273\\u0274\\u0007B\\u0002\",\n    \"\\u0002\\u0274\\u0275\\u0005\\u0016\\f\\u0002\\u0275C\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0276\\u027e\\u0005P)\\u0002\\u0277\\u0278\\u0007H\\u0002\\u0002\\u0278\\u0279\",\n    \"\\u0005P)\\u0002\\u0279\\u027a\\u00071\\u0002\\u0002\\u027a\\u027b\\u0005\\f\\u0007\",\n    \"\\u0002\\u027b\\u027c\\u0007I\\u0002\\u0002\\u027c\\u027e\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u027d\\u0276\\u0003\\u0002\\u0002\\u0002\\u027d\\u0277\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u027eE\\u0003\\u0002\\u0002\\u0002\\u027f\\u0288\\u0005H%\\u0002\\u0280\",\n    \"\\u0281\\u0007H\\u0002\\u0002\\u0281\\u0282\\u0005H%\\u0002\\u0282\\u0283\\u0007\",\n    \"K\\u0002\\u0002\\u0283\\u0284\\u0005\\f\\u0007\\u0002\\u0284\\u0285\\u0007I\\u0002\",\n    \"\\u0002\\u0285\\u0288\\u0003\\u0002\\u0002\\u0002\\u0286\\u0288\\u0005J&\\u0002\",\n    \"\\u0287\\u027f\\u0003\\u0002\\u0002\\u0002\\u0287\\u0280\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0287\\u0286\\u0003\\u0002\\u0002\\u0002\\u0288G\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u0289\\u028c\\u0007%\\u0002\\u0002\\u028a\\u028c\\u0005T+\\u0002\\u028b\\u0289\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u028b\\u028a\\u0003\\u0002\\u0002\\u0002\\u028cI\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u028d\\u0296\\u0007F\\u0002\\u0002\\u028e\\u028f\",\n    \"\\u0005X-\\u0002\\u028f\\u0290\\u0007B\\u0002\\u0002\\u0290\\u0291\\u0005\\u0016\",\n    \"\\f\\u0002\\u0291\\u0292\\u0003\\u0002\\u0002\\u0002\\u0292\\u0293\\u0007J\\u0002\",\n    \"\\u0002\\u0293\\u0295\\u0003\\u0002\\u0002\\u0002\\u0294\\u028e\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0295\\u0298\\u0003\\u0002\\u0002\\u0002\\u0296\\u0294\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0296\\u0297\\u0003\\u0002\\u0002\\u0002\\u0297\\u029d\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u0298\\u0296\\u0003\\u0002\\u0002\\u0002\\u0299\\u029a\\u0005X-\\u0002\",\n    \"\\u029a\\u029b\\u0007B\\u0002\\u0002\\u029b\\u029c\\u0005\\u0016\\f\\u0002\\u029c\",\n    \"\\u029e\\u0003\\u0002\\u0002\\u0002\\u029d\\u0299\\u0003\\u0002\\u0002\\u0002\\u029d\",\n    \"\\u029e\\u0003\\u0002\\u0002\\u0002\\u029e\\u029f\\u0003\\u0002\\u0002\\u0002\\u029f\",\n    \"\\u02a0\\u0007$\\u0002\\u0002\\u02a0\\u02a1\\u0007G\\u0002\\u0002\\u02a1K\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u02a2\\u02a3\\u0007D\\u0002\\u0002\\u02a3\\u02a6\\u0005\",\n    \"T+\\u0002\\u02a4\\u02a5\\u0007K\\u0002\\u0002\\u02a5\\u02a7\\u0005\\f\\u0007\\u0002\",\n    \"\\u02a6\\u02a4\\u0003\\u0002\\u0002\\u0002\\u02a6\\u02a7\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u02a7\\u02a8\\u0003\\u0002\\u0002\\u0002\\u02a8\\u02a9\\u0007E\\u0002\\u0002\",\n    \"\\u02a9M\\u0003\\u0002\\u0002\\u0002\\u02aa\\u02ad\\u0005\\f\\u0007\\u0002\\u02ab\",\n    \"\\u02ac\\u0007-\\u0002\\u0002\\u02ac\\u02ae\\u0005\\f\\u0007\\u0002\\u02ad\\u02ab\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u02ad\\u02ae\\u0003\\u0002\\u0002\\u0002\\u02aeO\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u02af\\u02b0\\u0007\\'\\u0002\\u0002\\u02b0Q\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u02b1\\u02b2\\u0007\\'\\u0002\\u0002\\u02b2S\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u02b3\\u02b4\\u0007&\\u0002\\u0002\\u02b4U\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u02b5\\u02b6\\t\\u0002\\u0002\\u0002\\u02b6W\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u02b7\\u02b8\\t\\u0002\\u0002\\u0002\\u02b8Y\\u0003\\u0002\\u0002\\u0002\\u02b9\",\n    \"\\u02ba\\t\\u0002\\u0002\\u0002\\u02ba[\\u0003\\u0002\\u0002\\u0002\\u02bb\\u02bf\",\n    \"\\u0007)\\u0002\\u0002\\u02bc\\u02be\\u0005^0\\u0002\\u02bd\\u02bc\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u02be\\u02c1\\u0003\\u0002\\u0002\\u0002\\u02bf\\u02bd\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u02bf\\u02c0\\u0003\\u0002\\u0002\\u0002\\u02c0\\u02c2\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u02c1\\u02bf\\u0003\\u0002\\u0002\\u0002\\u02c2\\u02c3\\t\\u0003\",\n    \"\\u0002\\u0002\\u02c3]\\u0003\\u0002\\u0002\\u0002\\u02c4\\u02c9\\u0005`1\\u0002\",\n    \"\\u02c5\\u02c9\\u0005b2\\u0002\\u02c6\\u02c9\\u0005d3\\u0002\\u02c7\\u02c9\\u0005\",\n    \"f4\\u0002\\u02c8\\u02c4\\u0003\\u0002\\u0002\\u0002\\u02c8\\u02c5\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u02c8\\u02c6\\u0003\\u0002\\u0002\\u0002\\u02c8\\u02c7\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u02c9_\\u0003\\u0002\\u0002\\u0002\\u02ca\\u02ce\\t\\u0004\\u0002\",\n    \"\\u0002\\u02cb\\u02cd\\u0005h5\\u0002\\u02cc\\u02cb\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u02cd\\u02d0\\u0003\\u0002\\u0002\\u0002\\u02ce\\u02cc\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u02ce\\u02cf\\u0003\\u0002\\u0002\\u0002\\u02cfa\\u0003\\u0002\\u0002\\u0002\",\n    \"\\u02d0\\u02ce\\u0003\\u0002\\u0002\\u0002\\u02d1\\u02d2\\t\\u0005\\u0002\\u0002\",\n    \"\\u02d2\\u02d3\\u0005\\u0016\\f\\u0002\\u02d3\\u02d4\\u0007I\\u0002\\u0002\\u02d4\",\n    \"c\\u0003\\u0002\\u0002\\u0002\\u02d5\\u02d6\\t\\u0006\\u0002\\u0002\\u02d6e\\u0003\",\n    \"\\u0002\\u0002\\u0002\\u02d7\\u02d8\\t\\u0007\\u0002\\u0002\\u02d8g\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u02d9\\u02da\\u0007W\\u0002\\u0002\\u02da\\u02db\\u0005\\u0016\",\n    \"\\f\\u0002\\u02db\\u02dc\\u0007I\\u0002\\u0002\\u02dc\\u02f3\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u02dd\\u02e3\\u0007X\\u0002\\u0002\\u02de\\u02df\\u0005j6\\u0002\\u02df\",\n    \"\\u02e0\\u0007J\\u0002\\u0002\\u02e0\\u02e2\\u0003\\u0002\\u0002\\u0002\\u02e1\",\n    \"\\u02de\\u0003\\u0002\\u0002\\u0002\\u02e2\\u02e5\\u0003\\u0002\\u0002\\u0002\\u02e3\",\n    \"\\u02e1\\u0003\\u0002\\u0002\\u0002\\u02e3\\u02e4\\u0003\\u0002\\u0002\\u0002\\u02e4\",\n    \"\\u02e7\\u0003\\u0002\\u0002\\u0002\\u02e5\\u02e3\\u0003\\u0002\\u0002\\u0002\\u02e6\",\n    \"\\u02e8\\u0005j6\\u0002\\u02e7\\u02e6\\u0003\\u0002\\u0002\\u0002\\u02e7\\u02e8\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u02e8\\u02e9\\u0003\\u0002\\u0002\\u0002\\u02e9\\u02f3\",\n    \"\\u0007G\\u0002\\u0002\\u02ea\\u02ee\\u0007Y\\u0002\\u0002\\u02eb\\u02ed\\u0005\",\n    \"^0\\u0002\\u02ec\\u02eb\\u0003\\u0002\\u0002\\u0002\\u02ed\\u02f0\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u02ee\\u02ec\\u0003\\u0002\\u0002\\u0002\\u02ee\\u02ef\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u02ef\\u02f1\\u0003\\u0002\\u0002\\u0002\\u02f0\\u02ee\\u0003\\u0002\",\n    \"\\u0002\\u0002\\u02f1\\u02f3\\t\\b\\u0002\\u0002\\u02f2\\u02d9\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u02f2\\u02dd\\u0003\\u0002\\u0002\\u0002\\u02f2\\u02ea\\u0003\\u0002\\u0002\",\n    \"\\u0002\\u02f3i\\u0003\\u0002\\u0002\\u0002\\u02f4\\u02f8\\u0005X-\\u0002\\u02f5\",\n    \"\\u02f7\\u0005F$\\u0002\\u02f6\\u02f5\\u0003\\u0002\\u0002\\u0002\\u02f7\\u02fa\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u02f8\\u02f6\\u0003\\u0002\\u0002\\u0002\\u02f8\\u02f9\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u02f9\\u02fb\\u0003\\u0002\\u0002\\u0002\\u02fa\\u02f8\",\n    \"\\u0003\\u0002\\u0002\\u0002\\u02fb\\u02fc\\u0007B\\u0002\\u0002\\u02fc\\u02fd\",\n    \"\\u0005\\u0016\\f\\u0002\\u02fdk\\u0003\\u0002\\u0002\\u0002Nou\\u007f\\u0087\\u0091\",\n    \"\\u0097\\u00a2\\u00a8\\u00ad\\u00bc\\u00be\\u00c7\\u00c9\\u00d0\\u00da\\u00e3\\u00f5\",\n    \"\\u00fd\\u0101\\u0107\\u0111\\u011b\\u0150\\u0152\\u0161\\u0167\\u0170\\u017a\\u0180\",\n    \"\\u018d\\u0193\\u01ab\\u01af\\u01b3\\u01b9\\u01bd\\u01c1\\u01c5\\u01d9\\u01de\\u01e0\",\n    \"\\u01e8\\u01fc\\u0204\\u0208\\u0210\\u0216\\u021c\\u021e\\u0223\\u0226\\u022c\\u023d\",\n    \"\\u0244\\u0249\\u024e\\u0255\\u025e\\u0265\\u0269\\u0270\\u027d\\u0287\\u028b\\u0296\",\n    \"\\u029d\\u02a6\\u02ad\\u02bf\\u02c8\\u02ce\\u02e3\\u02e7\\u02ee\\u02f2\\u02f8\"].join(\"\");\n\n\nconst atn = new antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATNDeserializer().deserialize(serializedATN);\n\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4__WEBPACK_IMPORTED_MODULE_0__.dfa.DFA(ds, index) );\n\nconst sharedContextCache = new antlr4__WEBPACK_IMPORTED_MODULE_0__.PredictionContextCache();\n\nclass ZordParser extends antlr4__WEBPACK_IMPORTED_MODULE_0__.Parser {\n\n    static grammarFileName = \"ZordParser.g4\";\n    static literalNames = [ null, null, null, null, \"'open'\", \"'type'\", \n                            \"'forall'\", \"'Trait'\", \"'mu'\", \"'Int'\", \"'Double'\", \n                            \"'String'\", \"'Bool'\", \"'Top'\", \"'Bot'\", \"'let'\", \n                            \"'letrec'\", \"'in'\", \"'if'\", \"'then'\", \"'else'\", \n                            \"'trait'\", \"'implements'\", \"'inherits'\", \"'new'\", \n                            \"'toString'\", \"'fold'\", \"'unfold'\", \"'@'\", \"'true'\", \n                            \"'false'\", \"'undefined'\", \"'override'\", \"'|'\", \n                            \"'..'\", \"'_'\", null, null, null, null, null, \n                            \"'()'\", \"'->'\", \"'=>'\", \"'&'\", \"'+'\", \"'-'\", \n                            \"'*'\", \"'/'\", \"'%'\", \"'!'\", \"'&&'\", \"'||'\", \n                            \"'++'\", \"'<'\", \"'>'\", null, null, \"'=='\", \"'!='\", \n                            \"','\", \"'^'\", \"'!!'\", \"'#'\", \"'='\", null, null, \n                            null, null, \"'}'\", null, \"')'\", \"';'\", \"':'\", \n                            \"'\\\\'\", \"'/\\\\'\", \"'.'\", \"'?'\", \"'$'\" ];\n    static symbolicNames = [ null, \"Whitespaces\", \"LineComment\", \"BlockComment\", \n                             \"Open\", \"Type\", \"ForAll\", \"TraitCaps\", \"Mu\", \n                             \"Int\", \"Double\", \"StringType\", \"Bool\", \"Top\", \n                             \"Bot\", \"Let\", \"LetRec\", \"In\", \"If\", \"Then\", \n                             \"Else\", \"TraitSmall\", \"Implements\", \"Inherits\", \n                             \"New\", \"ToString\", \"Fold\", \"Unfold\", \"At\", \n                             \"True_\", \"False_\", \"Undefined_\", \"Override\", \n                             \"Stick\", \"DotDot\", \"Underscore\", \"Lowerid\", \n                             \"Upperid\", \"Number\", \"BacktickOpen\", \"String\", \n                             \"Unit\", \"Arrow\", \"TraitArrow\", \"Intersect\", \n                             \"Plus\", \"Minus\", \"Star\", \"Divide\", \"Modulo\", \n                             \"Not\", \"And\", \"Or\", \"Append\", \"Less\", \"Greater\", \n                             \"LessEqual\", \"GreaterEqual\", \"Equal\", \"NotEqual\", \n                             \"Merge\", \"Forward\", \"Index\", \"Length\", \"Assign\", \n                             \"Newline\", \"BracketOpen\", \"BracketClose\", \"BraceOpen\", \n                             \"BraceClose\", \"ParenOpen\", \"ParenClose\", \"Semicolon\", \n                             \"Colon\", \"Backslash\", \"SlashBackslash\", \"Dot\", \n                             \"Question\", \"Dollar\", \"BacktickClose\", \"BracketCloseInDoc\", \n                             \"LineBreak\", \"Tag\", \"BackslashParen\", \"Plaintext\", \n                             \"ParenOpenInTag\", \"BraceOpenInTag\", \"BracketOpenInTag\", \n                             \"PlaintextAfterTag\", \"BracketCloseAfterTag\", \n                             \"BacktickCloseAfterTag\", \"TagAfterTag\", \"LinebreakAfterTag\", \n                             \"BackslashParenAfterTag\" ];\n    static ruleNames = [ \"program\", \"open\", \"definition\", \"typeDef\", \"termDef\", \n                         \"type\", \"btype\", \"atype\", \"recordType\", \"recordTypeElement\", \n                         \"expression\", \"opexpr\", \"lexpr\", \"lambda\", \"bigLambda\", \n                         \"let_\", \"letRec\", \"open_\", \"ifElse\", \"trait\", \"new_\", \n                         \"toString_\", \"fold\", \"unfold\", \"fexpr\", \"dotexpr\", \n                         \"aexpr\", \"array\", \"record\", \"recordField\", \"recordUpdate\", \n                         \"methodPattern\", \"defaultPattern\", \"typeParam\", \n                         \"termParam\", \"termId\", \"wildcard\", \"selfAnno\", \n                         \"sort\", \"typeNameDecl\", \"typeName\", \"termNameDecl\", \n                         \"termName\", \"labelDecl\", \"label\", \"document\", \"docElement\", \n                         \"command\", \"interpolation\", \"newline\", \"plaintext\", \n                         \"arg\", \"recordArgField\" ];\n\n    constructor(input) {\n        super(input);\n        this._interp = new antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);\n        this.ruleNames = ZordParser.ruleNames;\n        this.literalNames = ZordParser.literalNames;\n        this.symbolicNames = ZordParser.symbolicNames;\n    }\n\n    get atn() {\n        return atn;\n    }\n\n    sempred(localctx, ruleIndex, predIndex) {\n    \tswitch(ruleIndex) {\n    \tcase 5:\n    \t    \t\treturn this.type_sempred(localctx, predIndex);\n    \tcase 11:\n    \t    \t\treturn this.opexpr_sempred(localctx, predIndex);\n        default:\n            throw \"No predicate with index:\" + ruleIndex;\n       }\n    }\n\n    type_sempred(localctx, predIndex) {\n    \tswitch(predIndex) {\n    \t\tcase 0:\n    \t\t\treturn this.precpred(this._ctx, 2);\n    \t\tcase 1:\n    \t\t\treturn this.precpred(this._ctx, 1);\n    \t\tdefault:\n    \t\t\tthrow \"No predicate with index:\" + predIndex;\n    \t}\n    };\n\n    opexpr_sempred(localctx, predIndex) {\n    \tswitch(predIndex) {\n    \t\tcase 2:\n    \t\t\treturn this.precpred(this._ctx, 17);\n    \t\tcase 3:\n    \t\t\treturn this.precpred(this._ctx, 16);\n    \t\tcase 4:\n    \t\t\treturn this.precpred(this._ctx, 15);\n    \t\tcase 5:\n    \t\t\treturn this.precpred(this._ctx, 14);\n    \t\tcase 6:\n    \t\t\treturn this.precpred(this._ctx, 13);\n    \t\tcase 7:\n    \t\t\treturn this.precpred(this._ctx, 12);\n    \t\tcase 8:\n    \t\t\treturn this.precpred(this._ctx, 11);\n    \t\tcase 9:\n    \t\t\treturn this.precpred(this._ctx, 10);\n    \t\tcase 10:\n    \t\t\treturn this.precpred(this._ctx, 9);\n    \t\tcase 11:\n    \t\t\treturn this.precpred(this._ctx, 8);\n    \t\tcase 12:\n    \t\t\treturn this.precpred(this._ctx, 7);\n    \t\tcase 13:\n    \t\t\treturn this.precpred(this._ctx, 6);\n    \t\tcase 14:\n    \t\t\treturn this.precpred(this._ctx, 5);\n    \t\tcase 15:\n    \t\t\treturn this.precpred(this._ctx, 4);\n    \t\tcase 16:\n    \t\t\treturn this.precpred(this._ctx, 3);\n    \t\tcase 17:\n    \t\t\treturn this.precpred(this._ctx, 2);\n    \t\tcase 18:\n    \t\t\treturn this.precpred(this._ctx, 1);\n    \t\tdefault:\n    \t\t\tthrow \"No predicate with index:\" + predIndex;\n    \t}\n    };\n\n\n\n\n\tprogram() {\n\t    let localctx = new ProgramContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 0, ZordParser.RULE_program);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 109;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,0,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 106;\n\t                this.open(); \n\t            }\n\t            this.state = 111;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,0,this._ctx);\n\t        }\n\n\t        this.state = 115;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,1,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 112;\n\t                this.definition(); \n\t            }\n\t            this.state = 117;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,1,this._ctx);\n\t        }\n\n\t        this.state = 118;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\topen() {\n\t    let localctx = new OpenContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 2, ZordParser.RULE_open);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 120;\n\t        this.match(ZordParser.Open);\n\t        this.state = 125;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,2,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 121;\n\t                _la = this._input.LA(1);\n\t                if(!(_la===ZordParser.Lowerid || _la===ZordParser.Upperid)) {\n\t                this._errHandler.recoverInline(this);\n\t                }\n\t                else {\n\t                \tthis._errHandler.reportMatch(this);\n\t                    this.consume();\n\t                }\n\t                this.state = 122;\n\t                this.match(ZordParser.Divide); \n\t            }\n\t            this.state = 127;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,2,this._ctx);\n\t        }\n\n\t        this.state = 128;\n\t        _la = this._input.LA(1);\n\t        if(!(_la===ZordParser.Lowerid || _la===ZordParser.Upperid)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t        this.state = 129;\n\t        this.match(ZordParser.Semicolon);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tdefinition() {\n\t    let localctx = new DefinitionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 4, ZordParser.RULE_definition);\n\t    try {\n\t        this.state = 133;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.Type:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 131;\n\t            this.typeDef();\n\t            break;\n\t        case ZordParser.Lowerid:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 132;\n\t            this.termDef();\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttypeDef() {\n\t    let localctx = new TypeDefContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 6, ZordParser.RULE_typeDef);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 135;\n\t        this.match(ZordParser.Type);\n\t        this.state = 136;\n\t        this.typeNameDecl();\n\t        this.state = 143;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===ZordParser.Less) {\n\t            this.state = 137;\n\t            this.match(ZordParser.Less);\n\t            this.state = 138;\n\t            this.typeNameDecl();\n\t            this.state = 139;\n\t            this.match(ZordParser.Greater);\n\t            this.state = 145;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 149;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===ZordParser.Upperid) {\n\t            this.state = 146;\n\t            this.typeNameDecl();\n\t            this.state = 151;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 152;\n\t        this.match(ZordParser.Assign);\n\t        this.state = 153;\n\t        this.type(0);\n\t        this.state = 154;\n\t        this.match(ZordParser.Semicolon);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttermDef() {\n\t    let localctx = new TermDefContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 8, ZordParser.RULE_termDef);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 156;\n\t        this.termNameDecl();\n\t        this.state = 160;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,6,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 157;\n\t                this.typeParam(); \n\t            }\n\t            this.state = 162;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,6,this._ctx);\n\t        }\n\n\t        this.state = 166;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===ZordParser.Underscore || _la===ZordParser.Lowerid || _la===ZordParser.BraceOpen || _la===ZordParser.ParenOpen) {\n\t            this.state = 163;\n\t            this.termParam();\n\t            this.state = 168;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 171;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.Colon) {\n\t            this.state = 169;\n\t            this.match(ZordParser.Colon);\n\t            this.state = 170;\n\t            this.type(0);\n\t        }\n\n\t        this.state = 173;\n\t        this.match(ZordParser.Assign);\n\t        this.state = 174;\n\t        this.expression();\n\t        this.state = 175;\n\t        this.match(ZordParser.Semicolon);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\ttype(_p) {\n\t\tif(_p===undefined) {\n\t\t    _p = 0;\n\t\t}\n\t    const _parentctx = this._ctx;\n\t    const _parentState = this.state;\n\t    let localctx = new TypeContext(this, this._ctx, _parentState);\n\t    let _prevctx = localctx;\n\t    const _startState = 10;\n\t    this.enterRecursionRule(localctx, 10, ZordParser.RULE_type, _p);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 178;\n\t        this.btype();\n\t        this._ctx.stop = this._input.LT(-1);\n\t        this.state = 188;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,10,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                if(this._parseListeners!==null) {\n\t                    this.triggerExitRuleEvent();\n\t                }\n\t                _prevctx = localctx;\n\t                this.state = 186;\n\t                this._errHandler.sync(this);\n\t                var la_ = this._interp.adaptivePredict(this._input,9,this._ctx);\n\t                switch(la_) {\n\t                case 1:\n\t                    localctx = new TypeContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_type);\n\t                    this.state = 180;\n\t                    if (!( this.precpred(this._ctx, 2))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 2)\");\n\t                    }\n\t                    this.state = 181;\n\t                    this.match(ZordParser.Intersect);\n\t                    this.state = 182;\n\t                    this.type(3);\n\t                    break;\n\n\t                case 2:\n\t                    localctx = new TypeContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_type);\n\t                    this.state = 183;\n\t                    if (!( this.precpred(this._ctx, 1))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 1)\");\n\t                    }\n\t                    this.state = 184;\n\t                    this.match(ZordParser.Arrow);\n\t                    this.state = 185;\n\t                    this.type(1);\n\t                    break;\n\n\t                } \n\t            }\n\t            this.state = 190;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,10,this._ctx);\n\t        }\n\n\t    } catch( error) {\n\t        if(error instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = error;\n\t\t        this._errHandler.reportError(this, error);\n\t\t        this._errHandler.recover(this, error);\n\t\t    } else {\n\t\t    \tthrow error;\n\t\t    }\n\t    } finally {\n\t        this.unrollRecursionContexts(_parentctx)\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tbtype() {\n\t    let localctx = new BtypeContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 12, ZordParser.RULE_btype);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.state = 225;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.Int:\n\t        case ZordParser.Double:\n\t        case ZordParser.StringType:\n\t        case ZordParser.Bool:\n\t        case ZordParser.Top:\n\t        case ZordParser.Bot:\n\t        case ZordParser.Upperid:\n\t        case ZordParser.BracketOpen:\n\t        case ZordParser.BraceOpen:\n\t        case ZordParser.ParenOpen:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 191;\n\t            this.atype();\n\t            this.state = 199;\n\t            this._errHandler.sync(this);\n\t            var _alt = this._interp.adaptivePredict(this._input,12,this._ctx)\n\t            while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t                if(_alt===1) {\n\t                    this.state = 197;\n\t                    this._errHandler.sync(this);\n\t                    switch(this._input.LA(1)) {\n\t                    case ZordParser.Int:\n\t                    case ZordParser.Double:\n\t                    case ZordParser.StringType:\n\t                    case ZordParser.Bool:\n\t                    case ZordParser.Top:\n\t                    case ZordParser.Bot:\n\t                    case ZordParser.Upperid:\n\t                    case ZordParser.BracketOpen:\n\t                    case ZordParser.BraceOpen:\n\t                    case ZordParser.ParenOpen:\n\t                        this.state = 192;\n\t                        this.atype();\n\t                        break;\n\t                    case ZordParser.Less:\n\t                        this.state = 193;\n\t                        this.match(ZordParser.Less);\n\t                        this.state = 194;\n\t                        this.sort();\n\t                        this.state = 195;\n\t                        this.match(ZordParser.Greater);\n\t                        break;\n\t                    default:\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t                    } \n\t                }\n\t                this.state = 201;\n\t                this._errHandler.sync(this);\n\t                _alt = this._interp.adaptivePredict(this._input,12,this._ctx);\n\t            }\n\n\t            break;\n\t        case ZordParser.ForAll:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 202;\n\t            this.match(ZordParser.ForAll);\n\t            this.state = 204; \n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t            do {\n\t                this.state = 203;\n\t                this.typeParam();\n\t                this.state = 206; \n\t                this._errHandler.sync(this);\n\t                _la = this._input.LA(1);\n\t            } while(_la===ZordParser.Upperid || _la===ZordParser.ParenOpen);\n\t            this.state = 208;\n\t            this.match(ZordParser.Dot);\n\t            this.state = 209;\n\t            this.type(0);\n\t            break;\n\t        case ZordParser.TraitCaps:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 211;\n\t            this.match(ZordParser.TraitCaps);\n\t            this.state = 212;\n\t            this.match(ZordParser.Less);\n\t            this.state = 213;\n\t            this.type(0);\n\t            this.state = 216;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t            if(_la===ZordParser.TraitArrow) {\n\t                this.state = 214;\n\t                this.match(ZordParser.TraitArrow);\n\t                this.state = 215;\n\t                this.type(0);\n\t            }\n\n\t            this.state = 218;\n\t            this.match(ZordParser.Greater);\n\t            break;\n\t        case ZordParser.Mu:\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 220;\n\t            this.match(ZordParser.Mu);\n\t            this.state = 221;\n\t            this.typeNameDecl();\n\t            this.state = 222;\n\t            this.match(ZordParser.Dot);\n\t            this.state = 223;\n\t            this.type(0);\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tatype() {\n\t    let localctx = new AtypeContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 14, ZordParser.RULE_atype);\n\t    try {\n\t        this.state = 243;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.Int:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 227;\n\t            this.match(ZordParser.Int);\n\t            break;\n\t        case ZordParser.Double:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 228;\n\t            this.match(ZordParser.Double);\n\t            break;\n\t        case ZordParser.StringType:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 229;\n\t            this.match(ZordParser.StringType);\n\t            break;\n\t        case ZordParser.Bool:\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 230;\n\t            this.match(ZordParser.Bool);\n\t            break;\n\t        case ZordParser.Top:\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 231;\n\t            this.match(ZordParser.Top);\n\t            break;\n\t        case ZordParser.Bot:\n\t            this.enterOuterAlt(localctx, 6);\n\t            this.state = 232;\n\t            this.match(ZordParser.Bot);\n\t            break;\n\t        case ZordParser.Upperid:\n\t            this.enterOuterAlt(localctx, 7);\n\t            this.state = 233;\n\t            this.typeName();\n\t            break;\n\t        case ZordParser.BraceOpen:\n\t            this.enterOuterAlt(localctx, 8);\n\t            this.state = 234;\n\t            this.recordType();\n\t            break;\n\t        case ZordParser.BracketOpen:\n\t            this.enterOuterAlt(localctx, 9);\n\t            this.state = 235;\n\t            this.match(ZordParser.BracketOpen);\n\t            this.state = 236;\n\t            this.type(0);\n\t            this.state = 237;\n\t            this.match(ZordParser.BracketClose);\n\t            break;\n\t        case ZordParser.ParenOpen:\n\t            this.enterOuterAlt(localctx, 10);\n\t            this.state = 239;\n\t            this.match(ZordParser.ParenOpen);\n\t            this.state = 240;\n\t            this.type(0);\n\t            this.state = 241;\n\t            this.match(ZordParser.ParenClose);\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\trecordType() {\n\t    let localctx = new RecordTypeContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 16, ZordParser.RULE_recordType);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 245;\n\t        this.match(ZordParser.BraceOpen);\n\t        this.state = 251;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,17,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 246;\n\t                this.recordTypeElement();\n\t                this.state = 247;\n\t                this.match(ZordParser.Semicolon); \n\t            }\n\t            this.state = 253;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,17,this._ctx);\n\t        }\n\n\t        this.state = 255;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.Lowerid || _la===ZordParser.Upperid) {\n\t            this.state = 254;\n\t            this.recordTypeElement();\n\t        }\n\n\t        this.state = 257;\n\t        this.match(ZordParser.BraceClose);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\trecordTypeElement() {\n\t    let localctx = new RecordTypeElementContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 18, ZordParser.RULE_recordTypeElement);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 259;\n\t        this.labelDecl();\n\t        this.state = 261;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.Question) {\n\t            this.state = 260;\n\t            this.match(ZordParser.Question);\n\t        }\n\n\t        this.state = 263;\n\t        this.match(ZordParser.Colon);\n\t        this.state = 264;\n\t        this.type(0);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\texpression() {\n\t    let localctx = new ExpressionContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 20, ZordParser.RULE_expression);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 266;\n\t        this.opexpr(0);\n\t        this.state = 271;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,20,this._ctx);\n\t        if(la_===1) {\n\t            this.state = 267;\n\t            this.match(ZordParser.Colon);\n\t            this.state = 268;\n\t            this.type(0);\n\n\t        } else if(la_===2) {\n\t            this.state = 269;\n\t            this.match(ZordParser.Backslash);\n\t            this.state = 270;\n\t            this.type(0);\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\topexpr(_p) {\n\t\tif(_p===undefined) {\n\t\t    _p = 0;\n\t\t}\n\t    const _parentctx = this._ctx;\n\t    const _parentState = this.state;\n\t    let localctx = new OpexprContext(this, this._ctx, _parentState);\n\t    let _prevctx = localctx;\n\t    const _startState = 22;\n\t    this.enterRecursionRule(localctx, 22, ZordParser.RULE_opexpr, _p);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 281;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.Open:\n\t        case ZordParser.Let:\n\t        case ZordParser.LetRec:\n\t        case ZordParser.If:\n\t        case ZordParser.TraitSmall:\n\t        case ZordParser.New:\n\t        case ZordParser.ToString:\n\t        case ZordParser.Fold:\n\t        case ZordParser.Unfold:\n\t        case ZordParser.True_:\n\t        case ZordParser.False_:\n\t        case ZordParser.Undefined_:\n\t        case ZordParser.Lowerid:\n\t        case ZordParser.Upperid:\n\t        case ZordParser.Number:\n\t        case ZordParser.BacktickOpen:\n\t        case ZordParser.String:\n\t        case ZordParser.Unit:\n\t        case ZordParser.BracketOpen:\n\t        case ZordParser.BraceOpen:\n\t        case ZordParser.ParenOpen:\n\t        case ZordParser.Backslash:\n\t        case ZordParser.SlashBackslash:\n\t        case ZordParser.Dollar:\n\t            this.state = 274;\n\t            this.lexpr();\n\t            break;\n\t        case ZordParser.Minus:\n\t            this.state = 275;\n\t            this.match(ZordParser.Minus);\n\t            this.state = 276;\n\t            this.opexpr(20);\n\t            break;\n\t        case ZordParser.Not:\n\t            this.state = 277;\n\t            this.match(ZordParser.Not);\n\t            this.state = 278;\n\t            this.opexpr(19);\n\t            break;\n\t        case ZordParser.Length:\n\t            this.state = 279;\n\t            this.match(ZordParser.Length);\n\t            this.state = 280;\n\t            this.opexpr(18);\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t        this._ctx.stop = this._input.LT(-1);\n\t        this.state = 336;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,23,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                if(this._parseListeners!==null) {\n\t                    this.triggerExitRuleEvent();\n\t                }\n\t                _prevctx = localctx;\n\t                this.state = 334;\n\t                this._errHandler.sync(this);\n\t                var la_ = this._interp.adaptivePredict(this._input,22,this._ctx);\n\t                switch(la_) {\n\t                case 1:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 283;\n\t                    if (!( this.precpred(this._ctx, 17))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 17)\");\n\t                    }\n\t                    this.state = 284;\n\t                    this.match(ZordParser.Index);\n\t                    this.state = 285;\n\t                    this.opexpr(18);\n\t                    break;\n\n\t                case 2:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 286;\n\t                    if (!( this.precpred(this._ctx, 16))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 16)\");\n\t                    }\n\t                    this.state = 287;\n\t                    this.match(ZordParser.Modulo);\n\t                    this.state = 288;\n\t                    this.opexpr(17);\n\t                    break;\n\n\t                case 3:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 289;\n\t                    if (!( this.precpred(this._ctx, 15))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 15)\");\n\t                    }\n\t                    this.state = 290;\n\t                    this.match(ZordParser.Divide);\n\t                    this.state = 291;\n\t                    this.opexpr(16);\n\t                    break;\n\n\t                case 4:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 292;\n\t                    if (!( this.precpred(this._ctx, 14))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 14)\");\n\t                    }\n\t                    this.state = 293;\n\t                    this.match(ZordParser.Star);\n\t                    this.state = 294;\n\t                    this.opexpr(15);\n\t                    break;\n\n\t                case 5:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 295;\n\t                    if (!( this.precpred(this._ctx, 13))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 13)\");\n\t                    }\n\t                    this.state = 296;\n\t                    this.match(ZordParser.Minus);\n\t                    this.state = 297;\n\t                    this.opexpr(14);\n\t                    break;\n\n\t                case 6:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 298;\n\t                    if (!( this.precpred(this._ctx, 12))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 12)\");\n\t                    }\n\t                    this.state = 299;\n\t                    this.match(ZordParser.Plus);\n\t                    this.state = 300;\n\t                    this.opexpr(13);\n\t                    break;\n\n\t                case 7:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 301;\n\t                    if (!( this.precpred(this._ctx, 11))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 11)\");\n\t                    }\n\t                    this.state = 302;\n\t                    this.match(ZordParser.Append);\n\t                    this.state = 303;\n\t                    this.opexpr(12);\n\t                    break;\n\n\t                case 8:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 304;\n\t                    if (!( this.precpred(this._ctx, 10))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 10)\");\n\t                    }\n\t                    this.state = 305;\n\t                    this.match(ZordParser.Less);\n\t                    this.state = 306;\n\t                    this.opexpr(11);\n\t                    break;\n\n\t                case 9:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 307;\n\t                    if (!( this.precpred(this._ctx, 9))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 9)\");\n\t                    }\n\t                    this.state = 308;\n\t                    this.match(ZordParser.Greater);\n\t                    this.state = 309;\n\t                    this.opexpr(10);\n\t                    break;\n\n\t                case 10:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 310;\n\t                    if (!( this.precpred(this._ctx, 8))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 8)\");\n\t                    }\n\t                    this.state = 311;\n\t                    this.match(ZordParser.LessEqual);\n\t                    this.state = 312;\n\t                    this.opexpr(9);\n\t                    break;\n\n\t                case 11:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 313;\n\t                    if (!( this.precpred(this._ctx, 7))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 7)\");\n\t                    }\n\t                    this.state = 314;\n\t                    this.match(ZordParser.GreaterEqual);\n\t                    this.state = 315;\n\t                    this.opexpr(8);\n\t                    break;\n\n\t                case 12:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 316;\n\t                    if (!( this.precpred(this._ctx, 6))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 6)\");\n\t                    }\n\t                    this.state = 317;\n\t                    this.match(ZordParser.Equal);\n\t                    this.state = 318;\n\t                    this.opexpr(7);\n\t                    break;\n\n\t                case 13:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 319;\n\t                    if (!( this.precpred(this._ctx, 5))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 5)\");\n\t                    }\n\t                    this.state = 320;\n\t                    this.match(ZordParser.NotEqual);\n\t                    this.state = 321;\n\t                    this.opexpr(6);\n\t                    break;\n\n\t                case 14:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 322;\n\t                    if (!( this.precpred(this._ctx, 4))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 4)\");\n\t                    }\n\t                    this.state = 323;\n\t                    this.match(ZordParser.And);\n\t                    this.state = 324;\n\t                    this.opexpr(4);\n\t                    break;\n\n\t                case 15:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 325;\n\t                    if (!( this.precpred(this._ctx, 3))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 3)\");\n\t                    }\n\t                    this.state = 326;\n\t                    this.match(ZordParser.Or);\n\t                    this.state = 327;\n\t                    this.opexpr(3);\n\t                    break;\n\n\t                case 16:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 328;\n\t                    if (!( this.precpred(this._ctx, 2))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 2)\");\n\t                    }\n\t                    this.state = 329;\n\t                    this.match(ZordParser.Forward);\n\t                    this.state = 330;\n\t                    this.opexpr(3);\n\t                    break;\n\n\t                case 17:\n\t                    localctx = new OpexprContext(this, _parentctx, _parentState);\n\t                    this.pushNewRecursionContext(localctx, _startState, ZordParser.RULE_opexpr);\n\t                    this.state = 331;\n\t                    if (!( this.precpred(this._ctx, 1))) {\n\t                        throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.FailedPredicateException(this, \"this.precpred(this._ctx, 1)\");\n\t                    }\n\t                    this.state = 332;\n\t                    this.match(ZordParser.Merge);\n\t                    this.state = 333;\n\t                    this.opexpr(2);\n\t                    break;\n\n\t                } \n\t            }\n\t            this.state = 338;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,23,this._ctx);\n\t        }\n\n\t    } catch( error) {\n\t        if(error instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = error;\n\t\t        this._errHandler.reportError(this, error);\n\t\t        this._errHandler.recover(this, error);\n\t\t    } else {\n\t\t    \tthrow error;\n\t\t    }\n\t    } finally {\n\t        this.unrollRecursionContexts(_parentctx)\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tlexpr() {\n\t    let localctx = new LexprContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 24, ZordParser.RULE_lexpr);\n\t    try {\n\t        this.state = 351;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.True_:\n\t        case ZordParser.False_:\n\t        case ZordParser.Undefined_:\n\t        case ZordParser.Lowerid:\n\t        case ZordParser.Upperid:\n\t        case ZordParser.Number:\n\t        case ZordParser.BacktickOpen:\n\t        case ZordParser.String:\n\t        case ZordParser.Unit:\n\t        case ZordParser.BracketOpen:\n\t        case ZordParser.BraceOpen:\n\t        case ZordParser.ParenOpen:\n\t        case ZordParser.Dollar:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 339;\n\t            this.fexpr();\n\t            break;\n\t        case ZordParser.Backslash:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 340;\n\t            this.lambda();\n\t            break;\n\t        case ZordParser.SlashBackslash:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 341;\n\t            this.bigLambda();\n\t            break;\n\t        case ZordParser.Let:\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 342;\n\t            this.let_();\n\t            break;\n\t        case ZordParser.LetRec:\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 343;\n\t            this.letRec();\n\t            break;\n\t        case ZordParser.Open:\n\t            this.enterOuterAlt(localctx, 6);\n\t            this.state = 344;\n\t            this.open_();\n\t            break;\n\t        case ZordParser.If:\n\t            this.enterOuterAlt(localctx, 7);\n\t            this.state = 345;\n\t            this.ifElse();\n\t            break;\n\t        case ZordParser.TraitSmall:\n\t            this.enterOuterAlt(localctx, 8);\n\t            this.state = 346;\n\t            this.trait();\n\t            break;\n\t        case ZordParser.New:\n\t            this.enterOuterAlt(localctx, 9);\n\t            this.state = 347;\n\t            this.new_();\n\t            break;\n\t        case ZordParser.ToString:\n\t            this.enterOuterAlt(localctx, 10);\n\t            this.state = 348;\n\t            this.toString_();\n\t            break;\n\t        case ZordParser.Fold:\n\t            this.enterOuterAlt(localctx, 11);\n\t            this.state = 349;\n\t            this.fold();\n\t            break;\n\t        case ZordParser.Unfold:\n\t            this.enterOuterAlt(localctx, 12);\n\t            this.state = 350;\n\t            this.unfold();\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tlambda() {\n\t    let localctx = new LambdaContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 26, ZordParser.RULE_lambda);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 353;\n\t        this.match(ZordParser.Backslash);\n\t        this.state = 355; \n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        do {\n\t            this.state = 354;\n\t            this.termParam();\n\t            this.state = 357; \n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        } while(_la===ZordParser.Underscore || _la===ZordParser.Lowerid || _la===ZordParser.BraceOpen || _la===ZordParser.ParenOpen);\n\t        this.state = 359;\n\t        this.match(ZordParser.Arrow);\n\t        this.state = 360;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tbigLambda() {\n\t    let localctx = new BigLambdaContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 28, ZordParser.RULE_bigLambda);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 362;\n\t        this.match(ZordParser.SlashBackslash);\n\t        this.state = 364; \n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        do {\n\t            this.state = 363;\n\t            this.typeParam();\n\t            this.state = 366; \n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        } while(_la===ZordParser.Upperid || _la===ZordParser.ParenOpen);\n\t        this.state = 368;\n\t        this.match(ZordParser.Dot);\n\t        this.state = 369;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tlet_() {\n\t    let localctx = new Let_Context(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 30, ZordParser.RULE_let_);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 371;\n\t        this.match(ZordParser.Let);\n\t        this.state = 372;\n\t        this.termNameDecl();\n\t        this.state = 376;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,27,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 373;\n\t                this.typeParam(); \n\t            }\n\t            this.state = 378;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,27,this._ctx);\n\t        }\n\n\t        this.state = 382;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===ZordParser.Underscore || _la===ZordParser.Lowerid || _la===ZordParser.BraceOpen || _la===ZordParser.ParenOpen) {\n\t            this.state = 379;\n\t            this.termParam();\n\t            this.state = 384;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 385;\n\t        this.match(ZordParser.Assign);\n\t        this.state = 386;\n\t        this.expression();\n\t        this.state = 387;\n\t        this.match(ZordParser.In);\n\t        this.state = 388;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tletRec() {\n\t    let localctx = new LetRecContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 32, ZordParser.RULE_letRec);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 390;\n\t        this.match(ZordParser.LetRec);\n\t        this.state = 391;\n\t        this.termNameDecl();\n\t        this.state = 395;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,29,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 392;\n\t                this.typeParam(); \n\t            }\n\t            this.state = 397;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,29,this._ctx);\n\t        }\n\n\t        this.state = 401;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===ZordParser.Underscore || _la===ZordParser.Lowerid || _la===ZordParser.BraceOpen || _la===ZordParser.ParenOpen) {\n\t            this.state = 398;\n\t            this.termParam();\n\t            this.state = 403;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 404;\n\t        this.match(ZordParser.Colon);\n\t        this.state = 405;\n\t        this.type(0);\n\t        this.state = 406;\n\t        this.match(ZordParser.Assign);\n\t        this.state = 407;\n\t        this.expression();\n\t        this.state = 408;\n\t        this.match(ZordParser.In);\n\t        this.state = 409;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\topen_() {\n\t    let localctx = new Open_Context(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 34, ZordParser.RULE_open_);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 411;\n\t        this.match(ZordParser.Open);\n\t        this.state = 412;\n\t        this.expression();\n\t        this.state = 413;\n\t        this.match(ZordParser.In);\n\t        this.state = 414;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tifElse() {\n\t    let localctx = new IfElseContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 36, ZordParser.RULE_ifElse);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 416;\n\t        this.match(ZordParser.If);\n\t        this.state = 417;\n\t        this.expression();\n\t        this.state = 418;\n\t        this.match(ZordParser.Then);\n\t        this.state = 419;\n\t        this.expression();\n\t        this.state = 420;\n\t        this.match(ZordParser.Else);\n\t        this.state = 421;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttrait() {\n\t    let localctx = new TraitContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 38, ZordParser.RULE_trait);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.state = 451;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,37,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 423;\n\t            this.match(ZordParser.TraitSmall);\n\t            this.state = 425;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t            if(_la===ZordParser.BracketOpen) {\n\t                this.state = 424;\n\t                this.selfAnno();\n\t            }\n\n\t            this.state = 429;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t            if(_la===ZordParser.Implements) {\n\t                this.state = 427;\n\t                this.match(ZordParser.Implements);\n\t                this.state = 428;\n\t                this.type(0);\n\t            }\n\n\t            this.state = 433;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t            if(_la===ZordParser.Inherits) {\n\t                this.state = 431;\n\t                this.match(ZordParser.Inherits);\n\t                this.state = 432;\n\t                this.opexpr(0);\n\t            }\n\n\t            this.state = 435;\n\t            this.match(ZordParser.TraitArrow);\n\t            this.state = 436;\n\t            this.opexpr(0);\n\t            break;\n\n\t        case 2:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 437;\n\t            this.match(ZordParser.TraitSmall);\n\t            this.state = 439;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t            if(_la===ZordParser.BracketOpen) {\n\t                this.state = 438;\n\t                this.selfAnno();\n\t            }\n\n\t            this.state = 443;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t            if(_la===ZordParser.Inherits) {\n\t                this.state = 441;\n\t                this.match(ZordParser.Inherits);\n\t                this.state = 442;\n\t                this.opexpr(0);\n\t            }\n\n\t            this.state = 447;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t            if(_la===ZordParser.Implements) {\n\t                this.state = 445;\n\t                this.match(ZordParser.Implements);\n\t                this.state = 446;\n\t                this.type(0);\n\t            }\n\n\t            this.state = 449;\n\t            this.match(ZordParser.TraitArrow);\n\t            this.state = 450;\n\t            this.opexpr(0);\n\t            break;\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tnew_() {\n\t    let localctx = new New_Context(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 40, ZordParser.RULE_new_);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 453;\n\t        this.match(ZordParser.New);\n\t        this.state = 454;\n\t        this.opexpr(0);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttoString_() {\n\t    let localctx = new ToString_Context(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 42, ZordParser.RULE_toString_);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 456;\n\t        this.match(ZordParser.ToString);\n\t        this.state = 457;\n\t        this.dotexpr();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tfold() {\n\t    let localctx = new FoldContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 44, ZordParser.RULE_fold);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 459;\n\t        this.match(ZordParser.Fold);\n\t        this.state = 460;\n\t        this.match(ZordParser.At);\n\t        this.state = 461;\n\t        this.atype();\n\t        this.state = 462;\n\t        this.dotexpr();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tunfold() {\n\t    let localctx = new UnfoldContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 46, ZordParser.RULE_unfold);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 464;\n\t        this.match(ZordParser.Unfold);\n\t        this.state = 465;\n\t        this.match(ZordParser.At);\n\t        this.state = 466;\n\t        this.atype();\n\t        this.state = 467;\n\t        this.dotexpr();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tfexpr() {\n\t    let localctx = new FexprContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 48, ZordParser.RULE_fexpr);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 471;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,38,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            this.state = 469;\n\t            this.typeNameDecl();\n\t            break;\n\n\t        case 2:\n\t            this.state = 470;\n\t            this.dotexpr();\n\t            break;\n\n\t        }\n\t        this.state = 478;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,40,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 476;\n\t                this._errHandler.sync(this);\n\t                switch(this._input.LA(1)) {\n\t                case ZordParser.True_:\n\t                case ZordParser.False_:\n\t                case ZordParser.Undefined_:\n\t                case ZordParser.Lowerid:\n\t                case ZordParser.Upperid:\n\t                case ZordParser.Number:\n\t                case ZordParser.BacktickOpen:\n\t                case ZordParser.String:\n\t                case ZordParser.Unit:\n\t                case ZordParser.BracketOpen:\n\t                case ZordParser.BraceOpen:\n\t                case ZordParser.ParenOpen:\n\t                case ZordParser.Dollar:\n\t                    this.state = 473;\n\t                    this.dotexpr();\n\t                    break;\n\t                case ZordParser.At:\n\t                    this.state = 474;\n\t                    this.match(ZordParser.At);\n\t                    this.state = 475;\n\t                    this.atype();\n\t                    break;\n\t                default:\n\t                    throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t                } \n\t            }\n\t            this.state = 480;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,40,this._ctx);\n\t        }\n\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tdotexpr() {\n\t    let localctx = new DotexprContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 50, ZordParser.RULE_dotexpr);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 481;\n\t        this.aexpr();\n\t        this.state = 486;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,41,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 482;\n\t                this.match(ZordParser.Dot);\n\t                this.state = 483;\n\t                this.label(); \n\t            }\n\t            this.state = 488;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,41,this._ctx);\n\t        }\n\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\taexpr() {\n\t    let localctx = new AexprContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 52, ZordParser.RULE_aexpr);\n\t    try {\n\t        this.state = 506;\n\t        this._errHandler.sync(this);\n\t        var la_ = this._interp.adaptivePredict(this._input,42,this._ctx);\n\t        switch(la_) {\n\t        case 1:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 489;\n\t            this.termName();\n\t            break;\n\n\t        case 2:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 490;\n\t            this.match(ZordParser.Number);\n\t            break;\n\n\t        case 3:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 491;\n\t            this.document();\n\t            break;\n\n\t        case 4:\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 492;\n\t            this.match(ZordParser.String);\n\t            break;\n\n\t        case 5:\n\t            this.enterOuterAlt(localctx, 5);\n\t            this.state = 493;\n\t            this.match(ZordParser.Unit);\n\t            break;\n\n\t        case 6:\n\t            this.enterOuterAlt(localctx, 6);\n\t            this.state = 494;\n\t            this.match(ZordParser.True_);\n\t            break;\n\n\t        case 7:\n\t            this.enterOuterAlt(localctx, 7);\n\t            this.state = 495;\n\t            this.match(ZordParser.False_);\n\t            break;\n\n\t        case 8:\n\t            this.enterOuterAlt(localctx, 8);\n\t            this.state = 496;\n\t            this.match(ZordParser.Undefined_);\n\t            break;\n\n\t        case 9:\n\t            this.enterOuterAlt(localctx, 9);\n\t            this.state = 497;\n\t            this.array();\n\t            break;\n\n\t        case 10:\n\t            this.enterOuterAlt(localctx, 10);\n\t            this.state = 498;\n\t            this.record();\n\t            break;\n\n\t        case 11:\n\t            this.enterOuterAlt(localctx, 11);\n\t            this.state = 499;\n\t            this.recordUpdate();\n\t            break;\n\n\t        case 12:\n\t            this.enterOuterAlt(localctx, 12);\n\t            this.state = 500;\n\t            this.match(ZordParser.Dollar);\n\t            this.state = 501;\n\t            this.typeNameDecl();\n\t            break;\n\n\t        case 13:\n\t            this.enterOuterAlt(localctx, 13);\n\t            this.state = 502;\n\t            this.match(ZordParser.ParenOpen);\n\t            this.state = 503;\n\t            this.expression();\n\t            this.state = 504;\n\t            this.match(ZordParser.ParenClose);\n\t            break;\n\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tarray() {\n\t    let localctx = new ArrayContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 54, ZordParser.RULE_array);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 508;\n\t        this.match(ZordParser.BracketOpen);\n\t        this.state = 514;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,43,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 509;\n\t                this.expression();\n\t                this.state = 510;\n\t                this.match(ZordParser.Semicolon); \n\t            }\n\t            this.state = 516;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,43,this._ctx);\n\t        }\n\n\t        this.state = 518;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ZordParser.Open) | (1 << ZordParser.Let) | (1 << ZordParser.LetRec) | (1 << ZordParser.If) | (1 << ZordParser.TraitSmall) | (1 << ZordParser.New) | (1 << ZordParser.ToString) | (1 << ZordParser.Fold) | (1 << ZordParser.Unfold) | (1 << ZordParser.True_) | (1 << ZordParser.False_) | (1 << ZordParser.Undefined_))) !== 0) || ((((_la - 36)) & ~0x1f) == 0 && ((1 << (_la - 36)) & ((1 << (ZordParser.Lowerid - 36)) | (1 << (ZordParser.Upperid - 36)) | (1 << (ZordParser.Number - 36)) | (1 << (ZordParser.BacktickOpen - 36)) | (1 << (ZordParser.String - 36)) | (1 << (ZordParser.Unit - 36)) | (1 << (ZordParser.Minus - 36)) | (1 << (ZordParser.Not - 36)) | (1 << (ZordParser.Length - 36)) | (1 << (ZordParser.BracketOpen - 36)))) !== 0) || ((((_la - 68)) & ~0x1f) == 0 && ((1 << (_la - 68)) & ((1 << (ZordParser.BraceOpen - 68)) | (1 << (ZordParser.ParenOpen - 68)) | (1 << (ZordParser.Backslash - 68)) | (1 << (ZordParser.SlashBackslash - 68)) | (1 << (ZordParser.Dollar - 68)))) !== 0)) {\n\t            this.state = 517;\n\t            this.expression();\n\t        }\n\n\t        this.state = 520;\n\t        this.match(ZordParser.BracketClose);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\trecord() {\n\t    let localctx = new RecordContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 56, ZordParser.RULE_record);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 522;\n\t        this.match(ZordParser.BraceOpen);\n\t        this.state = 532;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,46,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 526;\n\t                this._errHandler.sync(this);\n\t                var la_ = this._interp.adaptivePredict(this._input,45,this._ctx);\n\t                switch(la_) {\n\t                case 1:\n\t                    this.state = 523;\n\t                    this.recordField();\n\t                    break;\n\n\t                case 2:\n\t                    this.state = 524;\n\t                    this.methodPattern();\n\t                    break;\n\n\t                case 3:\n\t                    this.state = 525;\n\t                    this.defaultPattern();\n\t                    break;\n\n\t                }\n\t                this.state = 528;\n\t                this.match(ZordParser.Semicolon); \n\t            }\n\t            this.state = 534;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,46,this._ctx);\n\t        }\n\n\t        this.state = 540;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (ZordParser.Override - 32)) | (1 << (ZordParser.Underscore - 32)) | (1 << (ZordParser.Lowerid - 32)) | (1 << (ZordParser.Upperid - 32)))) !== 0) || _la===ZordParser.BracketOpen || _la===ZordParser.ParenOpen) {\n\t            this.state = 538;\n\t            this._errHandler.sync(this);\n\t            var la_ = this._interp.adaptivePredict(this._input,47,this._ctx);\n\t            switch(la_) {\n\t            case 1:\n\t                this.state = 535;\n\t                this.recordField();\n\t                break;\n\n\t            case 2:\n\t                this.state = 536;\n\t                this.methodPattern();\n\t                break;\n\n\t            case 3:\n\t                this.state = 537;\n\t                this.defaultPattern();\n\t                break;\n\n\t            }\n\t        }\n\n\t        this.state = 542;\n\t        this.match(ZordParser.BraceClose);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\trecordField() {\n\t    let localctx = new RecordFieldContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 58, ZordParser.RULE_recordField);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 545;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.Override) {\n\t            this.state = 544;\n\t            this.match(ZordParser.Override);\n\t        }\n\n\t        this.state = 548;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.BracketOpen) {\n\t            this.state = 547;\n\t            this.selfAnno();\n\t        }\n\n\t        this.state = 550;\n\t        this.labelDecl();\n\t        this.state = 554;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===ZordParser.Underscore || _la===ZordParser.Lowerid || _la===ZordParser.BraceOpen || _la===ZordParser.ParenOpen) {\n\t            this.state = 551;\n\t            this.termParam();\n\t            this.state = 556;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 557;\n\t        this.match(ZordParser.Assign);\n\t        this.state = 558;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\trecordUpdate() {\n\t    let localctx = new RecordUpdateContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 60, ZordParser.RULE_recordUpdate);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 560;\n\t        this.match(ZordParser.BraceOpen);\n\t        this.state = 561;\n\t        this.expression();\n\t        this.state = 562;\n\t        this.match(ZordParser.Stick);\n\t        this.state = 571;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,52,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 563;\n\t                this.labelDecl();\n\t                this.state = 564;\n\t                this.match(ZordParser.Assign);\n\t                this.state = 565;\n\t                this.expression();\n\t                this.state = 567;\n\t                this.match(ZordParser.Semicolon); \n\t            }\n\t            this.state = 573;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,52,this._ctx);\n\t        }\n\n\t        this.state = 578;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.Lowerid || _la===ZordParser.Upperid) {\n\t            this.state = 574;\n\t            this.labelDecl();\n\t            this.state = 575;\n\t            this.match(ZordParser.Assign);\n\t            this.state = 576;\n\t            this.expression();\n\t        }\n\n\t        this.state = 580;\n\t        this.match(ZordParser.BraceClose);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tmethodPattern() {\n\t    let localctx = new MethodPatternContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 62, ZordParser.RULE_methodPattern);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 583;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.Override) {\n\t            this.state = 582;\n\t            this.match(ZordParser.Override);\n\t        }\n\n\t        this.state = 588;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.BracketOpen) {\n\t            this.state = 585;\n\t            this.selfAnno();\n\t            this.state = 586;\n\t            this.match(ZordParser.At);\n\t        }\n\n\t        this.state = 590;\n\t        this.match(ZordParser.ParenOpen);\n\t        this.state = 591;\n\t        this.labelDecl();\n\t        this.state = 595;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===ZordParser.Underscore || _la===ZordParser.Lowerid || _la===ZordParser.BraceOpen || _la===ZordParser.ParenOpen) {\n\t            this.state = 592;\n\t            this.termParam();\n\t            this.state = 597;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 598;\n\t        this.match(ZordParser.ParenClose);\n\t        this.state = 599;\n\t        this.match(ZordParser.Dot);\n\t        this.state = 600;\n\t        this.labelDecl();\n\t        this.state = 604;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===ZordParser.Underscore || _la===ZordParser.Lowerid || _la===ZordParser.BraceOpen || _la===ZordParser.ParenOpen) {\n\t            this.state = 601;\n\t            this.termParam();\n\t            this.state = 606;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 607;\n\t        this.match(ZordParser.Assign);\n\t        this.state = 608;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tdefaultPattern() {\n\t    let localctx = new DefaultPatternContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 64, ZordParser.RULE_defaultPattern);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 611;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.Override) {\n\t            this.state = 610;\n\t            this.match(ZordParser.Override);\n\t        }\n\n\t        this.state = 615;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.Underscore:\n\t            this.state = 613;\n\t            this.match(ZordParser.Underscore);\n\t            break;\n\t        case ZordParser.BracketOpen:\n\t            this.state = 614;\n\t            this.selfAnno();\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t        this.state = 617;\n\t        this.match(ZordParser.Dot);\n\t        this.state = 618;\n\t        this.labelDecl();\n\t        this.state = 622;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===ZordParser.Underscore || _la===ZordParser.Lowerid || _la===ZordParser.BraceOpen || _la===ZordParser.ParenOpen) {\n\t            this.state = 619;\n\t            this.termParam();\n\t            this.state = 624;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 625;\n\t        this.match(ZordParser.Assign);\n\t        this.state = 626;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttypeParam() {\n\t    let localctx = new TypeParamContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 66, ZordParser.RULE_typeParam);\n\t    try {\n\t        this.state = 635;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.Upperid:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 628;\n\t            this.typeNameDecl();\n\t            break;\n\t        case ZordParser.ParenOpen:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 629;\n\t            this.match(ZordParser.ParenOpen);\n\t            this.state = 630;\n\t            this.typeNameDecl();\n\t            this.state = 631;\n\t            this.match(ZordParser.Star);\n\t            this.state = 632;\n\t            this.type(0);\n\t            this.state = 633;\n\t            this.match(ZordParser.ParenClose);\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttermParam() {\n\t    let localctx = new TermParamContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 68, ZordParser.RULE_termParam);\n\t    try {\n\t        this.state = 645;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.Underscore:\n\t        case ZordParser.Lowerid:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 637;\n\t            this.termId();\n\t            break;\n\t        case ZordParser.ParenOpen:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 638;\n\t            this.match(ZordParser.ParenOpen);\n\t            this.state = 639;\n\t            this.termId();\n\t            this.state = 640;\n\t            this.match(ZordParser.Colon);\n\t            this.state = 641;\n\t            this.type(0);\n\t            this.state = 642;\n\t            this.match(ZordParser.ParenClose);\n\t            break;\n\t        case ZordParser.BraceOpen:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 644;\n\t            this.wildcard();\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttermId() {\n\t    let localctx = new TermIdContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 70, ZordParser.RULE_termId);\n\t    try {\n\t        this.state = 649;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.Underscore:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 647;\n\t            this.match(ZordParser.Underscore);\n\t            break;\n\t        case ZordParser.Lowerid:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 648;\n\t            this.termNameDecl();\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\twildcard() {\n\t    let localctx = new WildcardContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 72, ZordParser.RULE_wildcard);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 651;\n\t        this.match(ZordParser.BraceOpen);\n\t        this.state = 660;\n\t        this._errHandler.sync(this);\n\t        var _alt = this._interp.adaptivePredict(this._input,64,this._ctx)\n\t        while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t            if(_alt===1) {\n\t                this.state = 652;\n\t                this.labelDecl();\n\t                this.state = 653;\n\t                this.match(ZordParser.Assign);\n\t                this.state = 654;\n\t                this.expression();\n\t                this.state = 656;\n\t                this.match(ZordParser.Semicolon); \n\t            }\n\t            this.state = 662;\n\t            this._errHandler.sync(this);\n\t            _alt = this._interp.adaptivePredict(this._input,64,this._ctx);\n\t        }\n\n\t        this.state = 667;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.Lowerid || _la===ZordParser.Upperid) {\n\t            this.state = 663;\n\t            this.labelDecl();\n\t            this.state = 664;\n\t            this.match(ZordParser.Assign);\n\t            this.state = 665;\n\t            this.expression();\n\t        }\n\n\t        this.state = 669;\n\t        this.match(ZordParser.DotDot);\n\t        this.state = 670;\n\t        this.match(ZordParser.BraceClose);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tselfAnno() {\n\t    let localctx = new SelfAnnoContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 74, ZordParser.RULE_selfAnno);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 672;\n\t        this.match(ZordParser.BracketOpen);\n\t        this.state = 673;\n\t        this.termNameDecl();\n\t        this.state = 676;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.Colon) {\n\t            this.state = 674;\n\t            this.match(ZordParser.Colon);\n\t            this.state = 675;\n\t            this.type(0);\n\t        }\n\n\t        this.state = 678;\n\t        this.match(ZordParser.BracketClose);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tsort() {\n\t    let localctx = new SortContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 76, ZordParser.RULE_sort);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 680;\n\t        this.type(0);\n\t        this.state = 683;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        if(_la===ZordParser.TraitArrow) {\n\t            this.state = 681;\n\t            this.match(ZordParser.TraitArrow);\n\t            this.state = 682;\n\t            this.type(0);\n\t        }\n\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttypeNameDecl() {\n\t    let localctx = new TypeNameDeclContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 78, ZordParser.RULE_typeNameDecl);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 685;\n\t        this.match(ZordParser.Upperid);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttypeName() {\n\t    let localctx = new TypeNameContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 80, ZordParser.RULE_typeName);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 687;\n\t        this.match(ZordParser.Upperid);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttermNameDecl() {\n\t    let localctx = new TermNameDeclContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 82, ZordParser.RULE_termNameDecl);\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 689;\n\t        this.match(ZordParser.Lowerid);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\ttermName() {\n\t    let localctx = new TermNameContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 84, ZordParser.RULE_termName);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 691;\n\t        _la = this._input.LA(1);\n\t        if(!(_la===ZordParser.Lowerid || _la===ZordParser.Upperid)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tlabelDecl() {\n\t    let localctx = new LabelDeclContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 86, ZordParser.RULE_labelDecl);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 693;\n\t        _la = this._input.LA(1);\n\t        if(!(_la===ZordParser.Lowerid || _la===ZordParser.Upperid)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tlabel() {\n\t    let localctx = new LabelContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 88, ZordParser.RULE_label);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 695;\n\t        _la = this._input.LA(1);\n\t        if(!(_la===ZordParser.Lowerid || _la===ZordParser.Upperid)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tdocument() {\n\t    let localctx = new DocumentContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 90, ZordParser.RULE_document);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 697;\n\t        this.match(ZordParser.BacktickOpen);\n\t        this.state = 701;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(((((_la - 81)) & ~0x1f) == 0 && ((1 << (_la - 81)) & ((1 << (ZordParser.LineBreak - 81)) | (1 << (ZordParser.Tag - 81)) | (1 << (ZordParser.BackslashParen - 81)) | (1 << (ZordParser.Plaintext - 81)) | (1 << (ZordParser.PlaintextAfterTag - 81)) | (1 << (ZordParser.TagAfterTag - 81)) | (1 << (ZordParser.LinebreakAfterTag - 81)) | (1 << (ZordParser.BackslashParenAfterTag - 81)))) !== 0)) {\n\t            this.state = 698;\n\t            this.docElement();\n\t            this.state = 703;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 704;\n\t        _la = this._input.LA(1);\n\t        if(!(_la===ZordParser.BacktickClose || _la===ZordParser.BacktickCloseAfterTag)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tdocElement() {\n\t    let localctx = new DocElementContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 92, ZordParser.RULE_docElement);\n\t    try {\n\t        this.state = 710;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.Tag:\n\t        case ZordParser.TagAfterTag:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 706;\n\t            this.command();\n\t            break;\n\t        case ZordParser.BackslashParen:\n\t        case ZordParser.BackslashParenAfterTag:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 707;\n\t            this.interpolation();\n\t            break;\n\t        case ZordParser.LineBreak:\n\t        case ZordParser.LinebreakAfterTag:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 708;\n\t            this.newline();\n\t            break;\n\t        case ZordParser.Plaintext:\n\t        case ZordParser.PlaintextAfterTag:\n\t            this.enterOuterAlt(localctx, 4);\n\t            this.state = 709;\n\t            this.plaintext();\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tcommand() {\n\t    let localctx = new CommandContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 94, ZordParser.RULE_command);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 712;\n\t        _la = this._input.LA(1);\n\t        if(!(_la===ZordParser.Tag || _la===ZordParser.TagAfterTag)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t        this.state = 716;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(((((_la - 85)) & ~0x1f) == 0 && ((1 << (_la - 85)) & ((1 << (ZordParser.ParenOpenInTag - 85)) | (1 << (ZordParser.BraceOpenInTag - 85)) | (1 << (ZordParser.BracketOpenInTag - 85)))) !== 0)) {\n\t            this.state = 713;\n\t            this.arg();\n\t            this.state = 718;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tinterpolation() {\n\t    let localctx = new InterpolationContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 96, ZordParser.RULE_interpolation);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 719;\n\t        _la = this._input.LA(1);\n\t        if(!(_la===ZordParser.BackslashParen || _la===ZordParser.BackslashParenAfterTag)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t        this.state = 720;\n\t        this.expression();\n\t        this.state = 721;\n\t        this.match(ZordParser.ParenClose);\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tnewline() {\n\t    let localctx = new NewlineContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 98, ZordParser.RULE_newline);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 723;\n\t        _la = this._input.LA(1);\n\t        if(!(_la===ZordParser.LineBreak || _la===ZordParser.LinebreakAfterTag)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\tplaintext() {\n\t    let localctx = new PlaintextContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 100, ZordParser.RULE_plaintext);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 725;\n\t        _la = this._input.LA(1);\n\t        if(!(_la===ZordParser.Plaintext || _la===ZordParser.PlaintextAfterTag)) {\n\t        this._errHandler.recoverInline(this);\n\t        }\n\t        else {\n\t        \tthis._errHandler.reportMatch(this);\n\t            this.consume();\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\targ() {\n\t    let localctx = new ArgContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 102, ZordParser.RULE_arg);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.state = 752;\n\t        this._errHandler.sync(this);\n\t        switch(this._input.LA(1)) {\n\t        case ZordParser.ParenOpenInTag:\n\t            this.enterOuterAlt(localctx, 1);\n\t            this.state = 727;\n\t            this.match(ZordParser.ParenOpenInTag);\n\t            this.state = 728;\n\t            this.expression();\n\t            this.state = 729;\n\t            this.match(ZordParser.ParenClose);\n\t            break;\n\t        case ZordParser.BraceOpenInTag:\n\t            this.enterOuterAlt(localctx, 2);\n\t            this.state = 731;\n\t            this.match(ZordParser.BraceOpenInTag);\n\t            this.state = 737;\n\t            this._errHandler.sync(this);\n\t            var _alt = this._interp.adaptivePredict(this._input,71,this._ctx)\n\t            while(_alt!=2 && _alt!=antlr4__WEBPACK_IMPORTED_MODULE_0__.atn.ATN.INVALID_ALT_NUMBER) {\n\t                if(_alt===1) {\n\t                    this.state = 732;\n\t                    this.recordArgField();\n\t                    this.state = 733;\n\t                    this.match(ZordParser.Semicolon); \n\t                }\n\t                this.state = 739;\n\t                this._errHandler.sync(this);\n\t                _alt = this._interp.adaptivePredict(this._input,71,this._ctx);\n\t            }\n\n\t            this.state = 741;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t            if(_la===ZordParser.Lowerid || _la===ZordParser.Upperid) {\n\t                this.state = 740;\n\t                this.recordArgField();\n\t            }\n\n\t            this.state = 743;\n\t            this.match(ZordParser.BraceClose);\n\t            break;\n\t        case ZordParser.BracketOpenInTag:\n\t            this.enterOuterAlt(localctx, 3);\n\t            this.state = 744;\n\t            this.match(ZordParser.BracketOpenInTag);\n\t            this.state = 748;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t            while(((((_la - 81)) & ~0x1f) == 0 && ((1 << (_la - 81)) & ((1 << (ZordParser.LineBreak - 81)) | (1 << (ZordParser.Tag - 81)) | (1 << (ZordParser.BackslashParen - 81)) | (1 << (ZordParser.Plaintext - 81)) | (1 << (ZordParser.PlaintextAfterTag - 81)) | (1 << (ZordParser.TagAfterTag - 81)) | (1 << (ZordParser.LinebreakAfterTag - 81)) | (1 << (ZordParser.BackslashParenAfterTag - 81)))) !== 0)) {\n\t                this.state = 745;\n\t                this.docElement();\n\t                this.state = 750;\n\t                this._errHandler.sync(this);\n\t                _la = this._input.LA(1);\n\t            }\n\t            this.state = 751;\n\t            _la = this._input.LA(1);\n\t            if(!(_la===ZordParser.BracketCloseInDoc || _la===ZordParser.BracketCloseAfterTag)) {\n\t            this._errHandler.recoverInline(this);\n\t            }\n\t            else {\n\t            \tthis._errHandler.reportMatch(this);\n\t                this.consume();\n\t            }\n\t            break;\n\t        default:\n\t            throw new antlr4__WEBPACK_IMPORTED_MODULE_0__.error.NoViableAltException(this);\n\t        }\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n\n\trecordArgField() {\n\t    let localctx = new RecordArgFieldContext(this, this._ctx, this.state);\n\t    this.enterRule(localctx, 104, ZordParser.RULE_recordArgField);\n\t    var _la = 0; // Token type\n\t    try {\n\t        this.enterOuterAlt(localctx, 1);\n\t        this.state = 754;\n\t        this.labelDecl();\n\t        this.state = 758;\n\t        this._errHandler.sync(this);\n\t        _la = this._input.LA(1);\n\t        while(_la===ZordParser.Underscore || _la===ZordParser.Lowerid || _la===ZordParser.BraceOpen || _la===ZordParser.ParenOpen) {\n\t            this.state = 755;\n\t            this.termParam();\n\t            this.state = 760;\n\t            this._errHandler.sync(this);\n\t            _la = this._input.LA(1);\n\t        }\n\t        this.state = 761;\n\t        this.match(ZordParser.Assign);\n\t        this.state = 762;\n\t        this.expression();\n\t    } catch (re) {\n\t    \tif(re instanceof antlr4__WEBPACK_IMPORTED_MODULE_0__.error.RecognitionException) {\n\t\t        localctx.exception = re;\n\t\t        this._errHandler.reportError(this, re);\n\t\t        this._errHandler.recover(this, re);\n\t\t    } else {\n\t\t    \tthrow re;\n\t\t    }\n\t    } finally {\n\t        this.exitRule();\n\t    }\n\t    return localctx;\n\t}\n\n\n}\n\nZordParser.EOF = antlr4__WEBPACK_IMPORTED_MODULE_0__.Token.EOF;\nZordParser.Whitespaces = 1;\nZordParser.LineComment = 2;\nZordParser.BlockComment = 3;\nZordParser.Open = 4;\nZordParser.Type = 5;\nZordParser.ForAll = 6;\nZordParser.TraitCaps = 7;\nZordParser.Mu = 8;\nZordParser.Int = 9;\nZordParser.Double = 10;\nZordParser.StringType = 11;\nZordParser.Bool = 12;\nZordParser.Top = 13;\nZordParser.Bot = 14;\nZordParser.Let = 15;\nZordParser.LetRec = 16;\nZordParser.In = 17;\nZordParser.If = 18;\nZordParser.Then = 19;\nZordParser.Else = 20;\nZordParser.TraitSmall = 21;\nZordParser.Implements = 22;\nZordParser.Inherits = 23;\nZordParser.New = 24;\nZordParser.ToString = 25;\nZordParser.Fold = 26;\nZordParser.Unfold = 27;\nZordParser.At = 28;\nZordParser.True_ = 29;\nZordParser.False_ = 30;\nZordParser.Undefined_ = 31;\nZordParser.Override = 32;\nZordParser.Stick = 33;\nZordParser.DotDot = 34;\nZordParser.Underscore = 35;\nZordParser.Lowerid = 36;\nZordParser.Upperid = 37;\nZordParser.Number = 38;\nZordParser.BacktickOpen = 39;\nZordParser.String = 40;\nZordParser.Unit = 41;\nZordParser.Arrow = 42;\nZordParser.TraitArrow = 43;\nZordParser.Intersect = 44;\nZordParser.Plus = 45;\nZordParser.Minus = 46;\nZordParser.Star = 47;\nZordParser.Divide = 48;\nZordParser.Modulo = 49;\nZordParser.Not = 50;\nZordParser.And = 51;\nZordParser.Or = 52;\nZordParser.Append = 53;\nZordParser.Less = 54;\nZordParser.Greater = 55;\nZordParser.LessEqual = 56;\nZordParser.GreaterEqual = 57;\nZordParser.Equal = 58;\nZordParser.NotEqual = 59;\nZordParser.Merge = 60;\nZordParser.Forward = 61;\nZordParser.Index = 62;\nZordParser.Length = 63;\nZordParser.Assign = 64;\nZordParser.Newline = 65;\nZordParser.BracketOpen = 66;\nZordParser.BracketClose = 67;\nZordParser.BraceOpen = 68;\nZordParser.BraceClose = 69;\nZordParser.ParenOpen = 70;\nZordParser.ParenClose = 71;\nZordParser.Semicolon = 72;\nZordParser.Colon = 73;\nZordParser.Backslash = 74;\nZordParser.SlashBackslash = 75;\nZordParser.Dot = 76;\nZordParser.Question = 77;\nZordParser.Dollar = 78;\nZordParser.BacktickClose = 79;\nZordParser.BracketCloseInDoc = 80;\nZordParser.LineBreak = 81;\nZordParser.Tag = 82;\nZordParser.BackslashParen = 83;\nZordParser.Plaintext = 84;\nZordParser.ParenOpenInTag = 85;\nZordParser.BraceOpenInTag = 86;\nZordParser.BracketOpenInTag = 87;\nZordParser.PlaintextAfterTag = 88;\nZordParser.BracketCloseAfterTag = 89;\nZordParser.BacktickCloseAfterTag = 90;\nZordParser.TagAfterTag = 91;\nZordParser.LinebreakAfterTag = 92;\nZordParser.BackslashParenAfterTag = 93;\n\nZordParser.RULE_program = 0;\nZordParser.RULE_open = 1;\nZordParser.RULE_definition = 2;\nZordParser.RULE_typeDef = 3;\nZordParser.RULE_termDef = 4;\nZordParser.RULE_type = 5;\nZordParser.RULE_btype = 6;\nZordParser.RULE_atype = 7;\nZordParser.RULE_recordType = 8;\nZordParser.RULE_recordTypeElement = 9;\nZordParser.RULE_expression = 10;\nZordParser.RULE_opexpr = 11;\nZordParser.RULE_lexpr = 12;\nZordParser.RULE_lambda = 13;\nZordParser.RULE_bigLambda = 14;\nZordParser.RULE_let_ = 15;\nZordParser.RULE_letRec = 16;\nZordParser.RULE_open_ = 17;\nZordParser.RULE_ifElse = 18;\nZordParser.RULE_trait = 19;\nZordParser.RULE_new_ = 20;\nZordParser.RULE_toString_ = 21;\nZordParser.RULE_fold = 22;\nZordParser.RULE_unfold = 23;\nZordParser.RULE_fexpr = 24;\nZordParser.RULE_dotexpr = 25;\nZordParser.RULE_aexpr = 26;\nZordParser.RULE_array = 27;\nZordParser.RULE_record = 28;\nZordParser.RULE_recordField = 29;\nZordParser.RULE_recordUpdate = 30;\nZordParser.RULE_methodPattern = 31;\nZordParser.RULE_defaultPattern = 32;\nZordParser.RULE_typeParam = 33;\nZordParser.RULE_termParam = 34;\nZordParser.RULE_termId = 35;\nZordParser.RULE_wildcard = 36;\nZordParser.RULE_selfAnno = 37;\nZordParser.RULE_sort = 38;\nZordParser.RULE_typeNameDecl = 39;\nZordParser.RULE_typeName = 40;\nZordParser.RULE_termNameDecl = 41;\nZordParser.RULE_termName = 42;\nZordParser.RULE_labelDecl = 43;\nZordParser.RULE_label = 44;\nZordParser.RULE_document = 45;\nZordParser.RULE_docElement = 46;\nZordParser.RULE_command = 47;\nZordParser.RULE_interpolation = 48;\nZordParser.RULE_newline = 49;\nZordParser.RULE_plaintext = 50;\nZordParser.RULE_arg = 51;\nZordParser.RULE_recordArgField = 52;\n\nclass ProgramContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_program;\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\topen = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(OpenContext);\n\t    } else {\n\t        return this.getTypedRuleContext(OpenContext,i);\n\t    }\n\t};\n\n\tdefinition = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(DefinitionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(DefinitionContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitProgram(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass OpenContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_open;\n    }\n\n\tOpen() {\n\t    return this.getToken(ZordParser.Open, 0);\n\t};\n\n\tSemicolon() {\n\t    return this.getToken(ZordParser.Semicolon, 0);\n\t};\n\n\tUpperid = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Upperid);\n\t    } else {\n\t        return this.getToken(ZordParser.Upperid, i);\n\t    }\n\t};\n\n\n\tLowerid = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Lowerid);\n\t    } else {\n\t        return this.getToken(ZordParser.Lowerid, i);\n\t    }\n\t};\n\n\n\tDivide = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Divide);\n\t    } else {\n\t        return this.getToken(ZordParser.Divide, i);\n\t    }\n\t};\n\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitOpen(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass DefinitionContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_definition;\n    }\n\n\ttypeDef() {\n\t    return this.getTypedRuleContext(TypeDefContext,0);\n\t};\n\n\ttermDef() {\n\t    return this.getTypedRuleContext(TermDefContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitDefinition(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TypeDefContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_typeDef;\n    }\n\n\tType() {\n\t    return this.getToken(ZordParser.Type, 0);\n\t};\n\n\ttypeNameDecl = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TypeNameDeclContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TypeNameDeclContext,i);\n\t    }\n\t};\n\n\tAssign() {\n\t    return this.getToken(ZordParser.Assign, 0);\n\t};\n\n\ttype() {\n\t    return this.getTypedRuleContext(TypeContext,0);\n\t};\n\n\tSemicolon() {\n\t    return this.getToken(ZordParser.Semicolon, 0);\n\t};\n\n\tLess = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Less);\n\t    } else {\n\t        return this.getToken(ZordParser.Less, i);\n\t    }\n\t};\n\n\n\tGreater = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Greater);\n\t    } else {\n\t        return this.getToken(ZordParser.Greater, i);\n\t    }\n\t};\n\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitTypeDef(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TermDefContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_termDef;\n    }\n\n\ttermNameDecl() {\n\t    return this.getTypedRuleContext(TermNameDeclContext,0);\n\t};\n\n\tAssign() {\n\t    return this.getToken(ZordParser.Assign, 0);\n\t};\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tSemicolon() {\n\t    return this.getToken(ZordParser.Semicolon, 0);\n\t};\n\n\ttypeParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TypeParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TypeParamContext,i);\n\t    }\n\t};\n\n\ttermParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TermParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TermParamContext,i);\n\t    }\n\t};\n\n\tColon() {\n\t    return this.getToken(ZordParser.Colon, 0);\n\t};\n\n\ttype() {\n\t    return this.getTypedRuleContext(TypeContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitTermDef(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TypeContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_type;\n    }\n\n\tbtype() {\n\t    return this.getTypedRuleContext(BtypeContext,0);\n\t};\n\n\ttype = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TypeContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TypeContext,i);\n\t    }\n\t};\n\n\tIntersect() {\n\t    return this.getToken(ZordParser.Intersect, 0);\n\t};\n\n\tArrow() {\n\t    return this.getToken(ZordParser.Arrow, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitType(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass BtypeContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_btype;\n    }\n\n\tatype = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(AtypeContext);\n\t    } else {\n\t        return this.getTypedRuleContext(AtypeContext,i);\n\t    }\n\t};\n\n\tLess = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Less);\n\t    } else {\n\t        return this.getToken(ZordParser.Less, i);\n\t    }\n\t};\n\n\n\tsort = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(SortContext);\n\t    } else {\n\t        return this.getTypedRuleContext(SortContext,i);\n\t    }\n\t};\n\n\tGreater = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Greater);\n\t    } else {\n\t        return this.getToken(ZordParser.Greater, i);\n\t    }\n\t};\n\n\n\tForAll() {\n\t    return this.getToken(ZordParser.ForAll, 0);\n\t};\n\n\tDot() {\n\t    return this.getToken(ZordParser.Dot, 0);\n\t};\n\n\ttype = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TypeContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TypeContext,i);\n\t    }\n\t};\n\n\ttypeParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TypeParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TypeParamContext,i);\n\t    }\n\t};\n\n\tTraitCaps() {\n\t    return this.getToken(ZordParser.TraitCaps, 0);\n\t};\n\n\tTraitArrow() {\n\t    return this.getToken(ZordParser.TraitArrow, 0);\n\t};\n\n\tMu() {\n\t    return this.getToken(ZordParser.Mu, 0);\n\t};\n\n\ttypeNameDecl() {\n\t    return this.getTypedRuleContext(TypeNameDeclContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitBtype(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass AtypeContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_atype;\n    }\n\n\tInt() {\n\t    return this.getToken(ZordParser.Int, 0);\n\t};\n\n\tDouble() {\n\t    return this.getToken(ZordParser.Double, 0);\n\t};\n\n\tStringType() {\n\t    return this.getToken(ZordParser.StringType, 0);\n\t};\n\n\tBool() {\n\t    return this.getToken(ZordParser.Bool, 0);\n\t};\n\n\tTop() {\n\t    return this.getToken(ZordParser.Top, 0);\n\t};\n\n\tBot() {\n\t    return this.getToken(ZordParser.Bot, 0);\n\t};\n\n\ttypeName() {\n\t    return this.getTypedRuleContext(TypeNameContext,0);\n\t};\n\n\trecordType() {\n\t    return this.getTypedRuleContext(RecordTypeContext,0);\n\t};\n\n\tBracketOpen() {\n\t    return this.getToken(ZordParser.BracketOpen, 0);\n\t};\n\n\ttype() {\n\t    return this.getTypedRuleContext(TypeContext,0);\n\t};\n\n\tBracketClose() {\n\t    return this.getToken(ZordParser.BracketClose, 0);\n\t};\n\n\tParenOpen() {\n\t    return this.getToken(ZordParser.ParenOpen, 0);\n\t};\n\n\tParenClose() {\n\t    return this.getToken(ZordParser.ParenClose, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitAtype(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass RecordTypeContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_recordType;\n    }\n\n\tBraceOpen() {\n\t    return this.getToken(ZordParser.BraceOpen, 0);\n\t};\n\n\tBraceClose() {\n\t    return this.getToken(ZordParser.BraceClose, 0);\n\t};\n\n\trecordTypeElement = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(RecordTypeElementContext);\n\t    } else {\n\t        return this.getTypedRuleContext(RecordTypeElementContext,i);\n\t    }\n\t};\n\n\tSemicolon = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Semicolon);\n\t    } else {\n\t        return this.getToken(ZordParser.Semicolon, i);\n\t    }\n\t};\n\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitRecordType(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass RecordTypeElementContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_recordTypeElement;\n    }\n\n\tlabelDecl() {\n\t    return this.getTypedRuleContext(LabelDeclContext,0);\n\t};\n\n\tColon() {\n\t    return this.getToken(ZordParser.Colon, 0);\n\t};\n\n\ttype() {\n\t    return this.getTypedRuleContext(TypeContext,0);\n\t};\n\n\tQuestion() {\n\t    return this.getToken(ZordParser.Question, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitRecordTypeElement(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass ExpressionContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_expression;\n    }\n\n\topexpr() {\n\t    return this.getTypedRuleContext(OpexprContext,0);\n\t};\n\n\tColon() {\n\t    return this.getToken(ZordParser.Colon, 0);\n\t};\n\n\ttype() {\n\t    return this.getTypedRuleContext(TypeContext,0);\n\t};\n\n\tBackslash() {\n\t    return this.getToken(ZordParser.Backslash, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitExpression(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass OpexprContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_opexpr;\n    }\n\n\tlexpr() {\n\t    return this.getTypedRuleContext(LexprContext,0);\n\t};\n\n\tMinus() {\n\t    return this.getToken(ZordParser.Minus, 0);\n\t};\n\n\topexpr = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(OpexprContext);\n\t    } else {\n\t        return this.getTypedRuleContext(OpexprContext,i);\n\t    }\n\t};\n\n\tNot() {\n\t    return this.getToken(ZordParser.Not, 0);\n\t};\n\n\tLength() {\n\t    return this.getToken(ZordParser.Length, 0);\n\t};\n\n\tIndex() {\n\t    return this.getToken(ZordParser.Index, 0);\n\t};\n\n\tModulo() {\n\t    return this.getToken(ZordParser.Modulo, 0);\n\t};\n\n\tDivide() {\n\t    return this.getToken(ZordParser.Divide, 0);\n\t};\n\n\tStar() {\n\t    return this.getToken(ZordParser.Star, 0);\n\t};\n\n\tPlus() {\n\t    return this.getToken(ZordParser.Plus, 0);\n\t};\n\n\tAppend() {\n\t    return this.getToken(ZordParser.Append, 0);\n\t};\n\n\tLess() {\n\t    return this.getToken(ZordParser.Less, 0);\n\t};\n\n\tGreater() {\n\t    return this.getToken(ZordParser.Greater, 0);\n\t};\n\n\tLessEqual() {\n\t    return this.getToken(ZordParser.LessEqual, 0);\n\t};\n\n\tGreaterEqual() {\n\t    return this.getToken(ZordParser.GreaterEqual, 0);\n\t};\n\n\tEqual() {\n\t    return this.getToken(ZordParser.Equal, 0);\n\t};\n\n\tNotEqual() {\n\t    return this.getToken(ZordParser.NotEqual, 0);\n\t};\n\n\tAnd() {\n\t    return this.getToken(ZordParser.And, 0);\n\t};\n\n\tOr() {\n\t    return this.getToken(ZordParser.Or, 0);\n\t};\n\n\tForward() {\n\t    return this.getToken(ZordParser.Forward, 0);\n\t};\n\n\tMerge() {\n\t    return this.getToken(ZordParser.Merge, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitOpexpr(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass LexprContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_lexpr;\n    }\n\n\tfexpr() {\n\t    return this.getTypedRuleContext(FexprContext,0);\n\t};\n\n\tlambda() {\n\t    return this.getTypedRuleContext(LambdaContext,0);\n\t};\n\n\tbigLambda() {\n\t    return this.getTypedRuleContext(BigLambdaContext,0);\n\t};\n\n\tlet_() {\n\t    return this.getTypedRuleContext(Let_Context,0);\n\t};\n\n\tletRec() {\n\t    return this.getTypedRuleContext(LetRecContext,0);\n\t};\n\n\topen_() {\n\t    return this.getTypedRuleContext(Open_Context,0);\n\t};\n\n\tifElse() {\n\t    return this.getTypedRuleContext(IfElseContext,0);\n\t};\n\n\ttrait() {\n\t    return this.getTypedRuleContext(TraitContext,0);\n\t};\n\n\tnew_() {\n\t    return this.getTypedRuleContext(New_Context,0);\n\t};\n\n\ttoString_() {\n\t    return this.getTypedRuleContext(ToString_Context,0);\n\t};\n\n\tfold() {\n\t    return this.getTypedRuleContext(FoldContext,0);\n\t};\n\n\tunfold() {\n\t    return this.getTypedRuleContext(UnfoldContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitLexpr(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass LambdaContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_lambda;\n    }\n\n\tBackslash() {\n\t    return this.getToken(ZordParser.Backslash, 0);\n\t};\n\n\tArrow() {\n\t    return this.getToken(ZordParser.Arrow, 0);\n\t};\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\ttermParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TermParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TermParamContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitLambda(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass BigLambdaContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_bigLambda;\n    }\n\n\tSlashBackslash() {\n\t    return this.getToken(ZordParser.SlashBackslash, 0);\n\t};\n\n\tDot() {\n\t    return this.getToken(ZordParser.Dot, 0);\n\t};\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\ttypeParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TypeParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TypeParamContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitBigLambda(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass Let_Context extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_let_;\n    }\n\n\tLet() {\n\t    return this.getToken(ZordParser.Let, 0);\n\t};\n\n\ttermNameDecl() {\n\t    return this.getTypedRuleContext(TermNameDeclContext,0);\n\t};\n\n\tAssign() {\n\t    return this.getToken(ZordParser.Assign, 0);\n\t};\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tIn() {\n\t    return this.getToken(ZordParser.In, 0);\n\t};\n\n\ttypeParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TypeParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TypeParamContext,i);\n\t    }\n\t};\n\n\ttermParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TermParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TermParamContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitLet_(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass LetRecContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_letRec;\n    }\n\n\tLetRec() {\n\t    return this.getToken(ZordParser.LetRec, 0);\n\t};\n\n\ttermNameDecl() {\n\t    return this.getTypedRuleContext(TermNameDeclContext,0);\n\t};\n\n\tColon() {\n\t    return this.getToken(ZordParser.Colon, 0);\n\t};\n\n\ttype() {\n\t    return this.getTypedRuleContext(TypeContext,0);\n\t};\n\n\tAssign() {\n\t    return this.getToken(ZordParser.Assign, 0);\n\t};\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tIn() {\n\t    return this.getToken(ZordParser.In, 0);\n\t};\n\n\ttypeParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TypeParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TypeParamContext,i);\n\t    }\n\t};\n\n\ttermParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TermParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TermParamContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitLetRec(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass Open_Context extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_open_;\n    }\n\n\tOpen() {\n\t    return this.getToken(ZordParser.Open, 0);\n\t};\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tIn() {\n\t    return this.getToken(ZordParser.In, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitOpen_(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass IfElseContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_ifElse;\n    }\n\n\tIf() {\n\t    return this.getToken(ZordParser.If, 0);\n\t};\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tThen() {\n\t    return this.getToken(ZordParser.Then, 0);\n\t};\n\n\tElse() {\n\t    return this.getToken(ZordParser.Else, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitIfElse(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TraitContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_trait;\n    }\n\n\tTraitSmall() {\n\t    return this.getToken(ZordParser.TraitSmall, 0);\n\t};\n\n\tTraitArrow() {\n\t    return this.getToken(ZordParser.TraitArrow, 0);\n\t};\n\n\topexpr = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(OpexprContext);\n\t    } else {\n\t        return this.getTypedRuleContext(OpexprContext,i);\n\t    }\n\t};\n\n\tselfAnno() {\n\t    return this.getTypedRuleContext(SelfAnnoContext,0);\n\t};\n\n\tImplements() {\n\t    return this.getToken(ZordParser.Implements, 0);\n\t};\n\n\ttype() {\n\t    return this.getTypedRuleContext(TypeContext,0);\n\t};\n\n\tInherits() {\n\t    return this.getToken(ZordParser.Inherits, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitTrait(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass New_Context extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_new_;\n    }\n\n\tNew() {\n\t    return this.getToken(ZordParser.New, 0);\n\t};\n\n\topexpr() {\n\t    return this.getTypedRuleContext(OpexprContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitNew_(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass ToString_Context extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_toString_;\n    }\n\n\tToString() {\n\t    return this.getToken(ZordParser.ToString, 0);\n\t};\n\n\tdotexpr() {\n\t    return this.getTypedRuleContext(DotexprContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitToString_(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass FoldContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_fold;\n    }\n\n\tFold() {\n\t    return this.getToken(ZordParser.Fold, 0);\n\t};\n\n\tAt() {\n\t    return this.getToken(ZordParser.At, 0);\n\t};\n\n\tatype() {\n\t    return this.getTypedRuleContext(AtypeContext,0);\n\t};\n\n\tdotexpr() {\n\t    return this.getTypedRuleContext(DotexprContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitFold(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass UnfoldContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_unfold;\n    }\n\n\tUnfold() {\n\t    return this.getToken(ZordParser.Unfold, 0);\n\t};\n\n\tAt() {\n\t    return this.getToken(ZordParser.At, 0);\n\t};\n\n\tatype() {\n\t    return this.getTypedRuleContext(AtypeContext,0);\n\t};\n\n\tdotexpr() {\n\t    return this.getTypedRuleContext(DotexprContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitUnfold(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass FexprContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_fexpr;\n    }\n\n\ttypeNameDecl() {\n\t    return this.getTypedRuleContext(TypeNameDeclContext,0);\n\t};\n\n\tdotexpr = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(DotexprContext);\n\t    } else {\n\t        return this.getTypedRuleContext(DotexprContext,i);\n\t    }\n\t};\n\n\tAt = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.At);\n\t    } else {\n\t        return this.getToken(ZordParser.At, i);\n\t    }\n\t};\n\n\n\tatype = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(AtypeContext);\n\t    } else {\n\t        return this.getTypedRuleContext(AtypeContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitFexpr(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass DotexprContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_dotexpr;\n    }\n\n\taexpr() {\n\t    return this.getTypedRuleContext(AexprContext,0);\n\t};\n\n\tDot = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Dot);\n\t    } else {\n\t        return this.getToken(ZordParser.Dot, i);\n\t    }\n\t};\n\n\n\tlabel = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(LabelContext);\n\t    } else {\n\t        return this.getTypedRuleContext(LabelContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitDotexpr(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass AexprContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_aexpr;\n    }\n\n\ttermName() {\n\t    return this.getTypedRuleContext(TermNameContext,0);\n\t};\n\n\tNumber() {\n\t    return this.getToken(ZordParser.Number, 0);\n\t};\n\n\tdocument() {\n\t    return this.getTypedRuleContext(DocumentContext,0);\n\t};\n\n\tString() {\n\t    return this.getToken(ZordParser.String, 0);\n\t};\n\n\tUnit() {\n\t    return this.getToken(ZordParser.Unit, 0);\n\t};\n\n\tTrue_() {\n\t    return this.getToken(ZordParser.True_, 0);\n\t};\n\n\tFalse_() {\n\t    return this.getToken(ZordParser.False_, 0);\n\t};\n\n\tUndefined_() {\n\t    return this.getToken(ZordParser.Undefined_, 0);\n\t};\n\n\tarray() {\n\t    return this.getTypedRuleContext(ArrayContext,0);\n\t};\n\n\trecord() {\n\t    return this.getTypedRuleContext(RecordContext,0);\n\t};\n\n\trecordUpdate() {\n\t    return this.getTypedRuleContext(RecordUpdateContext,0);\n\t};\n\n\tDollar() {\n\t    return this.getToken(ZordParser.Dollar, 0);\n\t};\n\n\ttypeNameDecl() {\n\t    return this.getTypedRuleContext(TypeNameDeclContext,0);\n\t};\n\n\tParenOpen() {\n\t    return this.getToken(ZordParser.ParenOpen, 0);\n\t};\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tParenClose() {\n\t    return this.getToken(ZordParser.ParenClose, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitAexpr(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass ArrayContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_array;\n    }\n\n\tBracketOpen() {\n\t    return this.getToken(ZordParser.BracketOpen, 0);\n\t};\n\n\tBracketClose() {\n\t    return this.getToken(ZordParser.BracketClose, 0);\n\t};\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tSemicolon = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Semicolon);\n\t    } else {\n\t        return this.getToken(ZordParser.Semicolon, i);\n\t    }\n\t};\n\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitArray(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass RecordContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_record;\n    }\n\n\tBraceOpen() {\n\t    return this.getToken(ZordParser.BraceOpen, 0);\n\t};\n\n\tBraceClose() {\n\t    return this.getToken(ZordParser.BraceClose, 0);\n\t};\n\n\tSemicolon = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Semicolon);\n\t    } else {\n\t        return this.getToken(ZordParser.Semicolon, i);\n\t    }\n\t};\n\n\n\trecordField = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(RecordFieldContext);\n\t    } else {\n\t        return this.getTypedRuleContext(RecordFieldContext,i);\n\t    }\n\t};\n\n\tmethodPattern = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(MethodPatternContext);\n\t    } else {\n\t        return this.getTypedRuleContext(MethodPatternContext,i);\n\t    }\n\t};\n\n\tdefaultPattern = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(DefaultPatternContext);\n\t    } else {\n\t        return this.getTypedRuleContext(DefaultPatternContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitRecord(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass RecordFieldContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_recordField;\n    }\n\n\tlabelDecl() {\n\t    return this.getTypedRuleContext(LabelDeclContext,0);\n\t};\n\n\tAssign() {\n\t    return this.getToken(ZordParser.Assign, 0);\n\t};\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tOverride() {\n\t    return this.getToken(ZordParser.Override, 0);\n\t};\n\n\tselfAnno() {\n\t    return this.getTypedRuleContext(SelfAnnoContext,0);\n\t};\n\n\ttermParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TermParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TermParamContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitRecordField(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass RecordUpdateContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_recordUpdate;\n    }\n\n\tBraceOpen() {\n\t    return this.getToken(ZordParser.BraceOpen, 0);\n\t};\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\tStick() {\n\t    return this.getToken(ZordParser.Stick, 0);\n\t};\n\n\tBraceClose() {\n\t    return this.getToken(ZordParser.BraceClose, 0);\n\t};\n\n\tSemicolon = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Semicolon);\n\t    } else {\n\t        return this.getToken(ZordParser.Semicolon, i);\n\t    }\n\t};\n\n\n\tlabelDecl = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(LabelDeclContext);\n\t    } else {\n\t        return this.getTypedRuleContext(LabelDeclContext,i);\n\t    }\n\t};\n\n\tAssign = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Assign);\n\t    } else {\n\t        return this.getToken(ZordParser.Assign, i);\n\t    }\n\t};\n\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitRecordUpdate(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass MethodPatternContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_methodPattern;\n    }\n\n\tParenOpen() {\n\t    return this.getToken(ZordParser.ParenOpen, 0);\n\t};\n\n\tlabelDecl = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(LabelDeclContext);\n\t    } else {\n\t        return this.getTypedRuleContext(LabelDeclContext,i);\n\t    }\n\t};\n\n\tParenClose() {\n\t    return this.getToken(ZordParser.ParenClose, 0);\n\t};\n\n\tDot() {\n\t    return this.getToken(ZordParser.Dot, 0);\n\t};\n\n\tAssign() {\n\t    return this.getToken(ZordParser.Assign, 0);\n\t};\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tOverride() {\n\t    return this.getToken(ZordParser.Override, 0);\n\t};\n\n\tselfAnno() {\n\t    return this.getTypedRuleContext(SelfAnnoContext,0);\n\t};\n\n\tAt() {\n\t    return this.getToken(ZordParser.At, 0);\n\t};\n\n\ttermParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TermParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TermParamContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitMethodPattern(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass DefaultPatternContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_defaultPattern;\n    }\n\n\tDot() {\n\t    return this.getToken(ZordParser.Dot, 0);\n\t};\n\n\tlabelDecl() {\n\t    return this.getTypedRuleContext(LabelDeclContext,0);\n\t};\n\n\tAssign() {\n\t    return this.getToken(ZordParser.Assign, 0);\n\t};\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tUnderscore() {\n\t    return this.getToken(ZordParser.Underscore, 0);\n\t};\n\n\tselfAnno() {\n\t    return this.getTypedRuleContext(SelfAnnoContext,0);\n\t};\n\n\tOverride() {\n\t    return this.getToken(ZordParser.Override, 0);\n\t};\n\n\ttermParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TermParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TermParamContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitDefaultPattern(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TypeParamContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_typeParam;\n    }\n\n\ttypeNameDecl() {\n\t    return this.getTypedRuleContext(TypeNameDeclContext,0);\n\t};\n\n\tParenOpen() {\n\t    return this.getToken(ZordParser.ParenOpen, 0);\n\t};\n\n\tStar() {\n\t    return this.getToken(ZordParser.Star, 0);\n\t};\n\n\ttype() {\n\t    return this.getTypedRuleContext(TypeContext,0);\n\t};\n\n\tParenClose() {\n\t    return this.getToken(ZordParser.ParenClose, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitTypeParam(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TermParamContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_termParam;\n    }\n\n\ttermId() {\n\t    return this.getTypedRuleContext(TermIdContext,0);\n\t};\n\n\tParenOpen() {\n\t    return this.getToken(ZordParser.ParenOpen, 0);\n\t};\n\n\tColon() {\n\t    return this.getToken(ZordParser.Colon, 0);\n\t};\n\n\ttype() {\n\t    return this.getTypedRuleContext(TypeContext,0);\n\t};\n\n\tParenClose() {\n\t    return this.getToken(ZordParser.ParenClose, 0);\n\t};\n\n\twildcard() {\n\t    return this.getTypedRuleContext(WildcardContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitTermParam(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TermIdContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_termId;\n    }\n\n\tUnderscore() {\n\t    return this.getToken(ZordParser.Underscore, 0);\n\t};\n\n\ttermNameDecl() {\n\t    return this.getTypedRuleContext(TermNameDeclContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitTermId(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass WildcardContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_wildcard;\n    }\n\n\tBraceOpen() {\n\t    return this.getToken(ZordParser.BraceOpen, 0);\n\t};\n\n\tDotDot() {\n\t    return this.getToken(ZordParser.DotDot, 0);\n\t};\n\n\tBraceClose() {\n\t    return this.getToken(ZordParser.BraceClose, 0);\n\t};\n\n\tSemicolon = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Semicolon);\n\t    } else {\n\t        return this.getToken(ZordParser.Semicolon, i);\n\t    }\n\t};\n\n\n\tlabelDecl = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(LabelDeclContext);\n\t    } else {\n\t        return this.getTypedRuleContext(LabelDeclContext,i);\n\t    }\n\t};\n\n\tAssign = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Assign);\n\t    } else {\n\t        return this.getToken(ZordParser.Assign, i);\n\t    }\n\t};\n\n\n\texpression = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ExpressionContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ExpressionContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitWildcard(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass SelfAnnoContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_selfAnno;\n    }\n\n\tBracketOpen() {\n\t    return this.getToken(ZordParser.BracketOpen, 0);\n\t};\n\n\ttermNameDecl() {\n\t    return this.getTypedRuleContext(TermNameDeclContext,0);\n\t};\n\n\tBracketClose() {\n\t    return this.getToken(ZordParser.BracketClose, 0);\n\t};\n\n\tColon() {\n\t    return this.getToken(ZordParser.Colon, 0);\n\t};\n\n\ttype() {\n\t    return this.getTypedRuleContext(TypeContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitSelfAnno(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass SortContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_sort;\n    }\n\n\ttype = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TypeContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TypeContext,i);\n\t    }\n\t};\n\n\tTraitArrow() {\n\t    return this.getToken(ZordParser.TraitArrow, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitSort(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TypeNameDeclContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_typeNameDecl;\n    }\n\n\tUpperid() {\n\t    return this.getToken(ZordParser.Upperid, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitTypeNameDecl(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TypeNameContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_typeName;\n    }\n\n\tUpperid() {\n\t    return this.getToken(ZordParser.Upperid, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitTypeName(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TermNameDeclContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_termNameDecl;\n    }\n\n\tLowerid() {\n\t    return this.getToken(ZordParser.Lowerid, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitTermNameDecl(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass TermNameContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_termName;\n    }\n\n\tLowerid() {\n\t    return this.getToken(ZordParser.Lowerid, 0);\n\t};\n\n\tUpperid() {\n\t    return this.getToken(ZordParser.Upperid, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitTermName(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass LabelDeclContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_labelDecl;\n    }\n\n\tLowerid() {\n\t    return this.getToken(ZordParser.Lowerid, 0);\n\t};\n\n\tUpperid() {\n\t    return this.getToken(ZordParser.Upperid, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitLabelDecl(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass LabelContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_label;\n    }\n\n\tLowerid() {\n\t    return this.getToken(ZordParser.Lowerid, 0);\n\t};\n\n\tUpperid() {\n\t    return this.getToken(ZordParser.Upperid, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitLabel(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass DocumentContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_document;\n    }\n\n\tBacktickOpen() {\n\t    return this.getToken(ZordParser.BacktickOpen, 0);\n\t};\n\n\tBacktickClose() {\n\t    return this.getToken(ZordParser.BacktickClose, 0);\n\t};\n\n\tBacktickCloseAfterTag() {\n\t    return this.getToken(ZordParser.BacktickCloseAfterTag, 0);\n\t};\n\n\tdocElement = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(DocElementContext);\n\t    } else {\n\t        return this.getTypedRuleContext(DocElementContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitDocument(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass DocElementContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_docElement;\n    }\n\n\tcommand() {\n\t    return this.getTypedRuleContext(CommandContext,0);\n\t};\n\n\tinterpolation() {\n\t    return this.getTypedRuleContext(InterpolationContext,0);\n\t};\n\n\tnewline() {\n\t    return this.getTypedRuleContext(NewlineContext,0);\n\t};\n\n\tplaintext() {\n\t    return this.getTypedRuleContext(PlaintextContext,0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitDocElement(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass CommandContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_command;\n    }\n\n\tTag() {\n\t    return this.getToken(ZordParser.Tag, 0);\n\t};\n\n\tTagAfterTag() {\n\t    return this.getToken(ZordParser.TagAfterTag, 0);\n\t};\n\n\targ = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(ArgContext);\n\t    } else {\n\t        return this.getTypedRuleContext(ArgContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitCommand(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass InterpolationContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_interpolation;\n    }\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tParenClose() {\n\t    return this.getToken(ZordParser.ParenClose, 0);\n\t};\n\n\tBackslashParen() {\n\t    return this.getToken(ZordParser.BackslashParen, 0);\n\t};\n\n\tBackslashParenAfterTag() {\n\t    return this.getToken(ZordParser.BackslashParenAfterTag, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitInterpolation(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass NewlineContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_newline;\n    }\n\n\tLineBreak() {\n\t    return this.getToken(ZordParser.LineBreak, 0);\n\t};\n\n\tLinebreakAfterTag() {\n\t    return this.getToken(ZordParser.LinebreakAfterTag, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitNewline(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass PlaintextContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_plaintext;\n    }\n\n\tPlaintext() {\n\t    return this.getToken(ZordParser.Plaintext, 0);\n\t};\n\n\tPlaintextAfterTag() {\n\t    return this.getToken(ZordParser.PlaintextAfterTag, 0);\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitPlaintext(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass ArgContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_arg;\n    }\n\n\tParenOpenInTag() {\n\t    return this.getToken(ZordParser.ParenOpenInTag, 0);\n\t};\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\tParenClose() {\n\t    return this.getToken(ZordParser.ParenClose, 0);\n\t};\n\n\tBraceOpenInTag() {\n\t    return this.getToken(ZordParser.BraceOpenInTag, 0);\n\t};\n\n\tBraceClose() {\n\t    return this.getToken(ZordParser.BraceClose, 0);\n\t};\n\n\trecordArgField = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(RecordArgFieldContext);\n\t    } else {\n\t        return this.getTypedRuleContext(RecordArgFieldContext,i);\n\t    }\n\t};\n\n\tSemicolon = function(i) {\n\t\tif(i===undefined) {\n\t\t\ti = null;\n\t\t}\n\t    if(i===null) {\n\t        return this.getTokens(ZordParser.Semicolon);\n\t    } else {\n\t        return this.getToken(ZordParser.Semicolon, i);\n\t    }\n\t};\n\n\n\tBracketOpenInTag() {\n\t    return this.getToken(ZordParser.BracketOpenInTag, 0);\n\t};\n\n\tBracketCloseInDoc() {\n\t    return this.getToken(ZordParser.BracketCloseInDoc, 0);\n\t};\n\n\tBracketCloseAfterTag() {\n\t    return this.getToken(ZordParser.BracketCloseAfterTag, 0);\n\t};\n\n\tdocElement = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(DocElementContext);\n\t    } else {\n\t        return this.getTypedRuleContext(DocElementContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitArg(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\nclass RecordArgFieldContext extends antlr4__WEBPACK_IMPORTED_MODULE_0__.ParserRuleContext {\n\n    constructor(parser, parent, invokingState) {\n        if(parent===undefined) {\n            parent = null;\n        }\n        if(invokingState===undefined || invokingState===null) {\n            invokingState = -1;\n        }\n        super(parent, invokingState);\n        this.parser = parser;\n        this.ruleIndex = ZordParser.RULE_recordArgField;\n    }\n\n\tlabelDecl() {\n\t    return this.getTypedRuleContext(LabelDeclContext,0);\n\t};\n\n\tAssign() {\n\t    return this.getToken(ZordParser.Assign, 0);\n\t};\n\n\texpression() {\n\t    return this.getTypedRuleContext(ExpressionContext,0);\n\t};\n\n\ttermParam = function(i) {\n\t    if(i===undefined) {\n\t        i = null;\n\t    }\n\t    if(i===null) {\n\t        return this.getTypedRuleContexts(TermParamContext);\n\t    } else {\n\t        return this.getTypedRuleContext(TermParamContext,i);\n\t    }\n\t};\n\n\taccept(visitor) {\n\t    if ( visitor instanceof _ZordParserVisitor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ) {\n\t        return visitor.visitRecordArgField(this);\n\t    } else {\n\t        return visitor.visitChildren(this);\n\t    }\n\t}\n\n\n}\n\n\n\n\nZordParser.ProgramContext = ProgramContext; \nZordParser.OpenContext = OpenContext; \nZordParser.DefinitionContext = DefinitionContext; \nZordParser.TypeDefContext = TypeDefContext; \nZordParser.TermDefContext = TermDefContext; \nZordParser.TypeContext = TypeContext; \nZordParser.BtypeContext = BtypeContext; \nZordParser.AtypeContext = AtypeContext; \nZordParser.RecordTypeContext = RecordTypeContext; \nZordParser.RecordTypeElementContext = RecordTypeElementContext; \nZordParser.ExpressionContext = ExpressionContext; \nZordParser.OpexprContext = OpexprContext; \nZordParser.LexprContext = LexprContext; \nZordParser.LambdaContext = LambdaContext; \nZordParser.BigLambdaContext = BigLambdaContext; \nZordParser.Let_Context = Let_Context; \nZordParser.LetRecContext = LetRecContext; \nZordParser.Open_Context = Open_Context; \nZordParser.IfElseContext = IfElseContext; \nZordParser.TraitContext = TraitContext; \nZordParser.New_Context = New_Context; \nZordParser.ToString_Context = ToString_Context; \nZordParser.FoldContext = FoldContext; \nZordParser.UnfoldContext = UnfoldContext; \nZordParser.FexprContext = FexprContext; \nZordParser.DotexprContext = DotexprContext; \nZordParser.AexprContext = AexprContext; \nZordParser.ArrayContext = ArrayContext; \nZordParser.RecordContext = RecordContext; \nZordParser.RecordFieldContext = RecordFieldContext; \nZordParser.RecordUpdateContext = RecordUpdateContext; \nZordParser.MethodPatternContext = MethodPatternContext; \nZordParser.DefaultPatternContext = DefaultPatternContext; \nZordParser.TypeParamContext = TypeParamContext; \nZordParser.TermParamContext = TermParamContext; \nZordParser.TermIdContext = TermIdContext; \nZordParser.WildcardContext = WildcardContext; \nZordParser.SelfAnnoContext = SelfAnnoContext; \nZordParser.SortContext = SortContext; \nZordParser.TypeNameDeclContext = TypeNameDeclContext; \nZordParser.TypeNameContext = TypeNameContext; \nZordParser.TermNameDeclContext = TermNameDeclContext; \nZordParser.TermNameContext = TermNameContext; \nZordParser.LabelDeclContext = LabelDeclContext; \nZordParser.LabelContext = LabelContext; \nZordParser.DocumentContext = DocumentContext; \nZordParser.DocElementContext = DocElementContext; \nZordParser.CommandContext = CommandContext; \nZordParser.InterpolationContext = InterpolationContext; \nZordParser.NewlineContext = NewlineContext; \nZordParser.PlaintextContext = PlaintextContext; \nZordParser.ArgContext = ArgContext; \nZordParser.RecordArgFieldContext = RecordArgFieldContext; \n\n\n//# sourceURL=webpack://bundle/./ZordParser/ZordParser.js?");

/***/ }),

/***/ "./ZordParser/ZordParserVisitor.js":
/*!*****************************************!*\
  !*** ./ZordParser/ZordParserVisitor.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ZordParserVisitor)\n/* harmony export */ });\n/* harmony import */ var antlr4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! antlr4 */ \"./node_modules/antlr4/src/antlr4/index.js\");\n// Generated from ZordParser.g4 by ANTLR 4.9.2\n// jshint ignore: start\n\n\n// This class defines a complete generic visitor for a parse tree produced by ZordParser.\n\nclass ZordParserVisitor extends antlr4__WEBPACK_IMPORTED_MODULE_0__.tree.ParseTreeVisitor {\n\n\t// Visit a parse tree produced by ZordParser#program.\n\tvisitProgram(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#open.\n\tvisitOpen(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#definition.\n\tvisitDefinition(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#typeDef.\n\tvisitTypeDef(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#termDef.\n\tvisitTermDef(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#type.\n\tvisitType(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#btype.\n\tvisitBtype(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#atype.\n\tvisitAtype(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#recordType.\n\tvisitRecordType(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#recordTypeElement.\n\tvisitRecordTypeElement(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#expression.\n\tvisitExpression(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#opexpr.\n\tvisitOpexpr(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#lexpr.\n\tvisitLexpr(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#lambda.\n\tvisitLambda(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#bigLambda.\n\tvisitBigLambda(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#let_.\n\tvisitLet_(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#letRec.\n\tvisitLetRec(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#open_.\n\tvisitOpen_(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#ifElse.\n\tvisitIfElse(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#trait.\n\tvisitTrait(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#new_.\n\tvisitNew_(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#toString_.\n\tvisitToString_(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#fold.\n\tvisitFold(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#unfold.\n\tvisitUnfold(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#fexpr.\n\tvisitFexpr(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#dotexpr.\n\tvisitDotexpr(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#aexpr.\n\tvisitAexpr(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#array.\n\tvisitArray(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#record.\n\tvisitRecord(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#recordField.\n\tvisitRecordField(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#recordUpdate.\n\tvisitRecordUpdate(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#methodPattern.\n\tvisitMethodPattern(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#defaultPattern.\n\tvisitDefaultPattern(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#typeParam.\n\tvisitTypeParam(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#termParam.\n\tvisitTermParam(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#termId.\n\tvisitTermId(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#wildcard.\n\tvisitWildcard(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#selfAnno.\n\tvisitSelfAnno(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#sort.\n\tvisitSort(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#typeNameDecl.\n\tvisitTypeNameDecl(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#typeName.\n\tvisitTypeName(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#termNameDecl.\n\tvisitTermNameDecl(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#termName.\n\tvisitTermName(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#labelDecl.\n\tvisitLabelDecl(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#label.\n\tvisitLabel(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#document.\n\tvisitDocument(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#docElement.\n\tvisitDocElement(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#command.\n\tvisitCommand(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#interpolation.\n\tvisitInterpolation(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#newline.\n\tvisitNewline(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#plaintext.\n\tvisitPlaintext(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#arg.\n\tvisitArg(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\t// Visit a parse tree produced by ZordParser#recordArgField.\n\tvisitRecordArgField(ctx) {\n\t  return this.visitChildren(ctx);\n\t}\n\n\n\n}\n\n//# sourceURL=webpack://bundle/./ZordParser/ZordParserVisitor.js?");

/***/ }),

/***/ "./ZordParser/index.js":
/*!*****************************!*\
  !*** ./ZordParser/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var antlr4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! antlr4 */ \"./node_modules/antlr4/src/antlr4/index.js\");\n/* harmony import */ var _ZordLexer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ZordLexer.js */ \"./ZordParser/ZordLexer.js\");\n/* harmony import */ var _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ZordParser.js */ \"./ZordParser/ZordParser.js\");\n/* harmony import */ var _ZordASTMaker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ZordASTMaker.js */ \"./ZordParser/ZordASTMaker.js\");\n\n\n\n\n\nfunction parse(input) {\n  const chars = new antlr4__WEBPACK_IMPORTED_MODULE_0__.InputStream(input);\n  const lexer = new _ZordLexer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](chars);\n  const tokens = new antlr4__WEBPACK_IMPORTED_MODULE_0__.CommonTokenStream(lexer);\n  const parser = new _ZordParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](tokens);\n  parser.buildParseTrees = true;\n  const tree = parser.program();\n  const ASTMaker = new _ZordASTMaker_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n  let ast = tree.accept(ASTMaker);\n  return ast;\n}\n\n\n//# sourceURL=webpack://bundle/./ZordParser/index.js?");

/***/ }),

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cp\": () => (/* binding */ cp),\n/* harmony export */   \"language\": () => (/* binding */ language),\n/* harmony export */   \"editorState\": () => (/* binding */ editorState),\n/* harmony export */   \"editorView\": () => (/* binding */ editorView),\n/* harmony export */   \"CP\": () => (/* reexport default from dynamic */ _src_CP_purs__WEBPACK_IMPORTED_MODULE_7___default.a),\n/* harmony export */   \"parse\": () => (/* reexport safe */ _ZordParser_index_js__WEBPACK_IMPORTED_MODULE_8__.parse)\n/* harmony export */ });\n/* harmony import */ var _codemirror_basic_setup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/basic-setup */ \"./node_modules/@codemirror/basic-setup/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_commands__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/commands */ \"./node_modules/@codemirror/commands/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/highlight */ \"./node_modules/@codemirror/highlight/dist/index.js\");\n/* harmony import */ var _grammar_cp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./grammar/cp */ \"./grammar/cp.js\");\n/* harmony import */ var _src_CP_purs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/CP.purs */ \"./src/CP.purs\");\n/* harmony import */ var _src_CP_purs__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_src_CP_purs__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _ZordParser_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ZordParser/index.js */ \"./ZordParser/index.js\");\n\n\n\n\n\n\n\n\nconst cp = new _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LanguageSupport(_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.LRLanguage.define({\n  parser: _grammar_cp__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n    props: [\n      _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.indentNodeProp.add({\n        RecordType: (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.continuedIndent)(),\n        Record: (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_1__.continuedIndent)(),\n      }),\n      _codemirror_language__WEBPACK_IMPORTED_MODULE_1__.foldNodeProp.add({\n        RecordType(tree) { return { from: tree.from + 1, to: tree.to - 1 } },\n        Record(tree)     { return { from: tree.from + 1, to: tree.to - 1 } },\n        Document(tree)   { return { from: tree.from + 1, to: tree.to - 1 } },\n      }),\n      (0,_codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.styleTags)({\n        'type let letrec trait implements inherits mu': _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.definitionKeyword,\n        'if then else new open in toString fold unfold forall Int Double Bool String Top Bot Trait': _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.keyword,\n        'override': _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.modifier,\n        'true false undefined': _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.atom,\n        Unit: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.unit,\n        TermName: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.variableName,\n        TermNameDecl: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.definition(_codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.variableName),\n        Label: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.propertyName,\n        LabelDecl: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.definition(_codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.propertyName),\n        LineComment: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.lineComment,\n        BlockComment: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.blockComment,\n        Number: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.number,\n        String: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.string,\n        Document: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.docString,\n        TypeOp: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.typeOperator,\n        ArithOp: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.arithmeticOperator,\n        LogicOp: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.logicOperator,\n        CompareOp: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.compareOperator,\n        MergeOp: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.operator,\n        TraitArrow: _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.definition(_codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.punctuation),\n        '( )': _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.paren,\n        '{ }': _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.brace,\n        '[ ]': _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.squareBracket,\n        '< >': _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.angleBracket,\n        '.': _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.derefOperator,\n        ';': _codemirror_highlight__WEBPACK_IMPORTED_MODULE_2__.tags.separator,\n      }),\n    ],\n  }),\n  languageData: {\n    closeBrackets: { brackets: ['{', '(', '[', '\"', '`'] },\n    commentTokens: { line: '--', block: { open: '{-', close: '-}' } },\n  },\n}));\n\nconst language = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Compartment;\n\nfunction editorState(doc, binding) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.create({\n    doc,\n    extensions: [\n      _codemirror_basic_setup__WEBPACK_IMPORTED_MODULE_4__.basicSetup,\n      _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.EditorView.lineWrapping,\n      _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.tabSize.of(2),\n      _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.keymap.of([_codemirror_commands__WEBPACK_IMPORTED_MODULE_6__.indentWithTab, { key: 'Mod-Enter', run: binding }]),\n      language.of([]),\n    ],\n  });\n}\n\nfunction editorView(state, parent) {\n  return new _codemirror_view__WEBPACK_IMPORTED_MODULE_5__.EditorView({ state, parent });\n}\n\n\n\n\n\n//# sourceURL=webpack://bundle/./app.js?");

/***/ }),

/***/ "./grammar/cp.js":
/*!***********************!*\
  !*** ./grammar/cp.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parser\": () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"./node_modules/@lezer/lr/dist/index.js\");\n// This file was generated by lezer-generator. You probably shouldn't edit it.\n\nconst spec_lowerid = {__proto__:null,open:8, type:14, forall:58, mu:64, true:86, false:88, undefined:90, override:96, let:122, in:124, letrec:128, if:134, then:136, else:138, trait:142, implements:144, inherits:146, new:150, toString:154, fold:156, unfold:158}\nconst spec_upperid = {__proto__:null,Int:24, Double:26, String:28, Bool:30, Top:32, Bot:34, Trait:66}\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n  version: 13,\n  states: \"!=lO]QPOOOOQO'#E['#E[O]QPOOO$vQQO'#DROOQO'#DS'#DSO'WQPO'#FYOOQO'#D['#D[O'_QPO'#F[OOQO'#D]'#D]OOQO'#Dc'#DcO%dQPO'#FbOOQO'#FX'#FXO)jQQO'#FWO+zQQO'#FVO,kQPO'#DeO,yQPO'#DhOOQO'#FU'#FUOOQO'#FT'#FTO%dQPO'#FTO.`QQO'#FSO.{QPO'#DQOOQO'#Eo'#EoOOQO'#E]'#E]O0vQPOOQOQPOOO2nQPO'#ElO,|QPO'#CbO2xQPO'#DjO2xQPO'#DmO%dQPO'#DpO2}QSO'#DtO%dQPO'#DxO3]QPO'#DzO4TQPO'#FUOOQO-E8Y-E8YO4YQPO'#FZO4bQPO'#FZO4iQPO,5;tO%dQPO'#DoO4nQPO'#CqO5SQPO'#D_O2xQPO'#F^OOQO'#Da'#DaO5eQPO'#F_O5mQPO'#D`O5rQPO'#F]O5zQPO'#F]O6SQPO'#F]O6XQPO'#F]O6pQPO,5;vO6uQPO,5;zO6zQPO'#F]O7YQPO,5;|O7_QPO'#EgO9ZQQO,5;rOOQO'#Eh'#EhO9zQPO'#EhO:lQQO,5;qOOQO'#DR'#DROOQO'#E}'#E}O,qQPO'#FPO<UQSO,5:PO<gQPO'#FQOOQO'#E|'#E|OOQO'#Ec'#EcOOQO'#Cd'#CdO,|QPO'#E{OOQO'#Ez'#EzOOQO'#Eb'#EbO<rQPO,5:SO=oQQO,5;oO%dQPO,5;oO%dQPO,5;oO%dQPO,5;oO%dQPO,5;oO%dQPO,5;oO%dQPO,5;oO%dQPO,5;oO%dQPO,5;oO>fQPO,5;nO.pQPO'#E{O>sQPO,59lO>}QPO,59lO%dQPO,59lO>fQPO,59lOOQO-E8Z-E8ZO?cQQO,5;WO?mQPO,5:ZO?rQPO,58|O?}QPO,5:UO@UQPO,5:XO@]QPO,5:[O%dQPO,5:`O@bQPO,5:`OAbQPO,5:`OAoQSO,5:`OAzQQO,5:dOOQO,5:f,5:fO9zQPO,5;pPBqQPO'#ElOOQO,5;P,5;POByQPO,5;uOOQO-E8c-E8cOOQO1G1`1G1`O%dQPO,59yOCRQPO,59yOCdQPO,5;xOOQO'#Cq'#CqOClQPO,5;yO5eQPO,59zOC}QPO,59zO5eQPO,5;wOOQO,5;Q,5;QODSQPO,5;wOD[QPO,5;wODdQPO,5;wOOQO-E8d-E8dO6zQPO,5;wOOQO1G1b1G1bODiQPO1G1fO5uQPO'#D`ODtQPO,5;wOOQO1G1h1G1hOOQO'#Dd'#DdOOQO,5;R,5;ROOQO-E8e-E8eOOQO'#Cn'#CnOD|QPO'#EtOOQO'#Co'#CoO>fQPO'#EvO>fQPO'#EwOOQO'#Es'#EsOOQO,5;S,5;SOOQO-E8f-E8fOEXQPO,5;kO%dQPO1G/kOOQO-E8a-E8aOE^QPO'#FROEcQPO'#FROEqQPO,5;lOEvQPO,5;gOOQO-E8`-E8`O%dQPO1G/nOOQO1G1Z1G1ZOG]QQO1G1ZOGdQQO1G1ZOH{QQO1G1ZOISQQO1G1ZOJkQQO1G1ZOJrQQO1G1ZOKhQQO1G1ZOLbQPO'#ErOOQO'#Eq'#EqOM|QPO1G1YO,yQPO'#EqO,|QPO'#EqONWQPO'#EqON]QPO1G/WO%dQPO1G/WO>fQPO1G/WONqQPO1G/WONvQPO1G/WOOQO1G0r1G0rO%dQPO1G/uO,|QPO'#EpOOQO'#E^'#E^O! RQPO1G.hOOQO'#E_'#E_O! UQPO1G.hO>fQPO1G.hO! ^QPO1G/pO! eQPO1G/pO%dQPO1G/pO! vQPO1G/sO! }QPO1G/sO>fQPO1G/sO%dQPO1G/vO!!`QQO1G/zO!#VQWO'#FWO!#^QWO'#FVO!$VQWO1G/zO!$^QWO'#ErO!%gQWO1G/zO%dQPO1G/zO@bQPO1G/zOAbQPO1G/zO3]QPO1G1[P!%uQPO,5;WP!%zQPO'#EeOOQO1G/e1G/eO%dQPO1G/eOOQO1G1d1G1dO>fQPO1G1dOOQO1G1e1G1eO!&PQPO1G1eOOQO1G/f1G/fO!&bQPO1G/fO!&gQPO1G1cO5eQPO1G1cP!&oQPO'#EfP!&wQPO'#EfP!&|QPO'#EfP6zQPO'#EfO!'RQPO1G1cO!'ZQPO7+'QOOQO1G0l1G0lO!'`QPO'#EuO!'eQPO'#EuO!'pQPO,5;`O!'uQPO,5;bO!(QQPO,5;cO>fQPO1G1VOOQO7+%V7+%VO%dQPO,5;mO!(]QPO,5;mOOQO-E8b-E8bO!(bQPO1G1WO>fQPO1G1ROOQO7+%Y7+%YO9zQPO'#ExOOQO'#Ea'#EaO!(gQPO,5;^O>fQPO,5;]O>fQPO,5;]O!)dQPO,5;]O!)oQPO,5;]OOQO,5;],5;]O%dQPO7+$rO>fQPO7+$rO!)tQPO7+$rO!)yQPO7+$rOOQO7+$r7+$rOOQO7+%a7+%aO!*UQPO,5;[OOQO-E8[-E8[O!*ZQPO7+$SO>fQPO7+$SOOQO-E8]-E8]O!*cQPO7+$SO!*nQPO7+%[O%dQPO7+%[O!+PQPO7+%[O!+UQPO7+%_O>fQPO7+%_O!+gQPO7+%_O!+rQPO7+%bO!+wQWO,5;rO!,OQWO,5;qO!-OQWO,5;oO%dQPO7+%fO!-VQWO,5:dO!-^QWO,5;^O@bQPO7+%fO!.gQQO7+%fO!/^QWO7+%fO!/eQWO7+%fOOQO7+&v7+&vOOQO7+%P7+%PO!/sQPO7+'OOOQO7+'P7+'PO5eQPO7+%QOOQO7+&W7+&WO!0OQPO7+&}P5eQPO,5;QP!0WQPO,5;QOOQO<<Jl<<JlO>fQPO,5;aO!0]QPO,5;aOOQO-E8^-E8^OOQO1G0z1G0zOOQO1G0|1G0|OOQO1G0}1G0}O!0bQPO7+&qO!0mQPO1G1XO%dQPO1G1XP!0xQPO'#EdOOQO7+&r7+&rO!0}QPO7+&mO!1YQSO'#EyO!1bQPO,5;dOOQO-E8_-E8_O!2UQPO1G0wOOQO1G0w1G0wO>fQPO1G0wO!2cQPO<<H^O!2hQPO<<H^OOQO<<H^<<H^O%dQPO<<H^OOQO1G0v1G0vO>fQPO<<GnO!2sQPO<<GnOOQO<<Gn<<GnO%dQPO<<HvO!3OQPO<<HvO%dQPO<<HvO>fQPO<<HyO!3TQPO<<HyO%dQPO<<HyO%dQPO<<H|O!4QQWO1G1ZO!4XQWO1G1ZO!5QQWO1G1ZO!5XQWO1G1ZO!6QQWO1G1ZO!6XQWO1G1ZO!6}QWO1G1ZO!7XQQO<<IQO!8OQWO1G/zO!8}QWO1G0wO!9_QWO<<IQO%dQPO<<IQO@bQPO<<IQOOQO<<Jj<<JjOOQO<<Hl<<HlP!9fQPO1G0lO!9kQPO1G0{O>fQPO1G0{P!9yQPO'#E`OOQO<<J]<<J]O!:OQQO'#ErO!;nQQO1G1YOOQO7+&U7+&UO!<nQPO7+&sP%dQPO,5;OOOQO<<JX<<JXO9zQPO,5;eOOQO1G1O1G1OO!=hQPO7+&cOOQOAN=xAN=xO%dQPOAN=xO!=uQPOAN=xO!=zQPOAN=YOOQOAN=YAN=YO!>VQPOAN>bO%dQPOAN>bOOQOAN>bAN>bO!>[QPOAN>eO%dQPOAN>eO!>gQPOAN>eOOQOAN>hAN>hO!>lQWO'#FSO!?gQWO7+%fO%dQPOAN>lO!@fQWO7+&cO!@vQQOAN>lO!AmQWOAN>lOOQO7+&Q7+&QO!AtQPO7+&gP>fQPO,5:zO!BSQQO,5;^P!CrQPO1G0jOOQO1G1P1G1PO!CwQPOG23dOOQOG23dG23dOOQOG22tG22tO%dQPOG23|OOQOG23|G23|O%dQPOG24PO!C|QPOG24PO%dQPOG24PO!DRQWO<<IQO!DYQQOG24WO%dQPOG24WP!EPQPO1G0fO!E[QQO1G0wOOQOLD)OLD)OOOQOLD)hLD)hO!FRQPOLD)kO%dQPOLD)kOOQOLD)kLD)kO!FWQWO1G1YO!GXQWOAN>lO!G`QQOLD)rO!HVQQO7+&cO%dQPO!$'MVOOQO!$'MV!$'MVO!H|QWOG24WOOQO!)9Bq!)9BqO!ITQWOLD)rO@bQPO'#FTO!I[QQO'#FSO@bQPO'#DxO3]QPO'#DzO@bQPO,5;oO@bQPO,5;oO@bQPO,5;oO@bQPO,5;oO@bQPO,5;oO@bQPO,5;oO@bQPO,5;oO@bQPO,5;oO!IlQPO,5;nOAbQPO,5;nO@bQPO,5:`O!IyQPO1G/kO!IyQPO1G/nO!IyQPO1G/uO@bQPO1G/zO3]QPO1G1[OAbQPO,5;]O!IlQPO,5;]OAbQPO,5;]O!IlQPO,5;]O@bQPO7+%fOAbQPO1G0wO!IlQPO1G0wO!IyQPO<<HvO!IyQPO<<H|O@bQPO<<IQO!IyQPOAN>bO!JyQWO'#FSO@bQPOAN>lO!IyQPOG23|O!IyQPOG23|O!IyQPOG24PO!IyQPOG24PO@bQPOG24WO!IyQPOLD)kO!IyQPOLD)kO!IyQPO!$'MVO!IyQPO!$'MVO!KTQSO'#DtO!KcQSO,5:PO!KtQPO,5:SO!LPQPO,5:ZO!LUQSO,5:`O9zQPO,5;pO!LaQWO1G/zO!LhQWO1G/zO!LvQPO,5;]O!MRQPO,5;]O!M^QPO,5;]O!McQPO,5;]O!MhQPO7+%[O!MmQPO7+%bO!MrQWO7+%fO!MyQWO7+%fO!NXQPO<<HvO!N^QWO<<IQO!NeQPOAN>bO!NjQPOAN>bO!NoQPOAN>eO!NtQPOAN>eO!NyQWOAN>lO# QQPOG24PO# VQPOG24PO# [QPOLD)kO# aQPOLD)kO!IyQPO1G/kO!IyQPO1G/nO!IyQPO1G/uO!IyQPO<<HvO!IyQPO<<H|O!IyQPOAN>bO,kQPO'#DeO,yQPO'#DhO# fQPO'#FUO%dQPO'#DoO@bQPO,5:`OAbQPO,5:`O,yQPO'#EqO,yQPO'#EqO,|QPO'#EqO,|QPO'#EqO%dQPO1G/pO%dQPO1G/vO@bQPO1G/zOAbQPO1G/zO%dQPO7+%[O@bQPO7+%fO%dQPO<<HvO%dQPO<<HvO%dQPO<<HyO%dQPO<<HyO@bQPO<<IQO%dQPOAN>eO%dQPOAN>eO%dQPOG24PO%dQPOG24PO# kQSO,5:PO# |QPO,5:SO#!XQPO,5:ZO#!^QPO7+%[O#!cQPO7+%bO#!hQPO<<HvO#!mQPO,5:UO#!tQPO,5:[O#!yQPO1G/pO##QQPO1G/pO##cQPO7+%[O##tQPO7+%[O#$VQPO7+%_O#$bQPO7+%_O#$mQPO<<HyO#$xQPO<<HyO#%TQPOAN>eO#%`QPOAN>eO,kQPO'#DeO,yQPO'#DhO%dQPO'#DoO%dQPO1G/pO%dQPO1G/vO%dQPO7+%[O2xQPO'#DjO%dQPO'#DpO>fQPO1G/sO>fQPO1G/sO>fQPO7+%_O>fQPO7+%_O>fQPO<<HyO>fQPO<<HyO!IyQPO'#FTO!IyQPO'#DxO!IyQPO,5;oO!IyQPO,5;oO!IyQPO,5;oO!IyQPO,5;oO!IyQPO,5;oO!IyQPO,5;oO!IyQPO,5;oO!IyQPO,5;oO!IyQPO,5:`O!IyQPO1G/zO!IyQPO7+%fO!IyQPO<<IQO!IyQPOAN>lO!IyQPOG24WO#%kQSO'#DtO#%yQSO,5:`O#&UQWO1G/zO#&]QWO1G/zO#&kQWO7+%fO#&rQWO7+%fO#'QQWO<<IQO#'XQWOAN>lO@bQPO,5:`OAbQPO,5:`O@bQPO1G/zOAbQPO1G/zO@bQPO7+%fO@bQPO<<IQO#'`QPO,5:UO#'gQPO,5:[O#'lQPO1G/pO#'sQPO1G/pO#(UQPO,5:XO#(]QPO,5:XO#(dQPO1G/sO#(kQPO1G/sO#(rQPO1G/sO#)TQPO1G/sO#)fQPO7+%_O#)wQPO7+%_O#*zQWO,5;oO#+XQWO,5:dO#,^QWO1G1ZO#,eQWO1G1ZO#-dQWO1G1ZO#-kQWO1G1ZO#.jQWO1G1ZO#.qQWO1G1ZO#/gQWO1G1ZO#/wQWO1G/zO#0UQWO7+%fO#0cQWO<<IQO#0pQWOAN>lO#0}QWOG24WO#1[QWOLD)rO2xQPO'#DjO%dQPO'#DpO2xQPO'#DmO2xQPO'#Dm\",\n  stateData: \"#1l~O#_OSPOSQOS~OSiOVjOdVOhTOjYOwZOxZOyZOzZO{ZO|ZO}ZO!Y^O!]_O!_kO!blO!emO!inO!moO!opO!pqO!qqO!rbO!sbO!tbO#aRO#bSO~OdvXfvXhvXjvXovXwvXxvXyvXzvX{vX|vX}vX!UvX!YvX!rvX!uvX!vvX!wvX!xvX!yvX!zvX!{vX!|vX!}vX#avX#bvX~OZuXduXfuXjuX#]vX#auX#buX#ruX~P#SOSvOdVOhTOjYOwZOxZOyZOzZO{ZO|ZO}ZO!Y^O!]_O!_kO!blO!emO!inO!moO!opO!pqO!qqO!rbO!sbO!tbO#aSO#bSO~Oi#}P~P%dOhyOj{O!Q!TO#awO#bwO#r!POg$PP~Oo!VOd#zXf#zXh#zXj#zXw#zXx#zXy#zXz#zX{#zX|#zX}#zX!U#zX!Y#zX!r#zX!u#zX!v#zX!w#zX!x#zX!y#zX!z#zX!{#zX!|#zX!}#zX#a#zX#b#zX~O#]#zXT#zXi#zXk#zX!`#zX!f#zXg#zX!g#zX$V#zX~P'vOdVOhTOjYOwZOxZOyZOzZO{ZO|ZO}ZO!U!YO#aSO#bSOf#yX!Y#yX!r#yX!u#yX!v#yX!w#yX!x#yX!y#yX!z#yX!{#yX!|#yX!}#yX~O#]#yXT#yXi#yXk#yX!`#yX!f#yXg#yX!g#yX$V#yX~P*ZOd!`Oj!^O#a![O#r!]O~Oj!dO#b!cO~O!r!kO!u!iO!v!jO!w!kO!x!lO!y!mO!z!nO!{!oO!|!oO!}!pO#]#vXT#vXi#vXk#vX!`#vX!f#vXg#vX!g#vX$V#vX~Of!qO!Y!qO~P-ROd!`Oj!rO#a![O#b!cO#r!]O~OZ!uOf!vO~P.jOSvOdVOhTOjYOwZOxZOyZOzZO{ZO|ZO}ZO!Y^O!]_O!_kO!blO!emO!inO!moO!opO!pqO!qqO!rbO!sbO!tbO#bSO~OVjO#aRO~P/VOSvOdVOhTOjYOwZOxZOyZOzZO{ZO|ZO}ZO!Y^O!]_O!_kO!blO!emO!inO!moO!opO!pqO!qqO!rbO!sbO!tbO~O#a!xO#b!xO~P1QO#a![O~OhyOl#OO!j#QO!k#PO~OdVOhTOjYOwZOxZOyZOzZO{ZO|ZO}ZO#aSO#bSO~O!U#UO~OT#WOi#}X~Oi#}X~P%dOi#ZO~OZeXdeXjeX#aeX#reX$TvX~OZ#[Od!`Oj!^O#a![O#r!]O~O#a#_O#b#_O~Oo#aO~Oo#cO!U#bO~OT#dOg$PX~Oo#cO~OhyOj{O!Q#iO#a#_O#b#_O#r#gOg$PX~Og#jO~O$T#kO~OhyOj{O#a#_O#b#_O~Ok#nO~O#a#oO#b#oO~Oo!VOd#zaf#zah#zaj#zaw#zax#zay#zaz#za{#za|#za}#za!U#za!Y#za!r#za!u#za!v#za!w#za!x#za!y#za!z#za!{#za!|#za!}#za#a#za#b#za~O#]#zaT#zai#zak#za!`#za!f#zag#za!g#za$V#za~P7gO[#wO]#wO^#wO_#wO`#wOa#wOd#sOh#uOj#vO#b#rO~O!U!YOf#ya!Y#ya!r#ya!u#ya!v#ya!w#ya!x#ya!y#ya!z#ya!{#ya!|#ya!}#ya#]#yaT#yai#yak#ya!`#ya!f#yag#ya!g#ya$V#ya~P3]Od!`Oj!^O!Z#{O#a![O#r!]O~O#a#_O#b#_O$V#uP~Oj!dOo$SO#b!cO~O!r!kO!u!iO!v!jO!w!kO!x!lO!y!mO!z!nO!{!oO!|!oO!}!pO~Of#wa!Y#wa#]#waT#wai#wak#wa!`#wa!f#wag#wa!g#wa$V#wa~P<}Om$`Op$aOq$bO~P9zOZ$dOf$eO~P.jOZ$dOd!`Of$eOj!^O#a![O#r!]O~OT$hO!`vX~P#SO!`$iO~OX$jOZ$oO#b!cO~OZ$rO~P.jOf$uO~P.jO!f$vO~OS*{O!Y*xO!]*yO!_+{O!b-bO!e+|O!i*VO!m)]O!o)^O!p*zO!q*zO!r)ZO!s)ZO!t)ZO~P3]Om+OOp+QOq$bO~P9zOl$}O!j%PO!k%OO~Of!la!Y!la#]!laT!lai!lak!la!`!la!f!lag!la!g!la$V!la~P<}O#a%RO#b%RO~OT#WOi#}a~OZ%UOd!`Oj!^O#a![O#r!]O~Of%WOi%VO~Od!`Oj!^Ok%XO#a![O#r!]O~Oj{O~Oo%^O!U#bO~OT#dOg$Pa~Oo%^O~O#a#_O#b#_Og#uP~OT%eOg$Pa~O#a#_O#b#_Og#iP~Of%kO~OZ%mO~O#a#_O#b#_O$V#uXg#uX~O$V%pO~On%qO~O!u!iOf#wi!Y#wi!r#wi!w#wi!x#wi!y#wi!z#wi!{#wi!|#wi!}#wi#]#wiT#wii#wik#wi!`#wi!f#wig#wi!g#wi$V#wi~O!v#wi~PE{O!v!jO~PE{O!r!kO!u!iO!v!jO!w!kOf#wi!Y#wi!y#wi!z#wi!{#wi!|#wi!}#wi#]#wiT#wii#wik#wi!`#wi!f#wig#wi!g#wi$V#wi~O!x#wi~PGkO!x!lO~PGkO!r!kO!u!iO!v!jO!w!kO!x!lO!y!mO!z!nOf#wi!Y#wi!|#wi!}#wi#]#wiT#wii#wik#wi!`#wi!f#wig#wi!g#wi$V#wi~O!{#wi~PIZO!{!oO~PIZO!r!kO!u!iO!v!jO!w!kO!x!lO!y!mO!z!nO!{!oO!|!oO~Of#wi!Y#wi!}#wi#]#wiT#wii#wik#wi!`#wi!f#wig#wi!g#wi$V#wi~PJyOX%sOr#fXs#fX#]#fXZ#fXT#fXi#fXk#fX!`#fX!f#fXg#fX!g#fX$V#fX~P9zO#]#viT#vii#vik#vi!`#vi!f#vig#vi!g#vi$V#vi~Or%vOs%wO~PM_OX%sO~OZ%{Od!`Of%|Oj!^O#a![O#r!]O~OT&PO~OZ%{Or%vOs%wO~OX$jOZ&UO#b!cO~OZ&YO~P.jOZ&YOd!`Oj!^O#a![O#r!]O~Of&]O~P.jOd!`Of&]Oj!^O#a![O#r!]O~Of!hi!Y!hi#]!hiT!hii!hik!hi!`!hi!f!hig!hi!g!hi$V!hi~P<}Ol#zX~P'vOl#yX~P*ZO!r)aO!u)_O!v)`O!w)aO!x)bO!y)cO!z)dO!{)eO!|)eO!})fO~Ol&cO~P!#eOX%sOl#fXr#fXs#fX!k#fX!r#fX!u#fX!v#fX!w#fX!x#fX!y#fX!z#fX!{#fX!|#fX!}#fXf#fX!Y#fX~P9zOl&cOr)oOs)qO!k&fO~OT$hO~OT#WO~Od!`Oj!^Ok&mO#a![O#r!]O~Oo&nO~OT&oOg$Pi~Oo&qO!U#bO~OT#dO~Oo&qO~OT%eOg$Pi~Og&sO~Of&tO~O#a#_O#b#_Og#iX~Og&wO~Oi&xOr%vOs%wO~Ok&yOr%vOs%wO~OZ&|O~Og'OO~OX%sOr#fas#fa#]#faZ#faT#fai#fak#fa!`#fa!f#fag#fa!g#fa$V#fa~P9zOj!dOo'VO#b!cO~Oo'VO~OT'YO~OZ'ZOr%vOs%wO~OY'[O~OZ']O#b!cO~OT'_Or%vOs%wO~OZ'`Od!`Oj!^O#a![O#r!]O~O!`'bO~Od!`Of'cOj!^O#a![O#r!]O~OZ'eOr%vOs%wO~O!g'fO~Ol#za~P7gO!U!YOl#ya!r#ya!u#ya!v#ya!w#ya!x#ya!y#ya!z#ya!{#ya!|#ya!}#yaf#ya!Y#ya~P3]Ol#wa~P!#eOl!la~P!#eOX%sOl#far#fas#fa!k#fa!r#fa!u#fa!v#fa!w#fa!x#fa!y#fa!z#fa!{#fa!|#fa!}#faf#fa!Y#fa~P9zOf!hq!Y!hq#]!hqT!hqi!hqk!hq!`!hq!f!hqg!hq!g!hq$V!hq~P<}Ol'rO~P!#eOl'rOr)oOs)qO!k'sO~Oi'tOr%vOs%wO~OT&oOg$Pq~OT%eO~Of'xO~Ok'zOr%vOs%wO~OT'}O$V#uig#ui~OZ(PO~Ok(QOr%vOs%wO~Ol(ROY#mX~OY(SO~O#]#eiT#eii#eik#ei!`#ei!f#eig#ei!g#ei$V#ei~Or%vOs%wOZ#ei~P!1gOT(UO~OZ(VOr%vOs%wO~OT(YOr%vOs%wO~O!`([O~OZ(_Or%vOs%wO~O!u)_Ol#wi!r#wi!w#wi!x#wi!y#wi!z#wi!{#wi!|#wi!}#wi~O!v#wi~P!3`O!v)`O~P!3`O!r)aO!u)_O!v)`O!w)aOl#wi!y#wi!z#wi!{#wi!|#wi!}#wi~O!x#wi~P!4`O!x)bO~P!4`O!r)aO!u)_O!v)`O!w)aO!x)bO!y)cO!z)dOl#wi!|#wi!}#wi~O!{#wi~P!5`O!{)eO~P!5`O!r)aO!u)_O!v)`O!w)aO!x)bO!y)cO!z)dO!{)eO!|)eO~Ol#wi!}#wi~P!6`Of!hy!Y!hy#]!hyT!hyi!hyk!hy!`!hy!f!hyg!hy!g!hy$V!hy~P<}Ol!hi~P!#eO!r#ei!u#ei!v#ei!w#ei!x#ei!y#ei!z#ei!{#ei!|#ei!}#eif#ei!Y#ei~Or)oOs)qOl#ei!k#ei~P!8VOl(dO~P!#eOT&oO~OT(hOr%vOs%wOg#ii~Of(jO~OX%sOf#fXr#fXs#fX!Y#fX!r#fX!u#fX!v#fX!w#fX!x#fX!y#fX!z#fX!{#fX!|#fX!}#fX#]#fXT#fXi#fXk#fX!`#fX!f#fXg#fX!g#fX$V#fX~P9zOr)pOs)rOf#vi!Y#vi!r#vi!u#vi!v#vi!w#vi!x#vi!y#vi!z#vi!{#vi!|#vi!}#vi~PM_OT'}O$V#uqg#uq~O#]#eqT#eqi#eqk#eq!`#eq!f#eqg#eq!g#eq$V#eq~Or%vOs%wOZ#eq~P!<yOT(oO~OT(pOr%vOs%wO~O!`(qO~OZ(sOr%vOs%wO~O!`(uO~Of)hO!Y)hO!r,XO!u,VO!v,WO!w,XO!x,YO!y,ZO!z,[O!{,]O!|,]O!},^Ol#vX~Ol!hq~P!#eO!r#eq!u#eq!v#eq!w#eq!x#eq!y#eq!z#eq!{#eq!|#eq!}#eqf#eq!Y#eq~Or)oOs)qOl#eq!k#eq~P!?nOf!h!R!Y!h!R#]!h!RT!h!Ri!h!Rk!h!R!`!h!R!f!h!Rg!h!R!g!h!R$V!h!R~P<}Ol(xO~P!#eOT(hOr%vOs%wOg#iq~OX%sOf#far#fas#fa!Y#fa!r#fa!u#fa!v#fa!w#fa!x#fa!y#fa!z#fa!{#fa!|#fa!}#fa#]#faT#fai#fak#fa!`#fa!f#fag#fa!g#fa$V#fa~P9zOT'}O~OT({O~O!`)OO~Ol!hy~P!#eOf!h!Z!Y!h!Z#]!h!ZT!h!Zi!h!Zk!h!Z!`!h!Z!f!h!Zg!h!Z!g!h!Z$V!h!Z~P<}OT(hOr%vOs%wO~Or)pOs)rO#]#eiT#eii#eik#ei!`#ei!f#eig#ei!g#ei$V#ei~P!8VO!`)UO~Or)oOs)qOl#vi!r#vi!u#vi!v#vi!w#vi!x#vi!y#vi!z#vi!{#vi!|#vi!}#vif#vi!Y#vi~Ol!h!R~P!#eOf!h!c!Y!h!c#]!h!cT!h!ci!h!ck!h!c!`!h!c!f!h!cg!h!c!g!h!c$V!h!c~P<}Or)pOs)rO#]#eqT#eqi#eqk#eq!`#eq!f#eqg#eq!g#eq$V#eq~P!?nOl!h!Z~P!#eOl!h!c~P!#eOf)gO!Y)gOf#vX!Y#vX~P-ROm+POp+ROq$bO~P9zOS+wO!Y+uO!]+vO!_-`O!b-cO!e-aO!i,eO!m,UO!o)^O!p*zO!q*zO!r,TO!s,TO!t,TO~P3]Of#vX!Y#vX~P!>lOhyOl)iO!j*}O!k*|O~Od!`Oj!^O!Z)jO#a![O#r!]O~Oj!dOo)kO#b!cO~O!`)lO~Ol)mO!j+VO!k+UO~Ol)sO~P!#eOl)sOr)oOs)qO!k+XO~Oj!dOo)tO#b!cO~Oj!dOo)uO#b!cO~Oo)tO~Oo)uO~O!`)vO~O!g)wO~Ol)xO~P!#eOl)xOr)oOs)qO!k+^O~O!`)yO~Ol){O~P!#eO!`)|O~O!`)}O~O!`*OO~O!`*PO~Ol*QO~P!#eO!`*RO~O!`*SO~O!`*TO~O!`*UO~O!U*[O~Od!`Oj!^O!Z*rO#a![O#r!]O~Oj!dOo*sO#b!cO~O!`*tO~O!`*uO~O!g*vO~O!`*wO~OZ+SO~P.jO!f+TO~OZ+WO~P.jOZ+WOd!`Oj!^O#a![O#r!]O~OZ+YOd!`Oj!^O#a![O#r!]O~OZ+ZOd!`Oj!^O#a![O#r!]O~OZ+[Or%vOs%wO~OZ+]Or%vOs%wO~OZ+_Or%vOs%wO~OZ+`Or%vOs%wO~OZ+aOr%vOs%wO~OZ+bOr%vOs%wO~OhyOl,_O!j,nO!k,mO~Ol,`O!j,pO!k,oO~Ol,aO~P!#eOl,aOr)oOs)qO!k,qO~Ol,bO~P!#eOl,bOr)oOs)qO!k,rO~Ol,cO~P!#eOl,dO~P!#eOZ+xO~P.jO!f+yO~OZ+zO~P.jOZ+zOd!`Oj!^O#a![O#r!]O~Of+}O~P.jOf,OO~P.jOf,PO~P.jOf,QO~P.jOd!`Of,POj!^O#a![O#r!]O~Od!`Of,QOj!^O#a![O#r!]O~Od!`Of,ROj!^O#a![O#r!]O~Od!`Of,SOj!^O#a![O#r!]O~O!r,XO!u,VO!v,WO!w,XO!x,YO!y,ZO!z,[O!{,]O!|,]O!},^O~Of#wal#wa!Y#wa~P#*YOf!lal!la!Y!la~P#*YO!u,VOf#wil#wi!Y#wi!r#wi!w#wi!x#wi!y#wi!z#wi!{#wi!|#wi!}#wi~O!v#wi~P#+fO!v,WO~P#+fO!r,XO!u,VO!v,WO!w,XOf#wil#wi!Y#wi!y#wi!z#wi!{#wi!|#wi!}#wi~O!x#wi~P#,lO!x,YO~P#,lO!r,XO!u,VO!v,WO!w,XO!x,YO!y,ZO!z,[Of#wil#wi!Y#wi!|#wi!}#wi~O!{#wi~P#-rO!{,]O~P#-rO!r,XO!u,VO!v,WO!w,XO!x,YO!y,ZO!z,[O!{,]O!|,]O~Of#wil#wi!Y#wi!}#wi~P#.xOf!hil!hi!Y!hi~P#*YOf!hql!hq!Y!hq~P#*YOf!hyl!hy!Y!hy~P#*YOf!h!Rl!h!R!Y!h!R~P#*YOf!h!Zl!h!Z!Y!h!Z~P#*YOf!h!cl!h!c!Y!h!c~P#*YO!r!y~\",\n  goto: \"!1}$VPPPPPP$WP$]PPPPPPPPP%d%dP&lPPPPPPPPPPPPPP$W'Y(pPPPPPPP+y+yP/P/o0OP+y0d0gPP0gP0gPP0gP0g0gPPP0gPPP0gP0gPPPPPPPPPPPPPPP3e3k3r3x4S4Y4h5p7b7i7o7u8PPPP8ZPP8_8d8h;T<Q=j>r%d%d>u?Q?T?q@_AXPBVBVCPCVF}Lk0g! i!$w!(P!+V!+Y!.`!.c!.m!.wP+yVeOQg!U!e_d!g!s!{!|$`$p$s%x*X*_*`*y+O+P+d+i+k+v,s,u,w,x,y,zQ!zjS$Q!d!rW$m!z$l$n&TQ%y$aQ&R$jQ*a+QR*b+R#]#w!Y!q!v#Q#U#u#v$]$e$o$u${%P%W%k%q%s%u%v%w%|&U&]&e&t'V']'c'x'{(R(j(k)g)h)o)p)q)r)t)u*[*}+V+},O,P,Q,R,S,n,pdxV!Q!T#a#c#i%^%b&n&qQ#`{S#}!`#kQ%f#sQ%n$OR&u%gUdOQg!r!]^dx!^!_!r!s!t!{!|#]#`$c$p$q$s$t%Y&X&[*W*x+c+i+k+l+m+n+u,s,u,v,w,x,y,z,{,|,}-OQ!{kQ!|lQ#^yQ+i+{Q,s-`Q,w-bR,x-c'WZOQTY]bgimoptv!Z!i!j!k!l!m!n!o!p!u#O#P#[#{$S$d$i$r$v$y$}%O%Q%U%m%{&Y&a&c&f&|'Z'`'b'e'f'r's(P(V([(_(d(q(s(u(x)O)U)Z)])^)_)`)a)b)c)d)e)f)i)j)k)l)m)n)s)v)w)x)y){)|)}*O*P*Q*R*S*T*U*r*s*t*u*v*w*{*|+S+T+U+W+X+Y+Z+[+]+^+_+`+a+b+w+x+y+z+|,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,d,m,o,q,r-aR!SV'XZOQTY]bgimoptv!Z!i!j!k!l!m!n!o!p!u#O#P#[#{$S$d$i$r$v$y$}%O%Q%U%m%{&Y&a&c&f&|'Z'`'b'e'f'r's(P(V([(_(d(q(s(u(x)O)U)Z)])^)_)`)a)b)c)d)e)f)i)j)k)l)m)n)s)v)w)x)y){)|)}*O*P*Q*R*S*T*U*r*s*t*u*v*w*{*|+S+T+U+W+X+Y+Z+[+]+^+_+`+a+b+w+x+y+z+|,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,d,m,o,q,r-aQ!OVQ#f!QQ#m!TQ%Z#aQ%]#cQ%c#iQ&p%^Q&r%bQ'u&nR'v&qQ!OVQ#f!QQ#m!TQ%c#iR&r%bQ}VQ#RnQ#e!QU#l!T#i%bQ*Z*VR,f,eR#p!V&w`OQTYbgimotv!i!j!k!l!m!n!o!p!u#O#P#[#{$S$d$i$r$v$}%O%U%m%{&Y&c&f&|'Z'`'b'e'f'r's(P(V([(_(d(q(s(u(x)O)U)Z)])_)`)a)b)c)d)e)f)i)j)k)l)m)s)v)w)x)y){)|)}*O*P*Q*R*S*T*U*r*s*t*u*v*w*{*|+S+T+U+W+X+Y+Z+[+]+^+_+`+a+b+w+x+y+z+|,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,d,m,o,q,r-aQQORrQSgOQR!wgQ$l!zR&S$lQ$n!zQ&T$lT&V$n&TQ%g#sR&v%gQ%u$]Q&e${U'S%u&e(kR(k'{Q!g_Q!sdj$R!g!s$p$s%x*X*_*`+d+k,u,y,zQ$p!{Q$s!|Q%x$`Q*X*yQ*_+OQ*`+PQ+d+vQ+k+iQ,u,sQ,y,wR,z,xQ!_^Q!tdQ#]xv#|!_!t#]$c$q$t%Y&X&[*W+c+l+m+n,v,{,|,}-OQ$c!sQ$q!{Q$t!|Q%Y#`Q&X$pQ&[$sQ*W*xQ+c+uQ+l+iQ+m+kQ+n,uQ,v,sQ,{,wQ,|,xQ,},yR-O,zS$O!`#kR%o$OQtTR#YtQ!QVR#h!QQ!W[S#q!W&`R&`$xQ!Z]S#y!Z&aR&a$yTPOQVfOQgT$k!z$lQ$_!qQ$g!vQ$|#QQ%i#uQ%j#vQ&O$eQ&W$oQ&^$uQ&i%PQ&l%WQ&z%kQ'P%qQ'T%vU'U%w)q)rQ'X%|Q'^&UQ'd&]Q'p)oQ'w&tQ'|)gQ(T'VQ(X']Q(^'cQ(e)tQ(i'xQ(y(jQ(z)pQ)Q)hQ)T)uQ*^*}Q*f+VQ+o+}Q+p,OQ+q,PQ+r,QQ+s,RQ+t,SQ,h,nR,j,p!u$^!q!v#Q#u#v$e$o$u%P%W%k%q%v%w%|&U&]&t'V']'c'x(j)g)h)o)p)q)r)t)u*}+V+},O,P,Q,R,S,n,pQ#x!Y!W$]!q!v#u#v$e$o$u%W%k%q%v%w%|&U&]&t'V']'c'x(j+},O,P,Q,R,Sd${#Q%P)h)o)q)t*}+V,n,pQ%Q#U[%t$]${%u&e'{(kQ'Q%sW'{)g)p)r)uQ(m(RR)n*[#]#t!Y!q!v#Q#U#u#v$]$e$o$u${%P%W%k%q%s%u%v%w%|&U&]&e&t'V']'c'x'{(R(j(k)g)h)o)p)q)r)t)u*[*}+V+},O,P,Q,R,S,n,pR%h#s[%t$]${%u&e'{(kR%z$bR'R%s!V!f_d!g!s!{!|$`$p$s%x*X*_*`*y+O+P+d+i+k+v,s,u,w,x,y,z!V!e_d!g!s!{!|$`$p$s%x*X*_*`*y+O+P+d+i+k+v,s,u,w,x,y,z!o!b^dx!_!s!t!{!|#]#`$c$p$q$s$t%Y&X&[*W*x+c+i+k+l+m+n+u,s,u,v,w,x,y,z,{,|,}-O!n!a^dx!_!s!t!{!|#]#`$c$p$q$s$t%Y&X&[*W*x+c+i+k+l+m+n+u,s,u,v,w,x,y,z,{,|,}-OT#z!^!r!o!a^dx!_!s!t!{!|#]#`$c$p$q$s$t%Y&X&[*W*x+c+i+k+l+m+n+u,s,u,v,w,x,y,z,{,|,}-OQ$P!`R%d#kUhOQgQsTQ!UYS!yivQ!}mQ#XtQ$f!uQ%T#[U%l#{)j*rU%r$S)k*sQ%}$dU&Q$i)l*tQ&Z$rQ&_$vQ&k%UQ&{%mQ'W%{Q'a&YQ(O&|Q(W'ZQ(Z'`U(]'b)v*uQ(`'eU(a'f)w*vQ(l(PQ(n(VU(r([)y*wQ(t(_U(|(q)|)}Q(}(sU)P(u*O*PU)V)O*R*SU)X)U*T*UQ*Y*{Q*c+SQ*d+TQ*g+WQ*i+YQ*j+ZQ*k+[Q*l+]Q*n+_Q*o+`Q*p+aQ*q+bQ+e+wQ+f+xQ+g+yQ+h+zQ+j+|R,t-a!zcOQTYgimtv!u#[$d$r$v%U%m%{&Y&|'Z'`'e(P(V(_(s*{+S+T+W+Y+Z+[+]+_+`+a+b+w+x+y+z+|-aQ!hbQ#SoU$T!i)_,VQ$U!jQ$V!kQ$W!lQ$X!mQ$Y!nQ$Z!oQ$[!pQ$w#OQ$z#PQ&b)ZQ&d)]Q&g$}Q&h%OQ'g)`Q'h)aQ'i)bQ'j)cQ'k)dQ'l)eQ'm)fQ'n&cQ'o)iQ'q&fd(b)j)k)l)v)w)y)|*O*R*TQ(c)mQ(f'rQ(g'sQ(v)sQ(w(dQ)R)xQ)S(xQ)W){Q)Y*Qd)[#{$S$i'b'f([(q(u)O)Ud)z)}*P*S*U*r*s*t*u*v*wQ*]*|Q*e+UQ*h+XQ*m+^Q,g,mQ,i,oQ,k,qQ,l,rQ-P,TQ-Q,UQ-R,WQ-S,XQ-T,YQ-U,ZQ-V,[Q-W,]Q-X,^Q-Y,_Q-Z,`Q-[,aQ-],bQ-^,cR-_,d&waOQTYbgimotv!i!j!k!l!m!n!o!p!u#O#P#[#{$S$d$i$r$v$}%O%U%m%{&Y&c&f&|'Z'`'b'e'f'r's(P(V([(_(d(q(s(u(x)O)U)Z)])_)`)a)b)c)d)e)f)i)j)k)l)m)s)v)w)x)y){)|)}*O*P*Q*R*S*T*U*r*s*t*u*v*w*{*|+S+T+U+W+X+Y+Z+[+]+^+_+`+a+b+w+x+y+z+|,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,d,m,o,q,r-a$Q]OQTYbgimotv!i!j!k!l!m!n!o!p!u#O#[#{$S$d$i$r$v$}%U%m%{&Y&c&|'Z'`'b'e'f'r(P(V([(_(d(q(s(u(x)O)U*{+S+T+W+Y+Z+[+]+_+`+a+b+w+x+y+z+|-aW!X]!Z$y&aS#Tp)^#t$y#P%O&f's)Z)])_)`)a)b)c)d)e)f)i)j)k)l)m)s)v)w)x)y){)|)}*O*P*Q*R*S*T*U*r*s*t*u*v*w*|+U+X+^,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,d,m,o,q,rT&j%Q)n$Y[OQTY]bgimoptv!Z!i!j!k!l!m!n!o!p!u#O#[#{$S$d$i$r$v$}%Q%U%m%{&Y&c&|'Z'`'b'e'f'r(P(V([(_(d(q(s(u(x)O)U*{+S+T+W+Y+Z+[+]+_+`+a+b+w+x+y+z+|-a#}$x#P$y%O&a&f's)Z)])^)_)`)a)b)c)d)e)f)i)j)k)l)m)n)s)v)w)x)y){)|)}*O*P*Q*R*S*T*U*r*s*t*u*v*w*|+U+X+^,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,d,m,o,q,r'XUOQTY]bgimoptv!Z!i!j!k!l!m!n!o!p!u#O#P#[#{$S$d$i$r$v$y$}%O%Q%U%m%{&Y&a&c&f&|'Z'`'b'e'f'r's(P(V([(_(d(q(s(u(x)O)U)Z)])^)_)`)a)b)c)d)e)f)i)j)k)l)m)n)s)v)w)x)y){)|)}*O*P*Q*R*S*T*U*r*s*t*u*v*w*{*|+S+T+U+W+X+Y+Z+[+]+^+_+`+a+b+w+x+y+z+|,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,d,m,o,q,r-aRuT'XWOQTY]bgimoptv!Z!i!j!k!l!m!n!o!p!u#O#P#[#{$S$d$i$r$v$y$}%O%Q%U%m%{&Y&a&c&f&|'Z'`'b'e'f'r's(P(V([(_(d(q(s(u(x)O)U)Z)])^)_)`)a)b)c)d)e)f)i)j)k)l)m)n)s)v)w)x)y){)|)}*O*P*Q*R*S*T*U*r*s*t*u*v*w*{*|+S+T+U+W+X+Y+Z+[+]+^+_+`+a+b+w+x+y+z+|,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,d,m,o,q,r-aR!RVazVn!Q!T#i%b*V,eY|V!Q!T#i%bR%[#b'XXOQTY]bgimoptv!Z!i!j!k!l!m!n!o!p!u#O#P#[#{$S$d$i$r$v$y$}%O%Q%U%m%{&Y&a&c&f&|'Z'`'b'e'f'r's(P(V([(_(d(q(s(u(x)O)U)Z)])^)_)`)a)b)c)d)e)f)i)j)k)l)m)n)s)v)w)x)y){)|)}*O*P*Q*R*S*T*U*r*s*t*u*v*w*{*|+S+T+U+W+X+Y+Z+[+]+^+_+`+a+b+w+x+y+z+|,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,d,m,o,q,r-a\",\n  nodeNames: \" LineComment BlockComment Program open ; TypeDef type TypeNameDecl < > = Int Double String Bool Top Bot TypeName RecordType { LabelDecl : } [ ] ( ) TraitArrow forall * . mu Trait TypeOp TypeOp TermDef TermNameDecl TermName Number String Document Unit true false undefined Array Record override RecordField MethodPattern SelfAnno @ RecordUpdate Label Lambda \\\\ -> BigLambda /\\\\ Let let in LetRec letrec Open IfElse if then else Trait trait implements inherits New new ToString toString fold unfold ArithOp LogicOp LengthOp IndexOp ArithOp ArithOp AppendOp CompareOp LogicOp LogicOp ForwardOp MergeOp\",\n  maxTerm: 145,\n  skippedNodes: [0,1,2],\n  repeatNodeCount: 13,\n  tokenData: \"/o~RzX^#upq#uqr$jrs%Pst%suv%xvw%}xy&[yz&iz{&n{|&u|}'S}!O'X!O!P'v!P!Q(T!Q!R(b!R![*P![!]+[!]!^+a!^!_+f!_!`+p!`!a,Q!b!c,[!c!},a!}#O,u#O#P,z#P#Q-P#Q#R-U#R#S-Z#S#T-`#T#o-q#o#p.V#p#q/]#q#r/j#y#z#u$f$g#u#BY#BZ#u$IS$I_#u$I|$JO#u$JT$JU#u$KV$KW#u&FU&FV#u~#zY#_~X^#upq#u#y#z#u$f$g#u#BY#BZ#u$IS$I_#u$I|$JO#u$JT$JU#u$KV$KW#u&FU&FV#uZ$oQ!sPqr$u!_!`$zY$zO!uYY%PO!yY~%UUx~OY%PZr%Prs%hs#O%P#O#P%m#P~%P~%mOx~~%pPO~%P~%xO!t~Y%}O!vY~&SPs~vw&V~&[O!z~~&aPj~yz&d~&iOz~~&nOk~Z&uOnP!vY~&zP!w~{|&}~'SO!x~~'XO!}~~'^Q!rZ}!O'd!`!a'o~'iQP~OY'dZ~'d_'vO!ZSrZ~'{Po~!O!P(O~(TO$V~Z(YP!vY#O#P(]P(bO!]P~(gWw~!O!P)P!Q![*P!g!h)e!q!r*b!z!{*p#X#Y)e#c#d*b#l#m*p~)SP!Q![)V~)[Rw~!Q![)V!g!h)e#X#Y)e~)hR{|)q}!O)q!Q![)w~)tP!Q![)w~)|Pw~!Q![)w~*USw~!O!P)P!Q![*P!g!h)e#X#Y)e~*eP!Q!Y*h~*mPw~!Q!Y*h~*sR!Q![*|!c!i*|#T#Z*|~+RRw~!Q![*|!c!i*|#T#Z*|~+aOf~~+fOT~~+mPX~!yY!_!`$z_+uQZR!_!`$z!`!a+{[,QOl[_,XPYT!yY!_!`$z~,aO!U~~,fT#b~wx,a!Q![,a!c!},a#R#S,a#T#o,a~,zOh~~-PO!Y~~-UOi~~-ZO!|~~-`O#r~~-cRO#S-`#S#T-l#T~-`~-qOy~~-vT#a~wx-q!Q![-q!c!}-q#R#S-q#T#o-q~.[Pd~}!O._~.bRO}._}!O.k!O~._~.nTO}._}!O.k!O#q._#q#r.}#r~._~/SRQ~O}._}!O.k!O~._Z/bP$TP#p#q/eY/jO!{Y~/oOg~\",\n  tokenizers: [0, 1, 2, 3],\n  topRules: {\"Program\":[0,3]},\n  specialized: [{term: 109, get: value => spec_lowerid[value] || -1},{term: 110, get: value => spec_upperid[value] || -1}],\n  tokenPrec: 4993\n})\n\n\n//# sourceURL=webpack://bundle/./grammar/cp.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/BufferedTokenStream.js":
/*!***************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/BufferedTokenStream.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst Lexer = __webpack_require__(/*! ./Lexer */ \"./node_modules/antlr4/src/antlr4/Lexer.js\");\nconst {Interval} = __webpack_require__(/*! ./IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\");\n\n// this is just to keep meaningful parameter types to Parser\nclass TokenStream {}\n\n/**\n * This implementation of {@link TokenStream} loads tokens from a\n * {@link TokenSource} on-demand, and places the tokens in a buffer to provide\n * access to any previous token by index.\n *\n * <p>\n * This token stream ignores the value of {@link Token//getChannel}. If your\n * parser requires the token stream filter tokens to only those on a particular\n * channel, such as {@link Token//DEFAULT_CHANNEL} or\n * {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a\n * {@link CommonTokenStream}.</p>\n */\nclass BufferedTokenStream extends TokenStream {\n\tconstructor(tokenSource) {\n\n\t\tsuper();\n\t\t// The {@link TokenSource} from which tokens for this stream are fetched.\n\t\tthis.tokenSource = tokenSource;\n\t\t/**\n\t\t * A collection of all tokens fetched from the token source. The list is\n\t\t * considered a complete view of the input once {@link //fetchedEOF} is set\n\t\t * to {@code true}.\n\t\t */\n\t\tthis.tokens = [];\n\n\t\t/**\n\t\t * The index into {@link //tokens} of the current token (next token to\n\t\t * {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should\n\t\t * be\n\t\t * {@link //LT LT(1)}.\n\t\t *\n\t\t * <p>This field is set to -1 when the stream is first constructed or when\n\t\t * {@link //setTokenSource} is called, indicating that the first token has\n\t\t * not yet been fetched from the token source. For additional information,\n\t\t * see the documentation of {@link IntStream} for a description of\n\t\t * Initializing Methods.</p>\n\t\t */\n\t\tthis.index = -1;\n\n\t\t/**\n\t\t * Indicates whether the {@link Token//EOF} token has been fetched from\n\t\t * {@link //tokenSource} and added to {@link //tokens}. This field improves\n\t\t * performance for the following cases:\n\t\t *\n\t\t * <ul>\n\t\t * <li>{@link //consume}: The lookahead check in {@link //consume} to\n\t\t * prevent\n\t\t * consuming the EOF symbol is optimized by checking the values of\n\t\t * {@link //fetchedEOF} and {@link //p} instead of calling {@link\n\t\t * //LA}.</li>\n\t\t * <li>{@link //fetch}: The check to prevent adding multiple EOF symbols\n\t\t * into\n\t\t * {@link //tokens} is trivial with this field.</li>\n\t\t * <ul>\n\t\t */\n\t\tthis.fetchedEOF = false;\n\t}\n\n\tmark() {\n\t\treturn 0;\n\t}\n\n\trelease(marker) {\n\t\t// no resources to release\n\t}\n\n\treset() {\n\t\tthis.seek(0);\n\t}\n\n\tseek(index) {\n\t\tthis.lazyInit();\n\t\tthis.index = this.adjustSeekIndex(index);\n\t}\n\n\tget(index) {\n\t\tthis.lazyInit();\n\t\treturn this.tokens[index];\n\t}\n\n\tconsume() {\n\t\tlet skipEofCheck = false;\n\t\tif (this.index >= 0) {\n\t\t\tif (this.fetchedEOF) {\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n\t\t\t\t// fetched token except the last.\n\t\t\t\tskipEofCheck = this.index < this.tokens.length - 1;\n\t\t\t} else {\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n\t\t\t\tskipEofCheck = this.index < this.tokens.length;\n\t\t\t}\n\t\t} else {\n\t\t\t// not yet initialized\n\t\t\tskipEofCheck = false;\n\t\t}\n\t\tif (!skipEofCheck && this.LA(1) === Token.EOF) {\n\t\t\tthrow \"cannot consume EOF\";\n\t\t}\n\t\tif (this.sync(this.index + 1)) {\n\t\t\tthis.index = this.adjustSeekIndex(this.index + 1);\n\t\t}\n\t}\n\n\t/**\n\t * Make sure index {@code i} in tokens has a token.\n\t *\n\t * @return {Boolean} {@code true} if a token is located at index {@code i}, otherwise\n\t * {@code false}.\n\t * @see //get(int i)\n\t */\n\tsync(i) {\n\t\tconst n = i - this.tokens.length + 1; // how many more elements we need?\n\t\tif (n > 0) {\n\t\t\tconst fetched = this.fetch(n);\n\t\t\treturn fetched >= n;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Add {@code n} elements to buffer.\n\t *\n\t * @return {Number} The actual number of elements added to the buffer.\n\t */\n\tfetch(n) {\n\t\tif (this.fetchedEOF) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst t = this.tokenSource.nextToken();\n\t\t\tt.tokenIndex = this.tokens.length;\n\t\t\tthis.tokens.push(t);\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tthis.fetchedEOF = true;\n\t\t\t\treturn i + 1;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n\n// Get all tokens from start..stop inclusively///\n\tgetTokens(start, stop, types) {\n\t\tif (types === undefined) {\n\t\t\ttypes = null;\n\t\t}\n\t\tif (start < 0 || stop < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.lazyInit();\n\t\tconst subset = [];\n\t\tif (stop >= this.tokens.length) {\n\t\t\tstop = this.tokens.length - 1;\n\t\t}\n\t\tfor (let i = start; i < stop; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (types === null || types.contains(t.type)) {\n\t\t\t\tsubset.push(t);\n\t\t\t}\n\t\t}\n\t\treturn subset;\n\t}\n\n\tLA(i) {\n\t\treturn this.LT(i).type;\n\t}\n\n\tLB(k) {\n\t\tif (this.index - k < 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.tokens[this.index - k];\n\t}\n\n\tLT(k) {\n\t\tthis.lazyInit();\n\t\tif (k === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (k < 0) {\n\t\t\treturn this.LB(-k);\n\t\t}\n\t\tconst i = this.index + k - 1;\n\t\tthis.sync(i);\n\t\tif (i >= this.tokens.length) { // return EOF token\n\t\t\t// EOF must be last token\n\t\t\treturn this.tokens[this.tokens.length - 1];\n\t\t}\n\t\treturn this.tokens[i];\n\t}\n\n\t/**\n\t * Allowed derived classes to modify the behavior of operations which change\n\t * the current stream position by adjusting the target token index of a seek\n\t * operation. The default implementation simply returns {@code i}. If an\n\t * exception is thrown in this method, the current stream index should not be\n\t * changed.\n\t *\n\t * <p>For example, {@link CommonTokenStream} overrides this method to ensure\n\t * that\n\t * the seek target is always an on-channel token.</p>\n\t *\n\t * @param {Number} i The target token index.\n\t * @return {Number} The adjusted target token index.\n\t */\n\tadjustSeekIndex(i) {\n\t\treturn i;\n\t}\n\n\tlazyInit() {\n\t\tif (this.index === -1) {\n\t\t\tthis.setup();\n\t\t}\n\t}\n\n\tsetup() {\n\t\tthis.sync(0);\n\t\tthis.index = this.adjustSeekIndex(0);\n\t}\n\n// Reset this token stream by setting its token source.///\n\tsetTokenSource(tokenSource) {\n\t\tthis.tokenSource = tokenSource;\n\t\tthis.tokens = [];\n\t\tthis.index = -1;\n\t\tthis.fetchedEOF = false;\n\t}\n\n\t/**\n\t * Given a starting index, return the index of the next token on channel.\n\t * Return i if tokens[i] is on channel. Return -1 if there are no tokens\n\t * on channel between i and EOF.\n\t */\n\tnextTokenOnChannel(i, channel) {\n\t\tthis.sync(i);\n\t\tif (i >= this.tokens.length) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet token = this.tokens[i];\n\t\twhile (token.channel !== this.channel) {\n\t\t\tif (token.type === Token.EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\ti += 1;\n\t\t\tthis.sync(i);\n\t\t\ttoken = this.tokens[i];\n\t\t}\n\t\treturn i;\n\t}\n\n\t/**\n\t * Given a starting index, return the index of the previous token on channel.\n\t * Return i if tokens[i] is on channel. Return -1 if there are no tokens\n\t * on channel between i and 0.\n\t */\n\tpreviousTokenOnChannel(i, channel) {\n\t\twhile (i >= 0 && this.tokens[i].channel !== channel) {\n\t\t\ti -= 1;\n\t\t}\n\t\treturn i;\n\t}\n\n\t/**\n\t * Collect all tokens on specified channel to the right of\n\t * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or\n\t * EOF. If channel is -1, find any non default channel token.\n\t */\n\tgetHiddenTokensToRight(tokenIndex,\n\t\t\tchannel) {\n\t\tif (channel === undefined) {\n\t\t\tchannel = -1;\n\t\t}\n\t\tthis.lazyInit();\n\t\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n\t\t\tthrow \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n\t\t}\n\t\tconst nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n\t\tconst from_ = tokenIndex + 1;\n\t\t// if none onchannel to right, nextOnChannel=-1 so set to = last token\n\t\tconst to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;\n\t\treturn this.filterForChannel(from_, to, channel);\n\t}\n\n\t/**\n\t * Collect all tokens on specified channel to the left of\n\t * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.\n\t * If channel is -1, find any non default channel token.\n\t */\n\tgetHiddenTokensToLeft(tokenIndex,\n\t\t\tchannel) {\n\t\tif (channel === undefined) {\n\t\t\tchannel = -1;\n\t\t}\n\t\tthis.lazyInit();\n\t\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\n\t\t\tthrow \"\" + tokenIndex + \" not in 0..\" + this.tokens.length - 1;\n\t\t}\n\t\tconst prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);\n\t\tif (prevOnChannel === tokenIndex - 1) {\n\t\t\treturn null;\n\t\t}\n\t\t// if none on channel to left, prevOnChannel=-1 then from=0\n\t\tconst from_ = prevOnChannel + 1;\n\t\tconst to = tokenIndex - 1;\n\t\treturn this.filterForChannel(from_, to, channel);\n\t}\n\n\tfilterForChannel(left, right, channel) {\n\t\tconst hidden = [];\n\t\tfor (let i = left; i < right + 1; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (channel === -1) {\n\t\t\t\tif (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {\n\t\t\t\t\thidden.push(t);\n\t\t\t\t}\n\t\t\t} else if (t.channel === channel) {\n\t\t\t\thidden.push(t);\n\t\t\t}\n\t\t}\n\t\tif (hidden.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn hidden;\n\t}\n\n\tgetSourceName() {\n\t\treturn this.tokenSource.getSourceName();\n\t}\n\n// Get the text of all tokens in this buffer.///\n\tgetText(interval) {\n\t\tthis.lazyInit();\n\t\tthis.fill();\n\t\tif (interval === undefined || interval === null) {\n\t\t\tinterval = new Interval(0, this.tokens.length - 1);\n\t\t}\n\t\tlet start = interval.start;\n\t\tif (start instanceof Token) {\n\t\t\tstart = start.tokenIndex;\n\t\t}\n\t\tlet stop = interval.stop;\n\t\tif (stop instanceof Token) {\n\t\t\tstop = stop.tokenIndex;\n\t\t}\n\t\tif (start === null || stop === null || start < 0 || stop < 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (stop >= this.tokens.length) {\n\t\t\tstop = this.tokens.length - 1;\n\t\t}\n\t\tlet s = \"\";\n\t\tfor (let i = start; i < stop + 1; i++) {\n\t\t\tconst t = this.tokens[i];\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = s + t.text;\n\t\t}\n\t\treturn s;\n\t}\n\n// Get all tokens from lexer until EOF///\n\tfill() {\n\t\tthis.lazyInit();\n\t\twhile (this.fetch(1000) === 1000) {\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\n\nmodule.exports = BufferedTokenStream;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/BufferedTokenStream.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/CharStreams.js":
/*!*******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/CharStreams.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst InputStream = __webpack_require__(/*! ./InputStream */ \"./node_modules/antlr4/src/antlr4/InputStream.js\");\nconst fs = __webpack_require__(/*! fs */ \"?1ac6\");\n\n/**\n * Utility functions to create InputStreams from various sources.\n *\n * All returned InputStreams support the full range of Unicode\n * up to U+10FFFF (the default behavior of InputStream only supports\n * code points up to U+FFFF).\n */\nconst CharStreams = {\n  // Creates an InputStream from a string.\n  fromString: function(str) {\n    return new InputStream(str, true);\n  },\n\n  /**\n   * Asynchronously creates an InputStream from a blob given the\n   * encoding of the bytes in that blob (defaults to 'utf8' if\n   * encoding is null).\n   *\n   * Invokes onLoad(result) on success, onError(error) on\n   * failure.\n   */\n  fromBlob: function(blob, encoding, onLoad, onError) {\n    const reader = new window.FileReader();\n    reader.onload = function(e) {\n      const is = new InputStream(e.target.result, true);\n      onLoad(is);\n    };\n    reader.onerror = onError;\n    reader.readAsText(blob, encoding);\n  },\n\n  /**\n   * Creates an InputStream from a Buffer given the\n   * encoding of the bytes in that buffer (defaults to 'utf8' if\n   * encoding is null).\n   */\n  fromBuffer: function(buffer, encoding) {\n    return new InputStream(buffer.toString(encoding), true);\n  },\n\n  /** Asynchronously creates an InputStream from a file on disk given\n   * the encoding of the bytes in that file (defaults to 'utf8' if\n   * encoding is null).\n   *\n   * Invokes callback(error, result) on completion.\n   */\n  fromPath: function(path, encoding, callback) {\n    fs.readFile(path, encoding, function(err, data) {\n      let is = null;\n      if (data !== null) {\n        is = new InputStream(data, true);\n      }\n      callback(err, is);\n    });\n  },\n\n  /**\n   * Synchronously creates an InputStream given a path to a file\n   * on disk and the encoding of the bytes in that file (defaults to\n   * 'utf8' if encoding is null).\n   */\n  fromPathSync: function(path, encoding) {\n    const data = fs.readFileSync(path, encoding);\n    return new InputStream(data, true);\n  }\n};\n\nmodule.exports = CharStreams;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/CharStreams.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/CommonTokenFactory.js":
/*!**************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/CommonTokenFactory.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst CommonToken = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\").CommonToken;\n\nclass TokenFactory {}\n\n/**\n * This default implementation of {@link TokenFactory} creates\n * {@link CommonToken} objects.\n */\nclass CommonTokenFactory extends TokenFactory {\n    constructor(copyText) {\n        super();\n        /**\n         * Indicates whether {@link CommonToken//setText} should be called after\n         * constructing tokens to explicitly set the text. This is useful for cases\n         * where the input stream might not be able to provide arbitrary substrings\n         * of text from the input after the lexer creates a token (e.g. the\n         * implementation of {@link CharStream//getText} in\n         * {@link UnbufferedCharStream} throws an\n         * {@link UnsupportedOperationException}). Explicitly setting the token text\n         * allows {@link Token//getText} to be called at any time regardless of the\n         * input stream implementation.\n         *\n         * <p>\n         * The default value is {@code false} to avoid the performance and memory\n         * overhead of copying text for every token unless explicitly requested.</p>\n         */\n        this.copyText = copyText===undefined ? false : copyText;\n    }\n\n    create(source, type, text, channel, start, stop, line, column) {\n        const t = new CommonToken(source, type, channel, start, stop);\n        t.line = line;\n        t.column = column;\n        if (text !==null) {\n            t.text = text;\n        } else if (this.copyText && source[1] !==null) {\n            t.text = source[1].getText(start,stop);\n        }\n        return t;\n    }\n\n    createThin(type, text) {\n        const t = new CommonToken(null, type);\n        t.text = text;\n        return t;\n    }\n}\n\n/**\n * The default {@link CommonTokenFactory} instance.\n *\n * <p>\n * This token factory does not explicitly copy token text when constructing\n * tokens.</p>\n */\nCommonTokenFactory.DEFAULT = new CommonTokenFactory();\n\nmodule.exports = CommonTokenFactory;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/CommonTokenFactory.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/CommonTokenStream.js":
/*!*************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/CommonTokenStream.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n\nconst Token = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\").Token;\nconst BufferedTokenStream = __webpack_require__(/*! ./BufferedTokenStream */ \"./node_modules/antlr4/src/antlr4/BufferedTokenStream.js\");\n\n/**\n * This class extends {@link BufferedTokenStream} with functionality to filter\n * token streams to tokens on a particular channel (tokens where\n * {@link Token//getChannel} returns a particular value).\n *\n * <p>\n * This token stream provides access to all tokens by index or when calling\n * methods like {@link //getText}. The channel filtering is only used for code\n * accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and\n * {@link //LB}.</p>\n *\n * <p>\n * By default, tokens are placed on the default channel\n * ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the\n * {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to\n * call {@link Lexer//setChannel}.\n * </p>\n *\n * <p>\n * Note: lexer rules which use the {@code ->skip} lexer command or call\n * {@link Lexer//skip} do not produce tokens at all, so input text matched by\n * such a rule will not be available as part of the token stream, regardless of\n * channel.</p>\n */\nclass CommonTokenStream extends BufferedTokenStream {\n    constructor(lexer, channel) {\n        super(lexer);\n        this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;\n    }\n\n    adjustSeekIndex(i) {\n        return this.nextTokenOnChannel(i, this.channel);\n    }\n\n    LB(k) {\n        if (k===0 || this.index-k<0) {\n            return null;\n        }\n        let i = this.index;\n        let n = 1;\n        // find k good tokens looking backwards\n        while (n <= k) {\n            // skip off-channel tokens\n            i = this.previousTokenOnChannel(i - 1, this.channel);\n            n += 1;\n        }\n        if (i < 0) {\n            return null;\n        }\n        return this.tokens[i];\n    }\n\n    LT(k) {\n        this.lazyInit();\n        if (k === 0) {\n            return null;\n        }\n        if (k < 0) {\n            return this.LB(-k);\n        }\n        let i = this.index;\n        let n = 1; // we know tokens[pos] is a good one\n        // find k good tokens\n        while (n < k) {\n            // skip off-channel tokens, but make sure to not look past EOF\n            if (this.sync(i + 1)) {\n                i = this.nextTokenOnChannel(i + 1, this.channel);\n            }\n            n += 1;\n        }\n        return this.tokens[i];\n    }\n\n    // Count EOF just once.\n    getNumberOfOnChannelTokens() {\n        let n = 0;\n        this.fill();\n        for (let i =0; i< this.tokens.length;i++) {\n            const t = this.tokens[i];\n            if( t.channel===this.channel) {\n                n += 1;\n            }\n            if( t.type===Token.EOF) {\n                break;\n            }\n        }\n        return n;\n    }\n}\n\nmodule.exports = CommonTokenStream;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/CommonTokenStream.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/FileStream.js":
/*!******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/FileStream.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst InputStream = __webpack_require__(/*! ./InputStream */ \"./node_modules/antlr4/src/antlr4/InputStream.js\");\nconst fs = __webpack_require__(/*! fs */ \"?1ac6\");\n\n/**\n * This is an InputStream that is loaded from a file all at once\n * when you construct the object.\n */\nclass FileStream extends InputStream {\n\tconstructor(fileName, decodeToUnicodeCodePoints) {\n\t\tconst data = fs.readFileSync(fileName, \"utf8\");\n\t\tsuper(data, decodeToUnicodeCodePoints);\n\t\tthis.fileName = fileName;\n\t}\n}\n\nmodule.exports = FileStream\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/FileStream.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/InputStream.js":
/*!*******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/InputStream.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\n__webpack_require__(/*! ./polyfills/codepointat */ \"./node_modules/antlr4/src/antlr4/polyfills/codepointat.js\");\n__webpack_require__(/*! ./polyfills/fromcodepoint */ \"./node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js\");\n\n/**\n * If decodeToUnicodeCodePoints is true, the input is treated\n * as a series of Unicode code points.\n *\n * Otherwise, the input is treated as a series of 16-bit UTF-16 code\n * units.\n */\nclass InputStream {\n\tconstructor(data, decodeToUnicodeCodePoints) {\n\t\tthis.name = \"<empty>\";\n\t\tthis.strdata = data;\n\t\tthis.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;\n\t\t// _loadString - Vacuum all input from a string and then treat it like a buffer.\n\t\tthis._index = 0;\n\t\tthis.data = [];\n\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\tfor (let i = 0; i < this.strdata.length; ) {\n\t\t\t\tconst codePoint = this.strdata.codePointAt(i);\n\t\t\t\tthis.data.push(codePoint);\n\t\t\t\ti += codePoint <= 0xFFFF ? 1 : 2;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < this.strdata.length; i++) {\n\t\t\t\tconst codeUnit = this.strdata.charCodeAt(i);\n\t\t\t\tthis.data.push(codeUnit);\n\t\t\t}\n\t\t}\n\t\tthis._size = this.data.length;\n\t}\n\n\t/**\n\t * Reset the stream so that it's in the same state it was\n\t * when the object was created *except* the data array is not\n\t * touched.\n\t */\n\treset() {\n\t\tthis._index = 0;\n\t}\n\n\tconsume() {\n\t\tif (this._index >= this._size) {\n\t\t\t// assert this.LA(1) == Token.EOF\n\t\t\tthrow (\"cannot consume EOF\");\n\t\t}\n\t\tthis._index += 1;\n\t}\n\n\tLA(offset) {\n\t\tif (offset === 0) {\n\t\t\treturn 0; // undefined\n\t\t}\n\t\tif (offset < 0) {\n\t\t\toffset += 1; // e.g., translate LA(-1) to use offset=0\n\t\t}\n\t\tconst pos = this._index + offset - 1;\n\t\tif (pos < 0 || pos >= this._size) { // invalid\n\t\t\treturn Token.EOF;\n\t\t}\n\t\treturn this.data[pos];\n\t}\n\n\tLT(offset) {\n\t\treturn this.LA(offset);\n\t}\n\n// mark/release do nothing; we have entire buffer\n\tmark() {\n\t\treturn -1;\n\t}\n\n\trelease(marker) {\n\t}\n\n\t/**\n\t * consume() ahead until p==_index; can't just set p=_index as we must\n\t * update line and column. If we seek backwards, just set p\n\t */\n\tseek(_index) {\n\t\tif (_index <= this._index) {\n\t\t\tthis._index = _index; // just jump; don't update stream state (line,\n\t\t\t\t\t\t\t\t\t// ...)\n\t\t\treturn;\n\t\t}\n\t\t// seek forward\n\t\tthis._index = Math.min(_index, this._size);\n\t}\n\n\tgetText(start, stop) {\n\t\tif (stop >= this._size) {\n\t\t\tstop = this._size - 1;\n\t\t}\n\t\tif (start >= this._size) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tif (this.decodeToUnicodeCodePoints) {\n\t\t\t\tlet result = \"\";\n\t\t\t\tfor (let i = start; i <= stop; i++) {\n\t\t\t\t\tresult += String.fromCodePoint(this.data[i]);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this.strdata.slice(start, stop + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this.strdata;\n\t}\n\n\tget index(){\n\t\treturn this._index;\n\t}\n\n\tget size(){\n\t\treturn this._size;\n\t}\n}\n\n\nmodule.exports = InputStream;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/InputStream.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/IntervalSet.js":
/*!*******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/IntervalSet.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\n\n/* stop is not included! */\nclass Interval {\n\tconstructor(start, stop) {\n\t\tthis.start = start;\n\t\tthis.stop = stop;\n\t}\n\n\tcontains(item) {\n\t\treturn item >= this.start && item < this.stop;\n\t}\n\n\ttoString() {\n\t\tif(this.start===this.stop-1) {\n\t\t\treturn this.start.toString();\n\t\t} else {\n\t\t\treturn this.start.toString() + \"..\" + (this.stop-1).toString();\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.stop - this.start;\n\t}\n}\n\n\nclass IntervalSet {\n\tconstructor() {\n\t\tthis.intervals = null;\n\t\tthis.readOnly = false;\n\t}\n\n\tfirst(v) {\n\t\tif (this.intervals === null || this.intervals.length===0) {\n\t\t\treturn Token.INVALID_TYPE;\n\t\t} else {\n\t\t\treturn this.intervals[0].start;\n\t\t}\n\t}\n\n\taddOne(v) {\n\t\tthis.addInterval(new Interval(v, v + 1));\n\t}\n\n\taddRange(l, h) {\n\t\tthis.addInterval(new Interval(l, h + 1));\n\t}\n\n\taddInterval(toAdd) {\n\t\tif (this.intervals === null) {\n\t\t\tthis.intervals = [];\n\t\t\tthis.intervals.push(toAdd);\n\t\t} else {\n\t\t\t// find insert pos\n\t\t\tfor (let pos = 0; pos < this.intervals.length; pos++) {\n\t\t\t\tconst existing = this.intervals[pos];\n\t\t\t\t// distinct range -> insert\n\t\t\t\tif (toAdd.stop < existing.start) {\n\t\t\t\t\tthis.intervals.splice(pos, 0, toAdd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// contiguous range -> adjust\n\t\t\t\telse if (toAdd.stop === existing.start) {\n\t\t\t\t\tthis.intervals[pos].start = toAdd.start;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// overlapping range -> adjust and reduce\n\t\t\t\telse if (toAdd.start <= existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));\n\t\t\t\t\tthis.reduce(pos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// greater than any existing\n\t\t\tthis.intervals.push(toAdd);\n\t\t}\n\t}\n\n\taddSet(other) {\n\t\tif (other.intervals !== null) {\n\t\t\tother.intervals.forEach( toAdd => this.addInterval(toAdd), this);\n\t\t}\n\t\treturn this;\n\t}\n\n\treduce(pos) {\n\t\t// only need to reduce if pos is not the last\n\t\tif (pos < this.intervals.length - 1) {\n\t\t\tconst current = this.intervals[pos];\n\t\t\tconst next = this.intervals[pos + 1];\n\t\t\t// if next contained in current\n\t\t\tif (current.stop >= next.stop) {\n\t\t\t\tthis.intervals.splice(pos + 1, 1);\n\t\t\t\tthis.reduce(pos);\n\t\t\t} else if (current.stop >= next.start) {\n\t\t\t\tthis.intervals[pos] = new Interval(current.start, next.stop);\n\t\t\t\tthis.intervals.splice(pos + 1, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcomplement(start, stop) {\n\t\tconst result = new IntervalSet();\n\t\tresult.addInterval(new Interval(start,stop+1));\n\t\tif(this.intervals !== null)\n\t\t\tthis.intervals.forEach(toRemove => result.removeRange(toRemove));\n\t\treturn result;\n\t}\n\n\tcontains(item) {\n\t\tif (this.intervals === null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tfor (let k = 0; k < this.intervals.length; k++) {\n\t\t\t\tif(this.intervals[k].contains(item)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tremoveRange(toRemove) {\n\t\tif(toRemove.start===toRemove.stop-1) {\n\t\t\tthis.removeOne(toRemove.start);\n\t\t} else if (this.intervals !== null) {\n\t\t\tlet pos = 0;\n\t\t\tfor(let n=0; n<this.intervals.length; n++) {\n\t\t\t\tconst existing = this.intervals[pos];\n\t\t\t\t// intervals are ordered\n\t\t\t\tif (toRemove.stop<=existing.start) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for including range, split it\n\t\t\t\telse if(toRemove.start>existing.start && toRemove.stop<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(existing.start, toRemove.start);\n\t\t\t\t\tconst x = new Interval(toRemove.stop, existing.stop);\n\t\t\t\t\tthis.intervals.splice(pos, 0, x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for included range, remove it\n\t\t\t\telse if(toRemove.start<=existing.start && toRemove.stop>=existing.stop) {\n\t\t\t\t\tthis.intervals.splice(pos, 1);\n\t\t\t\t\tpos = pos - 1; // need another pass\n\t\t\t\t}\n\t\t\t\t// check for lower boundary\n\t\t\t\telse if(toRemove.start<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(existing.start, toRemove.start);\n\t\t\t\t}\n\t\t\t\t// check for upper boundary\n\t\t\t\telse if(toRemove.stop<existing.stop) {\n\t\t\t\t\tthis.intervals[pos] = new Interval(toRemove.stop, existing.stop);\n\t\t\t\t}\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveOne(value) {\n\t\tif (this.intervals !== null) {\n\t\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\t\tconst existing = this.intervals[i];\n\t\t\t\t// intervals are ordered\n\t\t\t\tif (value < existing.start) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for single value range\n\t\t\t\telse if (value === existing.start && value === existing.stop - 1) {\n\t\t\t\t\tthis.intervals.splice(i, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for lower boundary\n\t\t\t\telse if (value === existing.start) {\n\t\t\t\t\tthis.intervals[i] = new Interval(existing.start + 1, existing.stop);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// check for upper boundary\n\t\t\t\telse if (value === existing.stop - 1) {\n\t\t\t\t\tthis.intervals[i] = new Interval(existing.start, existing.stop - 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// split existing range\n\t\t\t\telse if (value < existing.stop - 1) {\n\t\t\t\t\tconst replace = new Interval(existing.start, value);\n\t\t\t\t\texisting.start = value + 1;\n\t\t\t\t\tthis.intervals.splice(i, 0, replace);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString(literalNames, symbolicNames, elemsAreChar) {\n\t\tliteralNames = literalNames || null;\n\t\tsymbolicNames = symbolicNames || null;\n\t\telemsAreChar = elemsAreChar || false;\n\t\tif (this.intervals === null) {\n\t\t\treturn \"{}\";\n\t\t} else if(literalNames!==null || symbolicNames!==null) {\n\t\t\treturn this.toTokenString(literalNames, symbolicNames);\n\t\t} else if(elemsAreChar) {\n\t\t\treturn this.toCharString();\n\t\t} else {\n\t\t\treturn this.toIndexString();\n\t\t}\n\t}\n\n\ttoCharString() {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tif(existing.stop===existing.start+1) {\n\t\t\t\tif ( existing.start===Token.EOF ) {\n\t\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t\t} else {\n\t\t\t\t\tnames.push(\"'\" + String.fromCharCode(existing.start) + \"'\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames.push(\"'\" + String.fromCharCode(existing.start) + \"'..'\" + String.fromCharCode(existing.stop-1) + \"'\");\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\ttoIndexString() {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tif(existing.stop===existing.start+1) {\n\t\t\t\tif ( existing.start===Token.EOF ) {\n\t\t\t\t\tnames.push(\"<EOF>\");\n\t\t\t\t} else {\n\t\t\t\t\tnames.push(existing.start.toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnames.push(existing.start.toString() + \"..\" + (existing.stop-1).toString());\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\ttoTokenString(literalNames, symbolicNames) {\n\t\tconst names = [];\n\t\tfor (let i = 0; i < this.intervals.length; i++) {\n\t\t\tconst existing = this.intervals[i];\n\t\t\tfor (let j = existing.start; j < existing.stop; j++) {\n\t\t\t\tnames.push(this.elementName(literalNames, symbolicNames, j));\n\t\t\t}\n\t\t}\n\t\tif (names.length > 1) {\n\t\t\treturn \"{\" + names.join(\", \") + \"}\";\n\t\t} else {\n\t\t\treturn names[0];\n\t\t}\n\t}\n\n\telementName(literalNames, symbolicNames, token) {\n\t\tif (token === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (token === Token.EPSILON) {\n\t\t\treturn \"<EPSILON>\";\n\t\t} else {\n\t\t\treturn literalNames[token] || symbolicNames[token];\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.intervals.map( interval => interval.length ).reduce((acc, val) => acc + val);\n\t}\n}\n\nmodule.exports = {\n\tInterval,\n\tIntervalSet\n};\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/IntervalSet.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/LL1Analyzer.js":
/*!*******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/LL1Analyzer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Set, BitSet} = __webpack_require__(/*! ./Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\nconst {Token} = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst {ATNConfig} = __webpack_require__(/*! ./atn/ATNConfig */ \"./node_modules/antlr4/src/antlr4/atn/ATNConfig.js\");\nconst {IntervalSet} = __webpack_require__(/*! ./IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\");\nconst {RuleStopState} = __webpack_require__(/*! ./atn/ATNState */ \"./node_modules/antlr4/src/antlr4/atn/ATNState.js\");\nconst {RuleTransition, NotSetTransition, WildcardTransition, AbstractPredicateTransition} = __webpack_require__(/*! ./atn/Transition */ \"./node_modules/antlr4/src/antlr4/atn/Transition.js\");\nconst {predictionContextFromRuleContext, PredictionContext, SingletonPredictionContext} = __webpack_require__(/*! ./PredictionContext */ \"./node_modules/antlr4/src/antlr4/PredictionContext.js\");\n\nclass LL1Analyzer {\n    constructor(atn) {\n        this.atn = atn;\n    }\n\n    /**\n     * Calculates the SLL(1) expected lookahead set for each outgoing transition\n     * of an {@link ATNState}. The returned array has one element for each\n     * outgoing transition in {@code s}. If the closure from transition\n     * <em>i</em> leads to a semantic predicate before matching a symbol, the\n     * element at index <em>i</em> of the result will be {@code null}.\n     *\n     * @param s the ATN state\n     * @return the expected symbols for each outgoing transition of {@code s}.\n     */\n    getDecisionLookahead(s) {\n        if (s === null) {\n            return null;\n        }\n        const count = s.transitions.length;\n        const look = [];\n        for(let alt=0; alt< count; alt++) {\n            look[alt] = new IntervalSet();\n            const lookBusy = new Set();\n            const seeThruPreds = false; // fail to get lookahead upon pred\n            this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,\n                  look[alt], lookBusy, new BitSet(), seeThruPreds, false);\n            // Wipe out lookahead for this alternative if we found nothing\n            // or we had a predicate when we !seeThruPreds\n            if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {\n                look[alt] = null;\n            }\n        }\n        return look;\n    }\n\n    /**\n     * Compute set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     *\n     * <p>If {@code ctx} is {@code null} and the end of the rule containing\n     * {@code s} is reached, {@link Token//EPSILON} is added to the result set.\n     * If {@code ctx} is not {@code null} and the end of the outermost rule is\n     * reached, {@link Token//EOF} is added to the result set.</p>\n     *\n     * @param s the ATN state\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx the complete parser context, or {@code null} if the context\n     * should be ignored\n     *\n     * @return The set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     */\n    LOOK(s, stopState, ctx) {\n        const r = new IntervalSet();\n        const seeThruPreds = true; // ignore preds; get all lookahead\n        ctx = ctx || null;\n        const lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;\n        this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);\n        return r;\n    }\n\n    /**\n     * Compute set of tokens that can follow {@code s} in the ATN in the\n     * specified {@code ctx}.\n     *\n     * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the\n     * rule containing {@code s} is reached, {@link Token//EPSILON} is added to\n     * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is\n     * {@code true} and {@code stopState} or the end of the outermost rule is\n     * reached, {@link Token//EOF} is added to the result set.</p>\n     *\n     * @param s the ATN state.\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx The outer context, or {@code null} if the outer context should\n     * not be used.\n     * @param look The result lookahead set.\n     * @param lookBusy A set used for preventing epsilon closures in the ATN\n     * from causing a stack overflow. Outside code should pass\n     * {@code new Set<ATNConfig>} for this argument.\n     * @param calledRuleStack A set used for preventing left recursion in the\n     * ATN from causing a stack overflow. Outside code should pass\n     * {@code new BitSet()} for this argument.\n     * @param seeThruPreds {@code true} to true semantic predicates as\n     * implicitly {@code true} and \"see through them\", otherwise {@code false}\n     * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the\n     * result if one is encountered.\n     * @param addEOF Add {@link Token//EOF} to the result if the end of the\n     * outermost context is reached. This parameter has no effect if {@code ctx}\n     * is {@code null}.\n     */\n    _LOOK(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n        const c = new ATNConfig({state:s, alt:0, context: ctx}, null);\n        if (lookBusy.contains(c)) {\n            return;\n        }\n        lookBusy.add(c);\n        if (s === stopState) {\n            if (ctx ===null) {\n                look.addOne(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne(Token.EOF);\n                return;\n            }\n        }\n        if (s instanceof RuleStopState ) {\n            if (ctx ===null) {\n                look.addOne(Token.EPSILON);\n                return;\n            } else if (ctx.isEmpty() && addEOF) {\n                look.addOne(Token.EOF);\n                return;\n            }\n            if (ctx !== PredictionContext.EMPTY) {\n                const removed = calledRuleStack.contains(s.ruleIndex);\n                try {\n                    calledRuleStack.remove(s.ruleIndex);\n                    // run thru all possible stack tops in ctx\n                    for (let i = 0; i < ctx.length; i++) {\n                        const returnState = this.atn.states[ctx.getReturnState(i)];\n                        this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                    }\n                }finally {\n                    if (removed) {\n                        calledRuleStack.add(s.ruleIndex);\n                    }\n                }\n                return;\n            }\n        }\n        for(let j=0; j<s.transitions.length; j++) {\n            const t = s.transitions[j];\n            if (t.constructor === RuleTransition) {\n                if (calledRuleStack.contains(t.target.ruleIndex)) {\n                    continue;\n                }\n                const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);\n                try {\n                    calledRuleStack.add(t.target.ruleIndex);\n                    this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } finally {\n                    calledRuleStack.remove(t.target.ruleIndex);\n                }\n            } else if (t instanceof AbstractPredicateTransition ) {\n                if (seeThruPreds) {\n                    this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                } else {\n                    look.addOne(LL1Analyzer.HIT_PRED);\n                }\n            } else if( t.isEpsilon) {\n                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            } else if (t.constructor === WildcardTransition) {\n                look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );\n            } else {\n                let set = t.label;\n                if (set !== null) {\n                    if (t instanceof NotSetTransition) {\n                        set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                    }\n                    look.addSet(set);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Special value added to the lookahead sets to indicate that we hit\n * a predicate during analysis if {@code seeThruPreds==false}.\n */\nLL1Analyzer.HIT_PRED = Token.INVALID_TYPE;\n\nmodule.exports = LL1Analyzer;\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/LL1Analyzer.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/Lexer.js":
/*!*************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/Lexer.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst Recognizer = __webpack_require__(/*! ./Recognizer */ \"./node_modules/antlr4/src/antlr4/Recognizer.js\");\nconst CommonTokenFactory = __webpack_require__(/*! ./CommonTokenFactory */ \"./node_modules/antlr4/src/antlr4/CommonTokenFactory.js\");\nconst {RecognitionException} = __webpack_require__(/*! ./error/Errors */ \"./node_modules/antlr4/src/antlr4/error/Errors.js\");\nconst {LexerNoViableAltException} = __webpack_require__(/*! ./error/Errors */ \"./node_modules/antlr4/src/antlr4/error/Errors.js\");\n\nclass TokenSource {}\n\n/**\n * A lexer is recognizer that draws input symbols from a character stream.\n * lexer grammars result in a subclass of this object. A Lexer object\n * uses simplified match() and error recovery mechanisms in the interest of speed.\n */\nclass Lexer extends Recognizer {\n\tconstructor(input) {\n\t\tsuper();\n\t\tthis._input = input;\n\t\tthis._factory = CommonTokenFactory.DEFAULT;\n\t\tthis._tokenFactorySourcePair = [ this, input ];\n\n\t\tthis._interp = null; // child classes must populate this\n\n\t\t/**\n\t\t * The goal of all lexer rules/methods is to create a token object.\n\t\t * this is an instance variable as multiple rules may collaborate to\n\t\t * create a single token. nextToken will return this object after\n\t\t * matching lexer rule(s). If you subclass to allow multiple token\n\t\t * emissions, then set this to the last token to be matched or\n\t\t * something nonnull so that the auto token emit mechanism will not\n\t\t * emit another token.\n\t\t */\n\t\tthis._token = null;\n\n\t\t/**\n\t\t * What character index in the stream did the current token start at?\n\t\t * Needed, for example, to get the text for current token. Set at\n\t\t * the start of nextToken.\n\t\t */\n\t\tthis._tokenStartCharIndex = -1;\n\n\t\t// The line on which the first character of the token resides///\n\t\tthis._tokenStartLine = -1;\n\n\t\t// The character position of first character within the line///\n\t\tthis._tokenStartColumn = -1;\n\n\t\t// Once we see EOF on char stream, next token will be EOF.\n\t\t// If you have DONE : EOF ; then you see DONE EOF.\n\t\tthis._hitEOF = false;\n\n\t\t// The channel number for the current token///\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\n\t\t// The token type for the current token///\n\t\tthis._type = Token.INVALID_TYPE;\n\n\t\tthis._modeStack = [];\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\n\t\t/**\n\t\t * You can set the text for the current token to override what is in\n\t\t * the input char buffer. Use setText() or can set this instance var.\n\t\t */\n\t\tthis._text = null;\n\t}\n\n\treset() {\n\t\t// wack Lexer state variables\n\t\tif (this._input !== null) {\n\t\t\tthis._input.seek(0); // rewind the input\n\t\t}\n\t\tthis._token = null;\n\t\tthis._type = Token.INVALID_TYPE;\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\tthis._tokenStartCharIndex = -1;\n\t\tthis._tokenStartColumn = -1;\n\t\tthis._tokenStartLine = -1;\n\t\tthis._text = null;\n\n\t\tthis._hitEOF = false;\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\t\tthis._modeStack = [];\n\n\t\tthis._interp.reset();\n\t}\n\n// Return a token from this source; i.e., match a token on the char stream.\n\tnextToken() {\n\t\tif (this._input === null) {\n\t\t\tthrow \"nextToken requires a non-null input stream.\";\n\t\t}\n\n\t\t/**\n\t\t * Mark start location in char stream so unbuffered streams are\n\t\t * guaranteed at least have text of current token\n\t\t */\n\t\tconst tokenStartMarker = this._input.mark();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tif (this._hitEOF) {\n\t\t\t\t\tthis.emitEOF();\n\t\t\t\t\treturn this._token;\n\t\t\t\t}\n\t\t\t\tthis._token = null;\n\t\t\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\t\t\tthis._tokenStartCharIndex = this._input.index;\n\t\t\t\tthis._tokenStartColumn = this._interp.column;\n\t\t\t\tthis._tokenStartLine = this._interp.line;\n\t\t\t\tthis._text = null;\n\t\t\t\tlet continueOuter = false;\n\t\t\t\twhile (true) {\n\t\t\t\t\tthis._type = Token.INVALID_TYPE;\n\t\t\t\t\tlet ttype = Lexer.SKIP;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tttype = this._interp.match(this._input, this._mode);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif(e instanceof RecognitionException) {\n\t\t\t\t\t\t\tthis.notifyListeners(e); // report error\n\t\t\t\t\t\t\tthis.recover(e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log(e.stack);\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._input.LA(1) === Token.EOF) {\n\t\t\t\t\t\tthis._hitEOF = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Token.INVALID_TYPE) {\n\t\t\t\t\t\tthis._type = ttype;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Lexer.SKIP) {\n\t\t\t\t\t\tcontinueOuter = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type !== Lexer.MORE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (continueOuter) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (this._token === null) {\n\t\t\t\t\tthis.emit();\n\t\t\t\t}\n\t\t\t\treturn this._token;\n\t\t\t}\n\t\t} finally {\n\t\t\t// make sure we release marker after match or\n\t\t\t// unbuffered char stream will keep buffering\n\t\t\tthis._input.release(tokenStartMarker);\n\t\t}\n\t}\n\n\t/**\n\t * Instruct the lexer to skip creating a token for current lexer rule\n\t * and look for another token. nextToken() knows to keep looking when\n\t * a lexer rule finishes with token set to SKIP_TOKEN. Recall that\n\t * if token==null at end of any token rule, it creates one for you\n\t * and emits it.\n\t */\n\tskip() {\n\t\tthis._type = Lexer.SKIP;\n\t}\n\n\tmore() {\n\t\tthis._type = Lexer.MORE;\n\t}\n\n\tmode(m) {\n\t\tthis._mode = m;\n\t}\n\n\tpushMode(m) {\n\t\tif (this._interp.debug) {\n\t\t\tconsole.log(\"pushMode \" + m);\n\t\t}\n\t\tthis._modeStack.push(this._mode);\n\t\tthis.mode(m);\n\t}\n\n\tpopMode() {\n\t\tif (this._modeStack.length === 0) {\n\t\t\tthrow \"Empty Stack\";\n\t\t}\n\t\tif (this._interp.debug) {\n\t\t\tconsole.log(\"popMode back to \" + this._modeStack.slice(0, -1));\n\t\t}\n\t\tthis.mode(this._modeStack.pop());\n\t\treturn this._mode;\n\t}\n\n\t/**\n\t * By default does not support multiple emits per nextToken invocation\n\t * for efficiency reasons. Subclass and override this method, nextToken,\n\t * and getToken (to push tokens into a list and pull from that list\n\t * rather than a single variable as this implementation does).\n\t */\n\temitToken(token) {\n\t\tthis._token = token;\n\t}\n\n\t/**\n\t * The standard method called to automatically emit a token at the\n\t * outermost lexical rule. The token object should point into the\n\t * char buffer start..stop. If there is a text override in 'text',\n\t * use that to set the token's text. Override this method to emit\n\t * custom Token objects or provide a new factory.\n\t */\n\temit() {\n\t\tconst t = this._factory.create(this._tokenFactorySourcePair, this._type,\n\t\t\t\tthis._text, this._channel, this._tokenStartCharIndex, this\n\t\t\t\t\t\t.getCharIndex() - 1, this._tokenStartLine,\n\t\t\t\tthis._tokenStartColumn);\n\t\tthis.emitToken(t);\n\t\treturn t;\n\t}\n\n\temitEOF() {\n\t\tconst cpos = this.column;\n\t\tconst lpos = this.line;\n\t\tconst eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,\n\t\t\t\tnull, Token.DEFAULT_CHANNEL, this._input.index,\n\t\t\t\tthis._input.index - 1, lpos, cpos);\n\t\tthis.emitToken(eof);\n\t\treturn eof;\n\t}\n\n// What is the index of the current character of lookahead?///\n\tgetCharIndex() {\n\t\treturn this._input.index;\n\t}\n\n\t/**\n\t * Return a list of all Token objects in input char stream.\n\t * Forces load of all tokens. Does not include EOF token.\n\t */\n\tgetAllTokens() {\n\t\tconst tokens = [];\n\t\tlet t = this.nextToken();\n\t\twhile (t.type !== Token.EOF) {\n\t\t\ttokens.push(t);\n\t\t\tt = this.nextToken();\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tnotifyListeners(e) {\n\t\tconst start = this._tokenStartCharIndex;\n\t\tconst stop = this._input.index;\n\t\tconst text = this._input.getText(start, stop);\n\t\tconst msg = \"token recognition error at: '\" + this.getErrorDisplay(text) + \"'\";\n\t\tconst listener = this.getErrorListenerDispatch();\n\t\tlistener.syntaxError(this, null, this._tokenStartLine,\n\t\t\t\tthis._tokenStartColumn, msg, e);\n\t}\n\n\tgetErrorDisplay(s) {\n\t\tconst d = [];\n\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\td.push(s[i]);\n\t\t}\n\t\treturn d.join('');\n\t}\n\n\tgetErrorDisplayForChar(c) {\n\t\tif (c.charCodeAt(0) === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (c === '\\n') {\n\t\t\treturn \"\\\\n\";\n\t\t} else if (c === '\\t') {\n\t\t\treturn \"\\\\t\";\n\t\t} else if (c === '\\r') {\n\t\t\treturn \"\\\\r\";\n\t\t} else {\n\t\t\treturn c;\n\t\t}\n\t}\n\n\tgetCharErrorDisplay(c) {\n\t\treturn \"'\" + this.getErrorDisplayForChar(c) + \"'\";\n\t}\n\n\t/**\n\t * Lexers can normally match any char in it's vocabulary after matching\n\t * a token, so do the easy thing and just kill a character and hope\n\t * it all works out. You can instead use the rule invocation stack\n\t * to do sophisticated error recovery if you are in a fragment rule.\n\t */\n\trecover(re) {\n\t\tif (this._input.LA(1) !== Token.EOF) {\n\t\t\tif (re instanceof LexerNoViableAltException) {\n\t\t\t\t// skip a char and try again\n\t\t\t\tthis._interp.consume(this._input);\n\t\t\t} else {\n\t\t\t\t// TODO: Do we lose character or line position information?\n\t\t\t\tthis._input.consume();\n\t\t\t}\n\t\t}\n\t}\n\n\tget inputStream(){\n\t\treturn this._input;\n\t}\n\n\tset inputStream(input) {\n\t\tthis._input = null;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t\tthis.reset();\n\t\tthis._input = input;\n\t\tthis._tokenFactorySourcePair = [ this, this._input ];\n\t}\n\n\tget sourceName(){\n\t\treturn this._input.sourceName;\n\t}\n\n\tget type(){\n\t\treturn this.type;\n\t}\n\n\tset type(type) {\n\t\tthis._type = type;\n\t}\n\n\tget line(){\n\t\treturn this._interp.line;\n\t}\n\n\tset line(line) {\n\t\tthis._interp.line = line;\n\t}\n\n\tget column(){\n\t\treturn this._interp.column;\n\t}\n\n\tset column(column) {\n\t\tthis._interp.column = column;\n\t}\n\n\tget text(){\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t} else {\n\t\t\treturn this._interp.getText(this._input);\n\t\t}\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\n\n\n\nLexer.DEFAULT_MODE = 0;\nLexer.MORE = -2;\nLexer.SKIP = -3;\n\nLexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;\nLexer.HIDDEN = Token.HIDDEN_CHANNEL;\nLexer.MIN_CHAR_VALUE = 0x0000;\nLexer.MAX_CHAR_VALUE = 0x10FFFF;\n\n// Set the char stream and reset the lexer\n\n\nmodule.exports = Lexer;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/Lexer.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/Parser.js":
/*!**************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/Parser.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst {ParseTreeListener, TerminalNode, ErrorNode} = __webpack_require__(/*! ./tree/Tree */ \"./node_modules/antlr4/src/antlr4/tree/Tree.js\");\nconst Recognizer = __webpack_require__(/*! ./Recognizer */ \"./node_modules/antlr4/src/antlr4/Recognizer.js\");\nconst {DefaultErrorStrategy} = __webpack_require__(/*! ./error/ErrorStrategy */ \"./node_modules/antlr4/src/antlr4/error/ErrorStrategy.js\");\nconst ATNDeserializer = __webpack_require__(/*! ./atn/ATNDeserializer */ \"./node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js\");\nconst ATNDeserializationOptions = __webpack_require__(/*! ./atn/ATNDeserializationOptions */ \"./node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js\");\nconst Lexer = __webpack_require__(/*! ./Lexer */ \"./node_modules/antlr4/src/antlr4/Lexer.js\");\n\nclass TraceListener extends ParseTreeListener {\n\tconstructor(parser) {\n\t\tsuper();\n\t\tthis.parser = parser;\n\t}\n\n\tenterEveryRule(ctx) {\n\t\tconsole.log(\"enter   \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n\t}\n\n\tvisitTerminal(node) {\n\t\tconsole.log(\"consume \" + node.symbol + \" rule \" + this.parser.ruleNames[this.parser._ctx.ruleIndex]);\n\t}\n\n\texitEveryRule(ctx) {\n\t\tconsole.log(\"exit    \" + this.parser.ruleNames[ctx.ruleIndex] + \", LT(1)=\" + this.parser._input.LT(1).text);\n\t}\n}\n\nclass Parser extends Recognizer {\n\t/**\n\t * this is all the parsing support code essentially; most of it is error\n\t * recovery stuff.\n\t */\n\tconstructor(input) {\n\t\tsuper();\n\t\t// The input stream.\n\t\tthis._input = null;\n\t\t/**\n\t\t * The error handling strategy for the parser. The default value is a new\n\t\t * instance of {@link DefaultErrorStrategy}.\n\t\t */\n\t\tthis._errHandler = new DefaultErrorStrategy();\n\t\tthis._precedenceStack = [];\n\t\tthis._precedenceStack.push(0);\n\t\t/**\n\t\t * The {@link ParserRuleContext} object for the currently executing rule.\n\t\t * this is always non-null during the parsing process.\n\t\t */\n\t\tthis._ctx = null;\n\t\t/**\n\t\t * Specifies whether or not the parser should construct a parse tree during\n\t\t * the parsing process. The default value is {@code true}.\n\t\t */\n\t\tthis.buildParseTrees = true;\n\t\t/**\n\t\t * When {@link //setTrace}{@code (true)} is called, a reference to the\n\t\t * {@link TraceListener} is stored here so it can be easily removed in a\n\t\t * later call to {@link //setTrace}{@code (false)}. The listener itself is\n\t\t * implemented as a parser listener so this field is not directly used by\n\t\t * other parser methods.\n\t\t */\n\t\tthis._tracer = null;\n\t\t/**\n\t\t * The list of {@link ParseTreeListener} listeners registered to receive\n\t\t * events during the parse.\n\t\t */\n\t\tthis._parseListeners = null;\n\t\t/**\n\t\t * The number of syntax errors reported during parsing. this value is\n\t\t * incremented each time {@link //notifyErrorListeners} is called.\n\t\t */\n\t\tthis._syntaxErrors = 0;\n\t\tthis.setInputStream(input);\n\t}\n\n\t// reset the parser's state\n\treset() {\n\t\tif (this._input !== null) {\n\t\t\tthis._input.seek(0);\n\t\t}\n\t\tthis._errHandler.reset(this);\n\t\tthis._ctx = null;\n\t\tthis._syntaxErrors = 0;\n\t\tthis.setTrace(false);\n\t\tthis._precedenceStack = [];\n\t\tthis._precedenceStack.push(0);\n\t\tif (this._interp !== null) {\n\t\t\tthis._interp.reset();\n\t\t}\n\t}\n\n\t/**\n\t * Match current input symbol against {@code ttype}. If the symbol type\n\t * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are\n\t * called to complete the match process.\n\t *\n\t * <p>If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link //getBuildParseTree} is\n\t * {@code true} and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n\t *\n\t * @param ttype the token type to match\n\t * @return the matched symbol\n\t * @throws RecognitionException if the current input symbol did not match\n\t * {@code ttype} and the error strategy could not recover from the\n\t * mismatched symbol\n\t */\n\tmatch(ttype) {\n\t\tlet t = this.getCurrentToken();\n\t\tif (t.type === ttype) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this.buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token\n\t\t\t\t// insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\t/**\n\t * Match current input symbol as a wildcard. If the symbol type matches\n\t * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}\n\t * and {@link //consume} are called to complete the match process.\n\t *\n\t * <p>If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy//recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link //getBuildParseTree} is\n\t * {@code true} and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>\n\t *\n\t * @return the matched symbol\n\t * @throws RecognitionException if the current input symbol did not match\n\t * a wildcard and the error strategy could not recover from the mismatched\n\t * symbol\n\t */\n\tmatchWildcard() {\n\t\tlet t = this.getCurrentToken();\n\t\tif (t.type > 0) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this._buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token\n\t\t\t\t// insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\tgetParseListeners() {\n\t\treturn this._parseListeners || [];\n\t}\n\n\t/**\n\t * Registers {@code listener} to receive events during the parsing process.\n\t *\n\t * <p>To support output-preserving grammar transformations (including but not\n\t * limited to left-recursion removal, automated left-factoring, and\n\t * optimized code generation), calls to listener methods during the parse\n\t * may differ substantially from calls made by\n\t * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In\n\t * particular, rule entry and exit events may occur in a different order\n\t * during the parse than after the parser. In addition, calls to certain\n\t * rule entry methods may be omitted.</p>\n\t *\n\t * <p>With the following specific exceptions, calls to listener events are\n\t * <em>deterministic</em>, i.e. for identical input the calls to listener\n\t * methods will be the same.</p>\n\t *\n\t * <ul>\n\t * <li>Alterations to the grammar used to generate code may change the\n\t * behavior of the listener calls.</li>\n\t * <li>Alterations to the command line options passed to ANTLR 4 when\n\t * generating the parser may change the behavior of the listener calls.</li>\n\t * <li>Changing the version of the ANTLR Tool used to generate the parser\n\t * may change the behavior of the listener calls.</li>\n\t * </ul>\n\t *\n\t * @param listener the listener to add\n\t *\n\t * @throws NullPointerException if {@code} listener is {@code null}\n\t */\n\taddParseListener(listener) {\n\t\tif (listener === null) {\n\t\t\tthrow \"listener\";\n\t\t}\n\t\tif (this._parseListeners === null) {\n\t\t\tthis._parseListeners = [];\n\t\t}\n\t\tthis._parseListeners.push(listener);\n\t}\n\n\t/**\n\t * Remove {@code listener} from the list of parse listeners.\n\t *\n\t * <p>If {@code listener} is {@code null} or has not been added as a parse\n\t * listener, this method does nothing.</p>\n\t * @param listener the listener to remove\n\t */\n\tremoveParseListener(listener) {\n\t\tif (this._parseListeners !== null) {\n\t\t\tconst idx = this._parseListeners.indexOf(listener);\n\t\t\tif (idx >= 0) {\n\t\t\t\tthis._parseListeners.splice(idx, 1);\n\t\t\t}\n\t\t\tif (this._parseListeners.length === 0) {\n\t\t\t\tthis._parseListeners = null;\n\t\t\t}\n\t\t}\n\t}\n\n// Remove all parse listeners.\n\tremoveParseListeners() {\n\t\tthis._parseListeners = null;\n\t}\n\n// Notify any parse listeners of an enter rule event.\n\ttriggerEnterRuleEvent() {\n\t\tif (this._parseListeners !== null) {\n\t\t\tconst ctx = this._ctx;\n\t\t\tthis._parseListeners.map(function(listener) {\n\t\t\t\tlistener.enterEveryRule(ctx);\n\t\t\t\tctx.enterRule(listener);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Notify any parse listeners of an exit rule event.\n\t * @see //addParseListener\n\t */\n\ttriggerExitRuleEvent() {\n\t\tif (this._parseListeners !== null) {\n\t\t\t// reverse order walk of listeners\n\t\t\tconst ctx = this._ctx;\n\t\t\tthis._parseListeners.slice(0).reverse().map(function(listener) {\n\t\t\t\tctx.exitRule(listener);\n\t\t\t\tlistener.exitEveryRule(ctx);\n\t\t\t});\n\t\t}\n\t}\n\n\tgetTokenFactory() {\n\t\treturn this._input.tokenSource._factory;\n\t}\n\n\t// Tell our token source and error strategy about a new way to create tokens.\n\tsetTokenFactory(factory) {\n\t\tthis._input.tokenSource._factory = factory;\n\t}\n\n\t/**\n\t * The ATN with bypass alternatives is expensive to create so we create it\n\t * lazily.\n\t *\n\t * @throws UnsupportedOperationException if the current parser does not\n\t * implement the {@link //getSerializedATN()} method.\n\t */\n\tgetATNWithBypassAlts() {\n\t\tconst serializedAtn = this.getSerializedATN();\n\t\tif (serializedAtn === null) {\n\t\t\tthrow \"The current parser does not support an ATN with bypass alternatives.\";\n\t\t}\n\t\tlet result = this.bypassAltsAtnCache[serializedAtn];\n\t\tif (result === null) {\n\t\t\tconst deserializationOptions = new ATNDeserializationOptions();\n\t\t\tdeserializationOptions.generateRuleBypassTransitions = true;\n\t\t\tresult = new ATNDeserializer(deserializationOptions)\n\t\t\t\t\t.deserialize(serializedAtn);\n\t\t\tthis.bypassAltsAtnCache[serializedAtn] = result;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The preferred method of getting a tree pattern. For example, here's a\n\t * sample use:\n\t *\n\t * <pre>\n\t * ParseTree t = parser.expr();\n\t * ParseTreePattern p = parser.compileParseTreePattern(\"&lt;ID&gt;+0\",\n\t * MyParser.RULE_expr);\n\t * ParseTreeMatch m = p.match(t);\n\t * String id = m.get(\"ID\");\n\t * </pre>\n\t */\n\tcompileParseTreePattern(pattern, patternRuleIndex, lexer) {\n\t\tlexer = lexer || null;\n\t\tif (lexer === null) {\n\t\t\tif (this.getTokenStream() !== null) {\n\t\t\t\tconst tokenSource = this.getTokenStream().tokenSource;\n\t\t\t\tif (tokenSource instanceof Lexer) {\n\t\t\t\t\tlexer = tokenSource;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lexer === null) {\n\t\t\tthrow \"Parser can't discover a lexer to use\";\n\t\t}\n\t\tconst m = new ParseTreePatternMatcher(lexer, this);\n\t\treturn m.compile(pattern, patternRuleIndex);\n\t}\n\n\tgetInputStream() {\n\t\treturn this.getTokenStream();\n\t}\n\n\tsetInputStream(input) {\n\t\tthis.setTokenStream(input);\n\t}\n\n\tgetTokenStream() {\n\t\treturn this._input;\n\t}\n\n\t// Set the token stream and reset the parser.\n\tsetTokenStream(input) {\n\t\tthis._input = null;\n\t\tthis.reset();\n\t\tthis._input = input;\n\t}\n\n\t/**\n\t * Match needs to return the current input symbol, which gets put\n\t * into the label for the associated token ref; e.g., x=ID.\n\t */\n\tgetCurrentToken() {\n\t\treturn this._input.LT(1);\n\t}\n\n\tnotifyErrorListeners(msg, offendingToken, err) {\n\t\toffendingToken = offendingToken || null;\n\t\terr = err || null;\n\t\tif (offendingToken === null) {\n\t\t\toffendingToken = this.getCurrentToken();\n\t\t}\n\t\tthis._syntaxErrors += 1;\n\t\tconst line = offendingToken.line;\n\t\tconst column = offendingToken.column;\n\t\tconst listener = this.getErrorListenerDispatch();\n\t\tlistener.syntaxError(this, offendingToken, line, column, msg, err);\n\t}\n\n\t/**\n\t * Consume and return the {@linkplain //getCurrentToken current symbol}.\n\t *\n\t * <p>E.g., given the following input with {@code A} being the current\n\t * lookahead symbol, this function moves the cursor to {@code B} and returns\n\t * {@code A}.</p>\n\t *\n\t * <pre>\n\t * A B\n\t * ^\n\t * </pre>\n\t *\n\t * If the parser is not in error recovery mode, the consumed symbol is added\n\t * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and\n\t * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.\n\t * If the parser <em>is</em> in error recovery mode, the consumed symbol is\n\t * added to the parse tree using\n\t * {@link ParserRuleContext//addErrorNode(Token)}, and\n\t * {@link ParseTreeListener//visitErrorNode} is called on any parse\n\t * listeners.\n\t */\n\tconsume() {\n\t\tconst o = this.getCurrentToken();\n\t\tif (o.type !== Token.EOF) {\n\t\t\tthis.getInputStream().consume();\n\t\t}\n\t\tconst hasListener = this._parseListeners !== null && this._parseListeners.length > 0;\n\t\tif (this.buildParseTrees || hasListener) {\n\t\t\tlet node;\n\t\t\tif (this._errHandler.inErrorRecoveryMode(this)) {\n\t\t\t\tnode = this._ctx.addErrorNode(o);\n\t\t\t} else {\n\t\t\t\tnode = this._ctx.addTokenNode(o);\n\t\t\t}\n\t\t\tnode.invokingState = this.state;\n\t\t\tif (hasListener) {\n\t\t\t\tthis._parseListeners.map(function(listener) {\n\t\t\t\t\tif (node instanceof ErrorNode || (node.isErrorNode !== undefined && node.isErrorNode())) {\n\t\t\t\t\t\tlistener.visitErrorNode(node);\n\t\t\t\t\t} else if (node instanceof TerminalNode) {\n\t\t\t\t\t\tlistener.visitTerminal(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn o;\n\t}\n\n\taddContextToParseTree() {\n\t\t// add current context to parent if we have a parent\n\t\tif (this._ctx.parentCtx !== null) {\n\t\t\tthis._ctx.parentCtx.addChild(this._ctx);\n\t\t}\n\t}\n\n\t/**\n\t * Always called by generated parsers upon entry to a rule. Access field\n\t * {@link //_ctx} get the current context.\n\t */\n\tenterRule(localctx, state, ruleIndex) {\n\t\tthis.state = state;\n\t\tthis._ctx = localctx;\n\t\tthis._ctx.start = this._input.LT(1);\n\t\tif (this.buildParseTrees) {\n\t\t\tthis.addContextToParseTree();\n\t\t}\n\t\tif (this._parseListeners !== null) {\n\t\t\tthis.triggerEnterRuleEvent();\n\t\t}\n\t}\n\n\texitRule() {\n\t\tthis._ctx.stop = this._input.LT(-1);\n\t\t// trigger event on _ctx, before it reverts to parent\n\t\tif (this._parseListeners !== null) {\n\t\t\tthis.triggerExitRuleEvent();\n\t\t}\n\t\tthis.state = this._ctx.invokingState;\n\t\tthis._ctx = this._ctx.parentCtx;\n\t}\n\n\tenterOuterAlt(localctx, altNum) {\n\t\tlocalctx.setAltNumber(altNum);\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif (this.buildParseTrees && this._ctx !== localctx) {\n\t\t\tif (this._ctx.parentCtx !== null) {\n\t\t\t\tthis._ctx.parentCtx.removeLastChild();\n\t\t\t\tthis._ctx.parentCtx.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\tthis._ctx = localctx;\n\t}\n\n\t/**\n\t * Get the precedence level for the top-most precedence rule.\n\t *\n\t * @return The precedence level for the top-most precedence rule, or -1 if\n\t * the parser context is not nested within a precedence rule.\n\t */\n\tgetPrecedence() {\n\t\tif (this._precedenceStack.length === 0) {\n\t\t\treturn -1;\n\t\t} else {\n\t\t\treturn this._precedenceStack[this._precedenceStack.length-1];\n\t\t}\n\t}\n\n\tenterRecursionRule(localctx, state, ruleIndex, precedence) {\n\t   this.state = state;\n\t   this._precedenceStack.push(precedence);\n\t   this._ctx = localctx;\n\t   this._ctx.start = this._input.LT(1);\n\t   if (this._parseListeners !== null) {\n\t\t   this.triggerEnterRuleEvent(); // simulates rule entry for\n\t\t   \t\t\t\t\t\t\t\t\t// left-recursive rules\n\t   }\n   }\n\n\t// Like {@link //enterRule} but for recursive rules.\n\tpushNewRecursionContext(localctx, state, ruleIndex) {\n\t\tconst previous = this._ctx;\n\t\tprevious.parentCtx = localctx;\n\t\tprevious.invokingState = state;\n\t\tprevious.stop = this._input.LT(-1);\n\n\t\tthis._ctx = localctx;\n\t\tthis._ctx.start = previous.start;\n\t\tif (this.buildParseTrees) {\n\t\t\tthis._ctx.addChild(previous);\n\t\t}\n\t\tif (this._parseListeners !== null) {\n\t\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for\n\t\t\t\t\t\t\t\t\t\t\t// left-recursive rules\n\t\t}\n\t}\n\n\tunrollRecursionContexts(parentCtx) {\n\t\tthis._precedenceStack.pop();\n\t\tthis._ctx.stop = this._input.LT(-1);\n\t\tconst retCtx = this._ctx; // save current ctx (return value)\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tif (this._parseListeners !== null) {\n\t\t\twhile (this._ctx !== parentCtx) {\n\t\t\t\tthis.triggerExitRuleEvent();\n\t\t\t\tthis._ctx = this._ctx.parentCtx;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._ctx = parentCtx;\n\t\t}\n\t\t// hook into tree\n\t\tretCtx.parentCtx = parentCtx;\n\t\tif (this.buildParseTrees && parentCtx !== null) {\n\t\t\t// add return ctx into invoking rule's tree\n\t\t\tparentCtx.addChild(retCtx);\n\t\t}\n\t}\n\n\tgetInvokingContext(ruleIndex) {\n\t\tlet ctx = this._ctx;\n\t\twhile (ctx !== null) {\n\t\t\tif (ctx.ruleIndex === ruleIndex) {\n\t\t\t\treturn ctx;\n\t\t\t}\n\t\t\tctx = ctx.parentCtx;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprecpred(localctx, precedence) {\n\t\treturn precedence >= this._precedenceStack[this._precedenceStack.length-1];\n\t}\n\n\tinContext(context) {\n\t\t// TODO: useful in parser?\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks whether or not {@code symbol} can follow the current state in the\n\t * ATN. The behavior of this method is equivalent to the following, but is\n\t * implemented such that the complete context-sensitive follow set does not\n\t * need to be explicitly constructed.\n\t *\n\t * <pre>\n\t * return getExpectedTokens().contains(symbol);\n\t * </pre>\n\t *\n\t * @param symbol the symbol type to check\n\t * @return {@code true} if {@code symbol} can follow the current state in\n\t * the ATN, otherwise {@code false}.\n\t */\n\tisExpectedToken(symbol) {\n\t\tconst atn = this._interp.atn;\n\t\tlet ctx = this._ctx;\n\t\tconst s = atn.states[this.state];\n\t\tlet following = atn.nextTokens(s);\n\t\tif (following.contains(symbol)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!following.contains(Token.EPSILON)) {\n\t\t\treturn false;\n\t\t}\n\t\twhile (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n\t\t\tconst invokingState = atn.states[ctx.invokingState];\n\t\t\tconst rt = invokingState.transitions[0];\n\t\t\tfollowing = atn.nextTokens(rt.followState);\n\t\t\tif (following.contains(symbol)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tctx = ctx.parentCtx;\n\t\t}\n\t\tif (following.contains(Token.EPSILON) && symbol === Token.EOF) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Computes the set of input symbols which could follow the current parser\n\t * state and context, as given by {@link //getState} and {@link //getContext},\n\t * respectively.\n\t *\n\t * @see ATN//getExpectedTokens(int, RuleContext)\n\t */\n\tgetExpectedTokens() {\n\t\treturn this._interp.atn.getExpectedTokens(this.state, this._ctx);\n\t}\n\n\tgetExpectedTokensWithinCurrentRule() {\n\t\tconst atn = this._interp.atn;\n\t\tconst s = atn.states[this.state];\n\t\treturn atn.nextTokens(s);\n\t}\n\n\t// Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.\n\tgetRuleIndex(ruleName) {\n\t\tconst ruleIndex = this.getRuleIndexMap()[ruleName];\n\t\tif (ruleIndex !== null) {\n\t\t\treturn ruleIndex;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/**\n\t * Return List&lt;String&gt; of the rule names in your parser instance\n\t * leading up to a call to the current rule. You could override if\n\t * you want more details such as the file/line info of where\n\t * in the ATN a rule is invoked.\n\t *\n\t * this is very useful for error messages.\n\t */\n\tgetRuleInvocationStack(p) {\n\t\tp = p || null;\n\t\tif (p === null) {\n\t\t\tp = this._ctx;\n\t\t}\n\t\tconst stack = [];\n\t\twhile (p !== null) {\n\t\t\t// compute what follows who invoked us\n\t\t\tconst ruleIndex = p.ruleIndex;\n\t\t\tif (ruleIndex < 0) {\n\t\t\t\tstack.push(\"n/a\");\n\t\t\t} else {\n\t\t\t\tstack.push(this.ruleNames[ruleIndex]);\n\t\t\t}\n\t\t\tp = p.parentCtx;\n\t\t}\n\t\treturn stack;\n\t}\n\n\t// For debugging and other purposes.\n\tgetDFAStrings() {\n\t\treturn this._interp.decisionToDFA.toString();\n\t}\n\n\t// For debugging and other purposes.\n\tdumpDFA() {\n\t\tlet seenOne = false;\n\t\tfor (let i = 0; i < this._interp.decisionToDFA.length; i++) {\n\t\t\tconst dfa = this._interp.decisionToDFA[i];\n\t\t\tif (dfa.states.length > 0) {\n\t\t\t\tif (seenOne) {\n\t\t\t\t\tconsole.log();\n\t\t\t\t}\n\t\t\t\tthis.printer.println(\"Decision \" + dfa.decision + \":\");\n\t\t\t\tthis.printer.print(dfa.toString(this.literalNames, this.symbolicNames));\n\t\t\t\tseenOne = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\t\"\t\t\tprinter = function() {\\r\\n\" +\n\t\t\"\t\t\t\tthis.println = function(s) { document.getElementById('output') += s + '\\\\n'; }\\r\\n\" +\n\t\t\"\t\t\t\tthis.print = function(s) { document.getElementById('output') += s; }\\r\\n\" +\n\t\t\"\t\t\t};\\r\\n\" +\n\t\t*/\n\tgetSourceName() {\n\t\treturn this._input.sourceName;\n\t}\n\n\t/**\n\t * During a parse is sometimes useful to listen in on the rule entry and exit\n\t * events as well as token matches. this is for quick and dirty debugging.\n\t */\n\tsetTrace(trace) {\n\t\tif (!trace) {\n\t\t\tthis.removeParseListener(this._tracer);\n\t\t\tthis._tracer = null;\n\t\t} else {\n\t\t\tif (this._tracer !== null) {\n\t\t\t\tthis.removeParseListener(this._tracer);\n\t\t\t}\n\t\t\tthis._tracer = new TraceListener(this);\n\t\t\tthis.addParseListener(this._tracer);\n\t\t}\n\t}\n}\n\n/**\n * this field maps from the serialized ATN string to the deserialized {@link\n * ATN} with\n * bypass alternatives.\n *\n * @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()\n */\nParser.bypassAltsAtnCache = {};\n\nmodule.exports = Parser;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/Parser.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/ParserRuleContext.js":
/*!*************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/ParserRuleContext.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst RuleContext = __webpack_require__(/*! ./RuleContext */ \"./node_modules/antlr4/src/antlr4/RuleContext.js\");\nconst Tree = __webpack_require__(/*! ./tree/Tree */ \"./node_modules/antlr4/src/antlr4/tree/Tree.js\");\nconst INVALID_INTERVAL = Tree.INVALID_INTERVAL;\nconst TerminalNode = Tree.TerminalNode;\nconst TerminalNodeImpl = Tree.TerminalNodeImpl;\nconst ErrorNodeImpl = Tree.ErrorNodeImpl;\nconst Interval = __webpack_require__(/*! ./IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\").Interval;\n\n/**\n * A rule invocation record for parsing.\n *\n *  Contains all of the information about the current rule not stored in the\n *  RuleContext. It handles parse tree children list, Any ATN state\n *  tracing, and the default values available for rule indications:\n *  start, stop, rule index, current alt number, current\n *  ATN state.\n *\n *  Subclasses made for each rule and grammar track the parameters,\n *  return values, locals, and labels specific to that rule. These\n *  are the objects that are returned from rules.\n *\n *  Note text is not an actual field of a rule return value; it is computed\n *  from start and stop using the input stream's toString() method.  I\n *  could add a ctor to this so that we can pass in and store the input\n *  stream, but I'm not sure we want to do that.  It would seem to be undefined\n *  to get the .text property anyway if the rule matches tokens from multiple\n *  input streams.\n *\n *  I do not use getters for fields of objects that are used simply to\n *  group values such as this aggregate.  The getters/setters are there to\n *  satisfy the superclass interface.\n */\nclass ParserRuleContext extends RuleContext {\n\tconstructor(parent, invokingStateNumber) {\n\t\tparent = parent || null;\n\t\tinvokingStateNumber = invokingStateNumber || null;\n\t\tsuper(parent, invokingStateNumber);\n\t\tthis.ruleIndex = -1;\n\t\t/**\n\t\t * If we are debugging or building a parse tree for a visitor,\n\t\t * we need to track all of the tokens and rule invocations associated\n\t\t * with this rule's context. This is empty for parsing w/o tree constr.\n\t\t * operation because we don't the need to track the details about\n\t\t * how we parse this rule.\n\t\t */\n\t\tthis.children = null;\n\t\tthis.start = null;\n\t\tthis.stop = null;\n\t\t/**\n\t\t * The exception that forced this rule to return. If the rule successfully\n\t\t * completed, this is {@code null}.\n\t\t */\n\t\tthis.exception = null;\n\t}\n\n\t// COPY a ctx (I'm deliberately not using copy constructor)\n\tcopyFrom(ctx) {\n\t\t// from RuleContext\n\t\tthis.parentCtx = ctx.parentCtx;\n\t\tthis.invokingState = ctx.invokingState;\n\t\tthis.children = null;\n\t\tthis.start = ctx.start;\n\t\tthis.stop = ctx.stop;\n\t\t// copy any error nodes to alt label node\n\t\tif(ctx.children) {\n\t\t\tthis.children = [];\n\t\t\t// reset parent pointer for any error nodes\n\t\t\tctx.children.map(function(child) {\n\t\t\t\tif (child instanceof ErrorNodeImpl) {\n\t\t\t\t\tthis.children.push(child);\n\t\t\t\t\tchild.parentCtx = this;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t// Double dispatch methods for listeners\n\tenterRule(listener) {\n\t}\n\n\texitRule(listener) {\n\t}\n\n\t// Does not set parent link; other add methods do that\n\taddChild(child) {\n\t\tif (this.children === null) {\n\t\t\tthis.children = [];\n\t\t}\n\t\tthis.children.push(child);\n\t\treturn child;\n\t}\n\n\t/** Used by enterOuterAlt to toss out a RuleContext previously added as\n\t * we entered a rule. If we have // label, we will need to remove\n\t * generic ruleContext object.\n\t */\n\tremoveLastChild() {\n\t\tif (this.children !== null) {\n\t\t\tthis.children.pop();\n\t\t}\n\t}\n\n\taddTokenNode(token) {\n\t\tconst node = new TerminalNodeImpl(token);\n\t\tthis.addChild(node);\n\t\tnode.parentCtx = this;\n\t\treturn node;\n\t}\n\n\taddErrorNode(badToken) {\n\t\tconst node = new ErrorNodeImpl(badToken);\n\t\tthis.addChild(node);\n\t\tnode.parentCtx = this;\n\t\treturn node;\n\t}\n\n\tgetChild(i, type) {\n\t\ttype = type || null;\n\t\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\t\treturn null;\n\t\t}\n\t\tif (type === null) {\n\t\t\treturn this.children[i];\n\t\t} else {\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif(child instanceof type) {\n\t\t\t\t\tif(i===0) {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetToken(ttype, i) {\n\t\tif (this.children === null || i < 0 || i >= this.children.length) {\n\t\t\treturn null;\n\t\t}\n\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\tconst child = this.children[j];\n\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\tif(i===0) {\n\t\t\t\t\t\treturn child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetTokens(ttype ) {\n\t\tif (this.children=== null) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst tokens = [];\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif (child instanceof TerminalNode) {\n\t\t\t\t\tif (child.symbol.type === ttype) {\n\t\t\t\t\t\ttokens.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokens;\n\t\t}\n\t}\n\n\tgetTypedRuleContext(ctxType, i) {\n\t\treturn this.getChild(i, ctxType);\n\t}\n\n\tgetTypedRuleContexts(ctxType) {\n\t\tif (this.children=== null) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst contexts = [];\n\t\t\tfor(let j=0; j<this.children.length; j++) {\n\t\t\t\tconst child = this.children[j];\n\t\t\t\tif (child instanceof ctxType) {\n\t\t\t\t\tcontexts.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn contexts;\n\t\t}\n\t}\n\n\tgetChildCount() {\n\t\tif (this.children=== null) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn this.children.length;\n\t\t}\n\t}\n\n\tgetSourceInterval() {\n\t\tif( this.start === null || this.stop === null) {\n\t\t\treturn INVALID_INTERVAL;\n\t\t} else {\n\t\t\treturn new Interval(this.start.tokenIndex, this.stop.tokenIndex);\n\t\t}\n\t}\n}\n\nRuleContext.EMPTY = new ParserRuleContext();\n\nclass InterpreterRuleContext extends ParserRuleContext {\n\tconstructor(parent, invokingStateNumber, ruleIndex) {\n\t\tsuper(parent, invokingStateNumber);\n\t\tthis.ruleIndex = ruleIndex;\n\t}\n}\n\nmodule.exports = ParserRuleContext;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/ParserRuleContext.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/PredictionContext.js":
/*!*************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/PredictionContext.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst RuleContext = __webpack_require__(/*! ./RuleContext */ \"./node_modules/antlr4/src/antlr4/RuleContext.js\");\nconst {Hash, Map, equalArrays} = __webpack_require__(/*! ./Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\n\nclass PredictionContext {\n\n\tconstructor(cachedHashCode) {\n\t\tthis.cachedHashCode = cachedHashCode;\n\t}\n\n\t/**\n\t * Stores the computed hash code of this {@link PredictionContext}. The hash\n\t * code is computed in parts to match the following reference algorithm.\n\t *\n\t * <pre>\n\t * private int referenceHashCode() {\n\t * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link\n\t * //INITIAL_HASH});\n\t *\n\t * for (int i = 0; i &lt; {@link //size()}; i++) {\n\t * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent\n\t * getParent}(i));\n\t * }\n\t *\n\t * for (int i = 0; i &lt; {@link //size()}; i++) {\n\t * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link\n\t * //getReturnState getReturnState}(i));\n\t * }\n\t *\n\t * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link\n\t * //size()});\n\t * return hash;\n\t * }\n\t * </pre>\n\t * This means only the {@link //EMPTY} context is in set.\n\t */\n\tisEmpty() {\n\t\treturn this === PredictionContext.EMPTY;\n\t}\n\n\thasEmptyPath() {\n\t\treturn this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;\n\t}\n\n\thashCode() {\n\t\treturn this.cachedHashCode;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.cachedHashCode);\n\t}\n}\n\n/**\n * Represents {@code $} in local context prediction, which means wildcard.\n * {@code//+x =//}.\n */\nPredictionContext.EMPTY = null;\n\n/**\n * Represents {@code $} in an array in full context mode, when {@code $}\n * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,\n * {@code $} = {@link //EMPTY_RETURN_STATE}.\n */\nPredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;\n\nPredictionContext.globalNodeCount = 1;\nPredictionContext.id = PredictionContext.globalNodeCount;\n\n\n/*\nfunction calculateHashString(parent, returnState) {\n\treturn \"\" + parent + returnState;\n}\n*/\n\n/**\n * Used to cache {@link PredictionContext} objects. Its used for the shared\n * context cash associated with contexts in DFA states. This cache\n * can be used for both lexers and parsers.\n */\nclass PredictionContextCache {\n\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * Add a context to the cache and return it. If the context already exists,\n\t * return that one instead and do not add a new context to the cache.\n\t * Protect shared cache from unsafe thread access.\n\t */\n\tadd(ctx) {\n\t\tif (ctx === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY;\n\t\t}\n\t\tconst existing = this.cache.get(ctx) || null;\n\t\tif (existing !== null) {\n\t\t\treturn existing;\n\t\t}\n\t\tthis.cache.put(ctx, ctx);\n\t\treturn ctx;\n\t}\n\n\tget(ctx) {\n\t\treturn this.cache.get(ctx) || null;\n\t}\n\n\tget length(){\n\t\treturn this.cache.length;\n\t}\n}\n\n\nclass SingletonPredictionContext extends PredictionContext {\n\n\tconstructor(parent, returnState) {\n\t\tlet hashCode = 0;\n\t\tconst hash = new Hash();\n\t\tif(parent !== null) {\n\t\t\thash.update(parent, returnState);\n\t\t} else {\n\t\t\thash.update(1);\n\t\t}\n\t\thashCode = hash.finish();\n\t\tsuper(hashCode);\n\t\tthis.parentCtx = parent;\n\t\tthis.returnState = returnState;\n\t}\n\n\tgetParent(index) {\n\t\treturn this.parentCtx;\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnState;\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof SingletonPredictionContext)) {\n\t\t\treturn false;\n\t\t} else if (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t} else {\n\t\t\tif(this.returnState !== other.returnState)\n\t\t\t\treturn false;\n\t\t\telse if(this.parentCtx==null)\n\t\t\t\treturn other.parentCtx==null\n\t\t\telse\n\t\t\t\treturn this.parentCtx.equals(other.parentCtx);\n\t\t}\n\t}\n\n\ttoString() {\n\t\tconst up = this.parentCtx === null ? \"\" : this.parentCtx.toString();\n\t\tif (up.length === 0) {\n\t\t\tif (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\treturn \"$\";\n\t\t\t} else {\n\t\t\t\treturn \"\" + this.returnState;\n\t\t\t}\n\t\t} else {\n\t\t\treturn \"\" + this.returnState + \" \" + up;\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn 1;\n\t}\n\n\tstatic create(parent, returnState) {\n\t\tif (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {\n\t\t\t// someone can pass in the bits of an array ctx that mean $\n\t\t\treturn PredictionContext.EMPTY;\n\t\t} else {\n\t\t\treturn new SingletonPredictionContext(parent, returnState);\n\t\t}\n\t}\n}\n\nclass EmptyPredictionContext extends SingletonPredictionContext {\n\n\tconstructor() {\n\t\tsuper(null, PredictionContext.EMPTY_RETURN_STATE);\n\t}\n\n\tisEmpty() {\n\t\treturn true;\n\t}\n\n\tgetParent(index) {\n\t\treturn null;\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnState;\n\t}\n\n\tequals(other) {\n\t\treturn this === other;\n\t}\n\n\ttoString() {\n\t\treturn \"$\";\n\t}\n}\n\n\nPredictionContext.EMPTY = new EmptyPredictionContext();\n\nclass ArrayPredictionContext extends PredictionContext {\n\n\tconstructor(parents, returnStates) {\n\t\t/**\n\t\t * Parent can be null only if full ctx mode and we make an array\n\t\t * from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using\n\t\t * null parent and\n\t\t * returnState == {@link //EMPTY_RETURN_STATE}.\n\t\t */\n\t\tconst h = new Hash();\n\t\th.update(parents, returnStates);\n\t\tconst hashCode = h.finish();\n\t\tsuper(hashCode);\n\t\tthis.parents = parents;\n\t\tthis.returnStates = returnStates;\n\t\treturn this;\n\t}\n\n\tisEmpty() {\n\t\t// since EMPTY_RETURN_STATE can only appear in the last position, we\n\t\t// don't need to verify that size==1\n\t\treturn this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;\n\t}\n\n\tgetParent(index) {\n\t\treturn this.parents[index];\n\t}\n\n\tgetReturnState(index) {\n\t\treturn this.returnStates[index];\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof ArrayPredictionContext)) {\n\t\t\treturn false;\n\t\t} else if (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t} else {\n\t\t\treturn equalArrays(this.returnStates, other.returnStates) &&\n\t\t\t\tequalArrays(this.parents, other.parents);\n\t\t}\n\t}\n\n\ttoString() {\n\t\tif (this.isEmpty()) {\n\t\t\treturn \"[]\";\n\t\t} else {\n\t\t\tlet s = \"[\";\n\t\t\tfor (let i = 0; i < this.returnStates.length; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts = s + \", \";\n\t\t\t\t}\n\t\t\t\tif (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\ts = s + \"$\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts = s + this.returnStates[i];\n\t\t\t\tif (this.parents[i] !== null) {\n\t\t\t\t\ts = s + \" \" + this.parents[i];\n\t\t\t\t} else {\n\t\t\t\t\ts = s + \"null\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s + \"]\";\n\t\t}\n\t}\n\n\tget length(){\n\t\treturn this.returnStates.length;\n\t}\n}\n\n\n/**\n * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.\n * Return {@link //EMPTY} if {@code outerContext} is empty or null.\n */\nfunction predictionContextFromRuleContext(atn, outerContext) {\n\tif (outerContext === undefined || outerContext === null) {\n\t\touterContext = RuleContext.EMPTY;\n\t}\n\t// if we are in RuleContext of start rule, s, then PredictionContext\n\t// is EMPTY. Nobody called us. (if we are empty, return empty)\n\tif (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {\n\t\treturn PredictionContext.EMPTY;\n\t}\n\t// If we have a parent, convert it to a PredictionContext graph\n\tconst parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);\n\tconst state = atn.states[outerContext.invokingState];\n\tconst transition = state.transitions[0];\n\treturn SingletonPredictionContext.create(parent, transition.followState.stateNumber);\n}\n/*\nfunction calculateListsHashString(parents, returnStates) {\n\tconst s = \"\";\n\tparents.map(function(p) {\n\t\ts = s + p;\n\t});\n\treturnStates.map(function(r) {\n\t\ts = s + r;\n\t});\n\treturn s;\n}\n*/\nfunction merge(a, b, rootIsWildcard, mergeCache) {\n\t// share same graph if both same\n\tif (a === b) {\n\t\treturn a;\n\t}\n\tif (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n\t\treturn mergeSingletons(a, b, rootIsWildcard, mergeCache);\n\t}\n\t// At least one of a or b is array\n\t// If one is $ and rootIsWildcard, return $ as// wildcard\n\tif (rootIsWildcard) {\n\t\tif (a instanceof EmptyPredictionContext) {\n\t\t\treturn a;\n\t\t}\n\t\tif (b instanceof EmptyPredictionContext) {\n\t\t\treturn b;\n\t\t}\n\t}\n\t// convert singleton so both are arrays to normalize\n\tif (a instanceof SingletonPredictionContext) {\n\t\ta = new ArrayPredictionContext([a.getParent()], [a.returnState]);\n\t}\n\tif (b instanceof SingletonPredictionContext) {\n\t\tb = new ArrayPredictionContext([b.getParent()], [b.returnState]);\n\t}\n\treturn mergeArrays(a, b, rootIsWildcard, mergeCache);\n}\n\n/**\n * Merge two {@link SingletonPredictionContext} instances.\n *\n * <p>Stack tops equal, parents merge is same; return left graph.<br>\n * <embed src=\"images/SingletonMerge_SameRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Same stack top, parents differ; merge parents giving array node, then\n * remainders of those graphs. A new root node is created to point to the\n * merged parents.<br>\n * <embed src=\"images/SingletonMerge_SameRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to same parent. Make array node for the\n * root where both element in the root point to the same (original)\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootSamePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Different stack tops pointing to different parents. Make array node for\n * the root where each element points to the corresponding original\n * parent.<br>\n * <embed src=\"images/SingletonMerge_DiffRootDiffPar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n * @param mergeCache\n */\nfunction mergeSingletons(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tlet previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\n\tconst rootMerge = mergeRoot(a, b, rootIsWildcard);\n\tif (rootMerge !== null) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, rootMerge);\n\t\t}\n\t\treturn rootMerge;\n\t}\n\tif (a.returnState === b.returnState) {\n\t\tconst parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);\n\t\t// if parent is same as existing a or b parent or reduced to a parent,\n\t\t// return it\n\t\tif (parent === a.parentCtx) {\n\t\t\treturn a; // ax + bx = ax, if a=b\n\t\t}\n\t\tif (parent === b.parentCtx) {\n\t\t\treturn b; // ax + bx = bx, if a=b\n\t\t}\n\t\t// else: ax + ay = a'[x,y]\n\t\t// merge parents x and y, giving array node with x,y then remainders\n\t\t// of those graphs. dup a, a' points at merged array\n\t\t// new joined parent so create new singleton pointing to it, a'\n\t\tconst spc = SingletonPredictionContext.create(parent, a.returnState);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, spc);\n\t\t}\n\t\treturn spc;\n\t} else { // a != b payloads differ\n\t\t// see if we can collapse parents due to $+x parents if local ctx\n\t\tlet singleParent = null;\n\t\tif (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// bx =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [a,b]x\n\t\t\tsingleParent = a.parentCtx;\n\t\t}\n\t\tif (singleParent !== null) { // parents are same\n\t\t\t// sort payloads and use same parent\n\t\t\tconst payloads = [ a.returnState, b.returnState ];\n\t\t\tif (a.returnState > b.returnState) {\n\t\t\t\tpayloads[0] = b.returnState;\n\t\t\t\tpayloads[1] = a.returnState;\n\t\t\t}\n\t\t\tconst parents = [ singleParent, singleParent ];\n\t\t\tconst apc = new ArrayPredictionContext(parents, payloads);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, apc);\n\t\t\t}\n\t\t\treturn apc;\n\t\t}\n\t\t// parents differ and can't merge them. Just pack together\n\t\t// into array; can't merge.\n\t\t// ax + by = [ax,by]\n\t\tconst payloads = [ a.returnState, b.returnState ];\n\t\tlet parents = [ a.parentCtx, b.parentCtx ];\n\t\tif (a.returnState > b.returnState) { // sort by payload\n\t\t\tpayloads[0] = b.returnState;\n\t\t\tpayloads[1] = a.returnState;\n\t\t\tparents = [ b.parentCtx, a.parentCtx ];\n\t\t}\n\t\tconst a_ = new ArrayPredictionContext(parents, payloads);\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a_);\n\t\t}\n\t\treturn a_;\n\t}\n}\n\n/**\n * Handle case where at least one of {@code a} or {@code b} is\n * {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used\n * to represent {@link //EMPTY}.\n *\n * <h2>Local-Context Merges</h2>\n *\n * <p>These local-context merge operations are used when {@code rootIsWildcard}\n * is true.</p>\n *\n * <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>\n * <embed src=\"images/LocalMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is\n * {@code //EMPTY}; return left graph.<br>\n * <embed src=\"images/LocalMerge_EmptyParent.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Special case of last merge if local context.<br>\n * <embed src=\"images/LocalMerge_DiffRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <h2>Full-Context Merges</h2>\n *\n * <p>These full-context merge operations are used when {@code rootIsWildcard}\n * is false.</p>\n *\n * <p><embed src=\"images/FullMerge_EmptyRoots.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and\n * null parent).<br>\n * <embed src=\"images/FullMerge_EmptyRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p><embed src=\"images/FullMerge_SameRoot.svg\" type=\"image/svg+xml\"/></p>\n *\n * @param a the first {@link SingletonPredictionContext}\n * @param b the second {@link SingletonPredictionContext}\n * @param rootIsWildcard {@code true} if this is a local-context merge,\n * otherwise false to indicate a full-context merge\n */\nfunction mergeRoot(a, b, rootIsWildcard) {\n\tif (rootIsWildcard) {\n\t\tif (a === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // // + b =//\n\t\t}\n\t\tif (b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // a +// =//\n\t\t}\n\t} else {\n\t\tif (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {\n\t\t\treturn PredictionContext.EMPTY; // $ + $ = $\n\t\t} else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]\n\t\t\tconst payloads = [ b.returnState,\n\t\t\t\t\tPredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tconst parents = [ b.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t} else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)\n\t\t\tconst payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];\n\t\t\tconst parents = [ a.parentCtx, null ];\n\t\t\treturn new ArrayPredictionContext(parents, payloads);\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Merge two {@link ArrayPredictionContext} instances.\n *\n * <p>Different tops, different parents.<br>\n * <embed src=\"images/ArrayMerge_DiffTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, same parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSamePar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, different parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopDiffPar.svg\" type=\"image/svg+xml\"/></p>\n *\n * <p>Shared top, all shared parents.<br>\n * <embed src=\"images/ArrayMerge_ShareTopSharePar.svg\"\n * type=\"image/svg+xml\"/></p>\n *\n * <p>Equal tops, merge parents and reduce top to\n * {@link SingletonPredictionContext}.<br>\n * <embed src=\"images/ArrayMerge_EqualTop.svg\" type=\"image/svg+xml\"/></p>\n */\nfunction mergeArrays(a, b, rootIsWildcard, mergeCache) {\n\tif (mergeCache !== null) {\n\t\tlet previous = mergeCache.get(a, b);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t\tprevious = mergeCache.get(b, a);\n\t\tif (previous !== null) {\n\t\t\treturn previous;\n\t\t}\n\t}\n\t// merge sorted payloads a + b => M\n\tlet i = 0; // walks a\n\tlet j = 0; // walks b\n\tlet k = 0; // walks target M array\n\n\tlet mergedReturnStates = [];\n\tlet mergedParents = [];\n\t// walk and merge to yield mergedParents, mergedReturnStates\n\twhile (i < a.returnStates.length && j < b.returnStates.length) {\n\t\tconst a_parent = a.parents[i];\n\t\tconst b_parent = b.parents[j];\n\t\tif (a.returnStates[i] === b.returnStates[j]) {\n\t\t\t// same payload (stack tops are equal), must yield merged singleton\n\t\t\tconst payload = a.returnStates[i];\n\t\t\t// $+$ = $\n\t\t\tconst bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&\n\t\t\t\t\ta_parent === null && b_parent === null;\n\t\t\tconst ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ax\n\t\t\tif (bothDollars || ax_ax) {\n\t\t\t\tmergedParents[k] = a_parent; // choose left\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t} else { // ax+ay -> a'[x,y]\n\t\t\t\tmergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);\n\t\t\t\tmergedReturnStates[k] = payload;\n\t\t\t}\n\t\t\ti += 1; // hop over left one as usual\n\t\t\tj += 1; // but also skip one in right side since we merge\n\t\t} else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M\n\t\t\tmergedParents[k] = a_parent;\n\t\t\tmergedReturnStates[k] = a.returnStates[i];\n\t\t\ti += 1;\n\t\t} else { // b > a, copy b[j] to M\n\t\t\tmergedParents[k] = b_parent;\n\t\t\tmergedReturnStates[k] = b.returnStates[j];\n\t\t\tj += 1;\n\t\t}\n\t\tk += 1;\n\t}\n\t// copy over any payloads remaining in either array\n\tif (i < a.returnStates.length) {\n\t\tfor (let p = i; p < a.returnStates.length; p++) {\n\t\t\tmergedParents[k] = a.parents[p];\n\t\t\tmergedReturnStates[k] = a.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t} else {\n\t\tfor (let p = j; p < b.returnStates.length; p++) {\n\t\t\tmergedParents[k] = b.parents[p];\n\t\t\tmergedReturnStates[k] = b.returnStates[p];\n\t\t\tk += 1;\n\t\t}\n\t}\n\t// trim merged if we combined a few that had same stack tops\n\tif (k < mergedParents.length) { // write index < last position; trim\n\t\tif (k === 1) { // for just one merged element, return singleton top\n\t\t\tconst a_ = SingletonPredictionContext.create(mergedParents[0],\n\t\t\t\t\tmergedReturnStates[0]);\n\t\t\tif (mergeCache !== null) {\n\t\t\t\tmergeCache.set(a, b, a_);\n\t\t\t}\n\t\t\treturn a_;\n\t\t}\n\t\tmergedParents = mergedParents.slice(0, k);\n\t\tmergedReturnStates = mergedReturnStates.slice(0, k);\n\t}\n\n\tconst M = new ArrayPredictionContext(mergedParents, mergedReturnStates);\n\n\t// if we created same array as a or b, return that instead\n\t// TODO: track whether this is possible above during merge sort for speed\n\tif (M === a) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, a);\n\t\t}\n\t\treturn a;\n\t}\n\tif (M === b) {\n\t\tif (mergeCache !== null) {\n\t\t\tmergeCache.set(a, b, b);\n\t\t}\n\t\treturn b;\n\t}\n\tcombineCommonParents(mergedParents);\n\n\tif (mergeCache !== null) {\n\t\tmergeCache.set(a, b, M);\n\t}\n\treturn M;\n}\n\n/**\n * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}\n * ones.\n */\nfunction combineCommonParents(parents) {\n\tconst uniqueParents = new Map();\n\n\tfor (let p = 0; p < parents.length; p++) {\n\t\tconst parent = parents[p];\n\t\tif (!(uniqueParents.containsKey(parent))) {\n\t\t\tuniqueParents.put(parent, parent);\n\t\t}\n\t}\n\tfor (let q = 0; q < parents.length; q++) {\n\t\tparents[q] = uniqueParents.get(parents[q]);\n\t}\n}\n\nfunction getCachedPredictionContext(context, contextCache, visited) {\n\tif (context.isEmpty()) {\n\t\treturn context;\n\t}\n\tlet existing = visited.get(context) || null;\n\tif (existing !== null) {\n\t\treturn existing;\n\t}\n\texisting = contextCache.get(context);\n\tif (existing !== null) {\n\t\tvisited.put(context, existing);\n\t\treturn existing;\n\t}\n\tlet changed = false;\n\tlet parents = [];\n\tfor (let i = 0; i < parents.length; i++) {\n\t\tconst parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);\n\t\tif (changed || parent !== context.getParent(i)) {\n\t\t\tif (!changed) {\n\t\t\t\tparents = [];\n\t\t\t\tfor (let j = 0; j < context.length; j++) {\n\t\t\t\t\tparents[j] = context.getParent(j);\n\t\t\t\t}\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tparents[i] = parent;\n\t\t}\n\t}\n\tif (!changed) {\n\t\tcontextCache.add(context);\n\t\tvisited.put(context, context);\n\t\treturn context;\n\t}\n\tlet updated = null;\n\tif (parents.length === 0) {\n\t\tupdated = PredictionContext.EMPTY;\n\t} else if (parents.length === 1) {\n\t\tupdated = SingletonPredictionContext.create(parents[0], context\n\t\t\t\t.getReturnState(0));\n\t} else {\n\t\tupdated = new ArrayPredictionContext(parents, context.returnStates);\n\t}\n\tcontextCache.add(updated);\n\tvisited.put(updated, updated);\n\tvisited.put(context, updated);\n\n\treturn updated;\n}\n\n// ter's recursive version of Sam's getAllNodes()\nfunction getAllContextNodes(context, nodes, visited) {\n\tif (nodes === null) {\n\t\tnodes = [];\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else if (visited === null) {\n\t\tvisited = new Map();\n\t\treturn getAllContextNodes(context, nodes, visited);\n\t} else {\n\t\tif (context === null || visited.containsKey(context)) {\n\t\t\treturn nodes;\n\t\t}\n\t\tvisited.put(context, context);\n\t\tnodes.push(context);\n\t\tfor (let i = 0; i < context.length; i++) {\n\t\t\tgetAllContextNodes(context.getParent(i), nodes, visited);\n\t\t}\n\t\treturn nodes;\n\t}\n}\n\nmodule.exports = {\n\tmerge,\n\tPredictionContext,\n\tPredictionContextCache,\n\tSingletonPredictionContext,\n\tpredictionContextFromRuleContext,\n\tgetCachedPredictionContext\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/PredictionContext.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/Recognizer.js":
/*!******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/Recognizer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst {ConsoleErrorListener} = __webpack_require__(/*! ./error/ErrorListener */ \"./node_modules/antlr4/src/antlr4/error/ErrorListener.js\");\nconst {ProxyErrorListener} = __webpack_require__(/*! ./error/ErrorListener */ \"./node_modules/antlr4/src/antlr4/error/ErrorListener.js\");\n\nclass Recognizer {\n    constructor() {\n        this._listeners = [ ConsoleErrorListener.INSTANCE ];\n        this._interp = null;\n        this._stateNumber = -1;\n    }\n\n    checkVersion(toolVersion) {\n        const runtimeVersion = \"4.9.2\";\n        if (runtimeVersion!==toolVersion) {\n            console.log(\"ANTLR runtime and generated code versions disagree: \"+runtimeVersion+\"!=\"+toolVersion);\n        }\n    }\n\n    addErrorListener(listener) {\n        this._listeners.push(listener);\n    }\n\n    removeErrorListeners() {\n        this._listeners = [];\n    }\n\n    getTokenTypeMap() {\n        const tokenNames = this.getTokenNames();\n        if (tokenNames===null) {\n            throw(\"The current recognizer does not provide a list of token names.\");\n        }\n        let result = this.tokenTypeMapCache[tokenNames];\n        if(result===undefined) {\n            result = tokenNames.reduce(function(o, k, i) { o[k] = i; });\n            result.EOF = Token.EOF;\n            this.tokenTypeMapCache[tokenNames] = result;\n        }\n        return result;\n    }\n\n    /**\n     * Get a map from rule names to rule indexes.\n     * <p>Used for XPath and tree pattern compilation.</p>\n     */\n    getRuleIndexMap() {\n        const ruleNames = this.ruleNames;\n        if (ruleNames===null) {\n            throw(\"The current recognizer does not provide a list of rule names.\");\n        }\n        let result = this.ruleIndexMapCache[ruleNames]; // todo: should it be Recognizer.ruleIndexMapCache ?\n        if(result===undefined) {\n            result = ruleNames.reduce(function(o, k, i) { o[k] = i; });\n            this.ruleIndexMapCache[ruleNames] = result;\n        }\n        return result;\n    }\n\n    getTokenType(tokenName) {\n        const ttype = this.getTokenTypeMap()[tokenName];\n        if (ttype !==undefined) {\n            return ttype;\n        } else {\n            return Token.INVALID_TYPE;\n        }\n    }\n\n    // What is the error header, normally line/character position information?\n    getErrorHeader(e) {\n        const line = e.getOffendingToken().line;\n        const column = e.getOffendingToken().column;\n        return \"line \" + line + \":\" + column;\n    }\n\n    /**\n     * How should a token be displayed in an error message? The default\n     * is to display just the text, but during development you might\n     * want to have a lot of information spit out.  Override in that case\n     * to use t.toString() (which, for CommonToken, dumps everything about\n     * the token). This is better than forcing you to override a method in\n     * your token objects because you don't have to go modify your lexer\n     * so that it creates a new Java type.\n     *\n     * @deprecated This method is not called by the ANTLR 4 Runtime. Specific\n     * implementations of {@link ANTLRErrorStrategy} may provide a similar\n     * feature when necessary. For example, see\n     * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/\n    getTokenErrorDisplay(t) {\n        if (t===null) {\n            return \"<no token>\";\n        }\n        let s = t.text;\n        if (s===null) {\n            if (t.type===Token.EOF) {\n                s = \"<EOF>\";\n            } else {\n                s = \"<\" + t.type + \">\";\n            }\n        }\n        s = s.replace(\"\\n\",\"\\\\n\").replace(\"\\r\",\"\\\\r\").replace(\"\\t\",\"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n\n    getErrorListenerDispatch() {\n        return new ProxyErrorListener(this._listeners);\n    }\n\n    /**\n     * subclass needs to override these if there are sempreds or actions\n     * that the ATN interp needs to execute\n     */\n    sempred(localctx, ruleIndex, actionIndex) {\n        return true;\n    }\n\n    precpred(localctx , precedence) {\n        return true;\n    }\n\n    get state(){\n        return this._stateNumber;\n    }\n\n    set state(state) {\n        this._stateNumber = state;\n    }\n}\n\nRecognizer.tokenTypeMapCache = {};\nRecognizer.ruleIndexMapCache = {};\n\nmodule.exports = Recognizer;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/Recognizer.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/RuleContext.js":
/*!*******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/RuleContext.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {RuleNode} = __webpack_require__(/*! ./tree/Tree */ \"./node_modules/antlr4/src/antlr4/tree/Tree.js\");\nconst {INVALID_INTERVAL} = __webpack_require__(/*! ./tree/Tree */ \"./node_modules/antlr4/src/antlr4/tree/Tree.js\");\nconst Trees = __webpack_require__(/*! ./tree/Trees */ \"./node_modules/antlr4/src/antlr4/tree/Trees.js\");\n\nclass RuleContext extends RuleNode {\n\t/** A rule context is a record of a single rule invocation. It knows\n\t * which context invoked it, if any. If there is no parent context, then\n\t * naturally the invoking state is not valid.  The parent link\n\t * provides a chain upwards from the current rule invocation to the root\n\t * of the invocation tree, forming a stack. We actually carry no\n\t * information about the rule associated with this context (except\n\t * when parsing). We keep only the state number of the invoking state from\n\t * the ATN submachine that invoked this. Contrast this with the s\n\t * pointer inside ParserRuleContext that tracks the current state\n\t * being \"executed\" for the current rule.\n\t *\n\t * The parent contexts are useful for computing lookahead sets and\n\t * getting error information.\n\t *\n\t * These objects are used during parsing and prediction.\n\t * For the special case of parsers, we use the subclass\n\t * ParserRuleContext.\n\t *\n\t * @see ParserRuleContext\n\t */\n\tconstructor(parent, invokingState) {\n\t\t// What context invoked this rule?\n\t\tsuper();\n\t\tthis.parentCtx = parent || null;\n\t\t/**\n\t\t * What state invoked the rule associated with this context?\n\t\t * The \"return address\" is the followState of invokingState\n\t\t * If parent is null, this should be -1.\n\t\t */\n\t\tthis.invokingState = invokingState || -1;\n\t}\n\n\tdepth() {\n\t\tlet n = 0;\n\t\tlet p = this;\n\t\twhile (p !== null) {\n\t\t\tp = p.parentCtx;\n\t\t\tn += 1;\n\t\t}\n\t\treturn n;\n\t}\n\n\t/**\n\t * A context is empty if there is no invoking state; meaning nobody call\n\t * current context.\n\t */\n\tisEmpty() {\n\t\treturn this.invokingState === -1;\n\t}\n\n// satisfy the ParseTree / SyntaxTree interface\n\tgetSourceInterval() {\n\t\treturn INVALID_INTERVAL;\n\t}\n\n\tgetRuleContext() {\n\t\treturn this;\n\t}\n\n\tgetPayload() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the combined text of all child nodes. This method only considers\n\t * tokens which have been added to the parse tree.\n\t * <p>\n\t * Since tokens on hidden channels (e.g. whitespace or comments) are not\n\t * added to the parse trees, they will not appear in the output of this\n\t * method.\n\t */\n\tgetText() {\n\t\tif (this.getChildCount() === 0) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn this.children.map(function(child) {\n\t\t\t\treturn child.getText();\n\t\t\t}).join(\"\");\n\t\t}\n\t}\n\n\t/**\n\t * For rule associated with this parse tree internal node, return\n\t * the outer alternative number used to match the input. Default\n\t * implementation does not compute nor store this alt num. Create\n\t * a subclass of ParserRuleContext with backing field and set\n\t * option contextSuperClass.\n\t * to set it.\n\t */\n\tgetAltNumber() {\n\t    // use constant value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n\t    return 0;\n    }\n\n\t/**\n\t * Set the outer alternative number for this context node. Default\n\t * implementation does nothing to avoid backing field overhead for\n\t * trees that don't need it.  Create\n\t * a subclass of ParserRuleContext with backing field and set\n\t * option contextSuperClass.\n\t */\n\tsetAltNumber(altNumber) { }\n\n\tgetChild(i) {\n\t\treturn null;\n\t}\n\n\tgetChildCount() {\n\t\treturn 0;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitChildren(this);\n\t}\n\n\t/**\n\t * Print out a whole tree, not just a node, in LISP format\n\t * (root child1 .. childN). Print just a node if this is a leaf.\n\t */\n\ttoStringTree(ruleNames, recog) {\n\t\treturn Trees.toStringTree(this, ruleNames, recog);\n\t}\n\n\ttoString(ruleNames, stop) {\n\t\truleNames = ruleNames || null;\n\t\tstop = stop || null;\n\t\tlet p = this;\n\t\tlet s = \"[\";\n\t\twhile (p !== null && p !== stop) {\n\t\t\tif (ruleNames === null) {\n\t\t\t\tif (!p.isEmpty()) {\n\t\t\t\t\ts += p.invokingState;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst ri = p.ruleIndex;\n\t\t\t\tconst ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]\n\t\t\t\t\t\t: \"\" + ri;\n\t\t\t\ts += ruleName;\n\t\t\t}\n\t\t\tif (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {\n\t\t\t\ts += \" \";\n\t\t\t}\n\t\t\tp = p.parentCtx;\n\t\t}\n\t\ts += \"]\";\n\t\treturn s;\n\t}\n}\n\nmodule.exports = RuleContext;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/RuleContext.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/Token.js":
/*!*************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/Token.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * A token has properties: text, type, line, character position in the line\n * (so we can ignore tabs), token channel, index, and source from which\n * we obtained this token.\n */\nclass Token {\n\tconstructor() {\n\t\tthis.source = null;\n\t\tthis.type = null; // token type of the token\n\t\tthis.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL\n\t\tthis.start = null; // optional; return -1 if not implemented.\n\t\tthis.stop = null; // optional; return -1 if not implemented.\n\t\tthis.tokenIndex = null; // from 0..n-1 of the token object in the input stream\n\t\tthis.line = null; // line=1..n of the 1st character\n\t\tthis.column = null; // beginning of the line at which it occurs, 0..n-1\n\t\tthis._text = null; // text of the token.\n\t}\n\n\tgetTokenSource() {\n\t\treturn this.source[0];\n\t}\n\n\tgetInputStream() {\n\t\treturn this.source[1];\n\t}\n\n\tget text(){\n\t\treturn this._text;\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\nToken.INVALID_TYPE = 0;\n\n/**\n * During lookahead operations, this \"token\" signifies we hit rule end ATN state\n * and did not follow it despite needing to.\n */\nToken.EPSILON = -2;\n\nToken.MIN_USER_TOKEN_TYPE = 1;\n\nToken.EOF = -1;\n\n/**\n * All tokens go to the parser (unless skip() is called in that rule)\n * on a particular \"channel\". The parser tunes to a particular channel\n * so that whitespace etc... can go to the parser on a \"hidden\" channel.\n */\nToken.DEFAULT_CHANNEL = 0;\n\n/**\n * Anything on different channel than DEFAULT_CHANNEL is not parsed\n * by parser.\n */\nToken.HIDDEN_CHANNEL = 1;\n\n\nclass CommonToken extends Token {\n\tconstructor(source, type, channel, start, stop) {\n\t\tsuper();\n\t\tthis.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;\n\t\tthis.type = type !== undefined ? type : null;\n\t\tthis.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;\n\t\tthis.start = start !== undefined ? start : -1;\n\t\tthis.stop = stop !== undefined ? stop : -1;\n\t\tthis.tokenIndex = -1;\n\t\tif (this.source[0] !== null) {\n\t\t\tthis.line = source[0].line;\n\t\t\tthis.column = source[0].column;\n\t\t} else {\n\t\t\tthis.column = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n\t *\n\t * <p>\n\t * If {@code oldToken} is also a {@link CommonToken} instance, the newly\n\t * constructed token will share a reference to the {@link //text} field and\n\t * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will\n\t * be assigned the result of calling {@link //getText}, and {@link //source}\n\t * will be constructed from the result of {@link Token//getTokenSource} and\n\t * {@link Token//getInputStream}.</p>\n\t *\n\t * @param oldToken The token to copy.\n\t */\n\tclone() {\n\t\tconst t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);\n\t\tt.tokenIndex = this.tokenIndex;\n\t\tt.line = this.line;\n\t\tt.column = this.column;\n\t\tt.text = this.text;\n\t\treturn t;\n\t}\n\n\ttoString() {\n\t\tlet txt = this.text;\n\t\tif (txt !== null) {\n\t\t\ttxt = txt.replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\");\n\t\t} else {\n\t\t\ttxt = \"<no text>\";\n\t\t}\n\t\treturn \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" +\n\t\t\t\ttxt + \"',<\" + this.type + \">\" +\n\t\t\t\t(this.channel > 0 ? \",channel=\" + this.channel : \"\") + \",\" +\n\t\t\t\tthis.line + \":\" + this.column + \"]\";\n\t}\n\n\tget text(){\n\t\tif (this._text !== null) {\n\t\t\treturn this._text;\n\t\t}\n\t\tconst input = this.getInputStream();\n\t\tif (input === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst n = input.size;\n\t\tif (this.start < n && this.stop < n) {\n\t\t\treturn input.getText(this.start, this.stop);\n\t\t} else {\n\t\t\treturn \"<EOF>\";\n\t\t}\n\t}\n\n\tset text(text) {\n\t\tthis._text = text;\n\t}\n}\n\n/**\n * An empty {@link Pair} which is used as the default value of\n * {@link //source} for tokens that do not have a source.\n */\nCommonToken.EMPTY_SOURCE = [ null, null ];\n\nmodule.exports = {\n\tToken,\n\tCommonToken\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/Token.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/Utils.js":
/*!*************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/Utils.js ***!
  \*************************************************/
/***/ ((module) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nfunction arrayToString(a) {\n    return Array.isArray(a) ? (\"[\" + a.join(\", \") + \"]\") : \"null\";\n}\n\nString.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));\n\nString.prototype.hashCode = function () {\n    const key = this.toString();\n    let h1b, k1;\n\n    const remainder = key.length & 3; // key.length % 4\n    const bytes = key.length - remainder;\n    let h1 = String.prototype.seed;\n    const c1 = 0xcc9e2d51;\n    const c2 = 0x1b873593;\n    let i = 0;\n\n    while (i < bytes) {\n        k1 =\n            ((key.charCodeAt(i) & 0xff)) |\n            ((key.charCodeAt(++i) & 0xff) << 8) |\n            ((key.charCodeAt(++i) & 0xff) << 16) |\n            ((key.charCodeAt(++i) & 0xff) << 24);\n        ++i;\n\n        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n        k1 = (k1 << 15) | (k1 >>> 17);\n        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n        h1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n    }\n\n    k1 = 0;\n\n    switch (remainder) {\n        case 3:\n            k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            k1 ^= (key.charCodeAt(i) & 0xff);\n\n            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n            k1 = (k1 << 15) | (k1 >>> 17);\n            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n            h1 ^= k1;\n    }\n\n    h1 ^= key.length;\n\n    h1 ^= h1 >>> 16;\n    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n    h1 ^= h1 >>> 13;\n    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n    h1 ^= h1 >>> 16;\n\n    return h1 >>> 0;\n};\n\nfunction standardEqualsFunction(a, b) {\n    return a ? a.equals(b) : a==b;\n}\n\nfunction standardHashCodeFunction(a) {\n    return a ? a.hashCode() : -1;\n}\n\nclass Set {\n    constructor(hashFunction, equalsFunction) {\n        this.data = {};\n        this.hashFunction = hashFunction || standardHashCodeFunction;\n        this.equalsFunction = equalsFunction || standardEqualsFunction;\n    }\n\n    add(value) {\n        const hash = this.hashFunction(value);\n        const key = \"hash_\" + hash;\n        if (key in this.data) {\n            const values = this.data[key];\n            for (let i = 0; i < values.length; i++) {\n                if (this.equalsFunction(value, values[i])) {\n                    return values[i];\n                }\n            }\n            values.push(value);\n            return value;\n        } else {\n            this.data[key] = [value];\n            return value;\n        }\n    }\n\n    contains(value) {\n        return this.get(value) != null;\n    }\n\n    get(value) {\n        const hash = this.hashFunction(value);\n        const key = \"hash_\" + hash;\n        if (key in this.data) {\n            const values = this.data[key];\n            for (let i = 0; i < values.length; i++) {\n                if (this.equalsFunction(value, values[i])) {\n                    return values[i];\n                }\n            }\n        }\n        return null;\n    }\n\n    values() {\n        let l = [];\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l.concat(this.data[key]);\n            }\n        }\n        return l;\n    }\n\n    toString() {\n        return arrayToString(this.values());\n    }\n\n    get length(){\n        let l = 0;\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l + this.data[key].length;\n            }\n        }\n        return l;\n    }\n}\n\n\nclass BitSet {\n    constructor() {\n        this.data = [];\n    }\n\n    add(value) {\n        this.data[value] = true;\n    }\n\n    or(set) {\n        const bits = this;\n        Object.keys(set.data).map(function (alt) {\n            bits.add(alt);\n        });\n    }\n\n    remove(value) {\n        delete this.data[value];\n    }\n\n    contains(value) {\n        return this.data[value] === true;\n    }\n\n    values() {\n        return Object.keys(this.data);\n    }\n\n    minValue() {\n        return Math.min.apply(null, this.values());\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        hash.update(this.values());\n        return hash.finish();\n    }\n\n    equals(other) {\n        if (!(other instanceof BitSet)) {\n            return false;\n        }\n        return this.hashCode() === other.hashCode();\n    }\n\n    toString() {\n        return \"{\" + this.values().join(\", \") + \"}\";\n    }\n\n    get length(){\n        return this.values().length;\n    }\n}\n\n\nclass Map {\n    constructor(hashFunction, equalsFunction) {\n        this.data = {};\n        this.hashFunction = hashFunction || standardHashCodeFunction;\n        this.equalsFunction = equalsFunction || standardEqualsFunction;\n    }\n\n    put(key, value) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if (hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key)) {\n                    const oldValue = entry.value;\n                    entry.value = value;\n                    return oldValue;\n                }\n            }\n            entries.push({key:key, value:value});\n            return value;\n        } else {\n            this.data[hashKey] = [{key:key, value:value}];\n            return value;\n        }\n    }\n\n    containsKey(key) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if(hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    get(key) {\n        const hashKey = \"hash_\" + this.hashFunction(key);\n        if(hashKey in this.data) {\n            const entries = this.data[hashKey];\n            for (let i = 0; i < entries.length; i++) {\n                const entry = entries[i];\n                if (this.equalsFunction(key, entry.key))\n                    return entry.value;\n            }\n        }\n        return null;\n    }\n\n    entries() {\n        let l = [];\n        for (const key in this.data) {\n            if (key.indexOf(\"hash_\") === 0) {\n                l = l.concat(this.data[key]);\n            }\n        }\n        return l;\n    }\n\n    getKeys() {\n        return this.entries().map(function(e) {\n            return e.key;\n        });\n    }\n\n    getValues() {\n        return this.entries().map(function(e) {\n                return e.value;\n        });\n    }\n\n    toString() {\n        const ss = this.entries().map(function(entry) {\n            return '{' + entry.key + ':' + entry.value + '}';\n        });\n        return '[' + ss.join(\", \") + ']';\n    }\n\n    get length(){\n        let l = 0;\n        for (const hashKey in this.data) {\n            if (hashKey.indexOf(\"hash_\") === 0) {\n                l = l + this.data[hashKey].length;\n            }\n        }\n        return l;\n    }\n}\n\n\nclass AltDict {\n    constructor() {\n        this.data = {};\n    }\n\n    get(key) {\n        key = \"k-\" + key;\n        if (key in this.data) {\n            return this.data[key];\n        } else {\n            return null;\n        }\n    }\n\n    put(key, value) {\n        key = \"k-\" + key;\n        this.data[key] = value;\n    }\n\n    values() {\n        const data = this.data;\n        const keys = Object.keys(this.data);\n        return keys.map(function (key) {\n            return data[key];\n        });\n    }\n}\n\n\nclass DoubleDict {\n    constructor(defaultMapCtor) {\n        this.defaultMapCtor = defaultMapCtor || Map;\n        this.cacheMap = new this.defaultMapCtor();\n    }\n\n    get(a, b) {\n        const d = this.cacheMap.get(a) || null;\n        return d === null ? null : (d.get(b) || null);\n    }\n\n    set(a, b, o) {\n        let d = this.cacheMap.get(a) || null;\n        if (d === null) {\n            d = new this.defaultMapCtor();\n            this.cacheMap.put(a, d);\n        }\n        d.put(b, o);\n    }\n}\n\nclass Hash {\n    constructor() {\n        this.count = 0;\n        this.hash = 0;\n    }\n\n    update() {\n        for(let i=0;i<arguments.length;i++) {\n            const value = arguments[i];\n            if (value == null)\n                continue;\n            if(Array.isArray(value))\n                this.update.apply(this, value);\n            else {\n                let k = 0;\n                switch (typeof(value)) {\n                    case 'undefined':\n                    case 'function':\n                        continue;\n                    case 'number':\n                    case 'boolean':\n                        k = value;\n                        break;\n                    case 'string':\n                        k = value.hashCode();\n                        break;\n                    default:\n                        if(value.updateHashCode)\n                            value.updateHashCode(this);\n                        else\n                            console.log(\"No updateHashCode for \" + value.toString())\n                        continue;\n                }\n                k = k * 0xCC9E2D51;\n                k = (k << 15) | (k >>> (32 - 15));\n                k = k * 0x1B873593;\n                this.count = this.count + 1;\n                let hash = this.hash ^ k;\n                hash = (hash << 13) | (hash >>> (32 - 13));\n                hash = hash * 5 + 0xE6546B64;\n                this.hash = hash;\n            }\n        }\n    }\n\n    finish() {\n        let hash = this.hash ^ (this.count * 4);\n        hash = hash ^ (hash >>> 16);\n        hash = hash * 0x85EBCA6B;\n        hash = hash ^ (hash >>> 13);\n        hash = hash * 0xC2B2AE35;\n        hash = hash ^ (hash >>> 16);\n        return hash;\n    }\n}\n\nfunction hashStuff() {\n    const hash = new Hash();\n    hash.update.apply(hash, arguments);\n    return hash.finish();\n}\n\n\nfunction escapeWhitespace(s, escapeSpaces) {\n    s = s.replace(/\\t/g, \"\\\\t\")\n         .replace(/\\n/g, \"\\\\n\")\n         .replace(/\\r/g, \"\\\\r\");\n    if (escapeSpaces) {\n        s = s.replace(/ /g, \"\\u00B7\");\n    }\n    return s;\n}\n\nfunction titleCase(str) {\n    return str.replace(/\\w\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1);\n    });\n}\n\nfunction equalArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b))\n        return false;\n    if (a === b)\n        return true;\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] === b[i])\n            continue;\n        if (!a[i].equals || !a[i].equals(b[i]))\n            return false;\n    }\n    return true;\n}\n\nmodule.exports = {\n    Hash,\n    Set,\n    Map,\n    BitSet,\n    AltDict,\n    DoubleDict,\n    hashStuff,\n    escapeWhitespace,\n    arrayToString,\n    titleCase,\n    equalArrays\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/Utils.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/ATN.js":
/*!***************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/ATN.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst LL1Analyzer = __webpack_require__(/*! ./../LL1Analyzer */ \"./node_modules/antlr4/src/antlr4/LL1Analyzer.js\");\nconst {IntervalSet} = __webpack_require__(/*! ./../IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\");\nconst {Token} = __webpack_require__(/*! ./../Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\n\nclass ATN {\n\n    constructor(grammarType , maxTokenType) {\n        /**\n         * Used for runtime deserialization of ATNs from strings\n         * The type of the ATN.\n        */\n        this.grammarType = grammarType;\n        // The maximum value for any symbol recognized by a transition in the ATN.\n        this.maxTokenType = maxTokenType;\n        this.states = [];\n        /**\n         * Each subrule/rule is a decision point and we must track them so we\n         * can go back later and build DFA predictors for them.  This includes\n         * all the rules, subrules, optional blocks, ()+, ()* etc...\n         */\n        this.decisionToState = [];\n        // Maps from rule index to starting state number.\n        this.ruleToStartState = [];\n        // Maps from rule index to stop state number.\n        this.ruleToStopState = null;\n        this.modeNameToStartState = {};\n        /**\n         * For lexer ATNs, this maps the rule index to the resulting token type.\n         * For parser ATNs, this maps the rule index to the generated bypass token\n         * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}\n         * deserialization option was specified; otherwise, this is {@code null}\n         */\n        this.ruleToTokenType = null;\n        /**\n         * For lexer ATNs, this is an array of {@link LexerAction} objects which may\n         * be referenced by action transitions in the ATN\n         */\n        this.lexerActions = null;\n        this.modeToStartState = [];\n    }\n\n    /**\n     * Compute the set of valid tokens that can occur starting in state {@code s}.\n     * If {@code ctx} is null, the set of tokens will not include what can follow\n     * the rule surrounding {@code s}. In other words, the set will be\n     * restricted to tokens reachable staying within {@code s}'s rule\n     */\n    nextTokensInContext(s, ctx) {\n        const anal = new LL1Analyzer(this);\n        return anal.LOOK(s, null, ctx);\n    }\n\n    /**\n     * Compute the set of valid tokens that can occur starting in {@code s} and\n     * staying in same rule. {@link Token//EPSILON} is in set if we reach end of\n     * rule\n     */\n    nextTokensNoContext(s) {\n        if (s.nextTokenWithinRule !== null ) {\n            return s.nextTokenWithinRule;\n        }\n        s.nextTokenWithinRule = this.nextTokensInContext(s, null);\n        s.nextTokenWithinRule.readOnly = true;\n        return s.nextTokenWithinRule;\n    }\n\n    nextTokens(s, ctx) {\n        if ( ctx===undefined ) {\n            return this.nextTokensNoContext(s);\n        } else {\n            return this.nextTokensInContext(s, ctx);\n        }\n    }\n\n    addState(state) {\n        if ( state !== null ) {\n            state.atn = this;\n            state.stateNumber = this.states.length;\n        }\n        this.states.push(state);\n    }\n\n    removeState(state) {\n        this.states[state.stateNumber] = null; // just free mem, don't shift states in list\n    }\n\n    defineDecisionState(s) {\n        this.decisionToState.push(s);\n        s.decision = this.decisionToState.length-1;\n        return s.decision;\n    }\n\n    getDecisionState(decision) {\n        if (this.decisionToState.length===0) {\n            return null;\n        } else {\n            return this.decisionToState[decision];\n        }\n    }\n\n    /**\n     * Computes the set of input symbols which could follow ATN state number\n     * {@code stateNumber} in the specified full {@code context}. This method\n     * considers the complete parser context, but does not evaluate semantic\n     * predicates (i.e. all predicates encountered during the calculation are\n     * assumed true). If a path in the ATN exists from the starting state to the\n     * {@link RuleStopState} of the outermost context without matching any\n     * symbols, {@link Token//EOF} is added to the returned set.\n     *\n     * <p>If {@code context} is {@code null}, it is treated as\n     * {@link ParserRuleContext//EMPTY}.</p>\n     *\n     * @param stateNumber the ATN state number\n     * @param ctx the full parse context\n     *\n     * @return {IntervalSet} The set of potentially valid input symbols which could follow the\n     * specified state in the specified context.\n     *\n     * @throws IllegalArgumentException if the ATN does not contain a state with\n     * number {@code stateNumber}\n     */\n    getExpectedTokens(stateNumber, ctx ) {\n        if ( stateNumber < 0 || stateNumber >= this.states.length ) {\n            throw(\"Invalid state number.\");\n        }\n        const s = this.states[stateNumber];\n        let following = this.nextTokens(s);\n        if (!following.contains(Token.EPSILON)) {\n            return following;\n        }\n        const expected = new IntervalSet();\n        expected.addSet(following);\n        expected.removeOne(Token.EPSILON);\n        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n            const invokingState = this.states[ctx.invokingState];\n            const rt = invokingState.transitions[0];\n            following = this.nextTokens(rt.followState);\n            expected.addSet(following);\n            expected.removeOne(Token.EPSILON);\n            ctx = ctx.parentCtx;\n        }\n        if (following.contains(Token.EPSILON)) {\n            expected.addOne(Token.EOF);\n        }\n        return expected;\n    }\n}\n\nATN.INVALID_ALT_NUMBER = 0;\n\nmodule.exports = ATN;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/ATN.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/ATNConfig.js":
/*!*********************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/ATNConfig.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {DecisionState} = __webpack_require__(/*! ./ATNState */ \"./node_modules/antlr4/src/antlr4/atn/ATNState.js\");\nconst {SemanticContext} = __webpack_require__(/*! ./SemanticContext */ \"./node_modules/antlr4/src/antlr4/atn/SemanticContext.js\");\nconst {Hash} = __webpack_require__(/*! ../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\n\n\nfunction checkParams(params, isCfg) {\n\tif(params===null) {\n\t\tconst result = { state:null, alt:null, context:null, semanticContext:null };\n\t\tif(isCfg) {\n\t\t\tresult.reachesIntoOuterContext = 0;\n\t\t}\n\t\treturn result;\n\t} else {\n\t\tconst props = {};\n\t\tprops.state = params.state || null;\n\t\tprops.alt = (params.alt === undefined) ? null : params.alt;\n\t\tprops.context = params.context || null;\n\t\tprops.semanticContext = params.semanticContext || null;\n\t\tif(isCfg) {\n\t\t\tprops.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;\n\t\t\tprops.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;\n\t\t}\n\t\treturn props;\n\t}\n}\n\nclass ATNConfig {\n    /**\n     * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).\n     * The syntactic context is a graph-structured stack node whose\n     * path(s) to the root is the rule invocation(s)\n     * chain used to arrive at the state.  The semantic context is\n     * the tree of semantic predicates encountered before reaching\n     * an ATN state\n     */\n    constructor(params, config) {\n        this.checkContext(params, config);\n        params = checkParams(params);\n        config = checkParams(config, true);\n        // The ATN state associated with this configuration///\n        this.state = params.state!==null ? params.state : config.state;\n        // What alt (or lexer rule) is predicted by this configuration///\n        this.alt = params.alt!==null ? params.alt : config.alt;\n        /**\n         * The stack of invoking states leading to the rule/states associated\n         * with this config.  We track only those contexts pushed during\n         * execution of the ATN simulator\n         */\n        this.context = params.context!==null ? params.context : config.context;\n        this.semanticContext = params.semanticContext!==null ? params.semanticContext :\n            (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);\n        // TODO: make it a boolean then\n        /**\n         * We cannot execute predicates dependent upon local context unless\n         * we know for sure we are in the correct context. Because there is\n         * no way to do this efficiently, we simply cannot evaluate\n         * dependent predicates unless we are in the rule that initially\n         * invokes the ATN simulator.\n         * closure() tracks the depth of how far we dip into the\n         * outer context: depth &gt; 0.  Note that it may not be totally\n         * accurate depth since I don't ever decrement\n         */\n        this.reachesIntoOuterContext = config.reachesIntoOuterContext;\n        this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;\n    }\n\n    checkContext(params, config) {\n        if((params.context===null || params.context===undefined) &&\n                (config===null || config.context===null || config.context===undefined)) {\n            this.context = null;\n        }\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        this.updateHashCode(hash);\n        return hash.finish();\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);\n    }\n\n    /**\n     * An ATN configuration is equal to another if both have\n     * the same state, they predict the same alternative, and\n     * syntactic/semantic contexts are the same\n     */\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof ATNConfig)) {\n            return false;\n        } else {\n            return this.state.stateNumber===other.state.stateNumber &&\n                this.alt===other.alt &&\n                (this.context===null ? other.context===null : this.context.equals(other.context)) &&\n                this.semanticContext.equals(other.semanticContext) &&\n                this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;\n        }\n    }\n\n    hashCodeForConfigSet() {\n        const hash = new Hash();\n        hash.update(this.state.stateNumber, this.alt, this.semanticContext);\n        return hash.finish();\n    }\n\n    equalsForConfigSet(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof ATNConfig)) {\n            return false;\n        } else {\n            return this.state.stateNumber===other.state.stateNumber &&\n                this.alt===other.alt &&\n                this.semanticContext.equals(other.semanticContext);\n        }\n    }\n\n    toString() {\n        return \"(\" + this.state + \",\" + this.alt +\n            (this.context!==null ? \",[\" + this.context.toString() + \"]\" : \"\") +\n            (this.semanticContext !== SemanticContext.NONE ?\n                    (\",\" + this.semanticContext.toString())\n                    : \"\") +\n            (this.reachesIntoOuterContext>0 ?\n                    (\",up=\" + this.reachesIntoOuterContext)\n                    : \"\") + \")\";\n    }\n}\n\n\nclass LexerATNConfig extends ATNConfig {\n    constructor(params, config) {\n        super(params, config);\n\n        // This is the backing field for {@link //getLexerActionExecutor}.\n        const lexerActionExecutor = params.lexerActionExecutor || null;\n        this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);\n        this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;\n        this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;\n        this.equalsForConfigSet = LexerATNConfig.prototype.equals;\n        return this;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);\n    }\n\n    equals(other) {\n        return this === other ||\n                (other instanceof LexerATNConfig &&\n                this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision &&\n                (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&\n                super.equals(other));\n    }\n\n    checkNonGreedyDecision(source, target) {\n        return source.passedThroughNonGreedyDecision ||\n            (target instanceof DecisionState) && target.nonGreedy;\n    }\n}\n\n\nmodule.exports.ATNConfig = ATNConfig;\nmodule.exports.LexerATNConfig = LexerATNConfig;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/ATNConfig.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js":
/*!************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst ATN = __webpack_require__(/*! ./ATN */ \"./node_modules/antlr4/src/antlr4/atn/ATN.js\");\nconst Utils = __webpack_require__(/*! ./../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\nconst {SemanticContext} = __webpack_require__(/*! ./SemanticContext */ \"./node_modules/antlr4/src/antlr4/atn/SemanticContext.js\");\nconst {merge} = __webpack_require__(/*! ./../PredictionContext */ \"./node_modules/antlr4/src/antlr4/PredictionContext.js\");\n\nfunction hashATNConfig(c) {\n\treturn c.hashCodeForConfigSet();\n}\n\nfunction equalATNConfigs(a, b) {\n\tif ( a===b ) {\n\t\treturn true;\n\t} else if ( a===null || b===null ) {\n\t\treturn false;\n\t} else\n       return a.equalsForConfigSet(b);\n }\n\n/**\n * Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track\n * info about the set, with support for combining similar configurations using a\n * graph-structured stack\n */\nclass ATNConfigSet {\n\tconstructor(fullCtx) {\n\t\t/**\n\t\t * The reason that we need this is because we don't want the hash map to use\n\t\t * the standard hash code and equals. We need all configurations with the\n\t\t * same\n\t\t * {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively\n\t\t * doubles\n\t\t * the number of objects associated with ATNConfigs. The other solution is\n\t\t * to\n\t\t * use a hash table that lets us specify the equals/hashcode operation.\n\t\t * All configs but hashed by (s, i, _, pi) not including context. Wiped out\n\t\t * when we go readonly as this set becomes a DFA state\n\t\t */\n\t\tthis.configLookup = new Utils.Set(hashATNConfig, equalATNConfigs);\n\t\t/**\n\t\t * Indicates that this configuration set is part of a full context\n\t\t * LL prediction. It will be used to determine how to merge $. With SLL\n\t\t * it's a wildcard whereas it is not for LL context merge\n\t\t */\n\t\tthis.fullCtx = fullCtx === undefined ? true : fullCtx;\n\t\t/**\n\t\t * Indicates that the set of configurations is read-only. Do not\n\t\t * allow any code to manipulate the set; DFA states will point at\n\t\t * the sets and they must not change. This does not protect the other\n\t\t * fields; in particular, conflictingAlts is set after\n\t\t * we've made this readonly\n\t\t */\n\t\tthis.readOnly = false;\n\t\t// Track the elements as they are added to the set; supports get(i)///\n\t\tthis.configs = [];\n\n\t\t// TODO: these fields make me pretty uncomfortable but nice to pack up info\n\t\t// together, saves recomputation\n\t\t// TODO: can we track conflicts as they are added to save scanning configs\n\t\t// later?\n\t\tthis.uniqueAlt = 0;\n\t\tthis.conflictingAlts = null;\n\n\t\t/**\n\t\t * Used in parser and lexer. In lexer, it indicates we hit a pred\n\t\t * while computing a closure operation. Don't make a DFA state from this\n\t\t */\n\t\tthis.hasSemanticContext = false;\n\t\tthis.dipsIntoOuterContext = false;\n\n\t\tthis.cachedHashCode = -1;\n\t}\n\n\t/**\n\t * Adding a new config means merging contexts with existing configs for\n\t * {@code (s, i, pi, _)}, where {@code s} is the\n\t * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and\n\t * {@code pi} is the {@link ATNConfig//semanticContext}. We use\n\t * {@code (s,i,pi)} as key.\n\t *\n\t * <p>This method updates {@link //dipsIntoOuterContext} and\n\t * {@link //hasSemanticContext} when necessary.</p>\n\t */\n\tadd(config, mergeCache) {\n\t\tif (mergeCache === undefined) {\n\t\t\tmergeCache = null;\n\t\t}\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tif (config.semanticContext !== SemanticContext.NONE) {\n\t\t\tthis.hasSemanticContext = true;\n\t\t}\n\t\tif (config.reachesIntoOuterContext > 0) {\n\t\t\tthis.dipsIntoOuterContext = true;\n\t\t}\n\t\tconst existing = this.configLookup.add(config);\n\t\tif (existing === config) {\n\t\t\tthis.cachedHashCode = -1;\n\t\t\tthis.configs.push(config); // track order here\n\t\t\treturn true;\n\t\t}\n\t\t// a previous (s,i,pi,_), merge with it and save result\n\t\tconst rootIsWildcard = !this.fullCtx;\n\t\tconst merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);\n\t\t/**\n\t\t * no need to check for existing.context, config.context in cache\n\t\t * since only way to create new graphs is \"call rule\" and here. We\n\t\t * cache at both places\n\t\t */\n\t\texisting.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);\n\t\t// make sure to preserve the precedence filter suppression during the merge\n\t\tif (config.precedenceFilterSuppressed) {\n\t\t\texisting.precedenceFilterSuppressed = true;\n\t\t}\n\t\texisting.context = merged; // replace context; no need to alt mapping\n\t\treturn true;\n\t}\n\n\tgetStates() {\n\t\tconst states = new Utils.Set();\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tstates.add(this.configs[i].state);\n\t\t}\n\t\treturn states;\n\t}\n\n\tgetPredicates() {\n\t\tconst preds = [];\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tconst c = this.configs[i].semanticContext;\n\t\t\tif (c !== SemanticContext.NONE) {\n\t\t\t\tpreds.push(c.semanticContext);\n\t\t\t}\n\t\t}\n\t\treturn preds;\n\t}\n\n\toptimizeConfigs(interpreter) {\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tif (this.configLookup.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\tconst config = this.configs[i];\n\t\t\tconfig.context = interpreter.getCachedContext(config.context);\n\t\t}\n\t}\n\n\taddAll(coll) {\n\t\tfor (let i = 0; i < coll.length; i++) {\n\t\t\tthis.add(coll[i]);\n\t\t}\n\t\treturn false;\n\t}\n\n\tequals(other) {\n\t\treturn this === other ||\n\t\t\t(other instanceof ATNConfigSet &&\n\t\t\tUtils.equalArrays(this.configs, other.configs) &&\n\t\t\tthis.fullCtx === other.fullCtx &&\n\t\t\tthis.uniqueAlt === other.uniqueAlt &&\n\t\t\tthis.conflictingAlts === other.conflictingAlts &&\n\t\t\tthis.hasSemanticContext === other.hasSemanticContext &&\n\t\t\tthis.dipsIntoOuterContext === other.dipsIntoOuterContext);\n\t}\n\n\thashCode() {\n\t\tconst hash = new Utils.Hash();\n\t\thash.update(this.configs);\n\t\treturn hash.finish();\n\t}\n\n\tupdateHashCode(hash) {\n\t\tif (this.readOnly) {\n\t\t\tif (this.cachedHashCode === -1) {\n\t\t\t\tthis.cachedHashCode = this.hashCode();\n\t\t\t}\n\t\t\thash.update(this.cachedHashCode);\n\t\t} else {\n\t\t\thash.update(this.hashCode());\n\t\t}\n\t}\n\n\tisEmpty() {\n\t\treturn this.configs.length === 0;\n\t}\n\n\tcontains(item) {\n\t\tif (this.configLookup === null) {\n\t\t\tthrow \"This method is not implemented for readonly sets.\";\n\t\t}\n\t\treturn this.configLookup.contains(item);\n\t}\n\n\tcontainsFast(item) {\n\t\tif (this.configLookup === null) {\n\t\t\tthrow \"This method is not implemented for readonly sets.\";\n\t\t}\n\t\treturn this.configLookup.containsFast(item);\n\t}\n\n\tclear() {\n\t\tif (this.readOnly) {\n\t\t\tthrow \"This set is readonly\";\n\t\t}\n\t\tthis.configs = [];\n\t\tthis.cachedHashCode = -1;\n\t\tthis.configLookup = new Utils.Set();\n\t}\n\n\tsetReadonly(readOnly) {\n\t\tthis.readOnly = readOnly;\n\t\tif (readOnly) {\n\t\t\tthis.configLookup = null; // can't mod, no need for lookup cache\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn Utils.arrayToString(this.configs) +\n\t\t\t(this.hasSemanticContext ? \",hasSemanticContext=\" + this.hasSemanticContext : \"\") +\n\t\t\t(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? \",uniqueAlt=\" + this.uniqueAlt : \"\") +\n\t\t\t(this.conflictingAlts !== null ? \",conflictingAlts=\" + this.conflictingAlts : \"\") +\n\t\t\t(this.dipsIntoOuterContext ? \",dipsIntoOuterContext\" : \"\");\n\t}\n\n\tget items(){\n\t\treturn this.configs;\n\t}\n\n\tget length(){\n\t\treturn this.configs.length;\n\t}\n}\n\n\nclass OrderedATNConfigSet extends ATNConfigSet {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.configLookup = new Utils.Set();\n\t}\n}\n\nmodule.exports = {\n\tATNConfigSet,\n\tOrderedATNConfigSet\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js":
/*!*************************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nclass ATNDeserializationOptions {\n\tconstructor(copyFrom) {\n\t\tif(copyFrom===undefined) {\n\t\t\tcopyFrom = null;\n\t\t}\n\t\tthis.readOnly = false;\n\t\tthis.verifyATN = copyFrom===null ? true : copyFrom.verifyATN;\n\t\tthis.generateRuleBypassTransitions = copyFrom===null ? false : copyFrom.generateRuleBypassTransitions;\n\t}\n}\n\nATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();\nATNDeserializationOptions.defaultOptions.readOnly = true;\n\n//    def __setattr__(self, key, value):\n//        if key!=\"readOnly\" and self.readOnly:\n//            raise Exception(\"The object is read only.\")\n//        super(type(self), self).__setattr__(key,value)\n\nmodule.exports = ATNDeserializationOptions\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js":
/*!***************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./../Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst ATN = __webpack_require__(/*! ./ATN */ \"./node_modules/antlr4/src/antlr4/atn/ATN.js\");\nconst ATNType = __webpack_require__(/*! ./ATNType */ \"./node_modules/antlr4/src/antlr4/atn/ATNType.js\");\n\nconst {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n} = __webpack_require__(/*! ./ATNState */ \"./node_modules/antlr4/src/antlr4/atn/ATNState.js\");\n\nconst {\n    Transition,\n    AtomTransition,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    RangeTransition,\n    ActionTransition,\n    EpsilonTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition\n} = __webpack_require__(/*! ./Transition */ \"./node_modules/antlr4/src/antlr4/atn/Transition.js\")\n\nconst {IntervalSet} = __webpack_require__(/*! ./../IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\");\nconst ATNDeserializationOptions = __webpack_require__(/*! ./ATNDeserializationOptions */ \"./node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js\");\n\nconst {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction,\n} = __webpack_require__(/*! ./LexerAction */ \"./node_modules/antlr4/src/antlr4/atn/LexerAction.js\");\n\n// This is the earliest supported serialized UUID.\n// stick to serialized version for now, we don't need a UUID instance\nconst BASE_SERIALIZED_UUID = \"AADB8D7E-AEEF-4415-AD2B-8204D6CF042E\";\n\n//\n// This UUID indicates the serialized ATN contains two sets of\n// IntervalSets, where the second set's values are encoded as\n// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.\n//\nconst ADDED_UNICODE_SMP = \"59627784-3BE5-417A-B9EB-8131A7286089\";\n\n// This list contains all of the currently supported UUIDs, ordered by when\n// the feature first appeared in this branch.\nconst SUPPORTED_UUIDS = [ BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP ];\n\nconst SERIALIZED_VERSION = 3;\n\n// This is the current serialized UUID.\nconst SERIALIZED_UUID = ADDED_UNICODE_SMP;\n\nfunction initArray( length, value) {\n\tconst tmp = [];\n\ttmp[length-1] = value;\n\treturn tmp.map(function(i) {return value;});\n}\n\nclass ATNDeserializer {\n    constructor(options) {\n\n        if ( options=== undefined || options === null ) {\n            options = ATNDeserializationOptions.defaultOptions;\n        }\n        this.deserializationOptions = options;\n        this.stateFactories = null;\n        this.actionFactories = null;\n    }\n\n    /**\n     * Determines if a particular serialized representation of an ATN supports\n     * a particular feature, identified by the {@link UUID} used for serializing\n     * the ATN at the time the feature was first introduced.\n     *\n     * @param feature The {@link UUID} marking the first time the feature was\n     * supported in the serialized ATN.\n     * @param actualUuid The {@link UUID} of the actual serialized ATN which is\n     * currently being deserialized.\n     * @return {@code true} if the {@code actualUuid} value represents a\n     * serialized ATN at or after the feature identified by {@code feature} was\n     * introduced; otherwise, {@code false}.\n    */\n    isFeatureSupported(feature, actualUuid) {\n        const idx1 = SUPPORTED_UUIDS.indexOf(feature);\n        if (idx1<0) {\n            return false;\n        }\n        const idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);\n        return idx2 >= idx1;\n    }\n\n    deserialize(data) {\n        this.reset(data);\n        this.checkVersion();\n        this.checkUUID();\n        const atn = this.readATN();\n        this.readStates(atn);\n        this.readRules(atn);\n        this.readModes(atn);\n        const sets = [];\n        // First, deserialize sets with 16-bit arguments <= U+FFFF.\n        this.readSets(atn, sets, this.readInt.bind(this));\n        // Next, if the ATN was serialized with the Unicode SMP feature,\n        // deserialize sets with 32-bit arguments <= U+10FFFF.\n        if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {\n            this.readSets(atn, sets, this.readInt32.bind(this));\n        }\n        this.readEdges(atn, sets);\n        this.readDecisions(atn);\n        this.readLexerActions(atn);\n        this.markPrecedenceDecisions(atn);\n        this.verifyATN(atn);\n        if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {\n            this.generateRuleBypassTransitions(atn);\n            // re-verify after modification\n            this.verifyATN(atn);\n        }\n        return atn;\n    }\n\n    reset(data) {\n        const adjust = function(c) {\n            const v = c.charCodeAt(0);\n            return v>1  ? v-2 : v + 65534;\n        };\n        const temp = data.split(\"\").map(adjust);\n        // don't adjust the first value since that's the version number\n        temp[0] = data.charCodeAt(0);\n        this.data = temp;\n        this.pos = 0;\n    }\n\n    checkVersion() {\n        const version = this.readInt();\n        if ( version !== SERIALIZED_VERSION ) {\n            throw (\"Could not deserialize ATN with version \" + version + \" (expected \" + SERIALIZED_VERSION + \").\");\n        }\n    }\n\n    checkUUID() {\n        const uuid = this.readUUID();\n        if (SUPPORTED_UUIDS.indexOf(uuid)<0) {\n            throw (\"Could not deserialize ATN with UUID: \" + uuid +\n                            \" (expected \" + SERIALIZED_UUID + \" or a legacy UUID).\", uuid, SERIALIZED_UUID);\n        }\n        this.uuid = uuid;\n    }\n\n    readATN() {\n        const grammarType = this.readInt();\n        const maxTokenType = this.readInt();\n        return new ATN(grammarType, maxTokenType);\n    }\n\n    readStates(atn) {\n        let j, pair, stateNumber;\n        const  loopBackStateNumbers = [];\n        const  endStateNumbers = [];\n        const  nstates = this.readInt();\n        for(let i=0; i<nstates; i++) {\n            const  stype = this.readInt();\n            // ignore bad type of states\n            if (stype===ATNState.INVALID_TYPE) {\n                atn.addState(null);\n                continue;\n            }\n            let ruleIndex = this.readInt();\n            if (ruleIndex === 0xFFFF) {\n                ruleIndex = -1;\n            }\n            const  s = this.stateFactory(stype, ruleIndex);\n            if (stype === ATNState.LOOP_END) { // special case\n                const  loopBackStateNumber = this.readInt();\n                loopBackStateNumbers.push([s, loopBackStateNumber]);\n            } else if(s instanceof BlockStartState) {\n                const  endStateNumber = this.readInt();\n                endStateNumbers.push([s, endStateNumber]);\n            }\n            atn.addState(s);\n        }\n        // delay the assignment of loop back and end states until we know all the\n        // state instances have been initialized\n        for (j=0; j<loopBackStateNumbers.length; j++) {\n            pair = loopBackStateNumbers[j];\n            pair[0].loopBackState = atn.states[pair[1]];\n        }\n\n        for (j=0; j<endStateNumbers.length; j++) {\n            pair = endStateNumbers[j];\n            pair[0].endState = atn.states[pair[1]];\n        }\n\n        let numNonGreedyStates = this.readInt();\n        for (j=0; j<numNonGreedyStates; j++) {\n            stateNumber = this.readInt();\n            atn.states[stateNumber].nonGreedy = true;\n        }\n\n        let numPrecedenceStates = this.readInt();\n        for (j=0; j<numPrecedenceStates; j++) {\n            stateNumber = this.readInt();\n            atn.states[stateNumber].isPrecedenceRule = true;\n        }\n    }\n\n    readRules(atn) {\n        let i;\n        const nrules = this.readInt();\n        if (atn.grammarType === ATNType.LEXER ) {\n            atn.ruleToTokenType = initArray(nrules, 0);\n        }\n        atn.ruleToStartState = initArray(nrules, 0);\n        for (i=0; i<nrules; i++) {\n            const s = this.readInt();\n            atn.ruleToStartState[i] = atn.states[s];\n            if ( atn.grammarType === ATNType.LEXER ) {\n                let tokenType = this.readInt();\n                if (tokenType === 0xFFFF) {\n                    tokenType = Token.EOF;\n                }\n                atn.ruleToTokenType[i] = tokenType;\n            }\n        }\n        atn.ruleToStopState = initArray(nrules, 0);\n        for (i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (!(state instanceof RuleStopState)) {\n                continue;\n            }\n            atn.ruleToStopState[state.ruleIndex] = state;\n            atn.ruleToStartState[state.ruleIndex].stopState = state;\n        }\n    }\n\n    readModes(atn) {\n        const nmodes = this.readInt();\n        for (let i=0; i<nmodes; i++) {\n            let s = this.readInt();\n            atn.modeToStartState.push(atn.states[s]);\n        }\n    }\n\n    readSets(atn, sets, readUnicode) {\n        const m = this.readInt();\n        for (let i=0; i<m; i++) {\n            const iset = new IntervalSet();\n            sets.push(iset);\n            const n = this.readInt();\n            const containsEof = this.readInt();\n            if (containsEof!==0) {\n                iset.addOne(-1);\n            }\n            for (let j=0; j<n; j++) {\n                const i1 = readUnicode();\n                const i2 = readUnicode();\n                iset.addRange(i1, i2);\n            }\n        }\n    }\n\n    readEdges(atn, sets) {\n        let i, j, state, trans, target;\n        const nedges = this.readInt();\n        for (i=0; i<nedges; i++) {\n            const src = this.readInt();\n            const trg = this.readInt();\n            const ttype = this.readInt();\n            const arg1 = this.readInt();\n            const arg2 = this.readInt();\n            const arg3 = this.readInt();\n            trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n            const srcState = atn.states[src];\n            srcState.addTransition(trans);\n        }\n        // edges for rule stop states can be derived, so they aren't serialized\n        for (i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            for (j=0; j<state.transitions.length; j++) {\n                const t = state.transitions[j];\n                if (!(t instanceof RuleTransition)) {\n                    continue;\n                }\n                let outermostPrecedenceReturn = -1;\n                if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {\n                    if (t.precedence === 0) {\n                        outermostPrecedenceReturn = t.target.ruleIndex;\n                    }\n                }\n\n                trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);\n                atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);\n            }\n        }\n\n        for (i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            if (state instanceof BlockStartState) {\n                // we need to know the end state to set its start state\n                if (state.endState === null) {\n                    throw (\"IllegalState\");\n                }\n                // block end states can only be associated to a single block start\n                // state\n                if ( state.endState.startState !== null) {\n                    throw (\"IllegalState\");\n                }\n                state.endState.startState = state;\n            }\n            if (state instanceof PlusLoopbackState) {\n                for (j=0; j<state.transitions.length; j++) {\n                    target = state.transitions[j].target;\n                    if (target instanceof PlusBlockStartState) {\n                        target.loopBackState = state;\n                    }\n                }\n            } else if (state instanceof StarLoopbackState) {\n                for (j=0; j<state.transitions.length; j++) {\n                    target = state.transitions[j].target;\n                    if (target instanceof StarLoopEntryState) {\n                        target.loopBackState = state;\n                    }\n                }\n            }\n        }\n    }\n\n    readDecisions(atn) {\n        const ndecisions = this.readInt();\n        for (let i=0; i<ndecisions; i++) {\n            const s = this.readInt();\n            const decState = atn.states[s];\n            atn.decisionToState.push(decState);\n            decState.decision = i;\n        }\n    }\n\n    readLexerActions(atn) {\n        if (atn.grammarType === ATNType.LEXER) {\n            const count = this.readInt();\n            atn.lexerActions = initArray(count, null);\n            for (let i=0; i<count; i++) {\n                const actionType = this.readInt();\n                let data1 = this.readInt();\n                if (data1 === 0xFFFF) {\n                    data1 = -1;\n                }\n                let data2 = this.readInt();\n                if (data2 === 0xFFFF) {\n                    data2 = -1;\n                }\n\n                atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);\n            }\n        }\n    }\n\n    generateRuleBypassTransitions(atn) {\n        let i;\n        const count = atn.ruleToStartState.length;\n        for(i=0; i<count; i++) {\n            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n        }\n        for(i=0; i<count; i++) {\n            this.generateRuleBypassTransition(atn, i);\n        }\n    }\n\n    generateRuleBypassTransition(atn, idx) {\n        let i, state;\n        const bypassStart = new BasicBlockStartState();\n        bypassStart.ruleIndex = idx;\n        atn.addState(bypassStart);\n\n        const bypassStop = new BlockEndState();\n        bypassStop.ruleIndex = idx;\n        atn.addState(bypassStop);\n\n        bypassStart.endState = bypassStop;\n        atn.defineDecisionState(bypassStart);\n\n        bypassStop.startState = bypassStart;\n\n        let excludeTransition = null;\n        let endState = null;\n\n        if (atn.ruleToStartState[idx].isPrecedenceRule) {\n            // wrap from the beginning of the rule to the StarLoopEntryState\n            endState = null;\n            for(i=0; i<atn.states.length; i++) {\n                state = atn.states[i];\n                if (this.stateIsEndStateFor(state, idx)) {\n                    endState = state;\n                    excludeTransition = state.loopBackState.transitions[0];\n                    break;\n                }\n            }\n            if (excludeTransition === null) {\n                throw (\"Couldn't identify final state of the precedence rule prefix section.\");\n            }\n        } else {\n            endState = atn.ruleToStopState[idx];\n        }\n\n        // all non-excluded transitions that currently target end state need to\n        // target blockEnd instead\n        for(i=0; i<atn.states.length; i++) {\n            state = atn.states[i];\n            for(let j=0; j<state.transitions.length; j++) {\n                const transition = state.transitions[j];\n                if (transition === excludeTransition) {\n                    continue;\n                }\n                if (transition.target === endState) {\n                    transition.target = bypassStop;\n                }\n            }\n        }\n\n        // all transitions leaving the rule start state need to leave blockStart\n        // instead\n        const ruleToStartState = atn.ruleToStartState[idx];\n        const count = ruleToStartState.transitions.length;\n        while ( count > 0) {\n            bypassStart.addTransition(ruleToStartState.transitions[count-1]);\n            ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);\n        }\n        // link the new states\n        atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));\n        bypassStop.addTransition(new EpsilonTransition(endState));\n\n        const matchState = new BasicState();\n        atn.addState(matchState);\n        matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));\n        bypassStart.addTransition(new EpsilonTransition(matchState));\n    }\n\n    stateIsEndStateFor(state, idx) {\n        if ( state.ruleIndex !== idx) {\n            return null;\n        }\n        if (!( state instanceof StarLoopEntryState)) {\n            return null;\n        }\n        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n        if (!( maybeLoopEndState instanceof LoopEndState)) {\n            return null;\n        }\n        if (maybeLoopEndState.epsilonOnlyTransitions &&\n            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n            return state;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n     * the {@link StarLoopEntryState//isPrecedenceDecision} field to the\n     * correct value.\n     * @param atn The ATN.\n     */\n    markPrecedenceDecisions(atn) {\n        for(let i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (!( state instanceof StarLoopEntryState)) {\n                continue;\n            }\n            // We analyze the ATN to determine if this ATN decision state is the\n            // decision for the closure block that determines whether a\n            // precedence rule should continue or complete.\n            if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n                const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;\n                if (maybeLoopEndState instanceof LoopEndState) {\n                    if ( maybeLoopEndState.epsilonOnlyTransitions &&\n                            (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {\n                        state.isPrecedenceDecision = true;\n                    }\n                }\n            }\n        }\n    }\n\n    verifyATN(atn) {\n        if (!this.deserializationOptions.verifyATN) {\n            return;\n        }\n        // verify assumptions\n        for(let i=0; i<atn.states.length; i++) {\n            const state = atn.states[i];\n            if (state === null) {\n                continue;\n            }\n            this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);\n            if (state instanceof PlusBlockStartState) {\n                this.checkCondition(state.loopBackState !== null);\n            } else  if (state instanceof StarLoopEntryState) {\n                this.checkCondition(state.loopBackState !== null);\n                this.checkCondition(state.transitions.length === 2);\n                if (state.transitions[0].target instanceof StarBlockStartState) {\n                    this.checkCondition(state.transitions[1].target instanceof LoopEndState);\n                    this.checkCondition(!state.nonGreedy);\n                } else if (state.transitions[0].target instanceof LoopEndState) {\n                    this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);\n                    this.checkCondition(state.nonGreedy);\n                } else {\n                    throw(\"IllegalState\");\n                }\n            } else if (state instanceof StarLoopbackState) {\n                this.checkCondition(state.transitions.length === 1);\n                this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);\n            } else if (state instanceof LoopEndState) {\n                this.checkCondition(state.loopBackState !== null);\n            } else if (state instanceof RuleStartState) {\n                this.checkCondition(state.stopState !== null);\n            } else if (state instanceof BlockStartState) {\n                this.checkCondition(state.endState !== null);\n            } else if (state instanceof BlockEndState) {\n                this.checkCondition(state.startState !== null);\n            } else if (state instanceof DecisionState) {\n                this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);\n            } else {\n                this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));\n            }\n        }\n    }\n\n    checkCondition(condition, message) {\n        if (!condition) {\n            if (message === undefined || message===null) {\n                message = \"IllegalState\";\n            }\n            throw (message);\n        }\n    }\n\n    readInt() {\n        return this.data[this.pos++];\n    }\n\n    readInt32() {\n        const low = this.readInt();\n        const high = this.readInt();\n        return low | (high << 16);\n    }\n\n    readLong() {\n        const low = this.readInt32();\n        const high = this.readInt32();\n        return (low & 0x00000000FFFFFFFF) | (high << 32);\n    }\n\n    readUUID() {\n        const bb = [];\n        for(let i=7;i>=0;i--) {\n            const int = this.readInt();\n            /* jshint bitwise: false */\n            bb[(2*i)+1] = int & 0xFF;\n            bb[2*i] = (int >> 8) & 0xFF;\n        }\n        return byteToHex[bb[0]] + byteToHex[bb[1]] +\n        byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +\n        byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +\n        byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +\n        byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +\n        byteToHex[bb[10]] + byteToHex[bb[11]] +\n        byteToHex[bb[12]] + byteToHex[bb[13]] +\n        byteToHex[bb[14]] + byteToHex[bb[15]];\n    }\n\n    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {\n        const target = atn.states[trg];\n        switch(type) {\n        case Transition.EPSILON:\n            return new EpsilonTransition(target);\n        case Transition.RANGE:\n            return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);\n        case Transition.RULE:\n            return new RuleTransition(atn.states[arg1], arg2, arg3, target);\n        case Transition.PREDICATE:\n            return new PredicateTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.PRECEDENCE:\n            return new PrecedencePredicateTransition(target, arg1);\n        case Transition.ATOM:\n            return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);\n        case Transition.ACTION:\n            return new ActionTransition(target, arg1, arg2, arg3 !== 0);\n        case Transition.SET:\n            return new SetTransition(target, sets[arg1]);\n        case Transition.NOT_SET:\n            return new NotSetTransition(target, sets[arg1]);\n        case Transition.WILDCARD:\n            return new WildcardTransition(target);\n        default:\n            throw \"The specified transition type: \" + type + \" is not valid.\";\n        }\n    }\n\n    stateFactory(type, ruleIndex) {\n        if (this.stateFactories === null) {\n            const sf = [];\n            sf[ATNState.INVALID_TYPE] = null;\n            sf[ATNState.BASIC] = () => new BasicState();\n            sf[ATNState.RULE_START] = () => new RuleStartState();\n            sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();\n            sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();\n            sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();\n            sf[ATNState.TOKEN_START] = () => new TokensStartState();\n            sf[ATNState.RULE_STOP] = () => new RuleStopState();\n            sf[ATNState.BLOCK_END] = () => new BlockEndState();\n            sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();\n            sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();\n            sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();\n            sf[ATNState.LOOP_END] = () => new LoopEndState();\n            this.stateFactories = sf;\n        }\n        if (type>this.stateFactories.length || this.stateFactories[type] === null) {\n            throw(\"The specified state type \" + type + \" is not valid.\");\n        } else {\n            const s = this.stateFactories[type]();\n            if (s!==null) {\n                s.ruleIndex = ruleIndex;\n                return s;\n            }\n        }\n    }\n\n    lexerActionFactory(type, data1, data2) {\n        if (this.actionFactories === null) {\n            const af = [];\n            af[LexerActionType.CHANNEL] = (data1, data2) => new LexerChannelAction(data1);\n            af[LexerActionType.CUSTOM] = (data1, data2) => new LexerCustomAction(data1, data2);\n            af[LexerActionType.MODE] = (data1, data2) => new LexerModeAction(data1);\n            af[LexerActionType.MORE] = (data1, data2) => LexerMoreAction.INSTANCE;\n            af[LexerActionType.POP_MODE] = (data1, data2) => LexerPopModeAction.INSTANCE;\n            af[LexerActionType.PUSH_MODE] = (data1, data2) => new LexerPushModeAction(data1);\n            af[LexerActionType.SKIP] = (data1, data2) => LexerSkipAction.INSTANCE;\n            af[LexerActionType.TYPE] = (data1, data2) => new LexerTypeAction(data1);\n            this.actionFactories = af;\n        }\n        if (type>this.actionFactories.length || this.actionFactories[type] === null) {\n            throw(\"The specified lexer action type \" + type + \" is not valid.\");\n        } else {\n            return this.actionFactories[type](data1, data2);\n        }\n    }\n}\n\nfunction createByteToHex() {\n\tconst bth = [];\n\tfor (let i = 0; i < 256; i++) {\n\t\tbth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();\n\t}\n\treturn bth;\n}\n\nconst byteToHex = createByteToHex();\n\n\nmodule.exports = ATNDeserializer;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/ATNSimulator.js":
/*!************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/ATNSimulator.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {DFAState} = __webpack_require__(/*! ./../dfa/DFAState */ \"./node_modules/antlr4/src/antlr4/dfa/DFAState.js\");\nconst {ATNConfigSet} = __webpack_require__(/*! ./ATNConfigSet */ \"./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js\");\nconst {getCachedPredictionContext} = __webpack_require__(/*! ./../PredictionContext */ \"./node_modules/antlr4/src/antlr4/PredictionContext.js\");\nconst {Map} = __webpack_require__(/*! ./../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\n\nclass ATNSimulator {\n    constructor(atn, sharedContextCache) {\n        /**\n         * The context cache maps all PredictionContext objects that are ==\n         * to a single cached copy. This cache is shared across all contexts\n         * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet\n         * to use only cached nodes/graphs in addDFAState(). We don't want to\n         * fill this during closure() since there are lots of contexts that\n         * pop up but are not used ever again. It also greatly slows down closure().\n         *\n         * <p>This cache makes a huge difference in memory and a little bit in speed.\n         * For the Java grammar on java.*, it dropped the memory requirements\n         * at the end from 25M to 16M. We don't store any of the full context\n         * graphs in the DFA because they are limited to local context only,\n         * but apparently there's a lot of repetition there as well. We optimize\n         * the config contexts before storing the config set in the DFA states\n         * by literally rebuilding them with cached subgraphs only.</p>\n         *\n         * <p>I tried a cache for use during closure operations, that was\n         * whacked after each adaptivePredict(). It cost a little bit\n         * more time I think and doesn't save on the overall footprint\n         * so it's not worth the complexity.</p>\n         */\n        this.atn = atn;\n        this.sharedContextCache = sharedContextCache;\n        return this;\n    }\n\n    getCachedContext(context) {\n        if (this.sharedContextCache ===null) {\n            return context;\n        }\n        const visited = new Map();\n        return getCachedPredictionContext(context, this.sharedContextCache, visited);\n    }\n}\n\n// Must distinguish between missing edge and edge we know leads nowhere///\nATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());\n\n\nmodule.exports = ATNSimulator;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/ATNSimulator.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/ATNState.js":
/*!********************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/ATNState.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst INITIAL_NUM_TRANSITIONS = 4;\n\n/**\n * The following images show the relation of states and\n * {@link ATNState//transitions} for various grammar constructs.\n *\n * <ul>\n *\n * <li>Solid edges marked with an &//0949; indicate a required\n * {@link EpsilonTransition}.</li>\n *\n * <li>Dashed edges indicate locations where any transition derived from\n * {@link Transition} might appear.</li>\n *\n * <li>Dashed nodes are place holders for either a sequence of linked\n * {@link BasicState} states or the inclusion of a block representing a nested\n * construct in one of the forms below.</li>\n *\n * <li>Nodes showing multiple outgoing alternatives with a {@code ...} support\n * any number of alternatives (one or more). Nodes without the {@code ...} only\n * support the exact number of alternatives shown in the diagram.</li>\n *\n * </ul>\n *\n * <h2>Basic Blocks</h2>\n *\n * <h3>Rule</h3>\n *\n * <embed src=\"images/Rule.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Block of 1 or more alternatives</h3>\n *\n * <embed src=\"images/Block.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Greedy Loops</h2>\n *\n * <h3>Greedy Closure: {@code (...)*}</h3>\n *\n * <embed src=\"images/ClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Positive Closure: {@code (...)+}</h3>\n *\n * <embed src=\"images/PositiveClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Optional: {@code (...)?}</h3>\n *\n * <embed src=\"images/OptionalGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Non-Greedy Loops</h2>\n *\n * <h3>Non-Greedy Closure: {@code (...)*?}</h3>\n *\n * <embed src=\"images/ClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>\n *\n * <embed src=\"images/PositiveClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Optional: {@code (...)??}</h3>\n *\n * <embed src=\"images/OptionalNonGreedy.svg\" type=\"image/svg+xml\"/>\n */\nclass ATNState {\n    constructor() {\n        // Which ATN are we in?\n        this.atn = null;\n        this.stateNumber = ATNState.INVALID_STATE_NUMBER;\n        this.stateType = null;\n        this.ruleIndex = 0; // at runtime, we don't have Rule objects\n        this.epsilonOnlyTransitions = false;\n        // Track the transitions emanating from this ATN state.\n        this.transitions = [];\n        // Used to cache lookahead during parsing, not used during construction\n        this.nextTokenWithinRule = null;\n    }\n\n    toString() {\n        return this.stateNumber;\n    }\n\n    equals(other) {\n        if (other instanceof ATNState) {\n            return this.stateNumber===other.stateNumber;\n        } else {\n            return false;\n        }\n    }\n\n    isNonGreedyExitState() {\n        return false;\n    }\n\n    addTransition(trans, index) {\n        if(index===undefined) {\n            index = -1;\n        }\n        if (this.transitions.length===0) {\n            this.epsilonOnlyTransitions = trans.isEpsilon;\n        } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {\n            this.epsilonOnlyTransitions = false;\n        }\n        if (index===-1) {\n            this.transitions.push(trans);\n        } else {\n            this.transitions.splice(index, 1, trans);\n        }\n    }\n}\n\n// constants for serialization\nATNState.INVALID_TYPE = 0;\nATNState.BASIC = 1;\nATNState.RULE_START = 2;\nATNState.BLOCK_START = 3;\nATNState.PLUS_BLOCK_START = 4;\nATNState.STAR_BLOCK_START = 5;\nATNState.TOKEN_START = 6;\nATNState.RULE_STOP = 7;\nATNState.BLOCK_END = 8;\nATNState.STAR_LOOP_BACK = 9;\nATNState.STAR_LOOP_ENTRY = 10;\nATNState.PLUS_LOOP_BACK = 11;\nATNState.LOOP_END = 12;\n\nATNState.serializationNames = [\n            \"INVALID\",\n            \"BASIC\",\n            \"RULE_START\",\n            \"BLOCK_START\",\n            \"PLUS_BLOCK_START\",\n            \"STAR_BLOCK_START\",\n            \"TOKEN_START\",\n            \"RULE_STOP\",\n            \"BLOCK_END\",\n            \"STAR_LOOP_BACK\",\n            \"STAR_LOOP_ENTRY\",\n            \"PLUS_LOOP_BACK\",\n            \"LOOP_END\" ];\n\nATNState.INVALID_STATE_NUMBER = -1;\n\n\nclass BasicState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BASIC;\n    }\n}\n\nclass DecisionState extends ATNState {\n    constructor() {\n        super();\n        this.decision = -1;\n        this.nonGreedy = false;\n        return this;\n    }\n}\n\n/**\n *  The start of a regular {@code (...)} block\n */\nclass BlockStartState extends DecisionState {\n    constructor() {\n        super();\n        this.endState = null;\n        return this;\n    }\n}\n\nclass BasicBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BLOCK_START;\n        return this;\n    }\n}\n\n/**\n * Terminal node of a simple {@code (a|b|c)} block\n */\nclass BlockEndState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.BLOCK_END;\n        this.startState = null;\n        return this;\n    }\n}\n\n/**\n * The last node in the ATN for a rule, unless that rule is the start symbol.\n * In that case, there is one transition to EOF. Later, we might encode\n * references to all calls to this rule to compute FOLLOW sets for\n * error handling\n */\nclass RuleStopState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.RULE_STOP;\n        return this;\n    }\n}\n\nclass RuleStartState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.RULE_START;\n        this.stopState = null;\n        this.isPrecedenceRule = false;\n        return this;\n    }\n}\n\n/**\n * Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:\n * one to the loop back to start of the block and one to exit.\n */\nclass PlusLoopbackState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.PLUS_LOOP_BACK;\n        return this;\n    }\n}\n\n/**\n * Start of {@code (A|B|...)+} loop. Technically a decision state, but\n * we don't use for code generation; somebody might need it, so I'm defining\n * it for completeness. In reality, the {@link PlusLoopbackState} node is the\n * real decision-making note for {@code A+}\n */\nclass PlusBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.PLUS_BLOCK_START;\n        this.loopBackState = null;\n        return this;\n    }\n}\n\n/**\n * The block that begins a closure loop\n */\nclass StarBlockStartState extends BlockStartState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_BLOCK_START;\n        return this;\n    }\n}\n\nclass StarLoopbackState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_LOOP_BACK;\n        return this;\n    }\n}\n\nclass StarLoopEntryState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.STAR_LOOP_ENTRY;\n        this.loopBackState = null;\n        // Indicates whether this state can benefit from a precedence DFA during SLL decision making.\n        this.isPrecedenceDecision = null;\n        return this;\n    }\n}\n\n/**\n * Mark the end of a * or + loop\n */\nclass LoopEndState extends ATNState {\n    constructor() {\n        super();\n        this.stateType = ATNState.LOOP_END;\n        this.loopBackState = null;\n        return this;\n    }\n}\n\n/**\n * The Tokens rule start state linking to each lexer rule start state\n */\nclass TokensStartState extends DecisionState {\n    constructor() {\n        super();\n        this.stateType = ATNState.TOKEN_START;\n        return this;\n    }\n}\n\nmodule.exports = {\n    ATNState,\n    BasicState,\n    DecisionState,\n    BlockStartState,\n    BlockEndState,\n    LoopEndState,\n    RuleStartState,\n    RuleStopState,\n    TokensStartState,\n    PlusLoopbackState,\n    StarLoopbackState,\n    StarLoopEntryState,\n    PlusBlockStartState,\n    StarBlockStartState,\n    BasicBlockStartState\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/ATNState.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/ATNType.js":
/*!*******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/ATNType.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * Represents the type of recognizer an ATN applies to\n */\nmodule.exports = {\n    LEXER: 0,\n    PARSER: 1\n};\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/ATNType.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./../Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst Lexer = __webpack_require__(/*! ./../Lexer */ \"./node_modules/antlr4/src/antlr4/Lexer.js\");\nconst ATN = __webpack_require__(/*! ./ATN */ \"./node_modules/antlr4/src/antlr4/atn/ATN.js\");\nconst ATNSimulator = __webpack_require__(/*! ./ATNSimulator */ \"./node_modules/antlr4/src/antlr4/atn/ATNSimulator.js\");\nconst {DFAState} = __webpack_require__(/*! ./../dfa/DFAState */ \"./node_modules/antlr4/src/antlr4/dfa/DFAState.js\");\nconst {OrderedATNConfigSet} = __webpack_require__(/*! ./ATNConfigSet */ \"./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js\");\nconst {PredictionContext} = __webpack_require__(/*! ./../PredictionContext */ \"./node_modules/antlr4/src/antlr4/PredictionContext.js\");\nconst {SingletonPredictionContext} = __webpack_require__(/*! ./../PredictionContext */ \"./node_modules/antlr4/src/antlr4/PredictionContext.js\");\nconst {RuleStopState} = __webpack_require__(/*! ./ATNState */ \"./node_modules/antlr4/src/antlr4/atn/ATNState.js\");\nconst {LexerATNConfig} = __webpack_require__(/*! ./ATNConfig */ \"./node_modules/antlr4/src/antlr4/atn/ATNConfig.js\");\nconst {Transition} = __webpack_require__(/*! ./Transition */ \"./node_modules/antlr4/src/antlr4/atn/Transition.js\");\nconst LexerActionExecutor = __webpack_require__(/*! ./LexerActionExecutor */ \"./node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js\");\nconst {LexerNoViableAltException} = __webpack_require__(/*! ./../error/Errors */ \"./node_modules/antlr4/src/antlr4/error/Errors.js\");\n\nfunction resetSimState(sim) {\n\tsim.index = -1;\n\tsim.line = 0;\n\tsim.column = -1;\n\tsim.dfaState = null;\n}\n\nclass SimState {\n\tconstructor() {\n\t\tresetSimState(this);\n\t}\n\n\treset() {\n\t\tresetSimState(this);\n\t}\n}\n\nclass LexerATNSimulator extends ATNSimulator {\n\t/**\n\t * When we hit an accept state in either the DFA or the ATN, we\n\t * have to notify the character stream to start buffering characters\n\t * via {@link IntStream//mark} and record the current state. The current sim state\n\t * includes the current index into the input, the current line,\n\t * and current character position in that line. Note that the Lexer is\n\t * tracking the starting line and characterization of the token. These\n\t * variables track the \"state\" of the simulator when it hits an accept state.\n\t *\n\t * <p>We track these variables separately for the DFA and ATN simulation\n\t * because the DFA simulation often has to fail over to the ATN\n\t * simulation. If the ATN simulation fails, we need the DFA to fall\n\t * back to its previously accepted state, if any. If the ATN succeeds,\n\t * then the ATN does the accept and the DFA simulator that invoked it\n\t * can simply return the predicted token type.</p>\n\t */\n\tconstructor(recog, atn, decisionToDFA, sharedContextCache) {\n\t\tsuper(atn, sharedContextCache);\n\t\tthis.decisionToDFA = decisionToDFA;\n\t\tthis.recog = recog;\n\t\t/**\n\t\t * The current token's starting index into the character stream.\n\t\t * Shared across DFA to ATN simulation in case the ATN fails and the\n\t\t * DFA did not have a previous accept state. In this case, we use the\n\t\t * ATN-generated exception object\n\t\t */\n\t\tthis.startIndex = -1;\n\t\t// line number 1..n within the input///\n\t\tthis.line = 1;\n\t\t/**\n\t\t * The index of the character relative to the beginning of the line\n\t\t * 0..n-1\n\t\t */\n\t\tthis.column = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t\t/**\n\t\t * Used during DFA/ATN exec to record the most recent accept configuration\n\t\t * info\n\t\t */\n\t\tthis.prevAccept = new SimState();\n\t}\n\n\tcopyState(simulator) {\n\t\tthis.column = simulator.column;\n\t\tthis.line = simulator.line;\n\t\tthis.mode = simulator.mode;\n\t\tthis.startIndex = simulator.startIndex;\n\t}\n\n\tmatch(input, mode) {\n\t\tthis.match_calls += 1;\n\t\tthis.mode = mode;\n\t\tconst mark = input.mark();\n\t\ttry {\n\t\t\tthis.startIndex = input.index;\n\t\t\tthis.prevAccept.reset();\n\t\t\tconst dfa = this.decisionToDFA[mode];\n\t\t\tif (dfa.s0 === null) {\n\t\t\t\treturn this.matchATN(input);\n\t\t\t} else {\n\t\t\t\treturn this.execATN(input, dfa.s0);\n\t\t\t}\n\t\t} finally {\n\t\t\tinput.release(mark);\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.prevAccept.reset();\n\t\tthis.startIndex = -1;\n\t\tthis.line = 1;\n\t\tthis.column = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t}\n\n\tmatchATN(input) {\n\t\tconst startState = this.atn.modeToStartState[this.mode];\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"matchATN mode \" + this.mode + \" start: \" + startState);\n\t\t}\n\t\tconst old_mode = this.mode;\n\t\tconst s0_closure = this.computeStartState(input, startState);\n\t\tconst suppressEdge = s0_closure.hasSemanticContext;\n\t\ts0_closure.hasSemanticContext = false;\n\n\t\tconst next = this.addDFAState(s0_closure);\n\t\tif (!suppressEdge) {\n\t\t\tthis.decisionToDFA[this.mode].s0 = next;\n\t\t}\n\n\t\tconst predict = this.execATN(input, next);\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"DFA after matchATN: \" + this.decisionToDFA[old_mode].toLexerString());\n\t\t}\n\t\treturn predict;\n\t}\n\n\texecATN(input, ds0) {\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"start state closure=\" + ds0.configs);\n\t\t}\n\t\tif (ds0.isAcceptState) {\n\t\t\t// allow zero-length tokens\n\t\t\tthis.captureSimState(this.prevAccept, input, ds0);\n\t\t}\n\t\tlet t = input.LA(1);\n\t\tlet s = ds0; // s is current/from DFA state\n\n\t\twhile (true) { // while more work\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"execATN loop starting closure: \" + s.configs);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t * avoid looking up the DFA state again, which is expensive.\n\t\t\t * If the previous target was already part of the DFA, we might\n\t\t\t * be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t * it means that semantic predicates didn't prevent us from\n\t\t\t * creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t * the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t * it's configuration set; there's no point in re-computing it.\n\t\t\t * This is kind of like doing DFA simulation within the ATN\n\t\t\t * simulation because DFA simulation is really just a way to avoid\n\t\t\t * computing reach/closure sets. Technically, once we know that\n\t\t\t * we have a previously added DFA state, we could jump over to\n\t\t\t * the DFA simulator. But, that would mean popping back and forth\n\t\t\t * a lot and making things more complicated algorithmically.\n\t\t\t * This optimization makes a lot of sense for loops within DFA.\n\t\t\t * A character will take us back to an existing DFA state\n\t\t\t * that already has lots of edges out of it. e.g., .* in comments.\n\t\t\t * print(\"Target for:\" + str(s) + \" and:\" + str(t))\n\t\t\t */\n\t\t\tlet target = this.getExistingTargetState(s, t);\n\t\t\t// print(\"Existing:\" + str(target))\n\t\t\tif (target === null) {\n\t\t\t\ttarget = this.computeTargetState(input, s, t);\n\t\t\t\t// print(\"Computed:\" + str(target))\n\t\t\t}\n\t\t\tif (target === ATNSimulator.ERROR) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// If this is a consumable input element, make sure to consume before\n\t\t\t// capturing the accept state so the input index, line, and char\n\t\t\t// position accurately reflect the state of the interpreter at the\n\t\t\t// end of the token.\n\t\t\tif (t !== Token.EOF) {\n\t\t\t\tthis.consume(input);\n\t\t\t}\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tthis.captureSimState(this.prevAccept, input, target);\n\t\t\t\tif (t === Token.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = input.LA(1);\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\t\treturn this.failOrAccept(this.prevAccept, input, s.configs, t);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns {@code null}.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @return The existing target DFA state for the given input symbol\n\t * {@code t}, or {@code null} if the target state for this edge is not\n\t * already cached\n\t */\n\tgetExistingTargetState(s, t) {\n\t\tif (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];\n\t\tif(target===undefined) {\n\t\t\ttarget = null;\n\t\t}\n\t\tif (LexerATNSimulator.debug && target !== null) {\n\t\t\tconsole.log(\"reuse state \" + s.stateNumber + \" edge to \" + target.stateNumber);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param input The input stream\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t *\n\t * @return The computed target DFA state for the given input symbol\n\t * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n\t * returns {@link //ERROR}.\n\t */\n\tcomputeTargetState(input, s, t) {\n\t\tconst reach = new OrderedATNConfigSet();\n\t\t// if we don't find an existing DFA state\n\t\t// Fill reach starting from closure, following t transitions\n\t\tthis.getReachableConfigSet(input, s.configs, reach, t);\n\n\t\tif (reach.items.length === 0) { // we got nowhere on t from s\n\t\t\tif (!reach.hasSemanticContext) {\n\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t\t// cause a failover from DFA later.\n\t\t\t\tthis.addDFAEdge(s, t, ATNSimulator.ERROR);\n\t\t\t}\n\t\t\t// stop when we can't match any more char\n\t\t\treturn ATNSimulator.ERROR;\n\t\t}\n\t\t// Add an edge from s to target DFA found/created for reach\n\t\treturn this.addDFAEdge(s, t, null, reach);\n\t}\n\n\tfailOrAccept(prevAccept, input, reach, t) {\n\t\tif (this.prevAccept.dfaState !== null) {\n\t\t\tconst lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;\n\t\t\tthis.accept(input, lexerActionExecutor, this.startIndex,\n\t\t\t\t\tprevAccept.index, prevAccept.line, prevAccept.column);\n\t\t\treturn prevAccept.dfaState.prediction;\n\t\t} else {\n\t\t\t// if no accept and EOF is first char, return EOF\n\t\t\tif (t === Token.EOF && input.index === this.startIndex) {\n\t\t\t\treturn Token.EOF;\n\t\t\t}\n\t\t\tthrow new LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n\t\t}\n\t}\n\n\t/**\n\t * Given a starting configuration set, figure out all ATN configurations\n\t * we can reach upon input {@code t}. Parameter {@code reach} is a return\n\t * parameter.\n\t */\n\tgetReachableConfigSet(input, closure,\n\t\t\treach, t) {\n\t\t// this is used to skip processing for configs which have a lower priority\n\t\t// than a config that already reached an accept state for the same rule\n\t\tlet skipAlt = ATN.INVALID_ALT_NUMBER;\n\t\tfor (let i = 0; i < closure.items.length; i++) {\n\t\t\tconst cfg = closure.items[i];\n\t\t\tconst currentAltReachedAcceptState = (cfg.alt === skipAlt);\n\t\t\tif (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"testing %s at %s\\n\", this.getTokenName(t), cfg\n\t\t\t\t\t\t.toString(this.recog, true));\n\t\t\t}\n\t\t\tfor (let j = 0; j < cfg.state.transitions.length; j++) {\n\t\t\t\tconst trans = cfg.state.transitions[j]; // for each transition\n\t\t\t\tconst target = this.getReachableTarget(trans, t);\n\t\t\t\tif (target !== null) {\n\t\t\t\t\tlet lexerActionExecutor = cfg.lexerActionExecutor;\n\t\t\t\t\tif (lexerActionExecutor !== null) {\n\t\t\t\t\t\tlexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n\t\t\t\t\t}\n\t\t\t\t\tconst treatEofAsEpsilon = (t === Token.EOF);\n\t\t\t\t\tconst config = new LexerATNConfig({state:target, lexerActionExecutor:lexerActionExecutor}, cfg);\n\t\t\t\t\tif (this.closure(input, config, reach,\n\t\t\t\t\t\t\tcurrentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n\t\t\t\t\t\t// any remaining configs for this alt have a lower priority\n\t\t\t\t\t\t// than the one that just reached an accept state.\n\t\t\t\t\t\tskipAlt = cfg.alt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taccept(input, lexerActionExecutor,\n\t\t\t   startIndex, index, line, charPos) {\n\t\t   if (LexerATNSimulator.debug) {\n\t\t\t   console.log(\"ACTION %s\\n\", lexerActionExecutor);\n\t\t   }\n\t\t   // seek to after last char in token\n\t\t   input.seek(index);\n\t\t   this.line = line;\n\t\t   this.column = charPos;\n\t\t   if (lexerActionExecutor !== null && this.recog !== null) {\n\t\t\t   lexerActionExecutor.execute(this.recog, input, startIndex);\n\t\t   }\n\t   }\n\n\tgetReachableTarget(trans, t) {\n\t\tif (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\treturn trans.target;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tcomputeStartState(input, p) {\n\t\tconst initialContext = PredictionContext.EMPTY;\n\t\tconst configs = new OrderedATNConfigSet();\n\t\tfor (let i = 0; i < p.transitions.length; i++) {\n\t\t\tconst target = p.transitions[i].target;\n\t\t\tconst cfg = new LexerATNConfig({state:target, alt:i+1, context:initialContext}, null);\n\t\t\tthis.closure(input, cfg, configs, false, false, false);\n\t\t}\n\t\treturn configs;\n\t}\n\n\t/**\n\t * Since the alternatives within any lexer decision are ordered by\n\t * preference, this method stops pursuing the closure as soon as an accept\n\t * state is reached. After the first accept state is reached by depth-first\n\t * search from {@code config}, all other (potentially reachable) states for\n\t * this rule would have a lower priority.\n\t *\n\t * @return {Boolean} {@code true} if an accept state is reached, otherwise\n\t * {@code false}.\n\t */\n\tclosure(input, config, configs,\n\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n\t\tlet cfg = null;\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n\t\t}\n\t\tif (config.state instanceof RuleStopState) {\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tif (this.recog !== null) {\n\t\t\t\t\tconsole.log(\"closure at %s rule stop %s\\n\", this.recog.ruleNames[config.state.ruleIndex], config);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"closure at rule stop %s\\n\", config);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t\tif (config.context === null || config.context.isEmpty()) {\n\t\t\t\t\tconfigs.add(config);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tconfigs.add(new LexerATNConfig({ state:config.state, context:PredictionContext.EMPTY}, config));\n\t\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (config.context !== null && !config.context.isEmpty()) {\n\t\t\t\tfor (let i = 0; i < config.context.length; i++) {\n\t\t\t\t\tif (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {\n\t\t\t\t\t\tconst newContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\t\tconst returnState = this.atn.states[config.context.getReturnState(i)];\n\t\t\t\t\t\tcfg = new LexerATNConfig({ state:returnState, context:newContext }, config);\n\t\t\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg,\n\t\t\t\t\t\t\t\tconfigs, currentAltReachedAcceptState, speculative,\n\t\t\t\t\t\t\t\ttreatEofAsEpsilon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\t\t// optimization\n\t\tif (!config.state.epsilonOnlyTransitions) {\n\t\t\tif (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\t\tfor (let j = 0; j < config.state.transitions.length; j++) {\n\t\t\tconst trans = config.state.transitions[j];\n\t\t\tcfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);\n\t\t\tif (cfg !== null) {\n\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, cfg, configs,\n\t\t\t\t\t\tcurrentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\t// side-effect: can alter configs.hasSemanticContext\n\tgetEpsilonTarget(input, config, trans,\n\t\t\tconfigs, speculative, treatEofAsEpsilon) {\n\t\tlet cfg = null;\n\t\tif (trans.serializationType === Transition.RULE) {\n\t\t\tconst newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);\n\t\t\tcfg = new LexerATNConfig( { state:trans.target, context:newContext}, config);\n\t\t} else if (trans.serializationType === Transition.PRECEDENCE) {\n\t\t\tthrow \"Precedence predicates are not supported in lexers.\";\n\t\t} else if (trans.serializationType === Transition.PREDICATE) {\n\t\t\t// Track traversing semantic predicates. If we traverse,\n\t\t\t// we cannot add a DFA state for this \"reach\" computation\n\t\t\t// because the DFA would not test the predicate again in the\n\t\t\t// future. Rather than creating collections of semantic predicates\n\t\t\t// like v3 and testing them on prediction, v4 will test them on the\n\t\t\t// fly all the time using the ATN not the DFA. This is slower but\n\t\t\t// semantically it's not used that often. One of the key elements to\n\t\t\t// this predicate mechanism is not adding DFA states that see\n\t\t\t// predicates immediately afterwards in the ATN. For example,\n\n\t\t\t// a : ID {p1}? | ID {p2}? ;\n\n\t\t\t// should create the start state for rule 'a' (to save start state\n\t\t\t// competition), but should not create target of ID state. The\n\t\t\t// collection of ATN states the following ID references includes\n\t\t\t// states reached by traversing predicates. Since this is when we\n\t\t\t// test them, we cannot cash the DFA state target of ID.\n\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"EVAL rule \" + trans.ruleIndex + \":\" + trans.predIndex);\n\t\t\t}\n\t\t\tconfigs.hasSemanticContext = true;\n\t\t\tif (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {\n\t\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t\t}\n\t\t} else if (trans.serializationType === Transition.ACTION) {\n\t\t\tif (config.context === null || config.context.hasEmptyPath()) {\n\t\t\t\t// execute actions anywhere in the start rule for a token.\n\t\t\t\t//\n\t\t\t\t// TODO: if the entry rule is invoked recursively, some\n\t\t\t\t// actions may be executed during the recursive call. The\n\t\t\t\t// problem can appear when hasEmptyPath() is true but\n\t\t\t\t// isEmpty() is false. In this case, the config needs to be\n\t\t\t\t// split into two contexts - one with just the empty path\n\t\t\t\t// and another with everything but the empty path.\n\t\t\t\t// Unfortunately, the current algorithm does not allow\n\t\t\t\t// getEpsilonTarget to return two configurations, so\n\t\t\t\t// additional modifications are needed before we can support\n\t\t\t\t// the split operation.\n\t\t\t\tconst lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,\n\t\t\t\t\t\tthis.atn.lexerActions[trans.actionIndex]);\n\t\t\t\tcfg = new LexerATNConfig({ state:trans.target, lexerActionExecutor:lexerActionExecutor }, config);\n\t\t\t} else {\n\t\t\t\t// ignore actions in referenced rules\n\t\t\t\tcfg = new LexerATNConfig( { state:trans.target}, config);\n\t\t\t}\n\t\t} else if (trans.serializationType === Transition.EPSILON) {\n\t\t\tcfg = new LexerATNConfig({ state:trans.target}, config);\n\t\t} else if (trans.serializationType === Transition.ATOM ||\n\t\t\t\t\ttrans.serializationType === Transition.RANGE ||\n\t\t\t\t\ttrans.serializationType === Transition.SET) {\n\t\t\tif (treatEofAsEpsilon) {\n\t\t\t\tif (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {\n\t\t\t\t\tcfg = new LexerATNConfig( { state:trans.target }, config);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cfg;\n\t}\n\n\t/**\n\t * Evaluate a predicate specified in the lexer.\n\t *\n\t * <p>If {@code speculative} is {@code true}, this method was called before\n\t * {@link //consume} for the matched character. This method should call\n\t * {@link //consume} before evaluating the predicate to ensure position\n\t * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},\n\t * and {@link Lexer//getcolumn}, properly reflect the current\n\t * lexer state. This method should restore {@code input} and the simulator\n\t * to the original state before returning (i.e. undo the actions made by the\n\t * call to {@link //consume}.</p>\n\t *\n\t * @param input The input stream.\n\t * @param ruleIndex The rule containing the predicate.\n\t * @param predIndex The index of the predicate within the rule.\n\t * @param speculative {@code true} if the current index in {@code input} is\n\t * one character before the predicate's location.\n\t *\n\t * @return {@code true} if the specified predicate evaluates to\n\t * {@code true}.\n\t */\n\tevaluatePredicate(input, ruleIndex,\n\t\t\tpredIndex, speculative) {\n\t\t// assume true if no recognizer was provided\n\t\tif (this.recog === null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!speculative) {\n\t\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t\t}\n\t\tconst savedcolumn = this.column;\n\t\tconst savedLine = this.line;\n\t\tconst index = input.index;\n\t\tconst marker = input.mark();\n\t\ttry {\n\t\t\tthis.consume(input);\n\t\t\treturn this.recog.sempred(null, ruleIndex, predIndex);\n\t\t} finally {\n\t\t\tthis.column = savedcolumn;\n\t\t\tthis.line = savedLine;\n\t\t\tinput.seek(index);\n\t\t\tinput.release(marker);\n\t\t}\n\t}\n\n\tcaptureSimState(settings, input, dfaState) {\n\t\tsettings.index = input.index;\n\t\tsettings.line = this.line;\n\t\tsettings.column = this.column;\n\t\tsettings.dfaState = dfaState;\n\t}\n\n\taddDFAEdge(from_, tk, to, cfgs) {\n\t\tif (to === undefined) {\n\t\t\tto = null;\n\t\t}\n\t\tif (cfgs === undefined) {\n\t\t\tcfgs = null;\n\t\t}\n\t\tif (to === null && cfgs !== null) {\n\t\t\t// leading to this call, ATNConfigSet.hasSemanticContext is used as a\n\t\t\t// marker indicating dynamic predicate evaluation makes this edge\n\t\t\t// dependent on the specific input sequence, so the static edge in the\n\t\t\t// DFA should be omitted. The target DFAState is still created since\n\t\t\t// execATN has the ability to resynchronize with the DFA state cache\n\t\t\t// following the predicate evaluation step.\n\t\t\t//\n\t\t\t// TJP notes: next time through the DFA, we see a pred again and eval.\n\t\t\t// If that gets us to a previously created (but dangling) DFA\n\t\t\t// state, we can continue in pure DFA mode from there.\n\t\t\t// /\n\t\t\tconst suppressEdge = cfgs.hasSemanticContext;\n\t\t\tcfgs.hasSemanticContext = false;\n\n\t\t\tto = this.addDFAState(cfgs);\n\n\t\t\tif (suppressEdge) {\n\t\t\t\treturn to;\n\t\t\t}\n\t\t}\n\t\t// add the edge\n\t\tif (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {\n\t\t\t// Only track edges within the DFA bounds\n\t\t\treturn to;\n\t\t}\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + tk);\n\t\t}\n\t\tif (from_.edges === null) {\n\t\t\t// make room for tokens 1..n and -1 masquerading as index 0\n\t\t\tfrom_.edges = [];\n\t\t}\n\t\tfrom_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect\n\n\t\treturn to;\n\t}\n\n\t/**\n\t * Add a new DFA state if there isn't one with this set of\n\t * configurations already. This method also detects the first\n\t * configuration containing an ATN rule stop state. Later, when\n\t * traversing the DFA, we will know which rule to accept.\n\t */\n\taddDFAState(configs) {\n\t\tconst proposed = new DFAState(null, configs);\n\t\tlet firstConfigWithRuleStopState = null;\n\t\tfor (let i = 0; i < configs.items.length; i++) {\n\t\t\tconst cfg = configs.items[i];\n\t\t\tif (cfg.state instanceof RuleStopState) {\n\t\t\t\tfirstConfigWithRuleStopState = cfg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (firstConfigWithRuleStopState !== null) {\n\t\t\tproposed.isAcceptState = true;\n\t\t\tproposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n\t\t\tproposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n\t\t}\n\t\tconst dfa = this.decisionToDFA[this.mode];\n\t\tconst existing = dfa.states.get(proposed);\n\t\tif (existing!==null) {\n\t\t\treturn existing;\n\t\t}\n\t\tconst newState = proposed;\n\t\tnewState.stateNumber = dfa.states.length;\n\t\tconfigs.setReadonly(true);\n\t\tnewState.configs = configs;\n\t\tdfa.states.add(newState);\n\t\treturn newState;\n\t}\n\n\tgetDFA(mode) {\n\t\treturn this.decisionToDFA[mode];\n\t}\n\n// Get the text matched so far for the current token.\n\tgetText(input) {\n\t\t// index is first lookahead char, don't include.\n\t\treturn input.getText(this.startIndex, input.index - 1);\n\t}\n\n\tconsume(input) {\n\t\tconst curChar = input.LA(1);\n\t\tif (curChar === \"\\n\".charCodeAt(0)) {\n\t\t\tthis.line += 1;\n\t\t\tthis.column = 0;\n\t\t} else {\n\t\t\tthis.column += 1;\n\t\t}\n\t\tinput.consume();\n\t}\n\n\tgetTokenName(tt) {\n\t\tif (tt === -1) {\n\t\t\treturn \"EOF\";\n\t\t} else {\n\t\t\treturn \"'\" + String.fromCharCode(tt) + \"'\";\n\t\t}\n\t}\n}\n\nLexerATNSimulator.debug = false;\nLexerATNSimulator.dfa_debug = false;\n\nLexerATNSimulator.MIN_DFA_EDGE = 0;\nLexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN\n\nLexerATNSimulator.match_calls = 0;\n\nmodule.exports = LexerATNSimulator;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/LexerAction.js":
/*!***********************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/LexerAction.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst LexerActionType = {\n    // The type of a {@link LexerChannelAction} action.\n    CHANNEL: 0,\n    // The type of a {@link LexerCustomAction} action\n    CUSTOM: 1,\n    // The type of a {@link LexerModeAction} action.\n    MODE: 2,\n    //The type of a {@link LexerMoreAction} action.\n    MORE: 3,\n    //The type of a {@link LexerPopModeAction} action.\n    POP_MODE: 4,\n    //The type of a {@link LexerPushModeAction} action.\n    PUSH_MODE: 5,\n    //The type of a {@link LexerSkipAction} action.\n    SKIP: 6,\n    //The type of a {@link LexerTypeAction} action.\n    TYPE: 7\n}\n\nclass LexerAction {\n    constructor(action) {\n        this.actionType = action;\n        this.isPositionDependent = false;\n    }\n\n    hashCode() {\n        const hash = new Hash();\n        this.updateHashCode(hash);\n        return hash.finish()\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType);\n    }\n\n    equals(other) {\n        return this === other;\n    }\n}\n\n\n/**\n * Implements the {@code skip} lexer action by calling {@link Lexer//skip}.\n *\n * <p>The {@code skip} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerSkipAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.SKIP);\n    }\n\n    execute(lexer) {\n        lexer.skip();\n    }\n\n    toString() {\n        return \"skip\";\n    }\n}\n\n// Provides a singleton instance of this parameterless lexer action.\nLexerSkipAction.INSTANCE = new LexerSkipAction();\n\n/**\n * Implements the {@code type} lexer action by calling {@link Lexer//setType}\n * with the assigned type\n */\nclass LexerTypeAction extends LexerAction {\n    constructor(type) {\n        super(LexerActionType.TYPE);\n        this.type = type;\n    }\n\n    execute(lexer) {\n        lexer.type = this.type;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.type);\n    }\n\n    equals(other) {\n        if(this === other) {\n            return true;\n        } else if (! (other instanceof LexerTypeAction)) {\n            return false;\n        } else {\n            return this.type === other.type;\n        }\n    }\n\n    toString() {\n        return \"type(\" + this.type + \")\";\n    }\n}\n\n\n/**\n * Implements the {@code pushMode} lexer action by calling\n * {@link Lexer//pushMode} with the assigned mode\n */\nclass LexerPushModeAction extends LexerAction {\n    constructor(mode) {\n        super(LexerActionType.PUSH_MODE);\n        this.mode = mode;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//pushMode} with the\n     * value provided by {@link //getMode}.</p>\n     */\n    execute(lexer) {\n        lexer.pushMode(this.mode);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.mode);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerPushModeAction)) {\n            return false;\n        } else {\n            return this.mode === other.mode;\n        }\n    }\n\n    toString() {\n        return \"pushMode(\" + this.mode + \")\";\n    }\n}\n\n/**\n * Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.\n *\n * <p>The {@code popMode} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerPopModeAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.POP_MODE);\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n     */\n    execute(lexer) {\n        lexer.popMode();\n    }\n\n    toString() {\n        return \"popMode\";\n    }\n}\n\nLexerPopModeAction.INSTANCE = new LexerPopModeAction();\n\n/**\n * Implements the {@code more} lexer action by calling {@link Lexer//more}.\n *\n * <p>The {@code more} command does not have any parameters, so this action is\n * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>\n */\nclass LexerMoreAction extends LexerAction {\n    constructor() {\n        super(LexerActionType.MORE);\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>\n     */\n    execute(lexer) {\n        lexer.more();\n    }\n\n    toString() {\n        return \"more\";\n    }\n}\n\nLexerMoreAction.INSTANCE = new LexerMoreAction();\n\n\n/**\n * Implements the {@code mode} lexer action by calling {@link Lexer//mode} with\n * the assigned mode\n */\nclass LexerModeAction extends LexerAction {\n    constructor(mode) {\n        super(LexerActionType.MODE);\n        this.mode = mode;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//mode} with the\n     * value provided by {@link //getMode}.</p>\n     */\n    execute(lexer) {\n        lexer.mode(this.mode);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.mode);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerModeAction)) {\n            return false;\n        } else {\n            return this.mode === other.mode;\n        }\n    }\n\n    toString() {\n        return \"mode(\" + this.mode + \")\";\n    }\n}\n\n/**\n * Executes a custom lexer action by calling {@link Recognizer//action} with the\n * rule and action indexes assigned to the custom action. The implementation of\n * a custom action is added to the generated code for the lexer in an override\n * of {@link Recognizer//action} when the grammar is compiled.\n *\n * <p>This class may represent embedded actions created with the <code>{...}</code>\n * syntax in ANTLR 4, as well as actions created for lexer commands where the\n * command argument could not be evaluated when the grammar was compiled.</p>\n */\nclass LexerCustomAction extends LexerAction {\n    /**\n     * Constructs a custom lexer action with the specified rule and action\n     * indexes.\n     *\n     * @param ruleIndex The rule index to use for calls to\n     * {@link Recognizer//action}.\n     * @param actionIndex The action index to use for calls to\n     * {@link Recognizer//action}.\n     */\n    constructor(ruleIndex, actionIndex) {\n        super(LexerActionType.CUSTOM);\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex;\n        this.isPositionDependent = true;\n    }\n\n    /**\n     * <p>Custom actions are implemented by calling {@link Lexer//action} with the\n     * appropriate rule and action indexes.</p>\n     */\n    execute(lexer) {\n        lexer.action(null, this.ruleIndex, this.actionIndex);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.ruleIndex, this.actionIndex);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerCustomAction)) {\n            return false;\n        } else {\n            return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;\n        }\n    }\n}\n\n/**\n * Implements the {@code channel} lexer action by calling\n * {@link Lexer//setChannel} with the assigned channel.\n * Constructs a new {@code channel} action with the specified channel value.\n * @param channel The channel value to pass to {@link Lexer//setChannel}\n */\nclass LexerChannelAction extends LexerAction {\n    constructor(channel) {\n        super(LexerActionType.CHANNEL);\n        this.channel = channel;\n    }\n\n    /**\n     * <p>This action is implemented by calling {@link Lexer//setChannel} with the\n     * value provided by {@link //getChannel}.</p>\n     */\n    execute(lexer) {\n        lexer._channel = this.channel;\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.channel);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerChannelAction)) {\n            return false;\n        } else {\n            return this.channel === other.channel;\n        }\n    }\n\n    toString() {\n        return \"channel(\" + this.channel + \")\";\n    }\n}\n\n\n/**\n * This implementation of {@link LexerAction} is used for tracking input offsets\n * for position-dependent actions within a {@link LexerActionExecutor}.\n *\n * <p>This action is not serialized as part of the ATN, and is only required for\n * position-dependent lexer actions which appear at a location other than the\n * end of a rule. For more information about DFA optimizations employed for\n * lexer actions, see {@link LexerActionExecutor//append} and\n * {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>\n *\n * Constructs a new indexed custom action by associating a character offset\n * with a {@link LexerAction}.\n *\n * <p>Note: This class is only required for lexer actions for which\n * {@link LexerAction//isPositionDependent} returns {@code true}.</p>\n *\n * @param offset The offset into the input {@link CharStream}, relative to\n * the token start index, at which the specified lexer action should be\n * executed.\n * @param action The lexer action to execute at a particular offset in the\n * input {@link CharStream}.\n */\nclass LexerIndexedCustomAction extends LexerAction {\n    constructor(offset, action) {\n        super(action.actionType);\n        this.offset = offset;\n        this.action = action;\n        this.isPositionDependent = true;\n    }\n\n    /**\n     * <p>This method calls {@link //execute} on the result of {@link //getAction}\n     * using the provided {@code lexer}.</p>\n     */\n    execute(lexer) {\n        // assume the input stream position was properly set by the calling code\n        this.action.execute(lexer);\n    }\n\n    updateHashCode(hash) {\n        hash.update(this.actionType, this.offset, this.action);\n    }\n\n    equals(other) {\n        if (this === other) {\n            return true;\n        } else if (! (other instanceof LexerIndexedCustomAction)) {\n            return false;\n        } else {\n            return this.offset === other.offset && this.action === other.action;\n        }\n    }\n}\n\nmodule.exports = {\n    LexerActionType,\n    LexerSkipAction,\n    LexerChannelAction,\n    LexerCustomAction,\n    LexerIndexedCustomAction,\n    LexerMoreAction,\n    LexerTypeAction,\n    LexerPushModeAction,\n    LexerPopModeAction,\n    LexerModeAction\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/LexerAction.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js":
/*!*******************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {hashStuff} = __webpack_require__(/*! ../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\nconst {LexerIndexedCustomAction} = __webpack_require__(/*! ./LexerAction */ \"./node_modules/antlr4/src/antlr4/atn/LexerAction.js\");\n\nclass LexerActionExecutor {\n\t/**\n\t * Represents an executor for a sequence of lexer actions which traversed during\n\t * the matching operation of a lexer rule (token).\n\t *\n\t * <p>The executor tracks position information for position-dependent lexer actions\n\t * efficiently, ensuring that actions appearing only at the end of the rule do\n\t * not cause bloating of the {@link DFA} created for the lexer.</p>\n\t */\n\tconstructor(lexerActions) {\n\t\tthis.lexerActions = lexerActions === null ? [] : lexerActions;\n\t\t/**\n\t\t * Caches the result of {@link //hashCode} since the hash code is an element\n\t\t * of the performance-critical {@link LexerATNConfig//hashCode} operation\n\t\t */\n\t\tthis.cachedHashCode = hashStuff(lexerActions); // \"\".join([str(la) for la in\n\t\t// lexerActions]))\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which encodes the current offset\n\t * for position-dependent lexer actions.\n\t *\n\t * <p>Normally, when the executor encounters lexer actions where\n\t * {@link LexerAction//isPositionDependent} returns {@code true}, it calls\n\t * {@link IntStream//seek} on the input {@link CharStream} to set the input\n\t * position to the <em>end</em> of the current token. This behavior provides\n\t * for efficient DFA representation of lexer actions which appear at the end\n\t * of a lexer rule, even when the lexer rule matches a variable number of\n\t * characters.</p>\n\t *\n\t * <p>Prior to traversing a match transition in the ATN, the current offset\n\t * from the token start index is assigned to all position-dependent lexer\n\t * actions which have not already been assigned a fixed offset. By storing\n\t * the offsets relative to the token start index, the DFA representation of\n\t * lexer actions which appear in the middle of tokens remains efficient due\n\t * to sharing among tokens of the same length, regardless of their absolute\n\t * position in the input stream.</p>\n\t *\n\t * <p>If the current executor already has offsets assigned to all\n\t * position-dependent lexer actions, the method returns {@code this}.</p>\n\t *\n\t * @param offset The current offset to assign to all position-dependent\n\t * lexer actions which do not already have offsets assigned.\n\t *\n\t * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets\n\t * for all position-dependent lexer actions.\n\t */\n\tfixOffsetBeforeMatch(offset) {\n\t\tlet updatedLexerActions = null;\n\t\tfor (let i = 0; i < this.lexerActions.length; i++) {\n\t\t\tif (this.lexerActions[i].isPositionDependent &&\n\t\t\t\t\t!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {\n\t\t\t\tif (updatedLexerActions === null) {\n\t\t\t\t\tupdatedLexerActions = this.lexerActions.concat([]);\n\t\t\t\t}\n\t\t\t\tupdatedLexerActions[i] = new LexerIndexedCustomAction(offset,\n\t\t\t\t\t\tthis.lexerActions[i]);\n\t\t\t}\n\t\t}\n\t\tif (updatedLexerActions === null) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new LexerActionExecutor(updatedLexerActions);\n\t\t}\n\t}\n\n\t/**\n\t * Execute the actions encapsulated by this executor within the context of a\n\t * particular {@link Lexer}.\n\t *\n\t * <p>This method calls {@link IntStream//seek} to set the position of the\n\t * {@code input} {@link CharStream} prior to calling\n\t * {@link LexerAction//execute} on a position-dependent action. Before the\n\t * method returns, the input position will be restored to the same position\n\t * it was in when the method was invoked.</p>\n\t *\n\t * @param lexer The lexer instance.\n\t * @param input The input stream which is the source for the current token.\n\t * When this method is called, the current {@link IntStream//index} for\n\t * {@code input} should be the start of the following token, i.e. 1\n\t * character past the end of the current token.\n\t * @param startIndex The token start index. This value may be passed to\n\t * {@link IntStream//seek} to set the {@code input} position to the beginning\n\t * of the token.\n\t */\n\texecute(lexer, input, startIndex) {\n\t\tlet requiresSeek = false;\n\t\tconst stopIndex = input.index;\n\t\ttry {\n\t\t\tfor (let i = 0; i < this.lexerActions.length; i++) {\n\t\t\t\tlet lexerAction = this.lexerActions[i];\n\t\t\t\tif (lexerAction instanceof LexerIndexedCustomAction) {\n\t\t\t\t\tconst offset = lexerAction.offset;\n\t\t\t\t\tinput.seek(startIndex + offset);\n\t\t\t\t\tlexerAction = lexerAction.action;\n\t\t\t\t\trequiresSeek = (startIndex + offset) !== stopIndex;\n\t\t\t\t} else if (lexerAction.isPositionDependent) {\n\t\t\t\t\tinput.seek(stopIndex);\n\t\t\t\t\trequiresSeek = false;\n\t\t\t\t}\n\t\t\t\tlexerAction.execute(lexer);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (requiresSeek) {\n\t\t\t\tinput.seek(stopIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\thashCode() {\n\t\treturn this.cachedHashCode;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.cachedHashCode);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof LexerActionExecutor)) {\n\t\t\treturn false;\n\t\t} else if (this.cachedHashCode != other.cachedHashCode) {\n\t\t\treturn false;\n\t\t} else if (this.lexerActions.length != other.lexerActions.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tconst numActions = this.lexerActions.length\n\t\t\tfor (let idx = 0; idx < numActions; ++idx) {\n\t\t\t\tif (!this.lexerActions[idx].equals(other.lexerActions[idx])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which executes the actions for\n\t * the input {@code lexerActionExecutor} followed by a specified\n\t * {@code lexerAction}.\n\t *\n\t * @param lexerActionExecutor The executor for actions already traversed by\n\t * the lexer while matching a token within a particular\n\t * {@link LexerATNConfig}. If this is {@code null}, the method behaves as\n\t * though it were an empty executor.\n\t * @param lexerAction The lexer action to execute after the actions\n\t * specified in {@code lexerActionExecutor}.\n\t *\n\t * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions\n\t * of {@code lexerActionExecutor} and {@code lexerAction}.\n\t */\n\tstatic append(lexerActionExecutor, lexerAction) {\n\t\tif (lexerActionExecutor === null) {\n\t\t\treturn new LexerActionExecutor([ lexerAction ]);\n\t\t}\n\t\tconst lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);\n\t\treturn new LexerActionExecutor(lexerActions);\n\t}\n}\n\n\nmodule.exports = LexerActionExecutor;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js":
/*!******************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Utils = __webpack_require__(/*! ./../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\nconst {Set, BitSet, DoubleDict} = Utils;\n\nconst ATN = __webpack_require__(/*! ./ATN */ \"./node_modules/antlr4/src/antlr4/atn/ATN.js\");\nconst {ATNState, RuleStopState} = __webpack_require__(/*! ./ATNState */ \"./node_modules/antlr4/src/antlr4/atn/ATNState.js\");\n\nconst {ATNConfig} = __webpack_require__(/*! ./ATNConfig */ \"./node_modules/antlr4/src/antlr4/atn/ATNConfig.js\");\nconst {ATNConfigSet} = __webpack_require__(/*! ./ATNConfigSet */ \"./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js\");\nconst {Token} = __webpack_require__(/*! ./../Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst {DFAState, PredPrediction} = __webpack_require__(/*! ./../dfa/DFAState */ \"./node_modules/antlr4/src/antlr4/dfa/DFAState.js\");\nconst ATNSimulator = __webpack_require__(/*! ./ATNSimulator */ \"./node_modules/antlr4/src/antlr4/atn/ATNSimulator.js\");\nconst PredictionMode = __webpack_require__(/*! ./PredictionMode */ \"./node_modules/antlr4/src/antlr4/atn/PredictionMode.js\");\nconst RuleContext = __webpack_require__(/*! ./../RuleContext */ \"./node_modules/antlr4/src/antlr4/RuleContext.js\");\nconst ParserRuleContext = __webpack_require__(/*! ./../ParserRuleContext */ \"./node_modules/antlr4/src/antlr4/ParserRuleContext.js\");\nconst {SemanticContext} = __webpack_require__(/*! ./SemanticContext */ \"./node_modules/antlr4/src/antlr4/atn/SemanticContext.js\");\nconst {PredictionContext} = __webpack_require__(/*! ./../PredictionContext */ \"./node_modules/antlr4/src/antlr4/PredictionContext.js\");\nconst {Interval} = __webpack_require__(/*! ./../IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\");\nconst {Transition, SetTransition, NotSetTransition, RuleTransition, ActionTransition} = __webpack_require__(/*! ./Transition */ \"./node_modules/antlr4/src/antlr4/atn/Transition.js\");\nconst {NoViableAltException} = __webpack_require__(/*! ./../error/Errors */ \"./node_modules/antlr4/src/antlr4/error/Errors.js\");\nconst {SingletonPredictionContext, predictionContextFromRuleContext} = __webpack_require__(/*! ./../PredictionContext */ \"./node_modules/antlr4/src/antlr4/PredictionContext.js\");\n\n\n/**\n * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\n *\n * <p>\n * The basic complexity of the adaptive strategy makes it harder to understand.\n * We begin with ATN simulation to build paths in a DFA. Subsequent prediction\n * requests go through the DFA first. If they reach a state without an edge for\n * the current symbol, the algorithm fails over to the ATN simulation to\n * complete the DFA path for the current input (until it finds a conflict state\n * or uniquely predicting state).</p>\n *\n * <p>\n * All of that is done without using the outer context because we want to create\n * a DFA that is not dependent upon the rule invocation stack when we do a\n * prediction. One DFA works in all contexts. We avoid using context not\n * necessarily because it's slower, although it can be, but because of the DFA\n * caching problem. The closure routine only considers the rule invocation stack\n * created during prediction beginning in the decision rule. For example, if\n * prediction occurs without invoking another rule's ATN, there are no context\n * stacks in the configurations. When lack of context leads to a conflict, we\n * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\n * strategy (versus full LL(*)).</p>\n *\n * <p>\n * When SLL yields a configuration set with conflict, we rewind the input and\n * retry the ATN simulation, this time using full outer context without adding\n * to the DFA. Configuration context stacks will be the full invocation stacks\n * from the start rule. If we get a conflict using full context, then we can\n * definitively say we have a true ambiguity for that input sequence. If we\n * don't get a conflict, it implies that the decision is sensitive to the outer\n * context. (It is not context-sensitive in the sense of context-sensitive\n * grammars.)</p>\n *\n * <p>\n * The next time we reach this DFA state with an SLL conflict, through DFA\n * simulation, we will again retry the ATN simulation using full context mode.\n * This is slow because we can't save the results and have to \"interpret\" the\n * ATN each time we get that input.</p>\n *\n * <p>\n * <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>\n *\n * <p>\n * We could cache results from full context to predicted alternative easily and\n * that saves a lot of time but doesn't work in presence of predicates. The set\n * of visible predicates from the ATN start state changes depending on the\n * context, because closure can fall off the end of a rule. I tried to cache\n * tuples (stack context, semantic context, predicted alt) but it was slower\n * than interpreting and much more complicated. Also required a huge amount of\n * memory. The goal is not to create the world's fastest parser anyway. I'd like\n * to keep this algorithm simple. By launching multiple threads, we can improve\n * the speed of parsing across a large number of files.</p>\n *\n * <p>\n * There is no strict ordering between the amount of input used by SLL vs LL,\n * which makes it really hard to build a cache for full context. Let's say that\n * we have input A B C that leads to an SLL conflict with full context X. That\n * implies that using X we might only use A B but we could also use A B C D to\n * resolve conflict. Input A B C D could predict alternative 1 in one position\n * in the input and A B C E could predict alternative 2 in another position in\n * input. The conflicting SLL configurations could still be non-unique in the\n * full context prediction, which would lead us to requiring more input than the\n * original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\n * input\tused during the previous prediction. That amounts to a cache that maps\n * X to a specific DFA for that context.</p>\n *\n * <p>\n * Something should be done for left-recursive expression predictions. They are\n * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\n * with full LL thing Sam does.</p>\n *\n * <p>\n * <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>\n *\n * <p>\n * We avoid doing full context retry when the outer context is empty, we did not\n * dip into the outer context by falling off the end of the decision state rule,\n * or when we force SLL mode.</p>\n *\n * <p>\n * As an example of the not dip into outer context case, consider as super\n * constructor calls versus function calls. One grammar might look like\n * this:</p>\n *\n * <pre>\n * ctorBody\n *   : '{' superCall? stat* '}'\n *   ;\n * </pre>\n *\n * <p>\n * Or, you might see something like</p>\n *\n * <pre>\n * stat\n *   : superCall ';'\n *   | expression ';'\n *   | ...\n *   ;\n * </pre>\n *\n * <p>\n * In both cases I believe that no closure operations will dip into the outer\n * context. In the first case ctorBody in the worst case will stop at the '}'.\n * In the 2nd case it should stop at the ';'. Both cases should stay within the\n * entry rule and not dip into the outer context.</p>\n *\n * <p>\n * <strong>PREDICATES</strong></p>\n *\n * <p>\n * Predicates are always evaluated if present in either SLL or LL both. SLL and\n * LL simulation deals with predicates differently. SLL collects predicates as\n * it performs closure operations like ANTLR v3 did. It delays predicate\n * evaluation until it reaches and accept state. This allows us to cache the SLL\n * ATN simulation whereas, if we had evaluated predicates on-the-fly during\n * closure, the DFA state configuration sets would be different and we couldn't\n * build up a suitable DFA.</p>\n *\n * <p>\n * When building a DFA accept state during ATN simulation, we evaluate any\n * predicates and return the sole semantically valid alternative. If there is\n * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\n * we throw an exception. Alternatives without predicates act like they have\n * true predicates. The simple way to think about it is to strip away all\n * alternatives with false predicates and choose the minimum alternative that\n * remains.</p>\n *\n * <p>\n * When we start in the DFA and reach an accept state that's predicated, we test\n * those and return the minimum semantically viable alternative. If no\n * alternatives are viable, we throw an exception.</p>\n *\n * <p>\n * During full LL ATN simulation, closure always evaluates predicates and\n * on-the-fly. This is crucial to reducing the configuration set size during\n * closure. It hits a landmine when parsing with the Java grammar, for example,\n * without this on-the-fly evaluation.</p>\n *\n * <p>\n * <strong>SHARING DFA</strong></p>\n *\n * <p>\n * All instances of the same parser share the same decision DFAs through a\n * static field. Each instance gets its own ATN simulator but they share the\n * same {@link //decisionToDFA} field. They also share a\n * {@link PredictionContextCache} object that makes sure that all\n * {@link PredictionContext} objects are shared among the DFA states. This makes\n * a big size difference.</p>\n *\n * <p>\n * <strong>THREAD SAFETY</strong></p>\n *\n * <p>\n * The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when\n * it adds a new DFA object to that array. {@link //addDFAEdge}\n * locks on the DFA for the current decision when setting the\n * {@link DFAState//edges} field. {@link //addDFAState} locks on\n * the DFA for the current decision when looking up a DFA state to see if it\n * already exists. We must make sure that all requests to add DFA states that\n * are equivalent result in the same shared DFA object. This is because lots of\n * threads will be trying to update the DFA at once. The\n * {@link //addDFAState} method also locks inside the DFA lock\n * but this time on the shared context cache when it rebuilds the\n * configurations' {@link PredictionContext} objects using cached\n * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\n * safe as long as we can guarantee that all threads referencing\n * {@code s.edge[t]} get the same physical target {@link DFAState}, or\n * {@code null}. Once into the DFA, the DFA simulation does not reference the\n * {@link DFA//states} map. It follows the {@link DFAState//edges} field to new\n * targets. The DFA simulator will either find {@link DFAState//edges} to be\n * {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or\n * {@code dfa.edges[t]} to be non-null. The\n * {@link //addDFAEdge} method could be racing to set the field\n * but in either case the DFA simulator works; if {@code null}, and requests ATN\n * simulation. It could also race trying to get {@code dfa.edges[t]}, but either\n * way it will work because it's not doing a test and set operation.</p>\n *\n * <p>\n * <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage\n * Parsing)</strong></p>\n *\n * <p>\n * Sam pointed out that if SLL does not give a syntax error, then there is no\n * point in doing full LL, which is slower. We only have to try LL if we get a\n * syntax error. For maximum speed, Sam starts the parser set to pure SLL\n * mode with the {@link BailErrorStrategy}:</p>\n *\n * <pre>\n * parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};\n * parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\n * </pre>\n *\n * <p>\n * If it does not get a syntax error, then we're done. If it does get a syntax\n * error, we need to retry with the combined SLL/LL strategy.</p>\n *\n * <p>\n * The reason this works is as follows. If there are no SLL conflicts, then the\n * grammar is SLL (at least for that input set). If there is an SLL conflict,\n * the full LL analysis must yield a set of viable alternatives which is a\n * subset of the alternatives reported by SLL. If the LL set is a singleton,\n * then the grammar is LL but not SLL. If the LL set is the same size as the SLL\n * set, the decision is SLL. If the LL set has size &gt; 1, then that decision\n * is truly ambiguous on the current input. If the LL set is smaller, then the\n * SLL conflict resolution might choose an alternative that the full LL would\n * rule out as a possibility based upon better context information. If that's\n * the case, then the SLL parse will definitely get an error because the full LL\n * analysis says it's not viable. If SLL conflict resolution chooses an\n * alternative within the LL set, them both SLL and LL would choose the same\n * alternative because they both choose the minimum of multiple conflicting\n * alternatives.</p>\n *\n * <p>\n * Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and\n * a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL\n * parsing will get an error because SLL will pursue alternative 1. If\n * <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will\n * choose the same alternative because alternative one is the minimum of either\n * set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax\n * error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>\n *\n * <p>\n * Of course, if the input is invalid, then we will get an error for sure in\n * both SLL and LL parsing. Erroneous input will therefore require 2 passes over\n * the input.</p>\n */\nclass ParserATNSimulator extends ATNSimulator {\n    constructor(parser, atn, decisionToDFA, sharedContextCache) {\n        super(atn, sharedContextCache);\n        this.parser = parser;\n        this.decisionToDFA = decisionToDFA;\n        // SLL, LL, or LL + exact ambig detection?//\n        this.predictionMode = PredictionMode.LL;\n        // LAME globals to avoid parameters!!!!! I need these down deep in predTransition\n        this._input = null;\n        this._startIndex = 0;\n        this._outerContext = null;\n        this._dfa = null;\n        /**\n         * Each prediction operation uses a cache for merge of prediction contexts.\n         *  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap\n         *  isn't synchronized but we're ok since two threads shouldn't reuse same\n         *  parser/atnsim object because it can only handle one input at a time.\n         *  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid\n         *  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should\n         *  also be examined during cache lookup.\n         */\n        this.mergeCache = null;\n        this.debug = false;\n        this.debug_closure = false;\n        this.debug_add = false;\n        this.debug_list_atn_decisions = false;\n        this.dfa_debug = false;\n        this.retry_debug = false;\n    }\n\n    reset() {}\n\n    adaptivePredict(input, decision, outerContext) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"adaptivePredict decision \" + decision +\n                                   \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                   \" line \" + input.LT(1).line + \":\" +\n                                   input.LT(1).column);\n        }\n        this._input = input;\n        this._startIndex = input.index;\n        this._outerContext = outerContext;\n\n        const dfa = this.decisionToDFA[decision];\n        this._dfa = dfa;\n        const m = input.mark();\n        const index = input.index;\n\n        // Now we are certain to have a specific decision's DFA\n        // But, do we still need an initial state?\n        try {\n            let s0;\n            if (dfa.precedenceDfa) {\n                // the start state for a precedence DFA depends on the current\n                // parser precedence, and is provided by a DFA method.\n                s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());\n            } else {\n                // the start state for a \"regular\" DFA is just s0\n                s0 = dfa.s0;\n            }\n            if (s0===null) {\n                if (outerContext===null) {\n                    outerContext = RuleContext.EMPTY;\n                }\n                if (this.debug || this.debug_list_atn_decisions) {\n                    console.log(\"predictATN decision \" + dfa.decision +\n                                       \" exec LA(1)==\" + this.getLookaheadName(input) +\n                                       \", outerContext=\" + outerContext.toString(this.parser.ruleNames));\n                }\n\n                const fullCtx = false;\n                let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);\n\n                if( dfa.precedenceDfa) {\n                    // If this is a precedence DFA, we use applyPrecedenceFilter\n                    // to convert the computed start state to a precedence start\n                    // state. We then use DFA.setPrecedenceStartState to set the\n                    // appropriate start state for the precedence level rather\n                    // than simply setting DFA.s0.\n                    //\n                    dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway\n                    s0_closure = this.applyPrecedenceFilter(s0_closure);\n                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                    dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);\n                } else {\n                    s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));\n                    dfa.s0 = s0;\n                }\n            }\n            const alt = this.execATN(dfa, s0, input, index, outerContext);\n            if (this.debug) {\n                console.log(\"DFA after predictATN: \" + dfa.toString(this.parser.literalNames));\n            }\n            return alt;\n        } finally {\n            this._dfa = null;\n            this.mergeCache = null; // wack cache after each prediction\n            input.seek(index);\n            input.release(m);\n        }\n    }\n\n    /**\n     * Performs ATN simulation to compute a predicted alternative based\n     *  upon the remaining input, but also updates the DFA cache to avoid\n     *  having to traverse the ATN again for the same input sequence.\n     *\n     * There are some key conditions we're looking for after computing a new\n     * set of ATN configs (proposed DFA state):\n     *       if the set is empty, there is no viable alternative for current symbol\n     *       does the state uniquely predict an alternative?\n     *       does the state have a conflict that would prevent us from\n     *         putting it on the work list?\n     *\n     * We also have some key operations to do:\n     *       add an edge from previous DFA state to potentially new DFA state, D,\n     *         upon current symbol but only if adding to work list, which means in all\n     *         cases except no viable alternative (and possibly non-greedy decisions?)\n     *       collecting predicates and adding semantic context to DFA accept states\n     *       adding rule context to context-sensitive DFA accept states\n     *       consuming an input symbol\n     *       reporting a conflict\n     *       reporting an ambiguity\n     *       reporting a context sensitivity\n     *       reporting insufficient predicates\n     *\n     * cover these cases:\n     *    dead end\n     *    single alt\n     *    single alt + preds\n     *    conflict\n     *    conflict + preds\n     *\n     */\n    execATN(dfa, s0, input, startIndex, outerContext ) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"execATN decision \" + dfa.decision +\n                    \" exec LA(1)==\" + this.getLookaheadName(input) +\n                    \" line \" + input.LT(1).line + \":\" + input.LT(1).column);\n        }\n        let alt;\n        let previousD = s0;\n\n        if (this.debug) {\n            console.log(\"s0 = \" + s0);\n        }\n        let t = input.LA(1);\n        while(true) { // while more work\n            let D = this.getExistingTargetState(previousD, t);\n            if(D===null) {\n                D = this.computeTargetState(dfa, previousD, t);\n            }\n            if(D===ATNSimulator.ERROR) {\n                // if any configs in previous dipped into outer context, that\n                // means that input up to t actually finished entry rule\n                // at least for SLL decision. Full LL doesn't dip into outer\n                // so don't need special case.\n                // We will get an error no matter what so delay until after\n                // decision; better error message. Also, no reachable target\n                // ATN states in SLL implies LL will also get nowhere.\n                // If conflict in states that dip out, choose min since we\n                // will get error no matter what.\n                const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);\n                input.seek(startIndex);\n                alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);\n                if(alt!==ATN.INVALID_ALT_NUMBER) {\n                    return alt;\n                } else {\n                    throw e;\n                }\n            }\n            if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {\n                // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)\n                let conflictingAlts = null;\n                if (D.predicates!==null) {\n                    if (this.debug) {\n                        console.log(\"DFA state has preds in DFA sim LL failover\");\n                    }\n                    const conflictIndex = input.index;\n                    if(conflictIndex !== startIndex) {\n                        input.seek(startIndex);\n                    }\n                    conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);\n                    if (conflictingAlts.length===1) {\n                        if(this.debug) {\n                            console.log(\"Full LL avoided\");\n                        }\n                        return conflictingAlts.minValue();\n                    }\n                    if (conflictIndex !== startIndex) {\n                        // restore the index so reporting the fallback to full\n                        // context occurs with the index at the correct spot\n                        input.seek(conflictIndex);\n                    }\n                }\n                if (this.dfa_debug) {\n                    console.log(\"ctx sensitive state \" + outerContext +\" in \" + D);\n                }\n                const fullCtx = true;\n                const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);\n                this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);\n                alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);\n                return alt;\n            }\n            if (D.isAcceptState) {\n                if (D.predicates===null) {\n                    return D.prediction;\n                }\n                const stopIndex = input.index;\n                input.seek(startIndex);\n                const alts = this.evalSemanticContext(D.predicates, outerContext, true);\n                if (alts.length===0) {\n                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n                } else if (alts.length===1) {\n                    return alts.minValue();\n                } else {\n                    // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.\n                    this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);\n                    return alts.minValue();\n                }\n            }\n            previousD = D;\n\n            if (t !== Token.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n    }\n\n    /**\n     * Get an existing target state for an edge in the DFA. If the target state\n     * for the edge has not yet been computed or is otherwise not available,\n     * this method returns {@code null}.\n     *\n     * @param previousD The current DFA state\n     * @param t The next input symbol\n     * @return The existing target DFA state for the given input symbol\n     * {@code t}, or {@code null} if the target state for this edge is not\n     * already cached\n     */\n    getExistingTargetState(previousD, t) {\n        const edges = previousD.edges;\n        if (edges===null) {\n            return null;\n        } else {\n            return edges[t + 1] || null;\n        }\n    }\n\n    /**\n     * Compute a target state for an edge in the DFA, and attempt to add the\n     * computed state and corresponding edge to the DFA.\n     *\n     * @param dfa The DFA\n     * @param previousD The current DFA state\n     * @param t The next input symbol\n     *\n     * @return The computed target DFA state for the given input symbol\n     * {@code t}. If {@code t} does not lead to a valid DFA state, this method\n     * returns {@link //ERROR\n     */\n    computeTargetState(dfa, previousD, t) {\n       const reach = this.computeReachSet(previousD.configs, t, false);\n        if(reach===null) {\n            this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);\n            return ATNSimulator.ERROR;\n        }\n        // create new target state; we'll add to DFA after it's complete\n        let D = new DFAState(null, reach);\n\n        const predictedAlt = this.getUniqueAlt(reach);\n\n        if (this.debug) {\n            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n            console.log(\"SLL altSubSets=\" + Utils.arrayToString(altSubSets) +\n                        \", previous=\" + previousD.configs +\n                        \", configs=\" + reach +\n                        \", predict=\" + predictedAlt +\n                        \", allSubsetsConflict=\" +\n                        PredictionMode.allSubsetsConflict(altSubSets) + \", conflictingAlts=\" +\n                        this.getConflictingAlts(reach));\n        }\n        if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {\n            // NO CONFLICT, UNIQUELY PREDICTED ALT\n            D.isAcceptState = true;\n            D.configs.uniqueAlt = predictedAlt;\n            D.prediction = predictedAlt;\n        } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {\n            // MORE THAN ONE VIABLE ALTERNATIVE\n            D.configs.conflictingAlts = this.getConflictingAlts(reach);\n            D.requiresFullContext = true;\n            // in SLL-only mode, we will stop at this state and return the minimum alt\n            D.isAcceptState = true;\n            D.prediction = D.configs.conflictingAlts.minValue();\n        }\n        if (D.isAcceptState && D.configs.hasSemanticContext) {\n            this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));\n            if( D.predicates!==null) {\n                D.prediction = ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        // all adds to dfa are done after we've created full D state\n        D = this.addDFAEdge(dfa, previousD, t, D);\n        return D;\n    }\n\n    predicateDFAState(dfaState, decisionState) {\n        // We need to test all predicates, even in DFA states that\n        // uniquely predict alternative.\n        const nalts = decisionState.transitions.length;\n        // Update DFA so reach becomes accept state with (predicate,alt)\n        // pairs if preds found for conflicting alts\n        const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);\n        const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);\n        if (altToPred!==null) {\n            dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);\n            dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds\n        } else {\n            // There are preds in configs but they might go away\n            // when OR'd together like {p}? || NONE == NONE. If neither\n            // alt has preds, resolve to min alt\n            dfaState.prediction = altsToCollectPredsFrom.minValue();\n        }\n    }\n\n// comes back with reach.uniqueAlt set to a valid alt\n    execATNWithFullContext(dfa, D, // how far we got before failing over\n                                         s0,\n                                         input,\n                                         startIndex,\n                                         outerContext) {\n        if (this.debug || this.debug_list_atn_decisions) {\n            console.log(\"execATNWithFullContext \"+s0);\n        }\n        const fullCtx = true;\n        let foundExactAmbig = false;\n        let reach;\n        let previous = s0;\n        input.seek(startIndex);\n        let t = input.LA(1);\n        let predictedAlt = -1;\n        while (true) { // while more work\n            reach = this.computeReachSet(previous, t, fullCtx);\n            if (reach===null) {\n                // if any configs in previous dipped into outer context, that\n                // means that input up to t actually finished entry rule\n                // at least for LL decision. Full LL doesn't dip into outer\n                // so don't need special case.\n                // We will get an error no matter what so delay until after\n                // decision; better error message. Also, no reachable target\n                // ATN states in SLL implies LL will also get nowhere.\n                // If conflict in states that dip out, choose min since we\n                // will get error no matter what.\n                const e = this.noViableAlt(input, outerContext, previous, startIndex);\n                input.seek(startIndex);\n                const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);\n                if(alt!==ATN.INVALID_ALT_NUMBER) {\n                    return alt;\n                } else {\n                    throw e;\n                }\n            }\n            const altSubSets = PredictionMode.getConflictingAltSubsets(reach);\n            if(this.debug) {\n                console.log(\"LL altSubSets=\" + altSubSets + \", predict=\" +\n                      PredictionMode.getUniqueAlt(altSubSets) + \", resolvesToJustOneViableAlt=\" +\n                      PredictionMode.resolvesToJustOneViableAlt(altSubSets));\n            }\n            reach.uniqueAlt = this.getUniqueAlt(reach);\n            // unique prediction?\n            if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {\n                predictedAlt = reach.uniqueAlt;\n                break;\n            } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n                predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);\n                if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n                    break;\n                }\n            } else {\n                // In exact ambiguity mode, we never try to terminate early.\n                // Just keeps scarfing until we know what the conflict is\n                if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {\n                    foundExactAmbig = true;\n                    predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);\n                    break;\n                }\n                // else there are multiple non-conflicting subsets or\n                // we're not sure what the ambiguity is yet.\n                // So, keep going.\n            }\n            previous = reach;\n            if( t !== Token.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n        // If the configuration set uniquely predicts an alternative,\n        // without conflict, then we know that it's a full LL decision\n        // not SLL.\n        if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {\n            this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);\n            return predictedAlt;\n        }\n        // We do not check predicates here because we have checked them\n        // on-the-fly when doing full context prediction.\n\n        //\n        // In non-exact ambiguity detection mode, we might\tactually be able to\n        // detect an exact ambiguity, but I'm not going to spend the cycles\n        // needed to check. We only emit ambiguity warnings in exact ambiguity\n        // mode.\n        //\n        // For example, we might know that we have conflicting configurations.\n        // But, that does not mean that there is no way forward without a\n        // conflict. It's possible to have nonconflicting alt subsets as in:\n\n        // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]\n\n        // from\n        //\n        //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),\n        //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]\n        //\n        // In this case, (17,1,[5 $]) indicates there is some next sequence that\n        // would resolve this without conflict to alternative 1. Any other viable\n        // next sequence, however, is associated with a conflict.  We stop\n        // looking for input because no amount of further lookahead will alter\n        // the fact that we should predict alternative 1.  We just can't say for\n        // sure that there is an ambiguity without looking further.\n\n        this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);\n\n        return predictedAlt;\n    }\n\n    computeReachSet(closure, t, fullCtx) {\n        if (this.debug) {\n            console.log(\"in computeReachSet, starting closure: \" + closure);\n        }\n        if( this.mergeCache===null) {\n            this.mergeCache = new DoubleDict();\n        }\n        const intermediate = new ATNConfigSet(fullCtx);\n\n        // Configurations already in a rule stop state indicate reaching the end\n        // of the decision rule (local context) or end of the start rule (full\n        // context). Once reached, these configurations are never updated by a\n        // closure operation, so they are handled separately for the performance\n        // advantage of having a smaller intermediate set when calling closure.\n        //\n        // For full-context reach operations, separate handling is required to\n        // ensure that the alternative matching the longest overall sequence is\n        // chosen when multiple such configurations can match the input.\n\n        let skippedStopStates = null;\n\n        // First figure out where we can reach on input t\n        for (let i=0; i<closure.items.length;i++) {\n            const c = closure.items[i];\n            if(this.debug) {\n                console.log(\"testing \" + this.getTokenName(t) + \" at \" + c);\n            }\n            if (c.state instanceof RuleStopState) {\n                if (fullCtx || t === Token.EOF) {\n                    if (skippedStopStates===null) {\n                        skippedStopStates = [];\n                    }\n                    skippedStopStates.push(c);\n                    if(this.debug_add) {\n                        console.log(\"added \" + c + \" to skippedStopStates\");\n                    }\n                }\n                continue;\n            }\n            for(let j=0;j<c.state.transitions.length;j++) {\n                const trans = c.state.transitions[j];\n                const target = this.getReachableTarget(trans, t);\n                if (target!==null) {\n                    const cfg = new ATNConfig({state:target}, c);\n                    intermediate.add(cfg, this.mergeCache);\n                    if(this.debug_add) {\n                        console.log(\"added \" + cfg + \" to intermediate\");\n                    }\n                }\n            }\n        }\n        // Now figure out where the reach operation can take us...\n        let reach = null;\n\n        // This block optimizes the reach operation for intermediate sets which\n        // trivially indicate a termination state for the overall\n        // adaptivePredict operation.\n        //\n        // The conditions assume that intermediate\n        // contains all configurations relevant to the reach set, but this\n        // condition is not true when one or more configurations have been\n        // withheld in skippedStopStates, or when the current symbol is EOF.\n        //\n        if (skippedStopStates===null && t!==Token.EOF) {\n            if (intermediate.items.length===1) {\n                // Don't pursue the closure if there is just one state.\n                // It can only have one alternative; just add to result\n                // Also don't pursue the closure if there is unique alternative\n                // among the configurations.\n                reach = intermediate;\n            } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {\n                // Also don't pursue the closure if there is unique alternative\n                // among the configurations.\n                reach = intermediate;\n            }\n        }\n        // If the reach set could not be trivially determined, perform a closure\n        // operation on the intermediate set to compute its initial value.\n        //\n        if (reach===null) {\n            reach = new ATNConfigSet(fullCtx);\n            const closureBusy = new Set();\n            const treatEofAsEpsilon = t === Token.EOF;\n            for (let k=0; k<intermediate.items.length;k++) {\n                this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);\n            }\n        }\n        if (t === Token.EOF) {\n            // After consuming EOF no additional input is possible, so we are\n            // only interested in configurations which reached the end of the\n            // decision rule (local context) or end of the start rule (full\n            // context). Update reach to contain only these configurations. This\n            // handles both explicit EOF transitions in the grammar and implicit\n            // EOF transitions following the end of the decision or start rule.\n            //\n            // When reach==intermediate, no closure operation was performed. In\n            // this case, removeAllConfigsNotInRuleStopState needs to check for\n            // reachable rule stop states as well as configurations already in\n            // a rule stop state.\n            //\n            // This is handled before the configurations in skippedStopStates,\n            // because any configurations potentially added from that list are\n            // already guaranteed to meet this condition whether or not it's\n            // required.\n            //\n            reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);\n        }\n        // If skippedStopStates!==null, then it contains at least one\n        // configuration. For full-context reach operations, these\n        // configurations reached the end of the start rule, in which case we\n        // only add them back to reach if no configuration during the current\n        // closure operation reached such a state. This ensures adaptivePredict\n        // chooses an alternative matching the longest overall sequence when\n        // multiple alternatives are viable.\n        //\n        if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {\n            for (let l=0; l<skippedStopStates.length;l++) {\n                reach.add(skippedStopStates[l], this.mergeCache);\n            }\n        }\n        if (reach.items.length===0) {\n            return null;\n        } else {\n            return reach;\n        }\n    }\n\n    /**\n     * Return a configuration set containing only the configurations from\n     * {@code configs} which are in a {@link RuleStopState}. If all\n     * configurations in {@code configs} are already in a rule stop state, this\n     * method simply returns {@code configs}.\n     *\n     * <p>When {@code lookToEndOfRule} is true, this method uses\n     * {@link ATN//nextTokens} for each configuration in {@code configs} which is\n     * not already in a rule stop state to see if a rule stop state is reachable\n     * from the configuration via epsilon-only transitions.</p>\n     *\n     * @param configs the configuration set to update\n     * @param lookToEndOfRule when true, this method checks for rule stop states\n     * reachable by epsilon-only transitions from each configuration in\n     * {@code configs}.\n     *\n     * @return {@code configs} if all configurations in {@code configs} are in a\n     * rule stop state, otherwise return a new configuration set containing only\n     * the configurations from {@code configs} which are in a rule stop state\n     */\n    removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {\n        if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return configs;\n        }\n        const result = new ATNConfigSet(configs.fullCtx);\n        for(let i=0; i<configs.items.length;i++) {\n            const config = configs.items[i];\n            if (config.state instanceof RuleStopState) {\n                result.add(config, this.mergeCache);\n                continue;\n            }\n            if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {\n                const nextTokens = this.atn.nextTokens(config.state);\n                if (nextTokens.contains(Token.EPSILON)) {\n                    const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];\n                    result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);\n                }\n            }\n        }\n        return result;\n    }\n\n    computeStartState(p, ctx, fullCtx) {\n        // always at least the implicit call to start rule\n        const initialContext = predictionContextFromRuleContext(this.atn, ctx);\n        const configs = new ATNConfigSet(fullCtx);\n        for(let i=0;i<p.transitions.length;i++) {\n            const target = p.transitions[i].target;\n            const c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);\n            const closureBusy = new Set();\n            this.closure(c, configs, closureBusy, true, fullCtx, false);\n        }\n        return configs;\n    }\n\n    /**\n     * This method transforms the start state computed by\n     * {@link //computeStartState} to the special start state used by a\n     * precedence DFA for a particular precedence value. The transformation\n     * process applies the following changes to the start state's configuration\n     * set.\n     *\n     * <ol>\n     * <li>Evaluate the precedence predicates for each configuration using\n     * {@link SemanticContext//evalPrecedence}.</li>\n     * <li>Remove all configurations which predict an alternative greater than\n     * 1, for which another configuration that predicts alternative 1 is in the\n     * same ATN state with the same prediction context. This transformation is\n     * valid for the following reasons:\n     * <ul>\n     * <li>The closure block cannot contain any epsilon transitions which bypass\n     * the body of the closure, so all states reachable via alternative 1 are\n     * part of the precedence alternatives of the transformed left-recursive\n     * rule.</li>\n     * <li>The \"primary\" portion of a left recursive rule cannot contain an\n     * epsilon transition, so the only way an alternative other than 1 can exist\n     * in a state that is also reachable via alternative 1 is by nesting calls\n     * to the left-recursive rule, with the outer calls not being at the\n     * preferred precedence level.</li>\n     * </ul>\n     * </li>\n     * </ol>\n     *\n     * <p>\n     * The prediction context must be considered by this filter to address\n     * situations like the following.\n     * </p>\n     * <code>\n     * <pre>\n     * grammar TA;\n     * prog: statement* EOF;\n     * statement: letterA | statement letterA 'b' ;\n     * letterA: 'a';\n     * </pre>\n     * </code>\n     * <p>\n     * If the above grammar, the ATN state immediately before the token\n     * reference {@code 'a'} in {@code letterA} is reachable from the left edge\n     * of both the primary and closure blocks of the left-recursive rule\n     * {@code statement}. The prediction context associated with each of these\n     * configurations distinguishes between them, and prevents the alternative\n     * which stepped out to {@code prog} (and then back in to {@code statement}\n     * from being eliminated by the filter.\n     * </p>\n     *\n     * @param configs The configuration set computed by\n     * {@link //computeStartState} as the start state for the DFA.\n     * @return The transformed configuration set representing the start state\n     * for a precedence DFA at a particular precedence level (determined by\n     * calling {@link Parser//getPrecedence})\n     */\n    applyPrecedenceFilter(configs) {\n        let config;\n        const statesFromAlt1 = [];\n        const configSet = new ATNConfigSet(configs.fullCtx);\n        for(let i=0; i<configs.items.length; i++) {\n            config = configs.items[i];\n            // handle alt 1 first\n            if (config.alt !== 1) {\n                continue;\n            }\n            const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);\n            if (updatedContext===null) {\n                // the configuration was eliminated\n                continue;\n            }\n            statesFromAlt1[config.state.stateNumber] = config.context;\n            if (updatedContext !== config.semanticContext) {\n                configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);\n            } else {\n                configSet.add(config, this.mergeCache);\n            }\n        }\n        for(let i=0; i<configs.items.length; i++) {\n            config = configs.items[i];\n            if (config.alt === 1) {\n                // already handled\n                continue;\n            }\n            // In the future, this elimination step could be updated to also\n            // filter the prediction context for alternatives predicting alt>1\n            // (basically a graph subtraction algorithm).\n            if (!config.precedenceFilterSuppressed) {\n                const context = statesFromAlt1[config.state.stateNumber] || null;\n                if (context!==null && context.equals(config.context)) {\n                    // eliminated\n                    continue;\n                }\n            }\n            configSet.add(config, this.mergeCache);\n        }\n        return configSet;\n    }\n\n    getReachableTarget(trans, ttype) {\n        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n            return trans.target;\n        } else {\n            return null;\n        }\n    }\n\n    getPredsForAmbigAlts(ambigAlts, configs, nalts) {\n        // REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n        // altToPred starts as an array of all null contexts. The entry at index i\n        // corresponds to alternative i. altToPred[i] may have one of three values:\n        //   1. null: no ATNConfig c is found such that c.alt==i\n        //   2. SemanticContext.NONE: At least one ATNConfig c exists such that\n        //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,\n        //      alt i has at least one unpredicated config.\n        //   3. Non-NONE Semantic Context: There exists at least one, and for all\n        //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.\n        //\n        // From this, it is clear that NONE||anything==NONE.\n        //\n        let altToPred = [];\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if(ambigAlts.contains( c.alt )) {\n                altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);\n            }\n        }\n        let nPredAlts = 0;\n        for (let i =1;i< nalts+1;i++) {\n            const pred = altToPred[i] || null;\n            if (pred===null) {\n                altToPred[i] = SemanticContext.NONE;\n            } else if (pred !== SemanticContext.NONE) {\n                nPredAlts += 1;\n            }\n        }\n        // nonambig alts are null in altToPred\n        if (nPredAlts===0) {\n            altToPred = null;\n        }\n        if (this.debug) {\n            console.log(\"getPredsForAmbigAlts result \" + Utils.arrayToString(altToPred));\n        }\n        return altToPred;\n    }\n\n    getPredicatePredictions(ambigAlts, altToPred) {\n        const pairs = [];\n        let containsPredicate = false;\n        for (let i=1; i<altToPred.length;i++) {\n            const pred = altToPred[i];\n            // unpredicated is indicated by SemanticContext.NONE\n            if( ambigAlts!==null && ambigAlts.contains( i )) {\n                pairs.push(new PredPrediction(pred, i));\n            }\n            if (pred !== SemanticContext.NONE) {\n                containsPredicate = true;\n            }\n        }\n        if (! containsPredicate) {\n            return null;\n        }\n        return pairs;\n    }\n\n    /**\n     * This method is used to improve the localization of error messages by\n     * choosing an alternative rather than throwing a\n     * {@link NoViableAltException} in particular prediction scenarios where the\n     * {@link //ERROR} state was reached during ATN simulation.\n     *\n     * <p>\n     * The default implementation of this method uses the following\n     * algorithm to identify an ATN configuration which successfully parsed the\n     * decision entry rule. Choosing such an alternative ensures that the\n     * {@link ParserRuleContext} returned by the calling rule will be complete\n     * and valid, and the syntax error will be reported later at a more\n     * localized location.</p>\n     *\n     * <ul>\n     * <li>If a syntactically valid path or paths reach the end of the decision rule and\n     * they are semantically valid if predicated, return the min associated alt.</li>\n     * <li>Else, if a semantically invalid but syntactically valid path exist\n     * or paths exist, return the minimum associated alt.\n     * </li>\n     * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>\n     * </ul>\n     *\n     * <p>\n     * In some scenarios, the algorithm described above could predict an\n     * alternative which will result in a {@link FailedPredicateException} in\n     * the parser. Specifically, this could occur if the <em>only</em> configuration\n     * capable of successfully parsing to the end of the decision rule is\n     * blocked by a semantic predicate. By choosing this alternative within\n     * {@link //adaptivePredict} instead of throwing a\n     * {@link NoViableAltException}, the resulting\n     * {@link FailedPredicateException} in the parser will identify the specific\n     * predicate which is preventing the parser from successfully parsing the\n     * decision rule, which helps developers identify and correct logic errors\n     * in semantic predicates.\n     * </p>\n     *\n     * @param configs The ATN configurations which were valid immediately before\n     * the {@link //ERROR} state was reached\n     * @param outerContext The is the \\gamma_0 initial parser context from the paper\n     * or the parser stack at the instant before prediction commences.\n     *\n     * @return The value to return from {@link //adaptivePredict}, or\n     * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not\n     * identified and {@link //adaptivePredict} should report an error instead\n     */\n    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {\n        const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);\n        const semValidConfigs = cfgs[0];\n        const semInvalidConfigs = cfgs[1];\n        let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);\n        if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists\n            return alt;\n        }\n        // Is there a syntactically valid path with a failed pred?\n        if (semInvalidConfigs.items.length>0) {\n            alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);\n            if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists\n                return alt;\n            }\n        }\n        return ATN.INVALID_ALT_NUMBER;\n    }\n\n    getAltThatFinishedDecisionEntryRule(configs) {\n        const alts = [];\n        for(let i=0;i<configs.items.length; i++) {\n            const c = configs.items[i];\n            if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {\n                if(alts.indexOf(c.alt)<0) {\n                    alts.push(c.alt);\n                }\n            }\n        }\n        if (alts.length===0) {\n            return ATN.INVALID_ALT_NUMBER;\n        } else {\n            return Math.min.apply(null, alts);\n        }\n    }\n\n    /**\n     * Walk the list of configurations and split them according to\n     * those that have preds evaluating to true/false.  If no pred, assume\n     * true pred and include in succeeded set.  Returns Pair of sets.\n     *\n     * Create a new set so as not to alter the incoming parameter.\n     *\n     * Assumption: the input stream has been restored to the starting point\n     * prediction, which is where predicates need to evaluate.*/\n    splitAccordingToSemanticValidity( configs, outerContext) {\n        const succeeded = new ATNConfigSet(configs.fullCtx);\n        const failed = new ATNConfigSet(configs.fullCtx);\n        for(let i=0;i<configs.items.length; i++) {\n            const c = configs.items[i];\n            if (c.semanticContext !== SemanticContext.NONE) {\n                const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);\n                if (predicateEvaluationResult) {\n                    succeeded.add(c);\n                } else {\n                    failed.add(c);\n                }\n            } else {\n                succeeded.add(c);\n            }\n        }\n        return [succeeded, failed];\n    }\n\n    /**\n     * Look through a list of predicate/alt pairs, returning alts for the\n     * pairs that win. A {@code NONE} predicate indicates an alt containing an\n     * unpredicated config which behaves as \"always true.\" If !complete\n     * then we stop at the first predicate that evaluates to true. This\n     * includes pairs with null predicates.\n     */\n    evalSemanticContext(predPredictions, outerContext, complete) {\n        const predictions = new BitSet();\n        for(let i=0;i<predPredictions.length;i++) {\n            const pair = predPredictions[i];\n            if (pair.pred === SemanticContext.NONE) {\n                predictions.add(pair.alt);\n                if (! complete) {\n                    break;\n                }\n                continue;\n            }\n            const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);\n            if (this.debug || this.dfa_debug) {\n                console.log(\"eval pred \" + pair + \"=\" + predicateEvaluationResult);\n            }\n            if (predicateEvaluationResult) {\n                if (this.debug || this.dfa_debug) {\n                    console.log(\"PREDICT \" + pair.alt);\n                }\n                predictions.add(pair.alt);\n                if (! complete) {\n                    break;\n                }\n            }\n        }\n        return predictions;\n    }\n\n// TODO: If we are doing predicates, there is no point in pursuing\n//     closure operations if we reach a DFA state that uniquely predicts\n//     alternative. We will not be caching that DFA state and it is a\n//     waste to pursue the closure. Might have to advance when we do\n//     ambig detection thought :(\n//\n    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {\n        const initialDepth = 0;\n        this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,\n                                 fullCtx, initialDepth, treatEofAsEpsilon);\n    }\n\n    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        if (this.debug || this.debug_closure) {\n            console.log(\"closure(\" + config.toString(this.parser,true) + \")\");\n            // console.log(\"configs(\" + configs.toString() + \")\");\n            if(config.reachesIntoOuterContext>50) {\n                throw \"problem\";\n            }\n        }\n        if (config.state instanceof RuleStopState) {\n            // We hit rule end. If we have context info, use it\n            // run thru all possible stack tops in ctx\n            if (! config.context.isEmpty()) {\n                for (let i =0; i<config.context.length; i++) {\n                    if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {\n                        if (fullCtx) {\n                            configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);\n                            continue;\n                        } else {\n                            // we have no context info, just chase follow links (if greedy)\n                            if (this.debug) {\n                                console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                            }\n                            this.closure_(config, configs, closureBusy, collectPredicates,\n                                     fullCtx, depth, treatEofAsEpsilon);\n                        }\n                        continue;\n                    }\n                    const returnState = this.atn.states[config.context.getReturnState(i)];\n                    const newContext = config.context.getParent(i); // \"pop\" return state\n                    const parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};\n                    const c = new ATNConfig(parms, null);\n                    // While we have context to pop back from, we may have\n                    // gotten that context AFTER having falling off a rule.\n                    // Make sure we track that we are now out of context.\n                    c.reachesIntoOuterContext = config.reachesIntoOuterContext;\n                    this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);\n                }\n                return;\n            } else if( fullCtx) {\n                // reached end of start rule\n                configs.add(config, this.mergeCache);\n                return;\n            } else {\n                // else if we have no context info, just chase follow links (if greedy)\n                if (this.debug) {\n                    console.log(\"FALLING off rule \" + this.getRuleName(config.state.ruleIndex));\n                }\n            }\n        }\n        this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);\n    }\n\n    // Do the actual work of walking epsilon edges//\n    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {\n        const p = config.state;\n        // optimization\n        if (! p.epsilonOnlyTransitions) {\n            configs.add(config, this.mergeCache);\n            // make sure to not return here, because EOF transitions can act as\n            // both epsilon transitions and non-epsilon transitions.\n        }\n        for(let i = 0;i<p.transitions.length; i++) {\n            if(i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))\n                continue;\n\n            const t = p.transitions[i];\n            const continueCollecting = collectPredicates && !(t instanceof ActionTransition);\n            const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);\n            if (c!==null) {\n                let newDepth = depth;\n                if ( config.state instanceof RuleStopState) {\n                    // target fell off end of rule; mark resulting c as having dipped into outer context\n                    // We can't get here if incoming config was rule stop and we had context\n                    // track how far we dip into outer context.  Might\n                    // come in handy and we avoid evaluating context dependent\n                    // preds if this is > 0.\n                    if (this._dfa !== null && this._dfa.precedenceDfa) {\n                        if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {\n                            c.precedenceFilterSuppressed = true;\n                        }\n                    }\n\n                    c.reachesIntoOuterContext += 1;\n                    if (closureBusy.add(c)!==c) {\n                        // avoid infinite recursion for right-recursive rules\n                        continue;\n                    }\n                    configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method\n                    newDepth -= 1;\n                    if (this.debug) {\n                        console.log(\"dips into outer ctx: \" + c);\n                    }\n                } else {\n                    if (!t.isEpsilon && closureBusy.add(c)!==c){\n                        // avoid infinite recursion for EOF* and EOF+\n                        continue;\n                    }\n                    if (t instanceof RuleTransition) {\n                        // latch when newDepth goes negative - once we step out of the entry context we can't return\n                        if (newDepth >= 0) {\n                            newDepth += 1;\n                        }\n                    }\n                }\n                this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);\n            }\n        }\n    }\n\n    canDropLoopEntryEdgeInLeftRecursiveRule(config) {\n        // return False\n        const p = config.state;\n        // First check to see if we are in StarLoopEntryState generated during\n        // left-recursion elimination. For efficiency, also check if\n        // the context has an empty stack case. If so, it would mean\n        // global FOLLOW so we can't perform optimization\n        // Are we the special loop entry/exit state? or SLL wildcard\n        if(p.stateType !== ATNState.STAR_LOOP_ENTRY)\n            return false;\n        if(p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||\n               config.context.isEmpty() || config.context.hasEmptyPath())\n            return false;\n\n        // Require all return states to return back to the same rule that p is in.\n        const numCtxs = config.context.length;\n        for(let i=0; i<numCtxs; i++) { // for each stack context\n            const returnState = this.atn.states[config.context.getReturnState(i)];\n            if (returnState.ruleIndex !== p.ruleIndex)\n                return false;\n        }\n\n        const decisionStartState = p.transitions[0].target;\n        const blockEndStateNum = decisionStartState.endState.stateNumber;\n        const blockEndState = this.atn.states[blockEndStateNum];\n\n        // Verify that the top of each stack context leads to loop entry/exit\n        // state through epsilon edges and w/o leaving rule.\n        for(let i=0; i<numCtxs; i++) { // for each stack context\n            const returnStateNumber = config.context.getReturnState(i);\n            const returnState = this.atn.states[returnStateNumber];\n            // all states must have single outgoing epsilon edge\n            if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)\n                return false;\n\n            // Look for prefix op case like 'not expr', (' type ')' expr\n            const returnStateTarget = returnState.transitions[0].target;\n            if ( returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p )\n                continue;\n\n            // Look for 'expr op expr' or case where expr's return state is block end\n            // of (...)* internal block; the block end points to loop back\n            // which points to p but we don't need to check that\n            if ( returnState === blockEndState )\n                continue;\n\n            // Look for ternary expr ? expr : expr. The return state points at block end,\n            // which points at loop entry state\n            if ( returnStateTarget === blockEndState )\n                continue;\n\n            // Look for complex prefix 'between expr and expr' case where 2nd expr's\n            // return state points at block end state of (...)* internal block\n            if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1\n                    && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)\n                continue;\n\n            // anything else ain't conforming\n            return false;\n        }\n        return true;\n    }\n\n    getRuleName(index) {\n        if (this.parser!==null && index>=0) {\n            return this.parser.ruleNames[index];\n        } else {\n            return \"<rule \" + index + \">\";\n        }\n    }\n\n    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {\n        switch(t.serializationType) {\n        case Transition.RULE:\n            return this.ruleTransition(config, t);\n        case Transition.PRECEDENCE:\n            return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.PREDICATE:\n            return this.predTransition(config, t, collectPredicates, inContext, fullCtx);\n        case Transition.ACTION:\n            return this.actionTransition(config, t);\n        case Transition.EPSILON:\n            return new ATNConfig({state:t.target}, config);\n        case Transition.ATOM:\n        case Transition.RANGE:\n        case Transition.SET:\n            // EOF transitions act like epsilon transitions after the first EOF\n            // transition is traversed\n            if (treatEofAsEpsilon) {\n                if (t.matches(Token.EOF, 0, 1)) {\n                    return new ATNConfig({state: t.target}, config);\n                }\n            }\n            return null;\n        default:\n            return null;\n        }\n    }\n\n    actionTransition(config, t) {\n        if (this.debug) {\n            const index = t.actionIndex === -1 ? 65535 : t.actionIndex;\n            console.log(\"ACTION edge \" + t.ruleIndex + \":\" + index);\n        }\n        return new ATNConfig({state:t.target}, config);\n    }\n\n    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (this.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n                    pt.precedence + \">=_p, ctx dependent=true\");\n            if (this.parser!==null) {\n                console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n            }\n        }\n        let c = null;\n        if (collectPredicates && inContext) {\n            if (fullCtx) {\n                // In full context mode, we can evaluate predicates on-the-fly\n                // during closure, which dramatically reduces the size of\n                // the config sets. It also obviates the need to test predicates\n                // later during conflict resolution.\n                const currentPosition = this._input.index;\n                this._input.seek(this._startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n                this._input.seek(currentPosition);\n                if (predSucceeds) {\n                    c = new ATNConfig({state:pt.target}, config); // no pred context\n                }\n            } else {\n                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n            }\n        } else {\n            c = new ATNConfig({state:pt.target}, config);\n        }\n        if (this.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n\n    predTransition(config, pt, collectPredicates, inContext, fullCtx) {\n        if (this.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" + pt.ruleIndex +\n                    \":\" + pt.predIndex + \", ctx dependent=\" + pt.isCtxDependent);\n            if (this.parser!==null) {\n                console.log(\"context surrounding pred is \" + Utils.arrayToString(this.parser.getRuleInvocationStack()));\n            }\n        }\n        let c = null;\n        if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {\n            if (fullCtx) {\n                // In full context mode, we can evaluate predicates on-the-fly\n                // during closure, which dramatically reduces the size of\n                // the config sets. It also obviates the need to test predicates\n                // later during conflict resolution.\n                const currentPosition = this._input.index;\n                this._input.seek(this._startIndex);\n                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);\n                this._input.seek(currentPosition);\n                if (predSucceeds) {\n                    c = new ATNConfig({state:pt.target}, config); // no pred context\n                }\n            } else {\n                const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());\n                c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);\n            }\n        } else {\n            c = new ATNConfig({state:pt.target}, config);\n        }\n        if (this.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n\n    ruleTransition(config, t) {\n        if (this.debug) {\n            console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) + \", ctx=\" + config.context);\n        }\n        const returnState = t.followState;\n        const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);\n        return new ATNConfig({state:t.target, context:newContext}, config );\n    }\n\n    getConflictingAlts(configs) {\n        const altsets = PredictionMode.getConflictingAltSubsets(configs);\n        return PredictionMode.getAlts(altsets);\n    }\n\n    /**\n     * Sam pointed out a problem with the previous definition, v3, of\n     * ambiguous states. If we have another state associated with conflicting\n     * alternatives, we should keep going. For example, the following grammar\n     *\n     * s : (ID | ID ID?) ';' ;\n     *\n     * When the ATN simulation reaches the state before ';', it has a DFA\n     * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally\n     * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node\n     * because alternative to has another way to continue, via [6|2|[]].\n     * The key is that we have a single state that has config's only associated\n     * with a single alternative, 2, and crucially the state transitions\n     * among the configurations are all non-epsilon transitions. That means\n     * we don't consider any conflicts that include alternative 2. So, we\n     * ignore the conflict between alts 1 and 2. We ignore a set of\n     * conflicting alts when there is an intersection with an alternative\n     * associated with a single alt state in the state&rarr;config-list map.\n     *\n     * It's also the case that we might have two conflicting configurations but\n     * also a 3rd nonconflicting configuration for a different alternative:\n     * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:\n     *\n     * a : A | A | A B ;\n     *\n     * After matching input A, we reach the stop state for rule A, state 1.\n     * State 8 is the state right before B. Clearly alternatives 1 and 2\n     * conflict and no amount of further lookahead will separate the two.\n     * However, alternative 3 will be able to continue and so we do not\n     * stop working on this state. In the previous example, we're concerned\n     * with states associated with the conflicting alternatives. Here alt\n     * 3 is not associated with the conflicting configs, but since we can continue\n     * looking for input reasonably, I don't declare the state done. We\n     * ignore a set of conflicting alts when we have an alternative\n     * that we still need to pursue\n     */\n    getConflictingAltsOrUniqueAlt(configs) {\n        let conflictingAlts = null;\n        if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {\n            conflictingAlts = new BitSet();\n            conflictingAlts.add(configs.uniqueAlt);\n        } else {\n            conflictingAlts = configs.conflictingAlts;\n        }\n        return conflictingAlts;\n    }\n\n    getTokenName(t) {\n        if (t===Token.EOF) {\n            return \"EOF\";\n        }\n        if( this.parser!==null && this.parser.literalNames!==null) {\n            if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {\n                console.log(\"\" + t + \" ttype out of range: \" + this.parser.literalNames);\n                console.log(\"\" + this.parser.getInputStream().getTokens());\n            } else {\n                const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];\n                return name + \"<\" + t + \">\";\n            }\n        }\n        return \"\" + t;\n    }\n\n    getLookaheadName(input) {\n        return this.getTokenName(input.LA(1));\n    }\n\n    /**\n     * Used for debugging in adaptivePredict around execATN but I cut\n     * it out for clarity now that alg. works well. We can leave this\n     * \"dead\" code for a bit\n     */\n    dumpDeadEndConfigs(nvae) {\n        console.log(\"dead end configs: \");\n        const decs = nvae.getDeadEndConfigs();\n        for(let i=0; i<decs.length; i++) {\n            const c = decs[i];\n            let trans = \"no edges\";\n            if (c.state.transitions.length>0) {\n                const t = c.state.transitions[0];\n                if (t instanceof AtomTransition) {\n                    trans = \"Atom \"+ this.getTokenName(t.label);\n                } else if (t instanceof SetTransition) {\n                    const neg = (t instanceof NotSetTransition);\n                    trans = (neg ? \"~\" : \"\") + \"Set \" + t.set;\n                }\n            }\n            console.error(c.toString(this.parser, true) + \":\" + trans);\n        }\n    }\n\n    noViableAlt(input, outerContext, configs, startIndex) {\n        return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n    }\n\n    getUniqueAlt(configs) {\n        let alt = ATN.INVALID_ALT_NUMBER;\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (alt === ATN.INVALID_ALT_NUMBER) {\n                alt = c.alt // found first alt\n            } else if( c.alt!==alt) {\n                return ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return alt;\n    }\n\n    /**\n     * Add an edge to the DFA, if possible. This method calls\n     * {@link //addDFAState} to ensure the {@code to} state is present in the\n     * DFA. If {@code from} is {@code null}, or if {@code t} is outside the\n     * range of edges that can be represented in the DFA tables, this method\n     * returns without adding the edge to the DFA.\n     *\n     * <p>If {@code to} is {@code null}, this method returns {@code null}.\n     * Otherwise, this method returns the {@link DFAState} returned by calling\n     * {@link //addDFAState} for the {@code to} state.</p>\n     *\n     * @param dfa The DFA\n     * @param from_ The source state for the edge\n     * @param t The input symbol\n     * @param to The target state for the edge\n     *\n     * @return If {@code to} is {@code null}, this method returns {@code null};\n     * otherwise this method returns the result of calling {@link //addDFAState}\n     * on {@code to}\n     */\n    addDFAEdge(dfa, from_, t, to) {\n        if( this.debug) {\n            console.log(\"EDGE \" + from_ + \" -> \" + to + \" upon \" + this.getTokenName(t));\n        }\n        if (to===null) {\n            return null;\n        }\n        to = this.addDFAState(dfa, to); // used existing if possible not incoming\n        if (from_===null || t < -1 || t > this.atn.maxTokenType) {\n            return to;\n        }\n        if (from_.edges===null) {\n            from_.edges = [];\n        }\n        from_.edges[t+1] = to; // connect\n\n        if (this.debug) {\n            const literalNames = this.parser===null ? null : this.parser.literalNames;\n            const symbolicNames = this.parser===null ? null : this.parser.symbolicNames;\n            console.log(\"DFA=\\n\" + dfa.toString(literalNames, symbolicNames));\n        }\n        return to;\n    }\n\n    /**\n     * Add state {@code D} to the DFA if it is not already present, and return\n     * the actual instance stored in the DFA. If a state equivalent to {@code D}\n     * is already in the DFA, the existing state is returned. Otherwise this\n     * method returns {@code D} after adding it to the DFA.\n     *\n     * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and\n     * does not change the DFA.</p>\n     *\n     * @param dfa The dfa\n     * @param D The DFA state to add\n     * @return The state stored in the DFA. This will be either the existing\n     * state if {@code D} is already in the DFA, or {@code D} itself if the\n     * state was not already present\n     */\n    addDFAState(dfa, D) {\n        if (D === ATNSimulator.ERROR) {\n            return D;\n        }\n        const existing = dfa.states.get(D);\n        if(existing!==null) {\n            return existing;\n        }\n        D.stateNumber = dfa.states.length;\n        if (! D.configs.readOnly) {\n            D.configs.optimizeConfigs(this);\n            D.configs.setReadonly(true);\n        }\n        dfa.states.add(D);\n        if (this.debug) {\n            console.log(\"adding new DFA state: \" + D);\n        }\n        return D;\n    }\n\n    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);\n        }\n    }\n\n    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);\n        }\n    }\n\n    // If context sensitive parsing, we know it's ambiguity not conflict//\n    reportAmbiguity(dfa, D, startIndex, stopIndex,\n                                   exact, ambigAlts, configs ) {\n        if (this.debug || this.retry_debug) {\n            const interval = new Interval(startIndex, stopIndex + 1);\n            console.log(\"reportAmbiguity \" + ambigAlts + \":\" + configs +\n                               \", input=\" + this.parser.getTokenStream().getText(interval));\n        }\n        if (this.parser!==null) {\n            this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n        }\n    }\n}\n\nmodule.exports = ParserATNSimulator;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/PredictionMode.js":
/*!**************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/PredictionMode.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Map, BitSet, AltDict, hashStuff} = __webpack_require__(/*! ./../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\nconst ATN = __webpack_require__(/*! ./ATN */ \"./node_modules/antlr4/src/antlr4/atn/ATN.js\");\nconst {RuleStopState} = __webpack_require__(/*! ./ATNState */ \"./node_modules/antlr4/src/antlr4/atn/ATNState.js\");\nconst {ATNConfigSet} = __webpack_require__(/*! ./ATNConfigSet */ \"./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js\");\nconst {ATNConfig} = __webpack_require__(/*! ./ATNConfig */ \"./node_modules/antlr4/src/antlr4/atn/ATNConfig.js\");\nconst {SemanticContext} = __webpack_require__(/*! ./SemanticContext */ \"./node_modules/antlr4/src/antlr4/atn/SemanticContext.js\");\n\n/**\n * This enumeration defines the prediction modes available in ANTLR 4 along with\n * utility methods for analyzing configuration sets for conflicts and/or\n * ambiguities.\n */\nconst PredictionMode = {\n    /**\n     * The SLL(*) prediction mode. This prediction mode ignores the current\n     * parser context when making predictions. This is the fastest prediction\n     * mode, and provides correct results for many grammars. This prediction\n     * mode is more powerful than the prediction mode provided by ANTLR 3, but\n     * may result in syntax errors for grammar and input combinations which are\n     * not SLL.\n     *\n     * <p>\n     * When using this prediction mode, the parser will either return a correct\n     * parse tree (i.e. the same parse tree that would be returned with the\n     * {@link //LL} prediction mode), or it will report a syntax error. If a\n     * syntax error is encountered when using the {@link //SLL} prediction mode,\n     * it may be due to either an actual syntax error in the input or indicate\n     * that the particular combination of grammar and input requires the more\n     * powerful {@link //LL} prediction abilities to complete successfully.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    SLL: 0,\n\n    /**\n     * The LL(*) prediction mode. This prediction mode allows the current parser\n     * context to be used for resolving SLL conflicts that occur during\n     * prediction. This is the fastest prediction mode that guarantees correct\n     * parse results for all combinations of grammars with syntactically correct\n     * inputs.\n     *\n     * <p>\n     * When using this prediction mode, the parser will make correct decisions\n     * for all syntactically-correct grammar and input combinations. However, in\n     * cases where the grammar is truly ambiguous this prediction mode might not\n     * report a precise answer for <em>exactly which</em> alternatives are\n     * ambiguous.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    LL: 1,\n\n    /**\n     *\n     * The LL(*) prediction mode with exact ambiguity detection. In addition to\n     * the correctness guarantees provided by the {@link //LL} prediction mode,\n     * this prediction mode instructs the prediction algorithm to determine the\n     * complete and exact set of ambiguous alternatives for every ambiguous\n     * decision encountered while parsing.\n     *\n     * <p>\n     * This prediction mode may be used for diagnosing ambiguities during\n     * grammar development. Due to the performance overhead of calculating sets\n     * of ambiguous alternatives, this prediction mode should be avoided when\n     * the exact results are not necessary.</p>\n     *\n     * <p>\n     * This prediction mode does not provide any guarantees for prediction\n     * behavior for syntactically-incorrect inputs.</p>\n     */\n    LL_EXACT_AMBIG_DETECTION: 2,\n\n    /**\n     *\n     * Computes the SLL prediction termination condition.\n     *\n     * <p>\n     * This method computes the SLL prediction termination condition for both of\n     * the following cases.</p>\n     *\n     * <ul>\n     * <li>The usual SLL+LL fallback upon SLL conflict</li>\n     * <li>Pure SLL without LL fallback</li>\n     * </ul>\n     *\n     * <p><strong>COMBINED SLL+LL PARSING</strong></p>\n     *\n     * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are\n     * ensured regardless of how the termination condition is computed by this\n     * method. Due to the substantially higher cost of LL prediction, the\n     * prediction should only fall back to LL when the additional lookahead\n     * cannot lead to a unique SLL prediction.</p>\n     *\n     * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only\n     * conflicting subsets should fall back to full LL, even if the\n     * configuration sets don't resolve to the same alternative (e.g.\n     * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting\n     * configuration, SLL could continue with the hopes that more lookahead will\n     * resolve via one of those non-conflicting configurations.</p>\n     *\n     * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)\n     * stops when it sees only conflicting configuration subsets. In contrast,\n     * full LL keeps going when there is uncertainty.</p>\n     *\n     * <p><strong>HEURISTIC</strong></p>\n     *\n     * <p>As a heuristic, we stop prediction when we see any conflicting subset\n     * unless we see a state that only has one alternative associated with it.\n     * The single-alt-state thing lets prediction continue upon rules like\n     * (otherwise, it would admit defeat too soon):</p>\n     *\n     * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>\n     *\n     * <p>When the ATN simulation reaches the state before {@code ';'}, it has a\n     * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally\n     * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop\n     * processing this node because alternative to has another way to continue,\n     * via {@code [6|2|[]]}.</p>\n     *\n     * <p>It also let's us continue for this rule:</p>\n     *\n     * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>\n     *\n     * <p>After matching input A, we reach the stop state for rule A, state 1.\n     * State 8 is the state right before B. Clearly alternatives 1 and 2\n     * conflict and no amount of further lookahead will separate the two.\n     * However, alternative 3 will be able to continue and so we do not stop\n     * working on this state. In the previous example, we're concerned with\n     * states associated with the conflicting alternatives. Here alt 3 is not\n     * associated with the conflicting configs, but since we can continue\n     * looking for input reasonably, don't declare the state done.</p>\n     *\n     * <p><strong>PURE SLL PARSING</strong></p>\n     *\n     * <p>To handle pure SLL parsing, all we have to do is make sure that we\n     * combine stack contexts for configurations that differ only by semantic\n     * predicate. From there, we can do the usual SLL termination heuristic.</p>\n     *\n     * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>\n     *\n     * <p>SLL decisions don't evaluate predicates until after they reach DFA stop\n     * states because they need to create the DFA cache that works in all\n     * semantic situations. In contrast, full LL evaluates predicates collected\n     * during start state computation so it can ignore predicates thereafter.\n     * This means that SLL termination detection can totally ignore semantic\n     * predicates.</p>\n     *\n     * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not\n     * semantic predicate contexts so we might see two configurations like the\n     * following.</p>\n     *\n     * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>\n     *\n     * <p>Before testing these configurations against others, we have to merge\n     * {@code x} and {@code x'} (without modifying the existing configurations).\n     * For example, we test {@code (x+x')==x''} when looking for conflicts in\n     * the following configurations.</p>\n     *\n     * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>\n     *\n     * <p>If the configuration set has predicates (as indicated by\n     * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of\n     * the configurations to strip out all of the predicates so that a standard\n     * {@link ATNConfigSet} will merge everything ignoring predicates.</p>\n     */\n    hasSLLConflictTerminatingPrediction: function( mode, configs) {\n        // Configs in rule stop states indicate reaching the end of the decision\n        // rule (local context) or end of start rule (full context). If all\n        // configs meet this condition, then none of the configurations is able\n        // to match additional input so we terminate prediction.\n        //\n        if (PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return true;\n        }\n        // pure SLL mode parsing\n        if (mode === PredictionMode.SLL) {\n            // Don't bother with combining configs from different semantic\n            // contexts if we can fail over to full LL; costs more time\n            // since we'll often fail over anyway.\n            if (configs.hasSemanticContext) {\n                // dup configs, tossing out semantic predicates\n                const dup = new ATNConfigSet();\n                for(let i=0;i<configs.items.length;i++) {\n                    let c = configs.items[i];\n                    c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);\n                    dup.add(c);\n                }\n                configs = dup;\n            }\n            // now we have combined contexts for configs with dissimilar preds\n        }\n        // pure SLL or combined SLL+LL mode parsing\n        const altsets = PredictionMode.getConflictingAltSubsets(configs);\n        return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);\n    },\n\n    /**\n     * Checks if any configuration in {@code configs} is in a\n     * {@link RuleStopState}. Configurations meeting this condition have reached\n     * the end of the decision rule (local context) or end of start rule (full\n     * context).\n     *\n     * @param configs the configuration set to test\n     * @return {@code true} if any configuration in {@code configs} is in a\n     * {@link RuleStopState}, otherwise {@code false}\n     */\n    hasConfigInRuleStopState: function(configs) {\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (c.state instanceof RuleStopState) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Checks if all configurations in {@code configs} are in a\n     * {@link RuleStopState}. Configurations meeting this condition have reached\n     * the end of the decision rule (local context) or end of start rule (full\n     * context).\n     *\n     * @param configs the configuration set to test\n     * @return {@code true} if all configurations in {@code configs} are in a\n     * {@link RuleStopState}, otherwise {@code false}\n     */\n    allConfigsInRuleStopStates: function(configs) {\n        for(let i=0;i<configs.items.length;i++) {\n            const c = configs.items[i];\n            if (!(c.state instanceof RuleStopState)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    /**\n     *\n     * Full LL prediction termination.\n     *\n     * <p>Can we stop looking ahead during ATN simulation or is there some\n     * uncertainty as to which alternative we will ultimately pick, after\n     * consuming more input? Even if there are partial conflicts, we might know\n     * that everything is going to resolve to the same minimum alternative. That\n     * means we can stop since no more lookahead will change that fact. On the\n     * other hand, there might be multiple conflicts that resolve to different\n     * minimums. That means we need more look ahead to decide which of those\n     * alternatives we should predict.</p>\n     *\n     * <p>The basic idea is to split the set of configurations {@code C}, into\n     * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with\n     * non-conflicting configurations. Two configurations conflict if they have\n     * identical {@link ATNConfig//state} and {@link ATNConfig//context} values\n     * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}\n     * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>\n     *\n     * <p>Reduce these configuration subsets to the set of possible alternatives.\n     * You can compute the alternative subsets in one pass as follows:</p>\n     *\n     * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in\n     * {@code C} holding {@code s} and {@code ctx} fixed.</p>\n     *\n     * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>\n     *\n     * <pre>\n     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n     * alt and not pred\n     * </pre>\n     *\n     * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>\n     *\n     * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with\n     * {@code s} and {@code ctx}.</p>\n     *\n     * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If\n     * the union of these alternative subsets is a singleton, then no amount of\n     * more lookahead will help us. We will always pick that alternative. If,\n     * however, there is more than one alternative, then we are uncertain which\n     * alternative to predict and must continue looking for resolution. We may\n     * or may not discover an ambiguity in the future, even if there are no\n     * conflicting subsets this round.</p>\n     *\n     * <p>The biggest sin is to terminate early because it means we've made a\n     * decision but were uncertain as to the eventual outcome. We haven't used\n     * enough lookahead. On the other hand, announcing a conflict too late is no\n     * big deal; you will still have the conflict. It's just inefficient. It\n     * might even look until the end of file.</p>\n     *\n     * <p>No special consideration for semantic predicates is required because\n     * predicates are evaluated on-the-fly for full LL prediction, ensuring that\n     * no configuration contains a semantic context during the termination\n     * check.</p>\n     *\n     * <p><strong>CONFLICTING CONFIGS</strong></p>\n     *\n     * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict\n     * when {@code i!=j} but {@code x=x'}. Because we merge all\n     * {@code (s, i, _)} configurations together, that means that there are at\n     * most {@code n} configurations associated with state {@code s} for\n     * {@code n} possible alternatives in the decision. The merged stacks\n     * complicate the comparison of configuration contexts {@code x} and\n     * {@code x'}. Sam checks to see if one is a subset of the other by calling\n     * merge and checking to see if the merged result is either {@code x} or\n     * {@code x'}. If the {@code x} associated with lowest alternative {@code i}\n     * is the superset, then {@code i} is the only possible prediction since the\n     * others resolve to {@code min(i)} as well. However, if {@code x} is\n     * associated with {@code j>i} then at least one stack configuration for\n     * {@code j} is not in conflict with alternative {@code i}. The algorithm\n     * should keep going, looking for more lookahead due to the uncertainty.</p>\n     *\n     * <p>For simplicity, I'm doing a equality check between {@code x} and\n     * {@code x'} that lets the algorithm continue to consume lookahead longer\n     * than necessary. The reason I like the equality is of course the\n     * simplicity but also because that is the test you need to detect the\n     * alternatives that are actually in conflict.</p>\n     *\n     * <p><strong>CONTINUE/STOP RULE</strong></p>\n     *\n     * <p>Continue if union of resolved alternative sets from non-conflicting and\n     * conflicting alternative subsets has more than one alternative. We are\n     * uncertain about which alternative to predict.</p>\n     *\n     * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which\n     * alternatives are still in the running for the amount of input we've\n     * consumed at this point. The conflicting sets let us to strip away\n     * configurations that won't lead to more states because we resolve\n     * conflicts to the configuration with a minimum alternate for the\n     * conflicting set.</p>\n     *\n     * <p><strong>CASES</strong></p>\n     *\n     * <ul>\n     *\n     * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>\n     *\n     * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},\n     * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set\n     * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n     * {@code {1,3}} =&gt; continue\n     * </li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n     * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set\n     * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =\n     * {@code {1}} =&gt; stop and predict 1</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},\n     * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce\n     * ambiguity {@code {1,2}}</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},\n     * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {2}} = {@code {1,2}} =&gt; continue</li>\n     *\n     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},\n     * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U\n     * {@code {3}} = {@code {1,3}} =&gt; continue</li>\n     *\n     * </ul>\n     *\n     * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>\n     *\n     * <p>If all states report the same conflicting set of alternatives, then we\n     * know we have the exact ambiguity set.</p>\n     *\n     * <p><code>|A_<em>i</em>|&gt;1</code> and\n     * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>\n     *\n     * <p>In other words, we continue examining lookahead until all {@code A_i}\n     * have more than one alternative and all {@code A_i} are the same. If\n     * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate\n     * because the resolved set is {@code {1}}. To determine what the real\n     * ambiguity is, we have to know whether the ambiguity is between one and\n     * two or one and three so we keep going. We can only stop prediction when\n     * we need exact ambiguity detection when the sets look like\n     * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>\n     */\n    resolvesToJustOneViableAlt: function(altsets) {\n        return PredictionMode.getSingleViableAlt(altsets);\n    },\n\n    /**\n     * Determines if every alternative subset in {@code altsets} contains more\n     * than one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if every {@link BitSet} in {@code altsets} has\n     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n     */\n    allSubsetsConflict: function(altsets) {\n        return ! PredictionMode.hasNonConflictingAltSet(altsets);\n    },\n    /**\n     * Determines if any single alternative subset in {@code altsets} contains\n     * exactly one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n     * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}\n     */\n    hasNonConflictingAltSet: function(altsets) {\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (alts.length===1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    /**\n     * Determines if any single alternative subset in {@code altsets} contains\n     * more than one alternative.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if {@code altsets} contains a {@link BitSet} with\n     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}\n     */\n    hasConflictingAltSet: function(altsets) {\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (alts.length>1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n\n    /**\n     * Determines if every alternative subset in {@code altsets} is equivalent.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return {@code true} if every member of {@code altsets} is equal to the\n     * others, otherwise {@code false}\n     */\n    allSubsetsEqual: function(altsets) {\n        let first = null;\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            if (first === null) {\n                first = alts;\n            } else if (alts!==first) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n\n    /**\n     * Returns the unique alternative predicted by all alternative subsets in\n     * {@code altsets}. If no such alternative exists, this method returns\n     * {@link ATN//INVALID_ALT_NUMBER}.\n     *\n     * @param altsets a collection of alternative subsets\n     */\n    getUniqueAlt: function(altsets) {\n        const all = PredictionMode.getAlts(altsets);\n        if (all.length===1) {\n            return all.minValue();\n        } else {\n            return ATN.INVALID_ALT_NUMBER;\n        }\n    },\n\n    /**\n     * Gets the complete set of represented alternatives for a collection of\n     * alternative subsets. This method returns the union of each {@link BitSet}\n     * in {@code altsets}.\n     *\n     * @param altsets a collection of alternative subsets\n     * @return the set of represented alternatives in {@code altsets}\n     */\n    getAlts: function(altsets) {\n        const all = new BitSet();\n        altsets.map( function(alts) { all.or(alts); });\n        return all;\n    },\n\n    /**\n     * This function gets the conflicting alt subsets from a configuration set.\n     * For each configuration {@code c} in {@code configs}:\n     *\n     * <pre>\n     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not\n     * alt and not pred\n     * </pre>\n     */\n    getConflictingAltSubsets: function(configs) {\n        const configToAlts = new Map();\n        configToAlts.hashFunction = function(cfg) { hashStuff(cfg.state.stateNumber, cfg.context); };\n        configToAlts.equalsFunction = function(c1, c2) { return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);};\n        configs.items.map(function(cfg) {\n            let alts = configToAlts.get(cfg);\n            if (alts === null) {\n                alts = new BitSet();\n                configToAlts.put(cfg, alts);\n            }\n            alts.add(cfg.alt);\n        });\n        return configToAlts.getValues();\n    },\n\n    /**\n     * Get a map from state to alt subset from a configuration set. For each\n     * configuration {@code c} in {@code configs}:\n     *\n     * <pre>\n     * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}\n     * </pre>\n     */\n    getStateToAltMap: function(configs) {\n        const m = new AltDict();\n        configs.items.map(function(c) {\n            let alts = m.get(c.state);\n            if (alts === null) {\n                alts = new BitSet();\n                m.put(c.state, alts);\n            }\n            alts.add(c.alt);\n        });\n        return m;\n    },\n\n    hasStateAssociatedWithOneAlt: function(configs) {\n        const values = PredictionMode.getStateToAltMap(configs).values();\n        for(let i=0;i<values.length;i++) {\n            if (values[i].length===1) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    getSingleViableAlt: function(altsets) {\n        let result = null;\n        for(let i=0;i<altsets.length;i++) {\n            const alts = altsets[i];\n            const minAlt = alts.minValue();\n            if(result===null) {\n                result = minAlt;\n            } else if(result!==minAlt) { // more than 1 viable alt\n                return ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return result;\n    }\n};\n\nmodule.exports = PredictionMode;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/PredictionMode.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/SemanticContext.js":
/*!***************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/SemanticContext.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst { Set, Hash, equalArrays } = __webpack_require__(/*! ./../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\n\n/**\n * A tree structure used to record the semantic context in which\n * an ATN configuration is valid.  It's either a single predicate,\n * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.\n *\n * <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of\n * {@link SemanticContext} within the scope of this outer class.</p>\n */\nclass SemanticContext {\n\n\thashCode() {\n\t\tconst hash = new Hash();\n\t\tthis.updateHashCode(hash);\n\t\treturn hash.finish();\n\t}\n\n\t/**\n\t * For context independent predicates, we evaluate them without a local\n\t * context (i.e., null context). That way, we can evaluate them without\n\t * having to create proper rule-specific context during prediction (as\n\t * opposed to the parser, which creates them naturally). In a practical\n\t * sense, this avoids a cast exception from RuleContext to myruleContext.\n\t *\n\t * <p>For context dependent predicates, we must pass in a local context so that\n\t * references such as $arg evaluate properly as _localctx.arg. We only\n\t * capture context dependent predicates in the context in which we begin\n\t * prediction, so we passed in the outer context here in case of context\n\t * dependent predicate evaluation.</p>\n\t */\n\tevaluate(parser, outerContext) {}\n\n\t/**\n\t * Evaluate the precedence predicates for the context and reduce the result.\n\t *\n\t * @param parser The parser instance.\n\t * @param outerContext The current parser context object.\n\t * @return The simplified semantic context after precedence predicates are\n\t * evaluated, which will be one of the following values.\n\t * <ul>\n\t * <li>{@link //NONE}: if the predicate simplifies to {@code true} after\n\t * precedence predicates are evaluated.</li>\n\t * <li>{@code null}: if the predicate simplifies to {@code false} after\n\t * precedence predicates are evaluated.</li>\n\t * <li>{@code this}: if the semantic context is not changed as a result of\n\t * precedence predicate evaluation.</li>\n\t * <li>A non-{@code null} {@link SemanticContext}: the new simplified\n\t * semantic context after precedence predicates are evaluated.</li>\n\t * </ul>\n\t */\n\tevalPrecedence(parser, outerContext) {\n\t\treturn this;\n\t}\n\n\tstatic andContext(a, b) {\n\t\tif (a === null || a === SemanticContext.NONE) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === null || b === SemanticContext.NONE) {\n\t\t\treturn a;\n\t\t}\n\t\tconst result = new AND(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tstatic orContext(a, b) {\n\t\tif (a === null) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === null) {\n\t\t\treturn a;\n\t\t}\n\t\tif (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tconst result = new OR(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\n\nclass Predicate extends SemanticContext {\n\n\tconstructor(ruleIndex, predIndex, isCtxDependent) {\n\t\tsuper();\n\t\tthis.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;\n\t\tthis.predIndex = predIndex === undefined ? -1 : predIndex;\n\t\tthis.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred\n\t}\n\n\tevaluate(parser, outerContext) {\n\t\tconst localctx = this.isCtxDependent ? outerContext : null;\n\t\treturn parser.sempred(localctx, this.ruleIndex, this.predIndex);\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof Predicate)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.ruleIndex === other.ruleIndex &&\n\t\t\t\t\tthis.predIndex === other.predIndex &&\n\t\t\t\t\tthis.isCtxDependent === other.isCtxDependent;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n\t}\n}\n\n/**\n * The default {@link SemanticContext}, which is semantically equivalent to\n * a predicate of the form {@code {true}?}\n */\nSemanticContext.NONE = new Predicate();\n\n\nclass PrecedencePredicate extends SemanticContext {\n\n\tconstructor(precedence) {\n\t\tsuper();\n\t\tthis.precedence = precedence === undefined ? 0 : precedence;\n\t}\n\n\tevaluate(parser, outerContext) {\n\t\treturn parser.precpred(outerContext, this.precedence);\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tif (parser.precpred(outerContext, this.precedence)) {\n\t\t\treturn SemanticContext.NONE;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tcompareTo(other) {\n\t\treturn this.precedence - other.precedence;\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.precedence);\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof PrecedencePredicate)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.precedence === other.precedence;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn \"{\" + this.precedence + \">=prec}?\";\n\t}\n\n\tstatic filterPrecedencePredicates(set) {\n\t\tconst result = [];\n\t\tset.values().map( function(context) {\n\t\t\tif (context instanceof PrecedencePredicate) {\n\t\t\t\tresult.push(context);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n}\n\nclass AND extends SemanticContext {\n\t/**\n\t * A semantic context which is true whenever none of the contained contexts\n\t * is false\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tconst operands = new Set();\n\t\tif (a instanceof AND) {\n\t\t\ta.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(a);\n\t\t}\n\t\tif (b instanceof AND) {\n\t\t\tb.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(b);\n\t\t}\n\t\tconst precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\t\tif (precedencePredicates.length > 0) {\n\t\t\t// interested in the transition with the lowest precedence\n\t\t\tlet reduced = null;\n\t\t\tprecedencePredicates.map( function(p) {\n\t\t\t\tif(reduced===null || p.precedence<reduced.precedence) {\n\t\t\t\t\treduced = p;\n\t\t\t\t}\n\t\t\t});\n\t\t\toperands.add(reduced);\n\t\t}\n\t\tthis.opnds = Array.from(operands.values());\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof AND)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn equalArrays(this.opnds, other.opnds);\n\t\t}\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.opnds, \"AND\");\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * <p>\n\t * The evaluation of predicates by this context is short-circuiting, but\n\t * unordered.</p>\n\t */\n\tevaluate(parser, outerContext) {\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tif (!this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tlet differs = false;\n\t\tconst operands = [];\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tconst context = this.opnds[i];\n\t\t\tconst evaluated = context.evalPrecedence(parser, outerContext);\n\t\t\tdiffers |= (evaluated !== context);\n\t\t\tif (evaluated === null) {\n\t\t\t\t// The AND context is false if any element is false\n\t\t\t\treturn null;\n\t\t\t} else if (evaluated !== SemanticContext.NONE) {\n\t\t\t\t// Reduce the result by skipping true elements\n\t\t\t\toperands.push(evaluated);\n\t\t\t}\n\t\t}\n\t\tif (!differs) {\n\t\t\treturn this;\n\t\t}\n\t\tif (operands.length === 0) {\n\t\t\t// all elements were true, so the AND context is true\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tlet result = null;\n\t\toperands.map(function(o) {\n\t\t\tresult = result === null ? o : SemanticContext.andContext(result, o);\n\t\t});\n\t\treturn result;\n\t}\n\n\ttoString() {\n\t\tconst s = this.opnds.map(o => o.toString());\n\t\treturn (s.length > 3 ? s.slice(3) : s).join(\"&&\");\n\t}\n}\n\n\nclass OR extends SemanticContext {\n\t/**\n\t * A semantic context which is true whenever at least one of the contained\n\t * contexts is true\n\t */\n\tconstructor(a, b) {\n\t\tsuper();\n\t\tconst operands = new Set();\n\t\tif (a instanceof OR) {\n\t\t\ta.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(a);\n\t\t}\n\t\tif (b instanceof OR) {\n\t\t\tb.opnds.map(function(o) {\n\t\t\t\toperands.add(o);\n\t\t\t});\n\t\t} else {\n\t\t\toperands.add(b);\n\t\t}\n\n\t\tconst precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);\n\t\tif (precedencePredicates.length > 0) {\n\t\t\t// interested in the transition with the highest precedence\n\t\t\tconst s = precedencePredicates.sort(function(a, b) {\n\t\t\t\treturn a.compareTo(b);\n\t\t\t});\n\t\t\tconst reduced = s[s.length-1];\n\t\t\toperands.add(reduced);\n\t\t}\n\t\tthis.opnds = Array.from(operands.values());\n\t}\n\n\tequals(other) {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t} else if (!(other instanceof OR)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn equalArrays(this.opnds, other.opnds);\n\t\t}\n\t}\n\n\tupdateHashCode(hash) {\n\t\thash.update(this.opnds, \"OR\");\n\t}\n\n\t/**\n\t * <p>\n\t * The evaluation of predicates by this context is short-circuiting, but\n\t * unordered.</p>\n\t */\n\tevaluate(parser, outerContext) {\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tif (this.opnds[i].evaluate(parser, outerContext)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tevalPrecedence(parser, outerContext) {\n\t\tlet differs = false;\n\t\tconst operands = [];\n\t\tfor (let i = 0; i < this.opnds.length; i++) {\n\t\t\tconst context = this.opnds[i];\n\t\t\tconst evaluated = context.evalPrecedence(parser, outerContext);\n\t\t\tdiffers |= (evaluated !== context);\n\t\t\tif (evaluated === SemanticContext.NONE) {\n\t\t\t\t// The OR context is true if any element is true\n\t\t\t\treturn SemanticContext.NONE;\n\t\t\t} else if (evaluated !== null) {\n\t\t\t\t// Reduce the result by skipping false elements\n\t\t\t\toperands.push(evaluated);\n\t\t\t}\n\t\t}\n\t\tif (!differs) {\n\t\t\treturn this;\n\t\t}\n\t\tif (operands.length === 0) {\n\t\t\t// all elements were false, so the OR context is false\n\t\t\treturn null;\n\t\t}\n\t\tconst result = null;\n\t\toperands.map(function(o) {\n\t\t\treturn result === null ? o : SemanticContext.orContext(result, o);\n\t\t});\n\t\treturn result;\n\t}\n\n\ttoString() {\n\t\tconst s = this.opnds.map(o => o.toString());\n\t\treturn (s.length > 3 ? s.slice(3) : s).join(\"||\");\n\t}\n}\n\nmodule.exports = {\n\tSemanticContext,\n\tPrecedencePredicate,\n\tPredicate\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/SemanticContext.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/Transition.js":
/*!**********************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/Transition.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./../Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst {IntervalSet} = __webpack_require__(/*! ./../IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\");\nconst {Predicate, PrecedencePredicate} = __webpack_require__(/*! ./SemanticContext */ \"./node_modules/antlr4/src/antlr4/atn/SemanticContext.js\");\n\n/**\n * An ATN transition between any two ATN states.  Subclasses define\n * atom, set, epsilon, action, predicate, rule transitions.\n *\n * <p>This is a one way link.  It emanates from a state (usually via a list of\n * transitions) and has a target state.</p>\n *\n * <p>Since we never have to change the ATN transitions once we construct it,\n * we can fix these transitions as specific classes. The DFA transitions\n * on the other hand need to update the labels as it adds transitions to\n * the states. We'll use the term Edge for the DFA to distinguish them from\n * ATN transitions.</p>\n */\nclass Transition {\n    constructor(target) {\n        // The target of this transition.\n        if (target===undefined || target===null) {\n            throw \"target cannot be null.\";\n        }\n        this.target = target;\n        // Are we epsilon, action, sempred?\n        this.isEpsilon = false;\n        this.label = null;\n    }\n}\n\n// constants for serialization\n\nTransition.EPSILON = 1;\nTransition.RANGE = 2;\nTransition.RULE = 3;\n// e.g., {isType(input.LT(1))}?\nTransition.PREDICATE = 4;\nTransition.ATOM = 5;\nTransition.ACTION = 6;\n// ~(A|B) or ~atom, wildcard, which convert to next 2\nTransition.SET = 7;\nTransition.NOT_SET = 8;\nTransition.WILDCARD = 9;\nTransition.PRECEDENCE = 10;\n\nTransition.serializationNames = [\n            \"INVALID\",\n            \"EPSILON\",\n            \"RANGE\",\n            \"RULE\",\n            \"PREDICATE\",\n            \"ATOM\",\n            \"ACTION\",\n            \"SET\",\n            \"NOT_SET\",\n            \"WILDCARD\",\n            \"PRECEDENCE\"\n        ];\n\nTransition.serializationTypes = {\n        EpsilonTransition: Transition.EPSILON,\n        RangeTransition: Transition.RANGE,\n        RuleTransition: Transition.RULE,\n        PredicateTransition: Transition.PREDICATE,\n        AtomTransition: Transition.ATOM,\n        ActionTransition: Transition.ACTION,\n        SetTransition: Transition.SET,\n        NotSetTransition: Transition.NOT_SET,\n        WildcardTransition: Transition.WILDCARD,\n        PrecedencePredicateTransition: Transition.PRECEDENCE\n    };\n\n\n// TODO: make all transitions sets? no, should remove set edges\n\nclass AtomTransition extends Transition {\n    constructor(target, label) {\n        super(target);\n        // The token type or character value; or, signifies special label.\n        this.label_ = label;\n        this.label = this.makeLabel();\n        this.serializationType = Transition.ATOM;\n    }\n\n    makeLabel() {\n        const s = new IntervalSet();\n        s.addOne(this.label_);\n        return s;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return this.label_ === symbol;\n    }\n\n    toString() {\n        return this.label_;\n    }\n}\n\n\nclass RuleTransition extends Transition {\n    constructor(ruleStart, ruleIndex, precedence, followState) {\n        super(ruleStart);\n        // ptr to the rule definition object for this rule ref\n        this.ruleIndex = ruleIndex;\n        this.precedence = precedence;\n        // what node to begin computations following ref to rule\n        this.followState = followState;\n        this.serializationType = Transition.RULE;\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n}\n\nclass EpsilonTransition extends Transition {\n    constructor(target, outermostPrecedenceReturn) {\n        super(target);\n        this.serializationType = Transition.EPSILON;\n        this.isEpsilon = true;\n        this.outermostPrecedenceReturn = outermostPrecedenceReturn;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    toString() {\n        return \"epsilon\";\n    }\n}\n\n\nclass RangeTransition extends Transition {\n    constructor(target, start, stop) {\n        super(target);\n        this.serializationType = Transition.RANGE;\n        this.start = start;\n        this.stop = stop;\n        this.label = this.makeLabel();\n    }\n\n    makeLabel() {\n        const s = new IntervalSet();\n        s.addRange(this.start, this.stop);\n        return s;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= this.start && symbol <= this.stop;\n    }\n\n    toString() {\n        return \"'\" + String.fromCharCode(this.start) + \"'..'\" + String.fromCharCode(this.stop) + \"'\";\n    }\n}\n\n\nclass AbstractPredicateTransition extends Transition {\n    constructor(target) {\n        super(target);\n    }\n}\n\nclass PredicateTransition extends AbstractPredicateTransition {\n    constructor(target, ruleIndex, predIndex, isCtxDependent) {\n        super(target);\n        this.serializationType = Transition.PREDICATE;\n        this.ruleIndex = ruleIndex;\n        this.predIndex = predIndex;\n        this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    getPredicate() {\n        return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\n    }\n\n    toString() {\n        return \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\n    }\n}\n\n\nclass ActionTransition extends Transition {\n    constructor(target, ruleIndex, actionIndex, isCtxDependent) {\n        super(target);\n        this.serializationType = Transition.ACTION;\n        this.ruleIndex = ruleIndex;\n        this.actionIndex = actionIndex===undefined ? -1 : actionIndex;\n        this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    toString() {\n        return \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\n    }\n}\n\n\n// A transition containing a set of values.\nclass SetTransition extends Transition {\n    constructor(target, set) {\n        super(target);\n        this.serializationType = Transition.SET;\n        if (set !==undefined && set !==null) {\n            this.label = set;\n        } else {\n            this.label = new IntervalSet();\n            this.label.addOne(Token.INVALID_TYPE);\n        }\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return this.label.contains(symbol);\n    }\n\n    toString() {\n        return this.label.toString();\n    }\n}\n\nclass NotSetTransition extends SetTransition {\n    constructor(target, set) {\n        super(target, set);\n        this.serializationType = Transition.NOT_SET;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&\n                !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\n    }\n\n    toString() {\n        return '~' + super.toString();\n    }\n}\n\nclass WildcardTransition extends Transition {\n    constructor(target) {\n        super(target);\n        this.serializationType = Transition.WILDCARD;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\n    }\n\n    toString() {\n        return \".\";\n    }\n}\n\nclass PrecedencePredicateTransition extends AbstractPredicateTransition {\n    constructor(target, precedence) {\n        super(target);\n        this.serializationType = Transition.PRECEDENCE;\n        this.precedence = precedence;\n        this.isEpsilon = true;\n    }\n\n    matches(symbol, minVocabSymbol, maxVocabSymbol) {\n        return false;\n    }\n\n    getPredicate() {\n        return new PrecedencePredicate(this.precedence);\n    }\n\n    toString() {\n        return this.precedence + \" >= _p\";\n    }\n}\n\nmodule.exports = {\n    Transition,\n    AtomTransition,\n    SetTransition,\n    NotSetTransition,\n    RuleTransition,\n    ActionTransition,\n    EpsilonTransition,\n    RangeTransition,\n    WildcardTransition,\n    PredicateTransition,\n    PrecedencePredicateTransition,\n    AbstractPredicateTransition\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/Transition.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/atn/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/atn/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.ATN = __webpack_require__(/*! ./ATN */ \"./node_modules/antlr4/src/antlr4/atn/ATN.js\");\nexports.ATNDeserializer = __webpack_require__(/*! ./ATNDeserializer */ \"./node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js\");\nexports.LexerATNSimulator = __webpack_require__(/*! ./LexerATNSimulator */ \"./node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js\");\nexports.ParserATNSimulator = __webpack_require__(/*! ./ParserATNSimulator */ \"./node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js\");\nexports.PredictionMode = __webpack_require__(/*! ./PredictionMode */ \"./node_modules/antlr4/src/antlr4/atn/PredictionMode.js\");\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/atn/index.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/dfa/DFA.js":
/*!***************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/dfa/DFA.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Set} = __webpack_require__(/*! ../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\nconst {DFAState} = __webpack_require__(/*! ./DFAState */ \"./node_modules/antlr4/src/antlr4/dfa/DFAState.js\");\nconst {StarLoopEntryState} = __webpack_require__(/*! ../atn/ATNState */ \"./node_modules/antlr4/src/antlr4/atn/ATNState.js\");\nconst {ATNConfigSet} = __webpack_require__(/*! ./../atn/ATNConfigSet */ \"./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js\");\nconst {DFASerializer} = __webpack_require__(/*! ./DFASerializer */ \"./node_modules/antlr4/src/antlr4/dfa/DFASerializer.js\");\nconst {LexerDFASerializer} = __webpack_require__(/*! ./DFASerializer */ \"./node_modules/antlr4/src/antlr4/dfa/DFASerializer.js\");\n\nclass DFA {\n\tconstructor(atnStartState, decision) {\n\t\tif (decision === undefined) {\n\t\t\tdecision = 0;\n\t\t}\n\t\t/**\n\t\t * From which ATN state did we create this DFA?\n\t\t */\n\t\tthis.atnStartState = atnStartState;\n\t\tthis.decision = decision;\n\t\t/**\n\t\t * A set of all DFA states. Use {@link Map} so we can get old state back\n\t\t * ({@link Set} only allows you to see if it's there).\n\t\t */\n\t\tthis._states = new Set();\n\t\tthis.s0 = null;\n\t\t/**\n\t\t * {@code true} if this DFA is for a precedence decision; otherwise,\n\t\t * {@code false}. This is the backing field for {@link //isPrecedenceDfa},\n\t\t * {@link //setPrecedenceDfa}\n\t\t */\n\t\tthis.precedenceDfa = false;\n\t\tif (atnStartState instanceof StarLoopEntryState)\n\t\t{\n\t\t\tif (atnStartState.isPrecedenceDecision) {\n\t\t\t\tthis.precedenceDfa = true;\n\t\t\t\tconst precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\t\tprecedenceState.edges = [];\n\t\t\t\tprecedenceState.isAcceptState = false;\n\t\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\t\tthis.s0 = precedenceState;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @return The start state corresponding to the specified precedence, or\n\t * {@code null} if no start state exists for the specified precedence.\n\t *\n\t * @throws IllegalStateException if this is not a precedence DFA.\n\t * @see //isPrecedenceDfa()\n\t */\n\tgetPrecedenceStartState(precedence) {\n\t\tif (!(this.precedenceDfa)) {\n\t\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\t\t// s0.edges is never null for a precedence DFA\n\t\tif (precedence < 0 || precedence >= this.s0.edges.length) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.s0.edges[precedence] || null;\n\t}\n\n\t/**\n\t * Set the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @param startState The start state corresponding to the specified\n\t * precedence.\n\t *\n\t * @throws IllegalStateException if this is not a precedence DFA.\n\t * @see //isPrecedenceDfa()\n\t */\n\tsetPrecedenceStartState(precedence, startState) {\n\t\tif (!(this.precedenceDfa)) {\n\t\t\tthrow (\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\t\tif (precedence < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * synchronization on s0 here is ok. when the DFA is turned into a\n\t\t * precedence DFA, s0 will be initialized once and not updated again\n\t\t * s0.edges is never null for a precedence DFA\n\t\t */\n\t\tthis.s0.edges[precedence] = startState;\n\t}\n\n\t/**\n\t * Sets whether this is a precedence DFA. If the specified value differs\n\t * from the current DFA configuration, the following actions are taken;\n\t * otherwise no changes are made to the current DFA.\n\t *\n\t * <ul>\n\t * <li>The {@link //states} map is cleared</li>\n\t * <li>If {@code precedenceDfa} is {@code false}, the initial state\n\t * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new\n\t * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to\n\t * store the start states for individual precedence values.</li>\n\t * <li>The {@link //precedenceDfa} field is updated</li>\n\t * </ul>\n\t *\n\t * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,\n\t * {@code false}\n\t */\n\tsetPrecedenceDfa(precedenceDfa) {\n\t\tif (this.precedenceDfa!==precedenceDfa) {\n\t\t\tthis._states = new Set();\n\t\t\tif (precedenceDfa) {\n\t\t\t\tconst precedenceState = new DFAState(null, new ATNConfigSet());\n\t\t\t\tprecedenceState.edges = [];\n\t\t\t\tprecedenceState.isAcceptState = false;\n\t\t\t\tprecedenceState.requiresFullContext = false;\n\t\t\t\tthis.s0 = precedenceState;\n\t\t\t} else {\n\t\t\t\tthis.s0 = null;\n\t\t\t}\n\t\t\tthis.precedenceDfa = precedenceDfa;\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of all states in this DFA, ordered by state number.\n\t */\n\tsortedStates() {\n\t\tconst list = this._states.values();\n\t\treturn list.sort(function(a, b) {\n\t\t\treturn a.stateNumber - b.stateNumber;\n\t\t});\n\t}\n\n\ttoString(literalNames, symbolicNames) {\n\t\tliteralNames = literalNames || null;\n\t\tsymbolicNames = symbolicNames || null;\n\t\tif (this.s0 === null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst serializer = new DFASerializer(this, literalNames, symbolicNames);\n\t\treturn serializer.toString();\n\t}\n\n\ttoLexerString() {\n\t\tif (this.s0 === null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tconst serializer = new LexerDFASerializer(this);\n\t\treturn serializer.toString();\n\t}\n\n\tget states(){\n\t\treturn this._states;\n\t}\n}\n\n\nmodule.exports = DFA;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/dfa/DFA.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/dfa/DFASerializer.js":
/*!*************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/dfa/DFASerializer.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * A DFA walker that knows how to dump them to serialized strings.\n */\nclass DFASerializer {\n    constructor(dfa, literalNames, symbolicNames) {\n        this.dfa = dfa;\n        this.literalNames = literalNames || [];\n        this.symbolicNames = symbolicNames || [];\n    }\n\n    toString() {\n       if(this.dfa.s0 === null) {\n           return null;\n       }\n       let buf = \"\";\n       const states = this.dfa.sortedStates();\n       for(let i=0; i<states.length; i++) {\n           const s = states[i];\n           if(s.edges!==null) {\n                const n = s.edges.length;\n                for(let j=0;j<n;j++) {\n                    const t = s.edges[j] || null;\n                    if(t!==null && t.stateNumber !== 0x7FFFFFFF) {\n                        buf = buf.concat(this.getStateString(s));\n                        buf = buf.concat(\"-\");\n                        buf = buf.concat(this.getEdgeLabel(j));\n                        buf = buf.concat(\"->\");\n                        buf = buf.concat(this.getStateString(t));\n                        buf = buf.concat('\\n');\n                    }\n                }\n           }\n       }\n       return buf.length===0 ? null : buf;\n    }\n\n    getEdgeLabel(i) {\n        if (i===0) {\n            return \"EOF\";\n        } else if(this.literalNames !==null || this.symbolicNames!==null) {\n            return this.literalNames[i-1] || this.symbolicNames[i-1];\n        } else {\n            return String.fromCharCode(i-1);\n        }\n    }\n\n    getStateString(s) {\n        const baseStateStr = ( s.isAcceptState ? \":\" : \"\") + \"s\" + s.stateNumber + ( s.requiresFullContext ? \"^\" : \"\");\n        if(s.isAcceptState) {\n            if (s.predicates !== null) {\n                return baseStateStr + \"=>\" + s.predicates.toString();\n            } else {\n                return baseStateStr + \"=>\" + s.prediction.toString();\n            }\n        } else {\n            return baseStateStr;\n        }\n    }\n}\n\nclass LexerDFASerializer extends DFASerializer {\n    constructor(dfa) {\n        super(dfa, null);\n    }\n\n    getEdgeLabel(i) {\n        return \"'\" + String.fromCharCode(i) + \"'\";\n    }\n}\n\nmodule.exports = { DFASerializer , LexerDFASerializer };\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/dfa/DFASerializer.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/dfa/DFAState.js":
/*!********************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/dfa/DFAState.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {ATNConfigSet} = __webpack_require__(/*! ./../atn/ATNConfigSet */ \"./node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js\");\nconst {Hash, Set} = __webpack_require__(/*! ./../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\n\n/**\n * Map a predicate to a predicted alternative.\n */\nclass PredPrediction {\n\tconstructor(pred, alt) {\n\t\tthis.alt = alt;\n\t\tthis.pred = pred;\n\t}\n\n\ttoString() {\n\t\treturn \"(\" + this.pred + \", \" + this.alt + \")\";\n\t}\n}\n\n/**\n * A DFA state represents a set of possible ATN configurations.\n * As Aho, Sethi, Ullman p. 117 says \"The DFA uses its state\n * to keep track of all possible states the ATN can be in after\n * reading each input symbol. That is to say, after reading\n * input a1a2..an, the DFA is in a state that represents the\n * subset T of the states of the ATN that are reachable from the\n * ATN's start state along some path labeled a1a2..an.\"\n * In conventional NFA&rarr;DFA conversion, therefore, the subset T\n * would be a bitset representing the set of states the\n * ATN could be in. We need to track the alt predicted by each\n * state as well, however. More importantly, we need to maintain\n * a stack of states, tracking the closure operations as they\n * jump from rule to rule, emulating rule invocations (method calls).\n * I have to add a stack to simulate the proper lookahead sequences for\n * the underlying LL grammar from which the ATN was derived.\n *\n * <p>I use a set of ATNConfig objects not simple states. An ATNConfig\n * is both a state (ala normal conversion) and a RuleContext describing\n * the chain of rules (if any) followed to arrive at that state.</p>\n *\n * <p>A DFA state may have multiple references to a particular state,\n * but with different ATN contexts (with same or different alts)\n * meaning that state was reached via a different set of rule invocations.</p>\n */\nclass DFAState {\n\tconstructor(stateNumber, configs) {\n\t\tif (stateNumber === null) {\n\t\t\tstateNumber = -1;\n\t\t}\n\t\tif (configs === null) {\n\t\t\tconfigs = new ATNConfigSet();\n\t\t}\n\t\tthis.stateNumber = stateNumber;\n\t\tthis.configs = configs;\n\t\t/**\n\t\t * {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)\n\t\t * {@link Token//EOF} maps to {@code edges[0]}.\n\t\t */\n\t\tthis.edges = null;\n\t\tthis.isAcceptState = false;\n\t\t/**\n\t\t * if accept state, what ttype do we match or alt do we predict?\n\t\t * This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link//predicates}\n\t\t * {@code !=null} or {@link //requiresFullContext}.\n\t\t */\n\t\tthis.prediction = 0;\n\t\tthis.lexerActionExecutor = null;\n\t\t/**\n\t\t * Indicates that this state was created during SLL prediction that\n\t\t * discovered a conflict between the configurations in the state. Future\n\t\t * {@link ParserATNSimulator//execATN} invocations immediately jumped doing\n\t\t * full context prediction if this field is true.\n\t\t */\n\t\tthis.requiresFullContext = false;\n\t\t/**\n\t\t * During SLL parsing, this is a list of predicates associated with the\n\t\t * ATN configurations of the DFA state. When we have predicates,\n\t\t * {@link //requiresFullContext} is {@code false} since full context\n\t\t * prediction evaluates predicates\n\t\t * on-the-fly. If this is not null, then {@link //prediction} is\n\t\t * {@link ATN//INVALID_ALT_NUMBER}.\n\t\t *\n\t\t * <p>We only use these for non-{@link //requiresFullContext} but\n\t\t * conflicting states. That\n\t\t * means we know from the context (it's $ or we don't dip into outer\n\t\t * context) that it's an ambiguity not a conflict.</p>\n\t\t *\n\t\t * <p>This list is computed by {@link\n\t\t * ParserATNSimulator//predicateDFAState}.</p>\n\t\t */\n\t\tthis.predicates = null;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the set of all alts mentioned by all ATN configurations in this\n\t * DFA state.\n\t */\n\tgetAltSet() {\n\t\tconst alts = new Set();\n\t\tif (this.configs !== null) {\n\t\t\tfor (let i = 0; i < this.configs.length; i++) {\n\t\t\t\tconst c = this.configs[i];\n\t\t\t\talts.add(c.alt);\n\t\t\t}\n\t\t}\n\t\tif (alts.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn alts;\n\t\t}\n\t}\n\n\t/**\n\t * Two {@link DFAState} instances are equal if their ATN configuration sets\n\t * are the same. This method is used to see if a state already exists.\n\t *\n\t * <p>Because the number of alternatives and number of ATN configurations are\n\t * finite, there is a finite number of DFA states that can be processed.\n\t * This is necessary to show that the algorithm terminates.</p>\n\t *\n\t * <p>Cannot test the DFA state numbers here because in\n\t * {@link ParserATNSimulator//addDFAState} we need to know if any other state\n\t * exists that has this exact set of ATN configurations. The\n\t * {@link //stateNumber} is irrelevant.</p>\n\t */\n\tequals(other) {\n\t\t// compare set of ATN configurations in this set with other\n\t\treturn this === other ||\n\t\t\t\t(other instanceof DFAState &&\n\t\t\t\t\tthis.configs.equals(other.configs));\n\t}\n\n\ttoString() {\n\t\tlet s = \"\" + this.stateNumber + \":\" + this.configs;\n\t\tif(this.isAcceptState) {\n\t\t\ts = s + \"=>\";\n\t\t\tif (this.predicates !== null)\n\t\t\t\ts = s + this.predicates;\n\t\t\telse\n\t\t\t\ts = s + this.prediction;\n\t\t}\n\t\treturn s;\n\t}\n\n\thashCode() {\n\t\tconst hash = new Hash();\n\t\thash.update(this.configs);\n\t\treturn hash.finish();\n\t}\n}\n\nmodule.exports = { DFAState, PredPrediction };\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/dfa/DFAState.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/dfa/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/dfa/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nexports.DFA = __webpack_require__(/*! ./DFA */ \"./node_modules/antlr4/src/antlr4/dfa/DFA.js\");\nexports.DFASerializer = __webpack_require__(/*! ./DFASerializer */ \"./node_modules/antlr4/src/antlr4/dfa/DFASerializer.js\").DFASerializer;\nexports.LexerDFASerializer = __webpack_require__(/*! ./DFASerializer */ \"./node_modules/antlr4/src/antlr4/dfa/DFASerializer.js\").LexerDFASerializer;\nexports.PredPrediction = __webpack_require__(/*! ./DFAState */ \"./node_modules/antlr4/src/antlr4/dfa/DFAState.js\").PredPrediction;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/dfa/index.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js":
/*!*************************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {BitSet} = __webpack_require__(/*! ./../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\nconst {ErrorListener} = __webpack_require__(/*! ./ErrorListener */ \"./node_modules/antlr4/src/antlr4/error/ErrorListener.js\")\nconst {Interval} = __webpack_require__(/*! ./../IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\")\n\n\n/**\n * This implementation of {@link ANTLRErrorListener} can be used to identify\n *  certain potential correctness and performance problems in grammars. \"Reports\"\n *  are made by calling {@link Parser//notifyErrorListeners} with the appropriate\n *  message.\n *\n *  <ul>\n *  <li><b>Ambiguities</b>: These are cases where more than one path through the\n *  grammar can match the input.</li>\n *  <li><b>Weak context sensitivity</b>: These are cases where full-context\n *  prediction resolved an SLL conflict to a unique alternative which equaled the\n *  minimum alternative of the SLL conflict.</li>\n *  <li><b>Strong (forced) context sensitivity</b>: These are cases where the\n *  full-context prediction resolved an SLL conflict to a unique alternative,\n *  <em>and</em> the minimum alternative of the SLL conflict was found to not be\n *  a truly viable alternative. Two-stage parsing cannot be used for inputs where\n *  this situation occurs.</li>\n *  </ul>\n */\nclass DiagnosticErrorListener extends ErrorListener {\n\tconstructor(exactOnly) {\n\t\tsuper();\n\t\texactOnly = exactOnly || true;\n\t\t// whether all ambiguities or only exact ambiguities are reported.\n\t\tthis.exactOnly = exactOnly;\n\t}\n\n\treportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n\t\tif (this.exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\t\tconst msg = \"reportAmbiguity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\": ambigAlts=\" +\n\t\t\tthis.getConflictingAlts(ambigAlts, configs) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\treportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n\t\tconst msg = \"reportAttemptingFullContext d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\treportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n\t\tconst msg = \"reportContextSensitivity d=\" +\n\t\t\tthis.getDecisionDescription(recognizer, dfa) +\n\t\t\t\", input='\" +\n\t\t\trecognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + \"'\"\n\t\trecognizer.notifyErrorListeners(msg);\n\t}\n\n\tgetDecisionDescription(recognizer, dfa) {\n\t\tconst decision = dfa.decision\n\t\tconst ruleIndex = dfa.atnStartState.ruleIndex\n\n\t\tconst ruleNames = recognizer.ruleNames\n\t\tif (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n\t\t\treturn \"\" + decision;\n\t\t}\n\t\tconst ruleName = ruleNames[ruleIndex] || null\n\t\tif (ruleName === null || ruleName.length === 0) {\n\t\t\treturn \"\" + decision;\n\t\t}\n\t\treturn `${decision} (${ruleName})`;\n\t}\n\n\t/**\n\t * Computes the set of conflicting or ambiguous alternatives from a\n\t * configuration set, if that information was not already provided by the\n\t * parser.\n\t *\n\t * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n\t * reported by the parser.\n\t * @param configs The conflicting or ambiguous configuration set.\n\t * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise\n\t * returns the set of alternatives represented in {@code configs}.\n     */\n\tgetConflictingAlts(reportedAlts, configs) {\n\t\tif (reportedAlts !== null) {\n\t\t\treturn reportedAlts;\n\t\t}\n\t\tconst result = new BitSet()\n\t\tfor (let i = 0; i < configs.items.length; i++) {\n\t\t\tresult.add(configs.items[i].alt);\n\t\t}\n\t\treturn `{${result.values().join(\", \")}}`;\n\t}\n}\n\nmodule.exports = DiagnosticErrorListener\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/error/ErrorListener.js":
/*!***************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/error/ErrorListener.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * Provides an empty default implementation of {@link ANTLRErrorListener}. The\n * default implementation of each method does nothing, but can be overridden as\n * necessary.\n */\nclass ErrorListener {\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n    }\n\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n    }\n\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n    }\n\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n    }\n}\n\n/**\n * {@inheritDoc}\n *\n * <p>\n * This implementation prints messages to {@link System//err} containing the\n * values of {@code line}, {@code charPositionInLine}, and {@code msg} using\n * the following format.</p>\n *\n * <pre>\n * line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>\n * </pre>\n *\n */\nclass ConsoleErrorListener extends ErrorListener {\n    constructor() {\n        super();\n    }\n\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n        console.error(\"line \" + line + \":\" + column + \" \" + msg);\n    }\n}\n\n\n/**\n * Provides a default instance of {@link ConsoleErrorListener}.\n */\nConsoleErrorListener.INSTANCE = new ConsoleErrorListener();\n\nclass ProxyErrorListener extends ErrorListener {\n    constructor(delegates) {\n        super();\n        if (delegates===null) {\n            throw \"delegates\";\n        }\n        this.delegates = delegates;\n        return this;\n    }\n\n    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {\n        this.delegates.map(d => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));\n    }\n\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n        this.delegates.map(d => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));\n    }\n\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {\n        this.delegates.map(d => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));\n    }\n\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {\n        this.delegates.map(d => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));\n    }\n}\n\nmodule.exports = {ErrorListener, ConsoleErrorListener, ProxyErrorListener}\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/error/ErrorListener.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/error/ErrorStrategy.js":
/*!***************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/error/ErrorStrategy.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./../Token */ \"./node_modules/antlr4/src/antlr4/Token.js\")\nconst {NoViableAltException, InputMismatchException, FailedPredicateException, ParseCancellationException} = __webpack_require__(/*! ./Errors */ \"./node_modules/antlr4/src/antlr4/error/Errors.js\")\nconst {ATNState} = __webpack_require__(/*! ./../atn/ATNState */ \"./node_modules/antlr4/src/antlr4/atn/ATNState.js\")\nconst {Interval, IntervalSet} = __webpack_require__(/*! ./../IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\")\n\nclass ErrorStrategy {\n\n    reset(recognizer) {\n    }\n\n    recoverInline(recognizer) {\n    }\n\n    recover(recognizer, e) {\n    }\n\n    sync(recognizer) {\n    }\n\n    inErrorRecoveryMode(recognizer) {\n    }\n\n    reportError(recognizer) {\n    }\n}\n\n\n/**\n * This is the default implementation of {@link ANTLRErrorStrategy} used for\n * error reporting and recovery in ANTLR parsers.\n*/\nclass DefaultErrorStrategy extends ErrorStrategy {\n    constructor() {\n        super();\n        /**\n         * Indicates whether the error strategy is currently \"recovering from an\n         * error\". This is used to suppress reporting multiple error messages while\n         * attempting to recover from a detected syntax error.\n         *\n         * @see //inErrorRecoveryMode\n         */\n        this.errorRecoveryMode = false;\n\n        /**\n         * The index into the input stream where the last error occurred.\n         * This is used to prevent infinite loops where an error is found\n         * but no token is consumed during recovery...another error is found,\n         * ad nauseum. This is a failsafe mechanism to guarantee that at least\n         * one token/tree node is consumed for two errors.\n         */\n        this.lastErrorIndex = -1;\n        this.lastErrorStates = null;\n        this.nextTokensContext = null;\n        this.nextTokenState = 0;\n    }\n\n    /**\n     * <p>The default implementation simply calls {@link //endErrorCondition} to\n     * ensure that the handler is not in error recovery mode.</p>\n    */\n    reset(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n\n    /**\n     * This method is called to enter error recovery mode when a recognition\n     * exception is reported.\n     *\n     * @param recognizer the parser instance\n    */\n    beginErrorCondition(recognizer) {\n        this.errorRecoveryMode = true;\n    }\n\n    inErrorRecoveryMode(recognizer) {\n        return this.errorRecoveryMode;\n    }\n\n    /**\n     * This method is called to leave error recovery mode after recovering from\n     * a recognition exception.\n     * @param recognizer\n     */\n    endErrorCondition(recognizer) {\n        this.errorRecoveryMode = false;\n        this.lastErrorStates = null;\n        this.lastErrorIndex = -1;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>The default implementation simply calls {@link //endErrorCondition}.</p>\n     */\n    reportMatch(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p>The default implementation returns immediately if the handler is already\n     * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}\n     * and dispatches the reporting task based on the runtime type of {@code e}\n     * according to the following table.</p>\n     *\n     * <ul>\n     * <li>{@link NoViableAltException}: Dispatches the call to\n     * {@link //reportNoViableAlternative}</li>\n     * <li>{@link InputMismatchException}: Dispatches the call to\n     * {@link //reportInputMismatch}</li>\n     * <li>{@link FailedPredicateException}: Dispatches the call to\n     * {@link //reportFailedPredicate}</li>\n     * <li>All other types: calls {@link Parser//notifyErrorListeners} to report\n     * the exception</li>\n     * </ul>\n     */\n    reportError(recognizer, e) {\n       // if we've already reported an error and have not matched a token\n       // yet successfully, don't report any errors.\n        if(this.inErrorRecoveryMode(recognizer)) {\n            return; // don't report spurious errors\n        }\n        this.beginErrorCondition(recognizer);\n        if ( e instanceof NoViableAltException ) {\n            this.reportNoViableAlternative(recognizer, e);\n        } else if ( e instanceof InputMismatchException ) {\n            this.reportInputMismatch(recognizer, e);\n        } else if ( e instanceof FailedPredicateException ) {\n            this.reportFailedPredicate(recognizer, e);\n        } else {\n            console.log(\"unknown recognition error type: \" + e.constructor.name);\n            console.log(e.stack);\n            recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);\n        }\n    }\n\n    /**\n     *\n     * {@inheritDoc}\n     *\n     * <p>The default implementation resynchronizes the parser by consuming tokens\n     * until we find one in the resynchronization set--loosely the set of tokens\n     * that can follow the current rule.</p>\n     *\n     */\n    recover(recognizer, e) {\n        if (this.lastErrorIndex===recognizer.getInputStream().index &&\n            this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {\n            // uh oh, another error at same token index and previously-visited\n            // state in ATN; must be a case where LT(1) is in the recovery\n            // token set so nothing got consumed. Consume a single token\n            // at least to prevent an infinite loop; this is a failsafe.\n            recognizer.consume();\n        }\n        this.lastErrorIndex = recognizer._input.index;\n        if (this.lastErrorStates === null) {\n            this.lastErrorStates = [];\n        }\n        this.lastErrorStates.push(recognizer.state);\n        const followSet = this.getErrorRecoverySet(recognizer)\n        this.consumeUntil(recognizer, followSet);\n    }\n\n    /**\n     * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure\n     * that the current lookahead symbol is consistent with what were expecting\n     * at this point in the ATN. You can call this anytime but ANTLR only\n     * generates code to check before subrules/loops and each iteration.\n     *\n     * <p>Implements Jim Idle's magic sync mechanism in closures and optional\n     * subrules. E.g.,</p>\n     *\n     * <pre>\n     * a : sync ( stuff sync )* ;\n     * sync : {consume to what can follow sync} ;\n     * </pre>\n     *\n     * At the start of a sub rule upon error, {@link //sync} performs single\n     * token deletion, if possible. If it can't do that, it bails on the current\n     * rule and uses the default error recovery, which consumes until the\n     * resynchronization set of the current rule.\n     *\n     * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block\n     * with an empty alternative), then the expected set includes what follows\n     * the subrule.</p>\n     *\n     * <p>During loop iteration, it consumes until it sees a token that can start a\n     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n     * stay in the loop as long as possible.</p>\n     *\n     * <p><strong>ORIGINS</strong></p>\n     *\n     * <p>Previous versions of ANTLR did a poor job of their recovery within loops.\n     * A single mismatch token or missing token would force the parser to bail\n     * out of the entire rules surrounding the loop. So, for rule</p>\n     *\n     * <pre>\n     * classDef : 'class' ID '{' member* '}'\n     * </pre>\n     *\n     * input with an extra token between members would force the parser to\n     * consume until it found the next class definition rather than the next\n     * member definition of the current class.\n     *\n     * <p>This functionality cost a little bit of effort because the parser has to\n     * compare token set at the start of the loop and at each iteration. If for\n     * some reason speed is suffering for you, you can turn off this\n     * functionality by simply overriding this method as a blank { }.</p>\n     *\n     */\n    sync(recognizer) {\n        // If already recovering, don't try to sync\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        const s = recognizer._interp.atn.states[recognizer.state];\n        const la = recognizer.getTokenStream().LA(1);\n        // try cheaper subset first; might get lucky. seems to shave a wee bit off\n        const nextTokens = recognizer.atn.nextTokens(s);\n        if(nextTokens.contains(la)) {\n            this.nextTokensContext = null;\n            this.nextTokenState = ATNState.INVALID_STATE_NUMBER;\n            return;\n        } else if (nextTokens.contains(Token.EPSILON)) {\n            if(this.nextTokensContext === null) {\n                // It's possible the next token won't match information tracked\n                // by sync is restricted for performance.\n                this.nextTokensContext = recognizer._ctx;\n                this.nextTokensState = recognizer._stateNumber;\n            }\n            return;\n        }\n        switch (s.stateType) {\n        case ATNState.BLOCK_START:\n        case ATNState.STAR_BLOCK_START:\n        case ATNState.PLUS_BLOCK_START:\n        case ATNState.STAR_LOOP_ENTRY:\n           // report error and recover if possible\n            if( this.singleTokenDeletion(recognizer) !== null) {\n                return;\n            } else {\n                throw new InputMismatchException(recognizer);\n            }\n        case ATNState.PLUS_LOOP_BACK:\n        case ATNState.STAR_LOOP_BACK:\n            this.reportUnwantedToken(recognizer);\n            const expecting = new IntervalSet()\n            expecting.addSet(recognizer.getExpectedTokens());\n            const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer))\n            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n            break;\n        default:\n            // do nothing if we can't identify the exact kind of ATN state\n        }\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is a\n     * {@link NoViableAltException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportNoViableAlternative(recognizer, e) {\n        const tokens = recognizer.getTokenStream()\n        let input\n        if(tokens !== null) {\n            if (e.startToken.type===Token.EOF) {\n                input = \"<EOF>\";\n            } else {\n                input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));\n            }\n        } else {\n            input = \"<unknown input>\";\n        }\n        const msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is an\n     * {@link InputMismatchException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportInputMismatch(recognizer, e) {\n        const msg = \"mismatched input \" + this.getTokenErrorDisplay(e.offendingToken) +\n            \" expecting \" + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This is called by {@link //reportError} when the exception is a\n     * {@link FailedPredicateException}.\n     *\n     * @see //reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportFailedPredicate(recognizer, e) {\n        const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex]\n        const msg = \"rule \" + ruleName + \" \" + e.message\n        recognizer.notifyErrorListeners(msg, e.offendingToken, e);\n    }\n\n    /**\n     * This method is called to report a syntax error which requires the removal\n     * of a token from the input stream. At the time this method is called, the\n     * erroneous symbol is current {@code LT(1)} symbol and has not yet been\n     * removed from the input stream. When this method returns,\n     * {@code recognizer} is in error recovery mode.\n     *\n     * <p>This method is called when {@link //singleTokenDeletion} identifies\n     * single-token deletion as a viable recovery strategy for a mismatched\n     * input error.</p>\n     *\n     * <p>The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser//notifyErrorListeners}.</p>\n     *\n     * @param recognizer the parser instance\n     *\n     */\n    reportUnwantedToken(recognizer) {\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken()\n        const tokenName = this.getTokenErrorDisplay(t)\n        const expecting = this.getExpectedTokens(recognizer)\n        const msg = \"extraneous input \" + tokenName + \" expecting \" +\n            expecting.toString(recognizer.literalNames, recognizer.symbolicNames)\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n\n    /**\n     * This method is called to report a syntax error which requires the\n     * insertion of a missing token into the input stream. At the time this\n     * method is called, the missing token has not yet been inserted. When this\n     * method returns, {@code recognizer} is in error recovery mode.\n     *\n     * <p>This method is called when {@link //singleTokenInsertion} identifies\n     * single-token insertion as a viable recovery strategy for a mismatched\n     * input error.</p>\n     *\n     * <p>The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser//notifyErrorListeners}.</p>\n     *\n     * @param recognizer the parser instance\n     */\n    reportMissingToken(recognizer) {\n        if ( this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        const t = recognizer.getCurrentToken()\n        const expecting = this.getExpectedTokens(recognizer)\n        const msg = \"missing \" + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +\n            \" at \" + this.getTokenErrorDisplay(t)\n        recognizer.notifyErrorListeners(msg, t, null);\n    }\n\n    /**\n     * <p>The default implementation attempts to recover from the mismatched input\n     * by using single token insertion and deletion as described below. If the\n     * recovery attempt fails, this method throws an\n     * {@link InputMismatchException}.</p>\n     *\n     * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>\n     *\n     * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the\n     * right token, however, then assume {@code LA(1)} is some extra spurious\n     * token and delete it. Then consume and return the next token (which was\n     * the {@code LA(2)} token) as the successful result of the match operation.</p>\n     *\n     * <p>This recovery strategy is implemented by {@link\n     * //singleTokenDeletion}.</p>\n     *\n     * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>\n     *\n     * <p>If current token (at {@code LA(1)}) is consistent with what could come\n     * after the expected {@code LA(1)} token, then assume the token is missing\n     * and use the parser's {@link TokenFactory} to create it on the fly. The\n     * \"insertion\" is performed by returning the created token as the successful\n     * result of the match operation.</p>\n     *\n     * <p>This recovery strategy is implemented by {@link\n     * //singleTokenInsertion}.</p>\n     *\n     * <p><strong>EXAMPLE</strong></p>\n     *\n     * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When\n     * the parser returns from the nested call to {@code expr}, it will have\n     * call chain:</p>\n     *\n     * <pre>\n     * stat &rarr; expr &rarr; atom\n     * </pre>\n     *\n     * and it will be trying to match the {@code ')'} at this point in the\n     * derivation:\n     *\n     * <pre>\n     * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'\n     * ^\n     * </pre>\n     *\n     * The attempt to match {@code ')'} will fail when it sees {@code ';'} and\n     * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}\n     * is in the set of tokens that can follow the {@code ')'} token reference\n     * in rule {@code atom}. It can assume that you forgot the {@code ')'}.\n     */\n    recoverInline(recognizer) {\n        // SINGLE TOKEN DELETION\n        const matchedSymbol = this.singleTokenDeletion(recognizer)\n        if (matchedSymbol !== null) {\n            // we have deleted the extra token.\n            // now, move past ttype token as if all were ok\n            recognizer.consume();\n            return matchedSymbol;\n        }\n        // SINGLE TOKEN INSERTION\n        if (this.singleTokenInsertion(recognizer)) {\n            return this.getMissingSymbol(recognizer);\n        }\n        // even that didn't work; must throw the exception\n        throw new InputMismatchException(recognizer);\n    }\n\n    /**\n     * This method implements the single-token insertion inline error recovery\n     * strategy. It is called by {@link //recoverInline} if the single-token\n     * deletion strategy fails to recover from the mismatched input. If this\n     * method returns {@code true}, {@code recognizer} will be in error recovery\n     * mode.\n     *\n     * <p>This method determines whether or not single-token insertion is viable by\n     * checking if the {@code LA(1)} input symbol could be successfully matched\n     * if it were instead the {@code LA(2)} symbol. If this method returns\n     * {@code true}, the caller is responsible for creating and inserting a\n     * token with the correct type to produce this behavior.</p>\n     *\n     * @param recognizer the parser instance\n     * @return {@code true} if single-token insertion is a viable recovery\n     * strategy for the current mismatched input, otherwise {@code false}\n     */\n    singleTokenInsertion(recognizer) {\n        const currentSymbolType = recognizer.getTokenStream().LA(1)\n        // if current token is consistent with what could come after current\n        // ATN state, then we know we're missing a token; error recovery\n        // is free to conjure up and insert the missing token\n        const atn = recognizer._interp.atn\n        const currentState = atn.states[recognizer.state]\n        const next = currentState.transitions[0].target\n        const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx)\n        if (expectingAtLL2.contains(currentSymbolType) ){\n            this.reportMissingToken(recognizer);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * This method implements the single-token deletion inline error recovery\n     * strategy. It is called by {@link //recoverInline} to attempt to recover\n     * from mismatched input. If this method returns null, the parser and error\n     * handler state will not have changed. If this method returns non-null,\n     * {@code recognizer} will <em>not</em> be in error recovery mode since the\n     * returned token was a successful match.\n     *\n     * <p>If the single-token deletion is successful, this method calls\n     * {@link //reportUnwantedToken} to report the error, followed by\n     * {@link Parser//consume} to actually \"delete\" the extraneous token. Then,\n     * before returning {@link //reportMatch} is called to signal a successful\n     * match.</p>\n     *\n     * @param recognizer the parser instance\n     * @return the successfully matched {@link Token} instance if single-token\n     * deletion successfully recovers from the mismatched input, otherwise\n     * {@code null}\n     */\n    singleTokenDeletion(recognizer) {\n        const nextTokenType = recognizer.getTokenStream().LA(2)\n        const expecting = this.getExpectedTokens(recognizer)\n        if (expecting.contains(nextTokenType)) {\n            this.reportUnwantedToken(recognizer);\n            // print(\"recoverFromMismatchedToken deleting \" \\\n            // + str(recognizer.getTokenStream().LT(1)) \\\n            // + \" since \" + str(recognizer.getTokenStream().LT(2)) \\\n            // + \" is what we want\", file=sys.stderr)\n            recognizer.consume(); // simply delete extra token\n            // we want to return the token we're actually matching\n            const matchedSymbol = recognizer.getCurrentToken()\n            this.reportMatch(recognizer); // we know current token is correct\n            return matchedSymbol;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Conjure up a missing token during error recovery.\n     *\n     * The recognizer attempts to recover from single missing\n     * symbols. But, actions might refer to that missing symbol.\n     * For example, x=ID {f($x);}. The action clearly assumes\n     * that there has been an identifier matched previously and that\n     * $x points at that token. If that token is missing, but\n     * the next token in the stream is what we want we assume that\n     * this token is missing and we keep going. Because we\n     * have to return some token to replace the missing token,\n     * we have to conjure one up. This method gives the user control\n     * over the tokens returned for missing tokens. Mostly,\n     * you will want to create something special for identifier\n     * tokens. For literals such as '{' and ',', the default\n     * action in the parser or tree parser works. It simply creates\n     * a CommonToken of the appropriate type. The text will be the token.\n     * If you change what tokens must be created by the lexer,\n     * override this method to create the appropriate tokens.\n     *\n     */\n    getMissingSymbol(recognizer) {\n        const currentSymbol = recognizer.getCurrentToken()\n        const expecting = this.getExpectedTokens(recognizer)\n        const expectedTokenType = expecting.first() // get any element\n        let tokenText\n        if (expectedTokenType===Token.EOF) {\n            tokenText = \"<missing EOF>\";\n        } else {\n            tokenText = \"<missing \" + recognizer.literalNames[expectedTokenType] + \">\";\n        }\n        let current = currentSymbol\n        const lookback = recognizer.getTokenStream().LT(-1)\n        if (current.type===Token.EOF && lookback !== null) {\n            current = lookback;\n        }\n        return recognizer.getTokenFactory().create(current.source,\n            expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,\n            -1, -1, current.line, current.column);\n    }\n\n    getExpectedTokens(recognizer) {\n        return recognizer.getExpectedTokens();\n    }\n\n    /**\n     * How should a token be displayed in an error message? The default\n     * is to display just the text, but during development you might\n     * want to have a lot of information spit out. Override in that case\n     * to use t.toString() (which, for CommonToken, dumps everything about\n     * the token). This is better than forcing you to override a method in\n     * your token objects because you don't have to go modify your lexer\n     * so that it creates a new Java type.\n     */\n    getTokenErrorDisplay(t) {\n        if (t === null) {\n            return \"<no token>\";\n        }\n        let s = t.text\n        if (s === null) {\n            if (t.type===Token.EOF) {\n                s = \"<EOF>\";\n            } else {\n                s = \"<\" + t.type + \">\";\n            }\n        }\n        return this.escapeWSAndQuote(s);\n    }\n\n    escapeWSAndQuote(s) {\n        s = s.replace(/\\n/g,\"\\\\n\");\n        s = s.replace(/\\r/g,\"\\\\r\");\n        s = s.replace(/\\t/g,\"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n\n    /**\n     * Compute the error recovery set for the current rule. During\n     * rule invocation, the parser pushes the set of tokens that can\n     * follow that rule reference on the stack; this amounts to\n     * computing FIRST of what follows the rule reference in the\n     * enclosing rule. See LinearApproximator.FIRST().\n     * This local follow set only includes tokens\n     * from within the rule; i.e., the FIRST computation done by\n     * ANTLR stops at the end of a rule.\n     *\n     * EXAMPLE\n     *\n     * When you find a \"no viable alt exception\", the input is not\n     * consistent with any of the alternatives for rule r. The best\n     * thing to do is to consume tokens until you see something that\n     * can legally follow a call to r//or* any rule that called r.\n     * You don't want the exact set of viable next tokens because the\n     * input might just be missing a token--you might consume the\n     * rest of the input looking for one of the missing tokens.\n     *\n     * Consider grammar:\n     *\n     * a : '[' b ']'\n     * | '(' b ')'\n     * ;\n     * b : c '^' INT ;\n     * c : ID\n     * | INT\n     * ;\n     *\n     * At each rule invocation, the set of tokens that could follow\n     * that rule is pushed on a stack. Here are the various\n     * context-sensitive follow sets:\n     *\n     * FOLLOW(b1_in_a) = FIRST(']') = ']'\n     * FOLLOW(b2_in_a) = FIRST(')') = ')'\n     * FOLLOW(c_in_b) = FIRST('^') = '^'\n     *\n     * Upon erroneous input \"[]\", the call chain is\n     *\n     * a -> b -> c\n     *\n     * and, hence, the follow context stack is:\n     *\n     * depth follow set start of rule execution\n     * 0 <EOF> a (from main())\n     * 1 ']' b\n     * 2 '^' c\n     *\n     * Notice that ')' is not included, because b would have to have\n     * been called from a different context in rule a for ')' to be\n     * included.\n     *\n     * For error recovery, we cannot consider FOLLOW(c)\n     * (context-sensitive or otherwise). We need the combined set of\n     * all context-sensitive FOLLOW sets--the set of all tokens that\n     * could follow any reference in the call chain. We need to\n     * resync to one of those tokens. Note that FOLLOW(c)='^' and if\n     * we resync'd to that token, we'd consume until EOF. We need to\n     * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n     * In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n     * not consume anything. After printing an error, rule c would\n     * return normally. Rule b would not find the required '^' though.\n     * At this point, it gets a mismatched token error and throws an\n     * exception (since LA(1) is not in the viable following token\n     * set). The rule exception handler tries to recover, but finds\n     * the same recovery set and doesn't consume anything. Rule b\n     * exits normally returning to rule a. Now it finds the ']' (and\n     * with the successful match exits errorRecovery mode).\n     *\n     * So, you can see that the parser walks up the call chain looking\n     * for the token that was a member of the recovery set.\n     *\n     * Errors are not generated in errorRecovery mode.\n     *\n     * ANTLR's error recovery mechanism is based upon original ideas:\n     *\n     * \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n     *\n     * and\n     *\n     * \"A note on error recovery in recursive descent parsers\":\n     * http://portal.acm.org/citation.cfm?id=947902.947905\n     *\n     * Later, Josef Grosch had some good ideas:\n     *\n     * \"Efficient and Comfortable Error Recovery in Recursive Descent\n     * Parsers\":\n     * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n     *\n     * Like Grosch I implement context-sensitive FOLLOW sets that are combined\n     * at run-time upon error to avoid overhead during parsing.\n     */\n    getErrorRecoverySet(recognizer) {\n        const atn = recognizer._interp.atn\n        let ctx = recognizer._ctx\n        const recoverSet = new IntervalSet()\n        while (ctx !== null && ctx.invokingState>=0) {\n            // compute what follows who invoked us\n            const invokingState = atn.states[ctx.invokingState]\n            const rt = invokingState.transitions[0]\n            const follow = atn.nextTokens(rt.followState)\n            recoverSet.addSet(follow);\n            ctx = ctx.parentCtx;\n        }\n        recoverSet.removeOne(Token.EPSILON);\n        return recoverSet;\n    }\n\n// Consume tokens until one matches the given token set.//\n    consumeUntil(recognizer, set) {\n        let ttype = recognizer.getTokenStream().LA(1)\n        while( ttype !== Token.EOF && !set.contains(ttype)) {\n            recognizer.consume();\n            ttype = recognizer.getTokenStream().LA(1);\n        }\n    }\n}\n\n\n/**\n * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\n * by immediately canceling the parse operation with a\n * {@link ParseCancellationException}. The implementation ensures that the\n * {@link ParserRuleContext//exception} field is set for all parse tree nodes\n * that were not completed prior to encountering the error.\n *\n * <p>\n * This error strategy is useful in the following scenarios.</p>\n *\n * <ul>\n * <li><strong>Two-stage parsing:</strong> This error strategy allows the first\n * stage of two-stage parsing to immediately terminate if an error is\n * encountered, and immediately fall back to the second stage. In addition to\n * avoiding wasted work by attempting to recover from errors here, the empty\n * implementation of {@link BailErrorStrategy//sync} improves the performance of\n * the first stage.</li>\n * <li><strong>Silent validation:</strong> When syntax errors are not being\n * reported or logged, and the parse result is simply ignored if errors occur,\n * the {@link BailErrorStrategy} avoids wasting work on recovering from errors\n * when the result will be ignored either way.</li>\n * </ul>\n *\n * <p>\n * {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>\n *\n * @see Parser//setErrorHandler(ANTLRErrorStrategy)\n * */\nclass BailErrorStrategy extends DefaultErrorStrategy {\n    constructor() {\n        super();\n    }\n\n    /**\n     * Instead of recovering from exception {@code e}, re-throw it wrapped\n     * in a {@link ParseCancellationException} so it is not caught by the\n     * rule function catches. Use {@link Exception//getCause()} to get the\n     * original {@link RecognitionException}.\n     */\n    recover(recognizer, e) {\n        let context = recognizer._ctx\n        while (context !== null) {\n            context.exception = e;\n            context = context.parentCtx;\n        }\n        throw new ParseCancellationException(e);\n    }\n\n    /**\n     * Make sure we don't attempt to recover inline; if the parser\n     * successfully recovers, it won't throw an exception.\n     */\n    recoverInline(recognizer) {\n        this.recover(recognizer, new InputMismatchException(recognizer));\n    }\n\n// Make sure we don't attempt to recover from problems in subrules.//\n    sync(recognizer) {\n        // pass\n    }\n}\n\n\nmodule.exports = {BailErrorStrategy, DefaultErrorStrategy};\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/error/ErrorStrategy.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/error/Errors.js":
/*!********************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/error/Errors.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\n/**\n * The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n *  3 kinds of errors: prediction errors, failed predicate errors, and\n *  mismatched input errors. In each case, the parser knows where it is\n *  in the input, where it is in the ATN, the rule invocation stack,\n *  and what kind of problem occurred.\n */\n\nconst {PredicateTransition} = __webpack_require__(/*! ./../atn/Transition */ \"./node_modules/antlr4/src/antlr4/atn/Transition.js\");\nconst {Interval} = __webpack_require__(/*! ../IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\").Interval;\n\nclass RecognitionException extends Error {\n    constructor(params) {\n        super(params.message);\n        if (!!Error.captureStackTrace) {\n            Error.captureStackTrace(this, RecognitionException);\n        } else {\n            var stack = new Error().stack;\n        }\n        this.message = params.message;\n        this.recognizer = params.recognizer;\n        this.input = params.input;\n        this.ctx = params.ctx;\n        /**\n         * The current {@link Token} when an error occurred. Since not all streams\n         * support accessing symbols by index, we have to track the {@link Token}\n         * instance itself\n        */\n        this.offendingToken = null;\n        /**\n         * Get the ATN state number the parser was in at the time the error\n         * occurred. For {@link NoViableAltException} and\n         * {@link LexerNoViableAltException} exceptions, this is the\n         * {@link DecisionState} number. For others, it is the state whose outgoing\n         * edge we couldn't match.\n         */\n        this.offendingState = -1;\n        if (this.recognizer!==null) {\n            this.offendingState = this.recognizer.state;\n        }\n    }\n\n    /**\n     * Gets the set of input symbols which could potentially follow the\n     * previously matched symbol at the time this exception was thrown.\n     *\n     * <p>If the set of expected tokens is not known and could not be computed,\n     * this method returns {@code null}.</p>\n     *\n     * @return The set of token types that could potentially follow the current\n     * state in the ATN, or {@code null} if the information is not available.\n     */\n    getExpectedTokens() {\n        if (this.recognizer!==null) {\n            return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);\n        } else {\n            return null;\n        }\n    }\n\n    // <p>If the state number is not known, this method returns -1.</p>\n    toString() {\n        return this.message;\n    }\n}\n\nclass LexerNoViableAltException extends RecognitionException {\n    constructor(lexer, input, startIndex, deadEndConfigs) {\n        super({message: \"\", recognizer: lexer, input: input, ctx: null});\n        this.startIndex = startIndex;\n        this.deadEndConfigs = deadEndConfigs;\n    }\n\n    toString() {\n        let symbol = \"\";\n        if (this.startIndex >= 0 && this.startIndex < this.input.size) {\n            symbol = this.input.getText(new Interval(this.startIndex,this.startIndex));\n        }\n        return \"LexerNoViableAltException\" + symbol;\n    }\n}\n\n\n/**\n * Indicates that the parser could not decide which of two or more paths\n * to take based upon the remaining input. It tracks the starting token\n * of the offending input and also knows where the parser was\n * in the various paths when the error. Reported by reportNoViableAlternative()\n */\nclass NoViableAltException extends RecognitionException {\n    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {\n        ctx = ctx || recognizer._ctx;\n        offendingToken = offendingToken || recognizer.getCurrentToken();\n        startToken = startToken || recognizer.getCurrentToken();\n        input = input || recognizer.getInputStream();\n        super({message: \"\", recognizer: recognizer, input: input, ctx: ctx});\n        // Which configurations did we try at input.index() that couldn't match\n        // input.LT(1)?//\n        this.deadEndConfigs = deadEndConfigs;\n        // The token object at the start index; the input stream might\n        // not be buffering tokens so get a reference to it. (At the\n        // time the error occurred, of course the stream needs to keep a\n        // buffer all of the tokens but later we might not have access to those.)\n        this.startToken = startToken;\n        this.offendingToken = offendingToken;\n    }\n}\n\n/**\n * This signifies any kind of mismatched input exceptions such as\n * when the current input does not match the expected token.\n*/\nclass InputMismatchException extends RecognitionException {\n    constructor(recognizer) {\n        super({message: \"\", recognizer: recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx});\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n}\n\nfunction formatMessage(predicate, message) {\n    if (message !==null) {\n        return message;\n    } else {\n        return \"failed predicate: {\" + predicate + \"}?\";\n    }\n}\n\n/**\n * A semantic predicate failed during validation. Validation of predicates\n * occurs when normally parsing the alternative just like matching a token.\n * Disambiguating predicate evaluation occurs when we test a predicate during\n * prediction.\n*/\nclass FailedPredicateException extends RecognitionException {\n    constructor(recognizer, predicate, message) {\n        super({\n            message: formatMessage(predicate, message || null), recognizer: recognizer,\n            input: recognizer.getInputStream(), ctx: recognizer._ctx\n        });\n        const s = recognizer._interp.atn.states[recognizer.state]\n        const trans = s.transitions[0]\n        if (trans instanceof PredicateTransition) {\n            this.ruleIndex = trans.ruleIndex;\n            this.predicateIndex = trans.predIndex;\n        } else {\n            this.ruleIndex = 0;\n            this.predicateIndex = 0;\n        }\n        this.predicate = predicate;\n        this.offendingToken = recognizer.getCurrentToken();\n    }\n}\n\n\nclass ParseCancellationException extends Error{\n    constructor() {\n        super()\n        Error.captureStackTrace(this, ParseCancellationException);\n    }\n}\n\nmodule.exports = {\n    RecognitionException,\n    NoViableAltException,\n    LexerNoViableAltException,\n    InputMismatchException,\n    FailedPredicateException,\n    ParseCancellationException\n};\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/error/Errors.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/error/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/error/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nmodule.exports.RecognitionException = __webpack_require__(/*! ./Errors */ \"./node_modules/antlr4/src/antlr4/error/Errors.js\").RecognitionException;\nmodule.exports.NoViableAltException = __webpack_require__(/*! ./Errors */ \"./node_modules/antlr4/src/antlr4/error/Errors.js\").NoViableAltException;\nmodule.exports.LexerNoViableAltException = __webpack_require__(/*! ./Errors */ \"./node_modules/antlr4/src/antlr4/error/Errors.js\").LexerNoViableAltException;\nmodule.exports.InputMismatchException = __webpack_require__(/*! ./Errors */ \"./node_modules/antlr4/src/antlr4/error/Errors.js\").InputMismatchException;\nmodule.exports.FailedPredicateException = __webpack_require__(/*! ./Errors */ \"./node_modules/antlr4/src/antlr4/error/Errors.js\").FailedPredicateException;\nmodule.exports.DiagnosticErrorListener = __webpack_require__(/*! ./DiagnosticErrorListener */ \"./node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js\");\nmodule.exports.BailErrorStrategy = __webpack_require__(/*! ./ErrorStrategy */ \"./node_modules/antlr4/src/antlr4/error/ErrorStrategy.js\").BailErrorStrategy;\nmodule.exports.DefaultErrorStrategy = __webpack_require__(/*! ./ErrorStrategy */ \"./node_modules/antlr4/src/antlr4/error/ErrorStrategy.js\").DefaultErrorStrategy;\nmodule.exports.ErrorListener = __webpack_require__(/*! ./ErrorListener */ \"./node_modules/antlr4/src/antlr4/error/ErrorListener.js\").ErrorListener;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/error/index.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/index.js":
/*!*************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\nexports.atn = __webpack_require__(/*! ./atn/index */ \"./node_modules/antlr4/src/antlr4/atn/index.js\");\nexports.codepointat = __webpack_require__(/*! ./polyfills/codepointat */ \"./node_modules/antlr4/src/antlr4/polyfills/codepointat.js\");\nexports.dfa = __webpack_require__(/*! ./dfa/index */ \"./node_modules/antlr4/src/antlr4/dfa/index.js\");\nexports.fromcodepoint = __webpack_require__(/*! ./polyfills/fromcodepoint */ \"./node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js\");\nexports.tree = __webpack_require__(/*! ./tree/index */ \"./node_modules/antlr4/src/antlr4/tree/index.js\");\nexports.error = __webpack_require__(/*! ./error/index */ \"./node_modules/antlr4/src/antlr4/error/index.js\");\nexports.Token = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\").Token;\nexports.CharStreams = __webpack_require__(/*! ./CharStreams */ \"./node_modules/antlr4/src/antlr4/CharStreams.js\");\nexports.CommonToken = __webpack_require__(/*! ./Token */ \"./node_modules/antlr4/src/antlr4/Token.js\").CommonToken;\nexports.InputStream = __webpack_require__(/*! ./InputStream */ \"./node_modules/antlr4/src/antlr4/InputStream.js\");\nexports.FileStream = __webpack_require__(/*! ./FileStream */ \"./node_modules/antlr4/src/antlr4/FileStream.js\");\nexports.CommonTokenStream = __webpack_require__(/*! ./CommonTokenStream */ \"./node_modules/antlr4/src/antlr4/CommonTokenStream.js\");\nexports.Lexer = __webpack_require__(/*! ./Lexer */ \"./node_modules/antlr4/src/antlr4/Lexer.js\");\nexports.Parser = __webpack_require__(/*! ./Parser */ \"./node_modules/antlr4/src/antlr4/Parser.js\");\nvar pc = __webpack_require__(/*! ./PredictionContext */ \"./node_modules/antlr4/src/antlr4/PredictionContext.js\");\nexports.PredictionContextCache = pc.PredictionContextCache;\nexports.ParserRuleContext = __webpack_require__(/*! ./ParserRuleContext */ \"./node_modules/antlr4/src/antlr4/ParserRuleContext.js\");\nexports.Interval = __webpack_require__(/*! ./IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\").Interval;\nexports.IntervalSet = __webpack_require__(/*! ./IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\").IntervalSet;\nexports.Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\nexports.LL1Analyzer = __webpack_require__(/*! ./LL1Analyzer */ \"./node_modules/antlr4/src/antlr4/LL1Analyzer.js\").LL1Analyzer;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/index.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/polyfills/codepointat.js":
/*!*****************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/polyfills/codepointat.js ***!
  \*****************************************************************/
/***/ (() => {

eval("/*! https://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\t'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tconst object = {};\n\t\t\t\tconst $defineProperty = Object.defineProperty;\n\t\t\t\tresult = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {\n\t\t\t}\n\t\t\treturn result;\n\t\t}());\n\t\tconst codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tconst string = String(this);\n\t\t\tconst size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tlet index = position ? Number(position) : 0;\n\t\t\tif (index !== index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tconst first = string.charCodeAt(index);\n\t\t\tlet second;\n\t\t\tif ( // check if its the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/polyfills/codepointat.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js":
/*!*******************************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js ***!
  \*******************************************************************/
/***/ (() => {

eval("/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tconst defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tconst object = {};\n\t\t\t\tconst $defineProperty = Object.defineProperty;\n\t\t\t\tresult = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tconst stringFromCharCode = String.fromCharCode;\n\t\tconst floor = Math.floor;\n\t\tconst fromCodePoint = function(_) {\n\t\t\tconst MAX_SIZE = 0x4000;\n\t\t\tconst codeUnits = [];\n\t\t\tlet highSurrogate;\n\t\t\tlet lowSurrogate;\n\t\t\tlet index = -1;\n\t\t\tconst length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tlet result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tlet codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) !== codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/tree/Tree.js":
/*!*****************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/tree/Tree.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst {Token} = __webpack_require__(/*! ./../Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst {Interval} = __webpack_require__(/*! ./../IntervalSet */ \"./node_modules/antlr4/src/antlr4/IntervalSet.js\");\nconst INVALID_INTERVAL = new Interval(-1, -2);\n\n/**\n * The basic notion of a tree has a parent, a payload, and a list of children.\n * It is the most abstract interface for all the trees used by ANTLR.\n */\nclass Tree {}\n\nclass SyntaxTree extends Tree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ParseTree extends SyntaxTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass RuleNode extends ParseTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tgetRuleContext(){\n\t\tthrow new Error(\"missing interface implementation\")\n\t}\n}\n\nclass TerminalNode extends ParseTree {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ErrorNode extends TerminalNode {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nclass ParseTreeVisitor {\n\tvisit(ctx) {\n\t\t if (Array.isArray(ctx)) {\n\t\t\treturn ctx.map(function(child) {\n\t\t\t\treturn child.accept(this);\n\t\t\t}, this);\n\t\t} else {\n\t\t\treturn ctx.accept(this);\n\t\t}\n\t}\n\n\tvisitChildren(ctx) {\n\t\tif (ctx.children) {\n\t\t\treturn this.visit(ctx.children);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tvisitTerminal(node) {\n\t}\n\n\tvisitErrorNode(node) {\n\t}\n}\n\nclass ParseTreeListener {\n\tvisitTerminal(node) {\n\t}\n\n\tvisitErrorNode(node) {\n\t}\n\n\tenterEveryRule(node) {\n\t}\n\n\texitEveryRule(node) {\n\t}\n}\n\nclass TerminalNodeImpl extends TerminalNode {\n\tconstructor(symbol) {\n\t\tsuper();\n\t\tthis.parentCtx = null;\n\t\tthis.symbol = symbol;\n\t}\n\n\tgetChild(i) {\n\t\treturn null;\n\t}\n\n\tgetSymbol() {\n\t\treturn this.symbol;\n\t}\n\n\tgetParent() {\n\t\treturn this.parentCtx;\n\t}\n\n\tgetPayload() {\n\t\treturn this.symbol;\n\t}\n\n\tgetSourceInterval() {\n\t\tif (this.symbol === null) {\n\t\t\treturn INVALID_INTERVAL;\n\t\t}\n\t\tconst tokenIndex = this.symbol.tokenIndex;\n\t\treturn new Interval(tokenIndex, tokenIndex);\n\t}\n\n\tgetChildCount() {\n\t\treturn 0;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitTerminal(this);\n\t}\n\n\tgetText() {\n\t\treturn this.symbol.text;\n\t}\n\n\ttoString() {\n\t\tif (this.symbol.type === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else {\n\t\t\treturn this.symbol.text;\n\t\t}\n\t}\n}\n\n\n/**\n * Represents a token that was consumed during resynchronization\n * rather than during a valid match operation. For example,\n * we will create this kind of a node during single token insertion\n * and deletion as well as during \"consume until error recovery set\"\n * upon no viable alternative exceptions.\n */\nclass ErrorNodeImpl extends TerminalNodeImpl {\n\tconstructor(token) {\n\t\tsuper(token);\n\t}\n\n\tisErrorNode() {\n\t\treturn true;\n\t}\n\n\taccept(visitor) {\n\t\treturn visitor.visitErrorNode(this);\n\t}\n}\n\nclass ParseTreeWalker {\n\n\t/**\n\t * Performs a walk on the given parse tree starting at the root and going down recursively\n\t * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before\n\t * recursively walking down into child nodes, then\n\t * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.\n\t * @param listener The listener used by the walker to process grammar rules\n\t * @param t The parse tree to be walked on\n\t */\n\twalk(listener, t) {\n\t\tconst errorNode = t instanceof ErrorNode ||\n\t\t\t\t(t.isErrorNode !== undefined && t.isErrorNode());\n\t\tif (errorNode) {\n\t\t\tlistener.visitErrorNode(t);\n\t\t} else if (t instanceof TerminalNode) {\n\t\t\tlistener.visitTerminal(t);\n\t\t} else {\n\t\t\tthis.enterRule(listener, t);\n\t\t\tfor (let i = 0; i < t.getChildCount(); i++) {\n\t\t\t\tconst child = t.getChild(i);\n\t\t\t\tthis.walk(listener, child);\n\t\t\t}\n\t\t\tthis.exitRule(listener, t);\n\t\t}\n\t}\n\n\t/**\n\t * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}\n\t * then by triggering the event specific to the given parse tree node\n\t * @param listener The listener responding to the trigger events\n\t * @param r The grammar rule containing the rule context\n\t */\n\tenterRule(listener, r) {\n\t\tconst ctx = r.getRuleContext();\n\t\tlistener.enterEveryRule(ctx);\n\t\tctx.enterRule(listener);\n\t}\n\n\t/**\n\t * Exits a grammar rule by first triggering the event specific to the given parse tree node\n\t * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}\n\t * @param listener The listener responding to the trigger events\n\t * @param r The grammar rule containing the rule context\n\t */\n\texitRule(listener, r) {\n\t\tconst ctx = r.getRuleContext();\n\t\tctx.exitRule(listener);\n\t\tlistener.exitEveryRule(ctx);\n\t}\n}\n\nParseTreeWalker.DEFAULT = new ParseTreeWalker();\n\nmodule.exports = {\n\tRuleNode,\n\tErrorNode,\n\tTerminalNode,\n\tErrorNodeImpl,\n\tTerminalNodeImpl,\n\tParseTreeListener,\n\tParseTreeVisitor,\n\tParseTreeWalker,\n\tINVALID_INTERVAL\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/tree/Tree.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/tree/Trees.js":
/*!******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/tree/Trees.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Utils = __webpack_require__(/*! ./../Utils */ \"./node_modules/antlr4/src/antlr4/Utils.js\");\nconst {Token} = __webpack_require__(/*! ./../Token */ \"./node_modules/antlr4/src/antlr4/Token.js\");\nconst {ErrorNode, TerminalNode, RuleNode} = __webpack_require__(/*! ./Tree */ \"./node_modules/antlr4/src/antlr4/tree/Tree.js\");\n\n/** A set of utility routines useful for all kinds of ANTLR trees. */\nconst Trees = {\n    /**\n     * Print out a whole tree in LISP form. {@link //getNodeText} is used on the\n     *  node payloads to get the text for the nodes.  Detect\n     *  parse trees and extract data appropriately.\n     */\n    toStringTree: function(tree, ruleNames, recog) {\n        ruleNames = ruleNames || null;\n        recog = recog || null;\n        if(recog!==null) {\n            ruleNames = recog.ruleNames;\n        }\n        let s = Trees.getNodeText(tree, ruleNames);\n        s = Utils.escapeWhitespace(s, false);\n        const c = tree.getChildCount();\n        if(c===0) {\n            return s;\n        }\n        let res = \"(\" + s + ' ';\n        if(c>0) {\n            s = Trees.toStringTree(tree.getChild(0), ruleNames);\n            res = res.concat(s);\n        }\n        for(let i=1;i<c;i++) {\n            s = Trees.toStringTree(tree.getChild(i), ruleNames);\n            res = res.concat(' ' + s);\n        }\n        res = res.concat(\")\");\n        return res;\n    },\n\n    getNodeText: function(t, ruleNames, recog) {\n        ruleNames = ruleNames || null;\n        recog = recog || null;\n        if(recog!==null) {\n            ruleNames = recog.ruleNames;\n        }\n        if(ruleNames!==null) {\n            if (t instanceof RuleNode) {\n                const context = t.getRuleContext()\n                const altNumber = context.getAltNumber();\n                // use const value of ATN.INVALID_ALT_NUMBER to avoid circular dependency\n                if ( altNumber != 0 ) {\n                    return ruleNames[t.ruleIndex]+\":\"+altNumber;\n                }\n                return ruleNames[t.ruleIndex];\n            } else if ( t instanceof ErrorNode) {\n                return t.toString();\n            } else if(t instanceof TerminalNode) {\n                if(t.symbol!==null) {\n                    return t.symbol.text;\n                }\n            }\n        }\n        // no recog for rule names\n        const payload = t.getPayload();\n        if (payload instanceof Token ) {\n            return payload.text;\n        }\n        return t.getPayload().toString();\n    },\n\n    /**\n     * Return ordered list of all children of this node\n     */\n    getChildren: function(t) {\n        const list = [];\n        for(let i=0;i<t.getChildCount();i++) {\n            list.push(t.getChild(i));\n        }\n        return list;\n    },\n\n    /**\n     * Return a list of all ancestors of this node.  The first node of\n     * list is the root and the last is the parent of this node.\n     */\n    getAncestors: function(t) {\n        let ancestors = [];\n        t = t.getParent();\n        while(t!==null) {\n            ancestors = [t].concat(ancestors);\n            t = t.getParent();\n        }\n        return ancestors;\n    },\n\n    findAllTokenNodes: function(t, ttype) {\n        return Trees.findAllNodes(t, ttype, true);\n    },\n\n    findAllRuleNodes: function(t, ruleIndex) {\n        return Trees.findAllNodes(t, ruleIndex, false);\n    },\n\n    findAllNodes: function(t, index, findTokens) {\n        const nodes = [];\n        Trees._findAllNodes(t, index, findTokens, nodes);\n        return nodes;\n    },\n\n    _findAllNodes: function(t, index, findTokens, nodes) {\n        // check this node (the root) first\n        if(findTokens && (t instanceof TerminalNode)) {\n            if(t.symbol.type===index) {\n                nodes.push(t);\n            }\n        } else if(!findTokens && (t instanceof RuleNode)) {\n            if(t.ruleIndex===index) {\n                nodes.push(t);\n            }\n        }\n        // check children\n        for(let i=0;i<t.getChildCount();i++) {\n            Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n        }\n    },\n\n    descendants: function(t) {\n        let nodes = [t];\n        for(let i=0;i<t.getChildCount();i++) {\n            nodes = nodes.concat(Trees.descendants(t.getChild(i)));\n        }\n        return nodes;\n    }\n}\n\nmodule.exports = Trees;\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/tree/Trees.js?");

/***/ }),

/***/ "./node_modules/antlr4/src/antlr4/tree/index.js":
/*!******************************************************!*\
  !*** ./node_modules/antlr4/src/antlr4/tree/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.\n * Use of this file is governed by the BSD 3-clause license that\n * can be found in the LICENSE.txt file in the project root.\n */\n\nconst Tree = __webpack_require__(/*! ./Tree */ \"./node_modules/antlr4/src/antlr4/tree/Tree.js\");\nconst Trees = __webpack_require__(/*! ./Trees */ \"./node_modules/antlr4/src/antlr4/tree/Trees.js\");\nmodule.exports = {...Tree, Trees}\n\n\n//# sourceURL=webpack://bundle/./node_modules/antlr4/src/antlr4/tree/index.js?");

/***/ }),

/***/ "./.spago/arrays/v6.0.1/src/Data/Array.purs":
/*!**************************************************!*\
  !*** ./.spago/arrays/v6.0.1/src/Data/Array.purs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.js */ \"./.spago/arrays/v6.0.1/src/Data/Array.js\");\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Lazy = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Lazy.purs */ \"./.spago/control/v5.0.0/src/Control/Lazy.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Control_Monad_ST_Internal = __webpack_require__(/*! ./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs */ \"./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs\");\nvar Data_Array_ST = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array/ST.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array/ST.purs\");\nvar Data_Array_ST_Iterator = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array/ST/Iterator.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array/ST/Iterator.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar zipWithA = function (dictApplicative) {\n    return function (f) {\n        return function (xs) {\n            return function (ys) {\n                return Data_Traversable.sequence(Data_Traversable.traversableArray)(dictApplicative)($foreign.zipWith(f)(xs)(ys));\n            };\n        };\n    };\n};\nvar zip = $foreign.zipWith(Data_Tuple.Tuple.create);\nvar updateAtIndices = function (dictFoldable) {\n    return function (us) {\n        return function (xs) {\n            return Data_Array_ST.withArray(function (res) {\n                return Data_Foldable.traverse_(Control_Monad_ST_Internal.applicativeST)(dictFoldable)(function (v) {\n                    return Data_Array_ST.poke(v.value0)(v.value1)(res);\n                })(us);\n            })(xs)();\n        };\n    };\n};\nvar updateAt = $foreign[\"_updateAt\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar unsafeIndex = function (dictPartial) {\n    return $foreign.unsafeIndexImpl;\n};\nvar uncons = $foreign.unconsImpl(Data_Function[\"const\"](Data_Maybe.Nothing.value))(function (x) {\n    return function (xs) {\n        return new Data_Maybe.Just({\n            head: x,\n            tail: xs\n        });\n    };\n});\nvar toUnfoldable = function (dictUnfoldable) {\n    return function (xs) {\n        var len = $foreign.length(xs);\n        var f = function (i) {\n            if (i < len) {\n                return new Data_Maybe.Just(new Data_Tuple.Tuple(unsafeIndex()(xs)(i), i + 1 | 0));\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Maybe.Nothing.value;\n            };\n            throw new Error(\"Failed pattern match at Data.Array (line 158, column 3 - line 160, column 26): \" + [ i.constructor.name ]);\n        };\n        return Data_Unfoldable.unfoldr(dictUnfoldable)(f)(0);\n    };\n};\nvar take = function (n) {\n    return function (xs) {\n        var $67 = n < 1;\n        if ($67) {\n            return [  ];\n        };\n        return $foreign.slice(0)(n)(xs);\n    };\n};\nvar tail = $foreign.unconsImpl(Data_Function[\"const\"](Data_Maybe.Nothing.value))(function (v) {\n    return function (xs) {\n        return new Data_Maybe.Just(xs);\n    };\n});\nvar splitAt = function (i) {\n    return function (xs) {\n        if (i <= 0) {\n            return {\n                before: [  ],\n                after: xs\n            };\n        };\n        return {\n            before: $foreign.slice(0)(i)(xs),\n            after: $foreign.slice(i)($foreign.length(xs))(xs)\n        };\n    };\n};\nvar sortBy = function (comp) {\n    return $foreign.sortByImpl(comp)(function (v) {\n        if (v instanceof Data_Ordering.GT) {\n            return 1;\n        };\n        if (v instanceof Data_Ordering.EQ) {\n            return 0;\n        };\n        if (v instanceof Data_Ordering.LT) {\n            return -1 | 0;\n        };\n        throw new Error(\"Failed pattern match at Data.Array (line 831, column 31 - line 834, column 11): \" + [ v.constructor.name ]);\n    });\n};\nvar sortWith = function (dictOrd) {\n    return function (f) {\n        return sortBy(Data_Ord.comparing(dictOrd)(f));\n    };\n};\nvar sort = function (dictOrd) {\n    return function (xs) {\n        return sortBy(Data_Ord.compare(dictOrd))(xs);\n    };\n};\nvar snoc = function (xs) {\n    return function (x) {\n        return Data_Array_ST.withArray(Data_Array_ST.push(x))(xs)();\n    };\n};\nvar singleton = function (a) {\n    return [ a ];\n};\nvar $$null = function (xs) {\n    return $foreign.length(xs) === 0;\n};\nvar nubByEq = function (eq) {\n    return function (xs) {\n        return (function __do() {\n            var arr = Data_Array_ST[\"new\"]();\n            Control_Monad_ST_Internal.foreach(xs)(function (x) {\n                return function __do() {\n                    var e = Data_Functor.map(Control_Monad_ST_Internal.functorST)((function () {\n                        var $99 = Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean);\n                        var $100 = $foreign.any(function (v) {\n                            return eq(v)(x);\n                        });\n                        return function ($101) {\n                            return $99($100($101));\n                        };\n                    })())(Data_Array_ST.unsafeFreeze(arr))();\n                    return Control_Applicative.when(Control_Monad_ST_Internal.applicativeST)(e)(Data_Functor[\"void\"](Control_Monad_ST_Internal.functorST)(Data_Array_ST.push(x)(arr)))();\n                };\n            })();\n            return Data_Array_ST.unsafeFreeze(arr)();\n        })();\n    };\n};\nvar nubEq = function (dictEq) {\n    return nubByEq(Data_Eq.eq(dictEq));\n};\nvar modifyAtIndices = function (dictFoldable) {\n    return function (is) {\n        return function (f) {\n            return function (xs) {\n                return Data_Array_ST.withArray(function (res) {\n                    return Data_Foldable.traverse_(Control_Monad_ST_Internal.applicativeST)(dictFoldable)(function (i) {\n                        return Data_Array_ST.modify(i)(f)(res);\n                    })(is);\n                })(xs)();\n            };\n        };\n    };\n};\nvar mapWithIndex = function (f) {\n    return function (xs) {\n        return $foreign.zipWith(f)($foreign.range(0)($foreign.length(xs) - 1 | 0))(xs);\n    };\n};\nvar intersperse = function (a) {\n    return function (arr) {\n        var v = $foreign.length(arr);\n        if (v < 2) {\n            return arr;\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Array_ST.run((function () {\n                var unsafeGetElem = function (idx) {\n                    return unsafeIndex()(arr)(idx);\n                };\n                return function __do() {\n                    var out = Data_Array_ST[\"new\"]();\n                    Data_Array_ST.push(unsafeGetElem(0))(out)();\n                    Control_Monad_ST_Internal[\"for\"](1)(v)(function (idx) {\n                        return function __do() {\n                            Data_Array_ST.push(a)(out)();\n                            return Data_Functor[\"void\"](Control_Monad_ST_Internal.functorST)(Data_Array_ST.push(unsafeGetElem(idx))(out))();\n                        };\n                    })();\n                    return out;\n                };\n            })());\n        };\n        throw new Error(\"Failed pattern match at Data.Array (line 613, column 21 - line 622, column 19): \" + [ v.constructor.name ]);\n    };\n};\nvar intercalate = function (dictMonoid) {\n    return Data_Foldable.intercalate(Data_Foldable.foldableArray)(dictMonoid);\n};\nvar insertAt = $foreign[\"_insertAt\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar init = function (xs) {\n    if ($$null(xs)) {\n        return Data_Maybe.Nothing.value;\n    };\n    if (Data_Boolean.otherwise) {\n        return new Data_Maybe.Just($foreign.slice(0)($foreign.length(xs) - 1 | 0)(xs));\n    };\n    throw new Error(\"Failed pattern match at Data.Array (line 340, column 1 - line 340, column 45): \" + [ xs.constructor.name ]);\n};\nvar index = $foreign.indexImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar last = function (xs) {\n    return index(xs)($foreign.length(xs) - 1 | 0);\n};\nvar unsnoc = function (xs) {\n    return Control_Apply.apply(Data_Maybe.applyMaybe)(Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {\n        return function (v1) {\n            return {\n                init: v,\n                last: v1\n            };\n        };\n    })(init(xs)))(last(xs));\n};\nvar modifyAt = function (i) {\n    return function (f) {\n        return function (xs) {\n            var go = function (x) {\n                return updateAt(i)(f(x))(xs);\n            };\n            return Data_Maybe.maybe(Data_Maybe.Nothing.value)(go)(index(xs)(i));\n        };\n    };\n};\nvar span = function (p) {\n    return function (arr) {\n        var go = function ($copy_i) {\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(i) {\n                var v = index(arr)(i);\n                if (v instanceof Data_Maybe.Just) {\n                    var $74 = p(v.value0);\n                    if ($74) {\n                        $copy_i = i + 1 | 0;\n                        return;\n                    };\n                    $tco_done = true;\n                    return new Data_Maybe.Just(i);\n                };\n                if (v instanceof Data_Maybe.Nothing) {\n                    $tco_done = true;\n                    return Data_Maybe.Nothing.value;\n                };\n                throw new Error(\"Failed pattern match at Data.Array (line 966, column 5 - line 968, column 25): \" + [ v.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($copy_i);\n            };\n            return $tco_result;\n        };\n        var breakIndex = go(0);\n        if (breakIndex instanceof Data_Maybe.Just && breakIndex.value0 === 0) {\n            return {\n                init: [  ],\n                rest: arr\n            };\n        };\n        if (breakIndex instanceof Data_Maybe.Just) {\n            return {\n                init: $foreign.slice(0)(breakIndex.value0)(arr),\n                rest: $foreign.slice(breakIndex.value0)($foreign.length(arr))(arr)\n            };\n        };\n        if (breakIndex instanceof Data_Maybe.Nothing) {\n            return {\n                init: arr,\n                rest: [  ]\n            };\n        };\n        throw new Error(\"Failed pattern match at Data.Array (line 953, column 3 - line 959, column 30): \" + [ breakIndex.constructor.name ]);\n    };\n};\nvar takeWhile = function (p) {\n    return function (xs) {\n        return (span(p)(xs)).init;\n    };\n};\nvar unzip = function (xs) {\n    return (function __do() {\n        var fsts = Data_Array_ST[\"new\"]();\n        var snds = Data_Array_ST[\"new\"]();\n        var iter = Data_Array_ST_Iterator.iterator(function (v) {\n            return index(xs)(v);\n        })();\n        Data_Array_ST_Iterator.iterate(iter)(function (v) {\n            return function __do() {\n                Data_Functor[\"void\"](Control_Monad_ST_Internal.functorST)(Data_Array_ST.push(v.value0)(fsts))();\n                return Data_Functor[\"void\"](Control_Monad_ST_Internal.functorST)(Data_Array_ST.push(v.value1)(snds))();\n            };\n        })();\n        var fsts$prime = Data_Array_ST.unsafeFreeze(fsts)();\n        var snds$prime = Data_Array_ST.unsafeFreeze(snds)();\n        return new Data_Tuple.Tuple(fsts$prime, snds$prime);\n    })();\n};\nvar head = function (xs) {\n    return index(xs)(0);\n};\nvar nubBy = function (comp) {\n    return function (xs) {\n        var indexedAndSorted = sortBy(function (x) {\n            return function (y) {\n                return comp(Data_Tuple.snd(x))(Data_Tuple.snd(y));\n            };\n        })(mapWithIndex(Data_Tuple.Tuple.create)(xs));\n        var v = head(indexedAndSorted);\n        if (v instanceof Data_Maybe.Nothing) {\n            return [  ];\n        };\n        if (v instanceof Data_Maybe.Just) {\n            return Data_Functor.map(Data_Functor.functorArray)(Data_Tuple.snd)(sortWith(Data_Ord.ordInt)(Data_Tuple.fst)((function __do() {\n                var result = Data_Array_ST.unsafeThaw(singleton(v.value0))();\n                Control_Monad_ST_Internal.foreach(indexedAndSorted)(function (v1) {\n                    return function __do() {\n                        var lst = Data_Functor.map(Control_Monad_ST_Internal.functorST)((function () {\n                            var $102 = (function (dictPartial) {\n                                var $104 = Data_Maybe.fromJust();\n                                return function ($105) {\n                                    return $104(last($105));\n                                };\n                            })();\n                            return function ($103) {\n                                return Data_Tuple.snd($102($103));\n                            };\n                        })())(Data_Array_ST.unsafeFreeze(result))();\n                        return Control_Applicative.when(Control_Monad_ST_Internal.applicativeST)(Data_Eq.notEq(Data_Ordering.eqOrdering)(comp(lst)(v1.value1))(Data_Ordering.EQ.value))(Data_Functor[\"void\"](Control_Monad_ST_Internal.functorST)(Data_Array_ST.push(v1)(result)))();\n                    };\n                })();\n                return Data_Array_ST.unsafeFreeze(result)();\n            })()));\n        };\n        throw new Error(\"Failed pattern match at Data.Array (line 1050, column 17 - line 1058, column 29): \" + [ v.constructor.name ]);\n    };\n};\nvar nub = function (dictOrd) {\n    return nubBy(Data_Ord.compare(dictOrd));\n};\nvar groupBy = function (op) {\n    return function (xs) {\n        return (function __do() {\n            var result = Data_Array_ST[\"new\"]();\n            var iter = Data_Array_ST_Iterator.iterator(function (v) {\n                return index(xs)(v);\n            })();\n            Data_Array_ST_Iterator.iterate(iter)(function (x) {\n                return Data_Functor[\"void\"](Control_Monad_ST_Internal.functorST)(function __do() {\n                    var sub = Data_Array_ST[\"new\"]();\n                    Data_Array_ST.push(x)(sub)();\n                    Data_Array_ST_Iterator.pushWhile(op(x))(iter)(sub)();\n                    var grp = Data_Array_ST.unsafeFreeze(sub)();\n                    return Data_Array_ST.push(grp)(result)();\n                });\n            })();\n            return Data_Array_ST.unsafeFreeze(result)();\n        })();\n    };\n};\nvar groupAllBy = function (cmp) {\n    var $106 = groupBy(function (x) {\n        return function (y) {\n            return Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(x)(y))(Data_Ordering.EQ.value);\n        };\n    });\n    var $107 = sortBy(cmp);\n    return function ($108) {\n        return $106($107($108));\n    };\n};\nvar groupAll = function (dictOrd) {\n    return groupAllBy(Data_Ord.compare(dictOrd));\n};\nvar group$prime = function (dictWarn) {\n    return function (dictOrd) {\n        return groupAll(dictOrd);\n    };\n};\nvar group = function (dictEq) {\n    return function (xs) {\n        return groupBy(Data_Eq.eq(dictEq))(xs);\n    };\n};\nvar fromFoldable = function (dictFoldable) {\n    return $foreign.fromFoldableImpl(Data_Foldable.foldr(dictFoldable));\n};\nvar foldr = Data_Foldable.foldr(Data_Foldable.foldableArray);\nvar foldl = Data_Foldable.foldl(Data_Foldable.foldableArray);\nvar foldRecM = function (dictMonadRec) {\n    return function (f) {\n        return function (b) {\n            return function (array) {\n                var go = function (res) {\n                    return function (i) {\n                        if (i >= $foreign.length(array)) {\n                            return Control_Applicative.pure((dictMonadRec.Monad0()).Applicative0())(new Control_Monad_Rec_Class.Done(res));\n                        };\n                        if (Data_Boolean.otherwise) {\n                            return Control_Bind.bind((dictMonadRec.Monad0()).Bind1())(f(res)(unsafeIndex()(array)(i)))(function (res$prime) {\n                                return Control_Applicative.pure((dictMonadRec.Monad0()).Applicative0())(new Control_Monad_Rec_Class.Loop({\n                                    a: res$prime,\n                                    b: i + 1 | 0\n                                }));\n                            });\n                        };\n                        throw new Error(\"Failed pattern match at Data.Array (line 1269, column 3 - line 1273, column 42): \" + [ res.constructor.name, i.constructor.name ]);\n                    };\n                };\n                return Control_Monad_Rec_Class.tailRecM2(dictMonadRec)(go)(b)(0);\n            };\n        };\n    };\n};\nvar foldMap = function (dictMonoid) {\n    return Data_Foldable.foldMap(Data_Foldable.foldableArray)(dictMonoid);\n};\nvar foldM = function (dictMonad) {\n    return function (f) {\n        return function (b) {\n            return $foreign.unconsImpl(function (v) {\n                return Control_Applicative.pure(dictMonad.Applicative0())(b);\n            })(function (a) {\n                return function (as) {\n                    return Control_Bind.bind(dictMonad.Bind1())(f(b)(a))(function (b$prime) {\n                        return foldM(dictMonad)(f)(b$prime)(as);\n                    });\n                };\n            });\n        };\n    };\n};\nvar fold = function (dictMonoid) {\n    return Data_Foldable.fold(Data_Foldable.foldableArray)(dictMonoid);\n};\nvar findMap = $foreign.findMapImpl(Data_Maybe.Nothing.value)(Data_Maybe.isJust);\nvar findLastIndex = $foreign.findLastIndexImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar insertBy = function (cmp) {\n    return function (x) {\n        return function (ys) {\n            var i = Data_Maybe.maybe(0)(function (v) {\n                return v + 1 | 0;\n            })(findLastIndex(function (y) {\n                return Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(x)(y))(Data_Ordering.GT.value);\n            })(ys));\n            return Data_Maybe.fromJust()(insertAt(i)(x)(ys));\n        };\n    };\n};\nvar insert = function (dictOrd) {\n    return insertBy(Data_Ord.compare(dictOrd));\n};\nvar findIndex = $foreign.findIndexImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar intersectBy = function (eq) {\n    return function (xs) {\n        return function (ys) {\n            return $foreign.filter(function (x) {\n                return Data_Maybe.isJust(findIndex(eq(x))(ys));\n            })(xs);\n        };\n    };\n};\nvar intersect = function (dictEq) {\n    return intersectBy(Data_Eq.eq(dictEq));\n};\nvar find = function (f) {\n    return function (xs) {\n        return Data_Functor.map(Data_Maybe.functorMaybe)(unsafeIndex()(xs))(findIndex(f)(xs));\n    };\n};\nvar elemLastIndex = function (dictEq) {\n    return function (x) {\n        return findLastIndex(function (v) {\n            return Data_Eq.eq(dictEq)(v)(x);\n        });\n    };\n};\nvar elemIndex = function (dictEq) {\n    return function (x) {\n        return findIndex(function (v) {\n            return Data_Eq.eq(dictEq)(v)(x);\n        });\n    };\n};\nvar notElem = function (dictEq) {\n    return function (a) {\n        return function (arr) {\n            return Data_Maybe.isNothing(elemIndex(dictEq)(a)(arr));\n        };\n    };\n};\nvar elem = function (dictEq) {\n    return function (a) {\n        return function (arr) {\n            return Data_Maybe.isJust(elemIndex(dictEq)(a)(arr));\n        };\n    };\n};\nvar dropWhile = function (p) {\n    return function (xs) {\n        return (span(p)(xs)).rest;\n    };\n};\nvar dropEnd = function (n) {\n    return function (xs) {\n        return take($foreign.length(xs) - n | 0)(xs);\n    };\n};\nvar drop = function (n) {\n    return function (xs) {\n        var $89 = n < 1;\n        if ($89) {\n            return xs;\n        };\n        return $foreign.slice(n)($foreign.length(xs))(xs);\n    };\n};\nvar takeEnd = function (n) {\n    return function (xs) {\n        return drop($foreign.length(xs) - n | 0)(xs);\n    };\n};\nvar deleteAt = $foreign[\"_deleteAt\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar deleteBy = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2.length === 0) {\n                return [  ];\n            };\n            return Data_Maybe.maybe(v2)(function (i) {\n                return Data_Maybe.fromJust()(deleteAt(i)(v2));\n            })(findIndex(v(v1))(v2));\n        };\n    };\n};\nvar unionBy = function (eq) {\n    return function (xs) {\n        return function (ys) {\n            return Data_Semigroup.append(Data_Semigroup.semigroupArray)(xs)(foldl(Data_Function.flip(deleteBy(eq)))(nubByEq(eq)(ys))(xs));\n        };\n    };\n};\nvar union = function (dictEq) {\n    return unionBy(Data_Eq.eq(dictEq));\n};\nvar $$delete = function (dictEq) {\n    return deleteBy(Data_Eq.eq(dictEq));\n};\nvar difference = function (dictEq) {\n    return foldr($$delete(dictEq));\n};\nvar cons = function (x) {\n    return function (xs) {\n        return Data_Semigroup.append(Data_Semigroup.semigroupArray)([ x ])(xs);\n    };\n};\nvar some = function (dictAlternative) {\n    return function (dictLazy) {\n        return function (v) {\n            return Control_Apply.apply((dictAlternative.Applicative0()).Apply0())(Data_Functor.map(((dictAlternative.Plus1()).Alt0()).Functor0())(cons)(v))(Control_Lazy.defer(dictLazy)(function (v1) {\n                return many(dictAlternative)(dictLazy)(v);\n            }));\n        };\n    };\n};\nvar many = function (dictAlternative) {\n    return function (dictLazy) {\n        return function (v) {\n            return Control_Alt.alt((dictAlternative.Plus1()).Alt0())(some(dictAlternative)(dictLazy)(v))(Control_Applicative.pure(dictAlternative.Applicative0())([  ]));\n        };\n    };\n};\nvar concatMap = Data_Function.flip(Control_Bind.bind(Control_Bind.bindArray));\nvar mapMaybe = function (f) {\n    return concatMap((function () {\n        var $109 = Data_Maybe.maybe([  ])(singleton);\n        return function ($110) {\n            return $109(f($110));\n        };\n    })());\n};\nvar filterA = function (dictApplicative) {\n    return function (p) {\n        var $111 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(mapMaybe(function (v) {\n            if (v.value1) {\n                return new Data_Maybe.Just(v.value0);\n            };\n            return Data_Maybe.Nothing.value;\n        }));\n        var $112 = Data_Traversable.traverse(Data_Traversable.traversableArray)(dictApplicative)(function (x) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Tuple.Tuple.create(x))(p(x));\n        });\n        return function ($113) {\n            return $111($112($113));\n        };\n    };\n};\nvar catMaybes = mapMaybe(Control_Category.identity(Control_Category.categoryFn));\nvar alterAt = function (i) {\n    return function (f) {\n        return function (xs) {\n            var go = function (x) {\n                var v = f(x);\n                if (v instanceof Data_Maybe.Nothing) {\n                    return deleteAt(i)(xs);\n                };\n                if (v instanceof Data_Maybe.Just) {\n                    return updateAt(i)(v.value0)(xs);\n                };\n                throw new Error(\"Failed pattern match at Data.Array (line 591, column 10 - line 593, column 32): \" + [ v.constructor.name ]);\n            };\n            return Data_Maybe.maybe(Data_Maybe.Nothing.value)(go)(index(xs)(i));\n        };\n    };\n};\nmodule.exports = {\n    fromFoldable: fromFoldable,\n    toUnfoldable: toUnfoldable,\n    singleton: singleton,\n    some: some,\n    many: many,\n    \"null\": $$null,\n    cons: cons,\n    snoc: snoc,\n    insert: insert,\n    insertBy: insertBy,\n    head: head,\n    last: last,\n    tail: tail,\n    init: init,\n    uncons: uncons,\n    unsnoc: unsnoc,\n    index: index,\n    elem: elem,\n    notElem: notElem,\n    elemIndex: elemIndex,\n    elemLastIndex: elemLastIndex,\n    find: find,\n    findMap: findMap,\n    findIndex: findIndex,\n    findLastIndex: findLastIndex,\n    insertAt: insertAt,\n    deleteAt: deleteAt,\n    updateAt: updateAt,\n    updateAtIndices: updateAtIndices,\n    modifyAt: modifyAt,\n    modifyAtIndices: modifyAtIndices,\n    alterAt: alterAt,\n    intersperse: intersperse,\n    concatMap: concatMap,\n    splitAt: splitAt,\n    filterA: filterA,\n    mapMaybe: mapMaybe,\n    catMaybes: catMaybes,\n    mapWithIndex: mapWithIndex,\n    foldl: foldl,\n    foldr: foldr,\n    foldMap: foldMap,\n    fold: fold,\n    intercalate: intercalate,\n    sort: sort,\n    sortBy: sortBy,\n    sortWith: sortWith,\n    take: take,\n    takeEnd: takeEnd,\n    takeWhile: takeWhile,\n    drop: drop,\n    dropEnd: dropEnd,\n    dropWhile: dropWhile,\n    span: span,\n    group: group,\n    groupAll: groupAll,\n    \"group'\": group$prime,\n    groupBy: groupBy,\n    groupAllBy: groupAllBy,\n    nub: nub,\n    nubEq: nubEq,\n    nubBy: nubBy,\n    nubByEq: nubByEq,\n    union: union,\n    unionBy: unionBy,\n    \"delete\": $$delete,\n    deleteBy: deleteBy,\n    difference: difference,\n    intersect: intersect,\n    intersectBy: intersectBy,\n    zipWithA: zipWithA,\n    zip: zip,\n    unzip: unzip,\n    foldM: foldM,\n    foldRecM: foldRecM,\n    unsafeIndex: unsafeIndex,\n    range: $foreign.range,\n    replicate: $foreign.replicate,\n    length: $foreign.length,\n    reverse: $foreign.reverse,\n    concat: $foreign.concat,\n    filter: $foreign.filter,\n    partition: $foreign.partition,\n    scanl: $foreign.scanl,\n    scanr: $foreign.scanr,\n    slice: $foreign.slice,\n    zipWith: $foreign.zipWith,\n    any: $foreign.any,\n    all: $foreign.all\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/arrays/v6.0.1/src/Data/Array.purs?");

/***/ }),

/***/ "./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty.purs":
/*!***********************************************************!*\
  !*** ./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty.purs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_Array_NonEmpty_Internal = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty/Internal.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty/Internal.purs\");\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_NonEmpty = __webpack_require__(/*! ./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs */ \"./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Semigroup_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable1 = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs\");\nvar Unsafe_Coerce = __webpack_require__(/*! ./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs */ \"./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs\");\nvar unsafeFromArrayF = Unsafe_Coerce.unsafeCoerce;\nvar unsafeFromArray = Data_Array_NonEmpty_Internal.NonEmptyArray;\nvar toArray = function (v) {\n    return v;\n};\nvar unionBy$prime = function (eq) {\n    return function (xs) {\n        var $50 = Data_Array.unionBy(eq)(toArray(xs));\n        return function ($51) {\n            return unsafeFromArray($50($51));\n        };\n    };\n};\nvar union$prime = function (dictEq) {\n    return unionBy$prime(Data_Eq.eq(dictEq));\n};\nvar unionBy = function (eq) {\n    return function (xs) {\n        var $52 = unionBy$prime(eq)(xs);\n        return function ($53) {\n            return $52(toArray($53));\n        };\n    };\n};\nvar union = function (dictEq) {\n    return unionBy(Data_Eq.eq(dictEq));\n};\nvar unzip = (function () {\n    var $54 = Data_Bifunctor.bimap(Data_Bifunctor.bifunctorTuple)(unsafeFromArray)(unsafeFromArray);\n    return function ($55) {\n        return $54(Data_Array.unzip(toArray($55)));\n    };\n})();\nvar updateAt = function (i) {\n    return function (x) {\n        var $56 = Data_Array.updateAt(i)(x);\n        return function ($57) {\n            return unsafeFromArrayF($56(toArray($57)));\n        };\n    };\n};\nvar zip = function (xs) {\n    return function (ys) {\n        return unsafeFromArray(Data_Array.zip(toArray(xs))(toArray(ys)));\n    };\n};\nvar zipWith = function (f) {\n    return function (xs) {\n        return function (ys) {\n            return unsafeFromArray(Data_Array.zipWith(f)(toArray(xs))(toArray(ys)));\n        };\n    };\n};\nvar zipWithA = function (dictApplicative) {\n    return function (f) {\n        return function (xs) {\n            return function (ys) {\n                return unsafeFromArrayF(Data_Array.zipWithA(dictApplicative)(f)(toArray(xs))(toArray(ys)));\n            };\n        };\n    };\n};\nvar splitAt = function (i) {\n    return function (xs) {\n        return Data_Array.splitAt(i)(toArray(xs));\n    };\n};\nvar some = function (dictAlternative) {\n    return function (dictLazy) {\n        var $58 = Data_Array.some(dictAlternative)(dictLazy);\n        return function ($59) {\n            return unsafeFromArrayF($58($59));\n        };\n    };\n};\nvar snoc$prime = function (xs) {\n    return function (x) {\n        return unsafeFromArray(Data_Array.snoc(xs)(x));\n    };\n};\nvar snoc = function (xs) {\n    return function (x) {\n        return unsafeFromArray(Data_Array.snoc(toArray(xs))(x));\n    };\n};\nvar singleton = function ($60) {\n    return unsafeFromArray(Data_Array.singleton($60));\n};\nvar replicate = function (i) {\n    return function (x) {\n        return unsafeFromArray(Data_Array.replicate(Data_Ord.max(Data_Ord.ordInt)(1)(i))(x));\n    };\n};\nvar range = function (x) {\n    return function (y) {\n        return unsafeFromArray(Data_Array.range(x)(y));\n    };\n};\nvar modifyAt = function (i) {\n    return function (f) {\n        var $61 = Data_Array.modifyAt(i)(f);\n        return function ($62) {\n            return unsafeFromArrayF($61(toArray($62)));\n        };\n    };\n};\nvar intersectBy$prime = function (eq) {\n    return function (xs) {\n        return Data_Array.intersectBy(eq)(toArray(xs));\n    };\n};\nvar intersectBy = function (eq) {\n    return function (xs) {\n        var $63 = intersectBy$prime(eq)(xs);\n        return function ($64) {\n            return $63(toArray($64));\n        };\n    };\n};\nvar intersect$prime = function (dictEq) {\n    return intersectBy$prime(Data_Eq.eq(dictEq));\n};\nvar intersect = function (dictEq) {\n    return intersectBy(Data_Eq.eq(dictEq));\n};\nvar intercalate = function (dictSemigroup) {\n    return Data_Semigroup_Foldable.intercalate(Data_Array_NonEmpty_Internal.foldable1NonEmptyArray)(dictSemigroup);\n};\nvar insertAt = function (i) {\n    return function (x) {\n        var $65 = Data_Array.insertAt(i)(x);\n        return function ($66) {\n            return unsafeFromArrayF($65(toArray($66)));\n        };\n    };\n};\nvar fromFoldable1 = function (dictFoldable1) {\n    var $67 = Data_Array.fromFoldable(dictFoldable1.Foldable0());\n    return function ($68) {\n        return unsafeFromArray($67($68));\n    };\n};\nvar fromArray = function (xs) {\n    if (Data_Array.length(xs) > 0) {\n        return new Data_Maybe.Just(unsafeFromArray(xs));\n    };\n    if (Data_Boolean.otherwise) {\n        return Data_Maybe.Nothing.value;\n    };\n    throw new Error(\"Failed pattern match at Data.Array.NonEmpty (line 159, column 1 - line 159, column 58): \" + [ xs.constructor.name ]);\n};\nvar fromFoldable = function (dictFoldable) {\n    var $69 = Data_Array.fromFoldable(dictFoldable);\n    return function ($70) {\n        return fromArray($69($70));\n    };\n};\nvar foldr1 = Data_Semigroup_Foldable.foldr1(Data_Array_NonEmpty_Internal.foldable1NonEmptyArray);\nvar foldl1 = Data_Semigroup_Foldable.foldl1(Data_Array_NonEmpty_Internal.foldable1NonEmptyArray);\nvar foldMap1 = function (dictSemigroup) {\n    return Data_Semigroup_Foldable.foldMap1(Data_Array_NonEmpty_Internal.foldable1NonEmptyArray)(dictSemigroup);\n};\nvar fold1 = function (dictSemigroup) {\n    return Data_Semigroup_Foldable.fold1(Data_Array_NonEmpty_Internal.foldable1NonEmptyArray)(dictSemigroup);\n};\nvar difference$prime = function (dictEq) {\n    return function (xs) {\n        return Data_Array.difference(dictEq)(toArray(xs));\n    };\n};\nvar cons$prime = function (x) {\n    return function (xs) {\n        return unsafeFromArray(Data_Array.cons(x)(xs));\n    };\n};\nvar fromNonEmpty = function (v) {\n    return cons$prime(v.value0)(v.value1);\n};\nvar concatMap = Data_Function.flip(Control_Bind.bind(Data_Array_NonEmpty_Internal.bindNonEmptyArray));\nvar concat = (function () {\n    var $71 = Data_Functor.map(Data_Array_NonEmpty_Internal.functorNonEmptyArray)(toArray);\n    return function ($72) {\n        return unsafeFromArray(Data_Array.concat(toArray($71($72))));\n    };\n})();\nvar appendArray = function (xs) {\n    return function (ys) {\n        return unsafeFromArray(Data_Semigroup.append(Data_Semigroup.semigroupArray)(toArray(xs))(ys));\n    };\n};\nvar alterAt = function (i) {\n    return function (f) {\n        var $73 = Data_Array.alterAt(i)(f);\n        return function ($74) {\n            return $73(toArray($74));\n        };\n    };\n};\nvar adaptMaybe = function (f) {\n    var $75 = Data_Maybe.fromJust();\n    return function ($76) {\n        return $75(f(toArray($76)));\n    };\n};\nvar head = adaptMaybe(Data_Array.head);\nvar init = adaptMaybe(Data_Array.init);\nvar last = adaptMaybe(Data_Array.last);\nvar tail = adaptMaybe(Data_Array.tail);\nvar uncons = adaptMaybe(Data_Array.uncons);\nvar toNonEmpty = function ($77) {\n    return (function (v) {\n        return new Data_NonEmpty.NonEmpty(v.head, v.tail);\n    })(uncons($77));\n};\nvar unsnoc = adaptMaybe(Data_Array.unsnoc);\nvar adaptAny = function (f) {\n    return function ($78) {\n        return f(toArray($78));\n    };\n};\nvar all = function (p) {\n    return adaptAny(Data_Array.all(p));\n};\nvar any = function (p) {\n    return adaptAny(Data_Array.any(p));\n};\nvar catMaybes = adaptAny(Data_Array.catMaybes);\nvar $$delete = function (dictEq) {\n    return function (x) {\n        return adaptAny(Data_Array[\"delete\"](dictEq)(x));\n    };\n};\nvar deleteAt = function (i) {\n    return adaptAny(Data_Array.deleteAt(i));\n};\nvar deleteBy = function (f) {\n    return function (x) {\n        return adaptAny(Data_Array.deleteBy(f)(x));\n    };\n};\nvar difference = function (dictEq) {\n    return function (xs) {\n        return adaptAny(difference$prime(dictEq)(xs));\n    };\n};\nvar drop = function (i) {\n    return adaptAny(Data_Array.drop(i));\n};\nvar dropEnd = function (i) {\n    return adaptAny(Data_Array.dropEnd(i));\n};\nvar dropWhile = function (f) {\n    return adaptAny(Data_Array.dropWhile(f));\n};\nvar elem = function (dictEq) {\n    return function (x) {\n        return adaptAny(Data_Array.elem(dictEq)(x));\n    };\n};\nvar elemIndex = function (dictEq) {\n    return function (x) {\n        return adaptAny(Data_Array.elemIndex(dictEq)(x));\n    };\n};\nvar elemLastIndex = function (dictEq) {\n    return function (x) {\n        return adaptAny(Data_Array.elemLastIndex(dictEq)(x));\n    };\n};\nvar filter = function (f) {\n    return adaptAny(Data_Array.filter(f));\n};\nvar filterA = function (dictApplicative) {\n    return function (f) {\n        return adaptAny(Data_Array.filterA(dictApplicative)(f));\n    };\n};\nvar find = function (p) {\n    return adaptAny(Data_Array.find(p));\n};\nvar findIndex = function (p) {\n    return adaptAny(Data_Array.findIndex(p));\n};\nvar findLastIndex = function (x) {\n    return adaptAny(Data_Array.findLastIndex(x));\n};\nvar findMap = function (p) {\n    return adaptAny(Data_Array.findMap(p));\n};\nvar foldM = function (dictMonad) {\n    return function (f) {\n        return function (acc) {\n            return adaptAny(Data_Array.foldM(dictMonad)(f)(acc));\n        };\n    };\n};\nvar foldRecM = function (dictMonadRec) {\n    return function (f) {\n        return function (acc) {\n            return adaptAny(Data_Array.foldRecM(dictMonadRec)(f)(acc));\n        };\n    };\n};\nvar index = adaptAny(Data_Array.index);\nvar length = adaptAny(Data_Array.length);\nvar mapMaybe = function (f) {\n    return adaptAny(Data_Array.mapMaybe(f));\n};\nvar notElem = function (dictEq) {\n    return function (x) {\n        return adaptAny(Data_Array.notElem(dictEq)(x));\n    };\n};\nvar partition = function (f) {\n    return adaptAny(Data_Array.partition(f));\n};\nvar slice = function (start) {\n    return function (end) {\n        return adaptAny(Data_Array.slice(start)(end));\n    };\n};\nvar span = function (f) {\n    return adaptAny(Data_Array.span(f));\n};\nvar take = function (i) {\n    return adaptAny(Data_Array.take(i));\n};\nvar takeEnd = function (i) {\n    return adaptAny(Data_Array.takeEnd(i));\n};\nvar takeWhile = function (f) {\n    return adaptAny(Data_Array.takeWhile(f));\n};\nvar toUnfoldable = function (dictUnfoldable) {\n    return adaptAny(Data_Array.toUnfoldable(dictUnfoldable));\n};\nvar unsafeAdapt = function (f) {\n    var $79 = adaptAny(f);\n    return function ($80) {\n        return unsafeFromArray($79($80));\n    };\n};\nvar cons = function (x) {\n    return unsafeAdapt(Data_Array.cons(x));\n};\nvar group = function (dictEq) {\n    return unsafeAdapt(Data_Array.group(dictEq));\n};\nvar group$prime = function (dictWarn) {\n    return function (dictOrd) {\n        return unsafeAdapt(Data_Array.groupAll(dictOrd));\n    };\n};\nvar groupAllBy = function (op) {\n    return unsafeAdapt(Data_Array.groupAllBy(op));\n};\nvar groupAll = function (dictOrd) {\n    return groupAllBy(Data_Ord.compare(dictOrd));\n};\nvar groupBy = function (op) {\n    return unsafeAdapt(Data_Array.groupBy(op));\n};\nvar insert = function (dictOrd) {\n    return function (x) {\n        return unsafeAdapt(Data_Array.insert(dictOrd)(x));\n    };\n};\nvar insertBy = function (f) {\n    return function (x) {\n        return unsafeAdapt(Data_Array.insertBy(f)(x));\n    };\n};\nvar intersperse = function (x) {\n    return unsafeAdapt(Data_Array.intersperse(x));\n};\nvar mapWithIndex = function (f) {\n    return unsafeAdapt(Data_Array.mapWithIndex(f));\n};\nvar modifyAtIndices = function (dictFoldable) {\n    return function (is) {\n        return function (f) {\n            return unsafeAdapt(Data_Array.modifyAtIndices(dictFoldable)(is)(f));\n        };\n    };\n};\nvar nub = function (dictOrd) {\n    return unsafeAdapt(Data_Array.nub(dictOrd));\n};\nvar nubBy = function (f) {\n    return unsafeAdapt(Data_Array.nubBy(f));\n};\nvar nubByEq = function (f) {\n    return unsafeAdapt(Data_Array.nubByEq(f));\n};\nvar nubEq = function (dictEq) {\n    return unsafeAdapt(Data_Array.nubEq(dictEq));\n};\nvar reverse = unsafeAdapt(Data_Array.reverse);\nvar scanl = function (f) {\n    return function (x) {\n        return unsafeAdapt(Data_Array.scanl(f)(x));\n    };\n};\nvar scanr = function (f) {\n    return function (x) {\n        return unsafeAdapt(Data_Array.scanr(f)(x));\n    };\n};\nvar sort = function (dictOrd) {\n    return unsafeAdapt(Data_Array.sort(dictOrd));\n};\nvar sortBy = function (f) {\n    return unsafeAdapt(Data_Array.sortBy(f));\n};\nvar sortWith = function (dictOrd) {\n    return function (f) {\n        return unsafeAdapt(Data_Array.sortWith(dictOrd)(f));\n    };\n};\nvar updateAtIndices = function (dictFoldable) {\n    return function (pairs) {\n        return unsafeAdapt(Data_Array.updateAtIndices(dictFoldable)(pairs));\n    };\n};\nvar unsafeIndex = function (dictPartial) {\n    return adaptAny(Data_Array.unsafeIndex());\n};\nvar toUnfoldable1 = function (dictUnfoldable1) {\n    return function (xs) {\n        var len = length(xs);\n        var f = function (i) {\n            return Data_Tuple.Tuple.create(unsafeIndex()(xs)(i))((function () {\n                var $49 = i < (len - 1 | 0);\n                if ($49) {\n                    return new Data_Maybe.Just(i + 1 | 0);\n                };\n                return Data_Maybe.Nothing.value;\n            })());\n        };\n        return Data_Unfoldable1.unfoldr1(dictUnfoldable1)(f)(0);\n    };\n};\nmodule.exports = {\n    fromArray: fromArray,\n    fromNonEmpty: fromNonEmpty,\n    toArray: toArray,\n    toNonEmpty: toNonEmpty,\n    fromFoldable: fromFoldable,\n    fromFoldable1: fromFoldable1,\n    toUnfoldable: toUnfoldable,\n    toUnfoldable1: toUnfoldable1,\n    singleton: singleton,\n    range: range,\n    replicate: replicate,\n    some: some,\n    length: length,\n    cons: cons,\n    \"cons'\": cons$prime,\n    snoc: snoc,\n    \"snoc'\": snoc$prime,\n    appendArray: appendArray,\n    insert: insert,\n    insertBy: insertBy,\n    head: head,\n    last: last,\n    tail: tail,\n    init: init,\n    uncons: uncons,\n    unsnoc: unsnoc,\n    index: index,\n    elem: elem,\n    notElem: notElem,\n    elemIndex: elemIndex,\n    elemLastIndex: elemLastIndex,\n    find: find,\n    findMap: findMap,\n    findIndex: findIndex,\n    findLastIndex: findLastIndex,\n    insertAt: insertAt,\n    deleteAt: deleteAt,\n    updateAt: updateAt,\n    updateAtIndices: updateAtIndices,\n    modifyAt: modifyAt,\n    modifyAtIndices: modifyAtIndices,\n    alterAt: alterAt,\n    intersperse: intersperse,\n    reverse: reverse,\n    concat: concat,\n    concatMap: concatMap,\n    filter: filter,\n    partition: partition,\n    splitAt: splitAt,\n    filterA: filterA,\n    mapMaybe: mapMaybe,\n    catMaybes: catMaybes,\n    mapWithIndex: mapWithIndex,\n    foldl1: foldl1,\n    foldr1: foldr1,\n    foldMap1: foldMap1,\n    fold1: fold1,\n    intercalate: intercalate,\n    scanl: scanl,\n    scanr: scanr,\n    sort: sort,\n    sortBy: sortBy,\n    sortWith: sortWith,\n    slice: slice,\n    take: take,\n    takeEnd: takeEnd,\n    takeWhile: takeWhile,\n    drop: drop,\n    dropEnd: dropEnd,\n    dropWhile: dropWhile,\n    span: span,\n    group: group,\n    groupAll: groupAll,\n    \"group'\": group$prime,\n    groupBy: groupBy,\n    groupAllBy: groupAllBy,\n    nub: nub,\n    nubBy: nubBy,\n    nubEq: nubEq,\n    nubByEq: nubByEq,\n    union: union,\n    \"union'\": union$prime,\n    unionBy: unionBy,\n    \"unionBy'\": unionBy$prime,\n    \"delete\": $$delete,\n    deleteBy: deleteBy,\n    difference: difference,\n    \"difference'\": difference$prime,\n    intersect: intersect,\n    \"intersect'\": intersect$prime,\n    intersectBy: intersectBy,\n    \"intersectBy'\": intersectBy$prime,\n    zipWith: zipWith,\n    zipWithA: zipWithA,\n    zip: zip,\n    unzip: unzip,\n    any: any,\n    all: all,\n    foldM: foldM,\n    foldRecM: foldRecM,\n    unsafeIndex: unsafeIndex\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty.purs?");

/***/ }),

/***/ "./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty/Internal.purs":
/*!********************************************************************!*\
  !*** ./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty/Internal.purs ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty/Internal.js */ \"./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty/Internal.js\");\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_FoldableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_FunctorWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Semigroup_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs\");\nvar Data_Semigroup_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_TraversableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs\");\nvar Data_Unfoldable1 = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs\");\nvar NonEmptyArray = function (x) {\n    return x;\n};\nvar unfoldable1NonEmptyArray = Data_Unfoldable1.unfoldable1Array;\nvar traversableWithIndexNonEmptyArray = Data_TraversableWithIndex.traversableWithIndexArray;\nvar traversableNonEmptyArray = Data_Traversable.traversableArray;\nvar showNonEmptyArray = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(NonEmptyArray \" + (Data_Show.show(Data_Show.showArray(dictShow))(v) + \")\");\n        }\n    };\n};\nvar semigroupNonEmptyArray = Data_Semigroup.semigroupArray;\nvar ordNonEmptyArray = function (dictOrd) {\n    return Data_Ord.ordArray(dictOrd);\n};\nvar ord1NonEmptyArray = Data_Ord.ord1Array;\nvar monadNonEmptyArray = Control_Monad.monadArray;\nvar functorWithIndexNonEmptyArray = Data_FunctorWithIndex.functorWithIndexArray;\nvar functorNonEmptyArray = Data_Functor.functorArray;\nvar foldableWithIndexNonEmptyArray = Data_FoldableWithIndex.foldableWithIndexArray;\nvar foldableNonEmptyArray = Data_Foldable.foldableArray;\nvar foldable1NonEmptyArray = {\n    foldMap1: function (dictSemigroup) {\n        return Data_Semigroup_Foldable.foldMap1DefaultL(foldable1NonEmptyArray)(functorNonEmptyArray)(dictSemigroup);\n    },\n    foldr1: $foreign.foldr1Impl,\n    foldl1: $foreign.foldl1Impl,\n    Foldable0: function () {\n        return foldableNonEmptyArray;\n    }\n};\nvar traversable1NonEmptyArray = {\n    traverse1: function (dictApply) {\n        return $foreign.traverse1Impl(Control_Apply.apply(dictApply))(Data_Functor.map(dictApply.Functor0()));\n    },\n    sequence1: function (dictApply) {\n        return Data_Semigroup_Traversable.sequence1Default(traversable1NonEmptyArray)(dictApply);\n    },\n    Foldable10: function () {\n        return foldable1NonEmptyArray;\n    },\n    Traversable1: function () {\n        return traversableNonEmptyArray;\n    }\n};\nvar eqNonEmptyArray = function (dictEq) {\n    return Data_Eq.eqArray(dictEq);\n};\nvar eq1NonEmptyArray = Data_Eq.eq1Array;\nvar bindNonEmptyArray = Control_Bind.bindArray;\nvar applyNonEmptyArray = Control_Apply.applyArray;\nvar applicativeNonEmptyArray = Control_Applicative.applicativeArray;\nvar altNonEmptyArray = Control_Alt.altArray;\nmodule.exports = {\n    NonEmptyArray: NonEmptyArray,\n    showNonEmptyArray: showNonEmptyArray,\n    eqNonEmptyArray: eqNonEmptyArray,\n    eq1NonEmptyArray: eq1NonEmptyArray,\n    ordNonEmptyArray: ordNonEmptyArray,\n    ord1NonEmptyArray: ord1NonEmptyArray,\n    semigroupNonEmptyArray: semigroupNonEmptyArray,\n    functorNonEmptyArray: functorNonEmptyArray,\n    functorWithIndexNonEmptyArray: functorWithIndexNonEmptyArray,\n    foldableNonEmptyArray: foldableNonEmptyArray,\n    foldableWithIndexNonEmptyArray: foldableWithIndexNonEmptyArray,\n    foldable1NonEmptyArray: foldable1NonEmptyArray,\n    unfoldable1NonEmptyArray: unfoldable1NonEmptyArray,\n    traversableNonEmptyArray: traversableNonEmptyArray,\n    traversableWithIndexNonEmptyArray: traversableWithIndexNonEmptyArray,\n    traversable1NonEmptyArray: traversable1NonEmptyArray,\n    applyNonEmptyArray: applyNonEmptyArray,\n    applicativeNonEmptyArray: applicativeNonEmptyArray,\n    bindNonEmptyArray: bindNonEmptyArray,\n    monadNonEmptyArray: monadNonEmptyArray,\n    altNonEmptyArray: altNonEmptyArray\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty/Internal.purs?");

/***/ }),

/***/ "./.spago/arrays/v6.0.1/src/Data/Array/ST.purs":
/*!*****************************************************!*\
  !*** ./.spago/arrays/v6.0.1/src/Data/Array/ST.purs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array/ST.js */ \"./.spago/arrays/v6.0.1/src/Data/Array/ST.js\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_ST_Internal = __webpack_require__(/*! ./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs */ \"./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar withArray = function (f) {\n    return function (xs) {\n        return function __do() {\n            var result = $foreign.thaw(xs)();\n            f(result)();\n            return $foreign.unsafeFreeze(result)();\n        };\n    };\n};\nvar unshift = function (a) {\n    return $foreign.unshiftAll([ a ]);\n};\nvar sortBy = function (comp) {\n    return $foreign.sortByImpl(comp)(function (v) {\n        if (v instanceof Data_Ordering.GT) {\n            return 1;\n        };\n        if (v instanceof Data_Ordering.EQ) {\n            return 0;\n        };\n        if (v instanceof Data_Ordering.LT) {\n            return -1 | 0;\n        };\n        throw new Error(\"Failed pattern match at Data.Array.ST (line 113, column 31 - line 116, column 11): \" + [ v.constructor.name ]);\n    });\n};\nvar sortWith = function (dictOrd) {\n    return function (f) {\n        return sortBy(Data_Ord.comparing(dictOrd)(f));\n    };\n};\nvar sort = function (dictOrd) {\n    return sortBy(Data_Ord.compare(dictOrd));\n};\nvar shift = $foreign.shiftImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar run = function (st) {\n    return Control_Bind.bind(Control_Monad_ST_Internal.bindST)(st)($foreign.unsafeFreeze)();\n};\nvar push = function (a) {\n    return $foreign.pushAll([ a ]);\n};\nvar pop = $foreign.popImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar peek = $foreign.peekImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar modify = function (i) {\n    return function (f) {\n        return function (xs) {\n            return function __do() {\n                var entry = peek(i)(xs)();\n                if (entry instanceof Data_Maybe.Just) {\n                    return $foreign.poke(i)(f(entry.value0))(xs)();\n                };\n                if (entry instanceof Data_Maybe.Nothing) {\n                    return false;\n                };\n                throw new Error(\"Failed pattern match at Data.Array.ST (line 198, column 3 - line 200, column 26): \" + [ entry.constructor.name ]);\n            };\n        };\n    };\n};\nvar empty = function (dictWarn) {\n    return $foreign[\"new\"];\n};\nmodule.exports = {\n    run: run,\n    withArray: withArray,\n    empty: empty,\n    peek: peek,\n    modify: modify,\n    pop: pop,\n    push: push,\n    shift: shift,\n    unshift: unshift,\n    sort: sort,\n    sortBy: sortBy,\n    sortWith: sortWith,\n    \"new\": $foreign[\"new\"],\n    poke: $foreign.poke,\n    pushAll: $foreign.pushAll,\n    unshiftAll: $foreign.unshiftAll,\n    splice: $foreign.splice,\n    freeze: $foreign.freeze,\n    thaw: $foreign.thaw,\n    unsafeFreeze: $foreign.unsafeFreeze,\n    unsafeThaw: $foreign.unsafeThaw,\n    toAssocArray: $foreign.toAssocArray\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/arrays/v6.0.1/src/Data/Array/ST.purs?");

/***/ }),

/***/ "./.spago/arrays/v6.0.1/src/Data/Array/ST/Iterator.purs":
/*!**************************************************************!*\
  !*** ./.spago/arrays/v6.0.1/src/Data/Array/ST/Iterator.purs ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Monad_ST_Internal = __webpack_require__(/*! ./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs */ \"./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs\");\nvar Data_Array_ST = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array/ST.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array/ST.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Iterator = (function () {\n    function Iterator(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    Iterator.create = function (value0) {\n        return function (value1) {\n            return new Iterator(value0, value1);\n        };\n    };\n    return Iterator;\n})();\nvar peek = function (v) {\n    return function __do() {\n        var i = Control_Monad_ST_Internal.read(v.value1)();\n        return v.value0(i);\n    };\n};\nvar next = function (v) {\n    return function __do() {\n        var i = Control_Monad_ST_Internal.read(v.value1)();\n        Control_Monad_ST_Internal.modify(function (v1) {\n            return v1 + 1 | 0;\n        })(v.value1)();\n        return v.value0(i);\n    };\n};\nvar pushWhile = function (p) {\n    return function (iter) {\n        return function (array) {\n            return function __do() {\n                var $$break = Control_Monad_ST_Internal[\"new\"](false)();\n                while (Data_Functor.map(Control_Monad_ST_Internal.functorST)(Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean))(Control_Monad_ST_Internal.read($$break))()) {\n                    (function __do() {\n                        var mx = peek(iter)();\n                        if (mx instanceof Data_Maybe.Just && p(mx.value0)) {\n                            Data_Array_ST.push(mx.value0)(array)();\n                            return Data_Functor[\"void\"](Control_Monad_ST_Internal.functorST)(next(iter))();\n                        };\n                        return Data_Functor[\"void\"](Control_Monad_ST_Internal.functorST)(Control_Monad_ST_Internal.write(true)($$break))();\n                    })();\n                };\n                return {};\n            };\n        };\n    };\n};\nvar pushAll = pushWhile(Data_Function[\"const\"](true));\nvar iterator = function (f) {\n    return Data_Functor.map(Control_Monad_ST_Internal.functorST)(Iterator.create(f))(Control_Monad_ST_Internal[\"new\"](0));\n};\nvar iterate = function (iter) {\n    return function (f) {\n        return function __do() {\n            var $$break = Control_Monad_ST_Internal[\"new\"](false)();\n            while (Data_Functor.map(Control_Monad_ST_Internal.functorST)(Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean))(Control_Monad_ST_Internal.read($$break))()) {\n                (function __do() {\n                    var mx = next(iter)();\n                    if (mx instanceof Data_Maybe.Just) {\n                        return f(mx.value0)();\n                    };\n                    if (mx instanceof Data_Maybe.Nothing) {\n                        return Data_Functor[\"void\"](Control_Monad_ST_Internal.functorST)(Control_Monad_ST_Internal.write(true)($$break))();\n                    };\n                    throw new Error(\"Failed pattern match at Data.Array.ST.Iterator (line 42, column 5 - line 44, column 47): \" + [ mx.constructor.name ]);\n                })();\n            };\n            return {};\n        };\n    };\n};\nvar exhausted = (function () {\n    var $13 = Data_Functor.map(Control_Monad_ST_Internal.functorST)(Data_Maybe.isNothing);\n    return function ($14) {\n        return $13(peek($14));\n    };\n})();\nmodule.exports = {\n    iterator: iterator,\n    iterate: iterate,\n    next: next,\n    peek: peek,\n    exhausted: exhausted,\n    pushWhile: pushWhile,\n    pushAll: pushAll\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/arrays/v6.0.1/src/Data/Array/ST/Iterator.purs?");

/***/ }),

/***/ "./.spago/bifunctors/v5.0.0/src/Control/Biapplicative.purs":
/*!*****************************************************************!*\
  !*** ./.spago/bifunctors/v5.0.0/src/Control/Biapplicative.purs ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Biapply = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Control/Biapply.purs */ \"./.spago/bifunctors/v5.0.0/src/Control/Biapply.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar bipure = function (dict) {\n    return dict.bipure;\n};\nvar biapplicativeTuple = {\n    bipure: Data_Tuple.Tuple.create,\n    Biapply0: function () {\n        return Control_Biapply.biapplyTuple;\n    }\n};\nmodule.exports = {\n    bipure: bipure,\n    biapplicativeTuple: biapplicativeTuple\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/bifunctors/v5.0.0/src/Control/Biapplicative.purs?");

/***/ }),

/***/ "./.spago/bifunctors/v5.0.0/src/Control/Biapply.purs":
/*!***********************************************************!*\
  !*** ./.spago/bifunctors/v5.0.0/src/Control/Biapply.purs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar biapplyTuple = {\n    biapply: function (v) {\n        return function (v1) {\n            return new Data_Tuple.Tuple(v.value0(v1.value0), v.value1(v1.value1));\n        };\n    },\n    Bifunctor0: function () {\n        return Data_Bifunctor.bifunctorTuple;\n    }\n};\nvar biapply = function (dict) {\n    return dict.biapply;\n};\nvar biapplyFirst = function (dictBiapply) {\n    return function (a) {\n        return function (b) {\n            return biapply(dictBiapply)(Control_Category.identity(Control_Category.categoryFn)(Data_Bifunctor.bimap(dictBiapply.Bifunctor0())(Data_Function[\"const\"](Control_Category.identity(Control_Category.categoryFn)))(Data_Function[\"const\"](Control_Category.identity(Control_Category.categoryFn))))(a))(b);\n        };\n    };\n};\nvar biapplySecond = function (dictBiapply) {\n    return function (a) {\n        return function (b) {\n            return biapply(dictBiapply)(Control_Category.identity(Control_Category.categoryFn)(Data_Bifunctor.bimap(dictBiapply.Bifunctor0())(Data_Function[\"const\"])(Data_Function[\"const\"]))(a))(b);\n        };\n    };\n};\nvar bilift2 = function (dictBiapply) {\n    return function (f) {\n        return function (g) {\n            return function (a) {\n                return function (b) {\n                    return biapply(dictBiapply)(Control_Category.identity(Control_Category.categoryFn)(Data_Bifunctor.bimap(dictBiapply.Bifunctor0())(f)(g))(a))(b);\n                };\n            };\n        };\n    };\n};\nvar bilift3 = function (dictBiapply) {\n    return function (f) {\n        return function (g) {\n            return function (a) {\n                return function (b) {\n                    return function (c) {\n                        return biapply(dictBiapply)(biapply(dictBiapply)(Control_Category.identity(Control_Category.categoryFn)(Data_Bifunctor.bimap(dictBiapply.Bifunctor0())(f)(g))(a))(b))(c);\n                    };\n                };\n            };\n        };\n    };\n};\nmodule.exports = {\n    biapply: biapply,\n    biapplyFirst: biapplyFirst,\n    biapplySecond: biapplySecond,\n    bilift2: bilift2,\n    bilift3: bilift3,\n    biapplyTuple: biapplyTuple\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/bifunctors/v5.0.0/src/Control/Biapply.purs?");

/***/ }),

/***/ "./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs":
/*!**********************************************************!*\
  !*** ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar bimap = function (dict) {\n    return dict.bimap;\n};\nvar lmap = function (dictBifunctor) {\n    return function (f) {\n        return bimap(dictBifunctor)(f)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar rmap = function (dictBifunctor) {\n    return bimap(dictBifunctor)(Control_Category.identity(Control_Category.categoryFn));\n};\nvar bifunctorTuple = {\n    bimap: function (f) {\n        return function (g) {\n            return function (v) {\n                return new Data_Tuple.Tuple(f(v.value0), g(v.value1));\n            };\n        };\n    }\n};\nvar bifunctorEither = {\n    bimap: function (v) {\n        return function (v1) {\n            return function (v2) {\n                if (v2 instanceof Data_Either.Left) {\n                    return new Data_Either.Left(v(v2.value0));\n                };\n                if (v2 instanceof Data_Either.Right) {\n                    return new Data_Either.Right(v1(v2.value0));\n                };\n                throw new Error(\"Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): \" + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);\n            };\n        };\n    }\n};\nvar bifunctorConst = {\n    bimap: function (f) {\n        return function (v) {\n            return function (v1) {\n                return f(v1);\n            };\n        };\n    }\n};\nmodule.exports = {\n    bimap: bimap,\n    lmap: lmap,\n    rmap: rmap,\n    bifunctorEither: bifunctorEither,\n    bifunctorTuple: bifunctorTuple,\n    bifunctorConst: bifunctorConst\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs?");

/***/ }),

/***/ "./.spago/catenable-lists/v6.0.1/src/Data/CatList.purs":
/*!*************************************************************!*\
  !*** ./.spago/catenable-lists/v6.0.1/src/Data/CatList.purs ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Data_CatQueue = __webpack_require__(/*! ./.spago/catenable-lists/v6.0.1/src/Data/CatQueue.purs */ \"./.spago/catenable-lists/v6.0.1/src/Data/CatQueue.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar CatNil = (function () {\n    function CatNil() {\n\n    };\n    CatNil.value = new CatNil();\n    return CatNil;\n})();\nvar CatCons = (function () {\n    function CatCons(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    CatCons.create = function (value0) {\n        return function (value1) {\n            return new CatCons(value0, value1);\n        };\n    };\n    return CatCons;\n})();\nvar showCatList = function (dictShow) {\n    return {\n        show: function (v) {\n            if (v instanceof CatNil) {\n                return \"CatNil\";\n            };\n            if (v instanceof CatCons) {\n                return \"(CatList \" + (Data_Show.show(dictShow)(v.value0) + (\" \" + (Data_Show.show(Data_CatQueue.showCatQueue(showCatList(dictShow)))(v.value1) + \")\")));\n            };\n            throw new Error(\"Failed pattern match at Data.CatList (line 148, column 1 - line 150, column 71): \" + [ v.constructor.name ]);\n        }\n    };\n};\nvar $$null = function (v) {\n    if (v instanceof CatNil) {\n        return true;\n    };\n    return false;\n};\nvar link = function (v) {\n    return function (v1) {\n        if (v instanceof CatNil) {\n            return v1;\n        };\n        if (v1 instanceof CatNil) {\n            return v;\n        };\n        if (v instanceof CatCons) {\n            return new CatCons(v.value0, Data_CatQueue.snoc(v.value1)(v1));\n        };\n        throw new Error(\"Failed pattern match at Data.CatList (line 109, column 1 - line 109, column 54): \" + [ v.constructor.name, v1.constructor.name ]);\n    };\n};\nvar foldr = function (k) {\n    return function (b) {\n        return function (q) {\n            var foldl = function ($copy_v) {\n                return function ($copy_c) {\n                    return function ($copy_v1) {\n                        var $tco_var_v = $copy_v;\n                        var $tco_var_c = $copy_c;\n                        var $tco_done = false;\n                        var $tco_result;\n                        function $tco_loop(v, c, v1) {\n                            if (v1 instanceof Data_List_Types.Nil) {\n                                $tco_done = true;\n                                return c;\n                            };\n                            if (v1 instanceof Data_List_Types.Cons) {\n                                $tco_var_v = v;\n                                $tco_var_c = v(c)(v1.value0);\n                                $copy_v1 = v1.value1;\n                                return;\n                            };\n                            throw new Error(\"Failed pattern match at Data.CatList (line 125, column 3 - line 125, column 59): \" + [ v.constructor.name, c.constructor.name, v1.constructor.name ]);\n                        };\n                        while (!$tco_done) {\n                            $tco_result = $tco_loop($tco_var_v, $tco_var_c, $copy_v1);\n                        };\n                        return $tco_result;\n                    };\n                };\n            };\n            var go = function ($copy_xs) {\n                return function ($copy_ys) {\n                    var $tco_var_xs = $copy_xs;\n                    var $tco_done1 = false;\n                    var $tco_result;\n                    function $tco_loop(xs, ys) {\n                        var v = Data_CatQueue.uncons(xs);\n                        if (v instanceof Data_Maybe.Nothing) {\n                            $tco_done1 = true;\n                            return foldl(function (x) {\n                                return function (i) {\n                                    return i(x);\n                                };\n                            })(b)(ys);\n                        };\n                        if (v instanceof Data_Maybe.Just) {\n                            $tco_var_xs = v.value0.value1;\n                            $copy_ys = new Data_List_Types.Cons(k(v.value0.value0), ys);\n                            return;\n                        };\n                        throw new Error(\"Failed pattern match at Data.CatList (line 121, column 14 - line 123, column 67): \" + [ v.constructor.name ]);\n                    };\n                    while (!$tco_done1) {\n                        $tco_result = $tco_loop($tco_var_xs, $copy_ys);\n                    };\n                    return $tco_result;\n                };\n            };\n            return go(q)(Data_List_Types.Nil.value);\n        };\n    };\n};\nvar uncons = function (v) {\n    if (v instanceof CatNil) {\n        return Data_Maybe.Nothing.value;\n    };\n    if (v instanceof CatCons) {\n        return new Data_Maybe.Just(new Data_Tuple.Tuple(v.value0, (function () {\n            var $45 = Data_CatQueue[\"null\"](v.value1);\n            if ($45) {\n                return CatNil.value;\n            };\n            return foldr(link)(CatNil.value)(v.value1);\n        })()));\n    };\n    throw new Error(\"Failed pattern match at Data.CatList (line 100, column 1 - line 100, column 61): \" + [ v.constructor.name ]);\n};\nvar foldableCatList = {\n    foldMap: function (dictMonoid) {\n        return Data_Foldable.foldMapDefaultL(foldableCatList)(dictMonoid);\n    },\n    foldr: function (f) {\n        return function (s) {\n            return function (l) {\n                return Data_Foldable.foldrDefault(foldableCatList)(f)(s)(l);\n            };\n        };\n    },\n    foldl: function (f) {\n        var go = function ($copy_acc) {\n            return function ($copy_q) {\n                var $tco_var_acc = $copy_acc;\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(acc, q) {\n                    var v = uncons(q);\n                    if (v instanceof Data_Maybe.Just) {\n                        $tco_var_acc = f(acc)(v.value0.value0);\n                        $copy_q = v.value0.value1;\n                        return;\n                    };\n                    if (v instanceof Data_Maybe.Nothing) {\n                        $tco_done = true;\n                        return acc;\n                    };\n                    throw new Error(\"Failed pattern match at Data.CatList (line 157, column 16 - line 159, column 22): \" + [ v.constructor.name ]);\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($tco_var_acc, $copy_q);\n                };\n                return $tco_result;\n            };\n        };\n        return go;\n    }\n};\nvar length = Data_Foldable.length(foldableCatList)(Data_Semiring.semiringInt);\nvar foldMap = function (dictMonoid) {\n    return function (v) {\n        return function (v1) {\n            if (v1 instanceof CatNil) {\n                return Data_Monoid.mempty(dictMonoid);\n            };\n            if (v1 instanceof CatCons) {\n                var d = (function () {\n                    var $54 = Data_CatQueue[\"null\"](v1.value1);\n                    if ($54) {\n                        return CatNil.value;\n                    };\n                    return foldr(link)(CatNil.value)(v1.value1);\n                })();\n                return Data_Semigroup.append(dictMonoid.Semigroup0())(v(v1.value0))(foldMap(dictMonoid)(v)(d));\n            };\n            throw new Error(\"Failed pattern match at Data.CatList (line 135, column 1 - line 135, column 62): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    };\n};\nvar empty = CatNil.value;\nvar append = link;\nvar cons = function (a) {\n    return function (cat) {\n        return append(new CatCons(a, Data_CatQueue.empty))(cat);\n    };\n};\nvar functorCatList = {\n    map: function (v) {\n        return function (v1) {\n            if (v1 instanceof CatNil) {\n                return CatNil.value;\n            };\n            if (v1 instanceof CatCons) {\n                var d = (function () {\n                    var $59 = Data_CatQueue[\"null\"](v1.value1);\n                    if ($59) {\n                        return CatNil.value;\n                    };\n                    return foldr(link)(CatNil.value)(v1.value1);\n                })();\n                return cons(v(v1.value0))(Data_Functor.map(functorCatList)(v)(d));\n            };\n            throw new Error(\"Failed pattern match at Data.CatList (line 185, column 1 - line 189, column 26): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    }\n};\nvar singleton = function (a) {\n    return cons(a)(CatNil.value);\n};\nvar traversableCatList = {\n    traverse: function (dictApplicative) {\n        return function (v) {\n            return function (v1) {\n                if (v1 instanceof CatNil) {\n                    return Control_Applicative.pure(dictApplicative)(CatNil.value);\n                };\n                if (v1 instanceof CatCons) {\n                    var d = (function () {\n                        var $64 = Data_CatQueue[\"null\"](v1.value1);\n                        if ($64) {\n                            return CatNil.value;\n                        };\n                        return foldr(link)(CatNil.value)(v1.value1);\n                    })();\n                    return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(cons)(v(v1.value0)))(Data_Traversable.traverse(traversableCatList)(dictApplicative)(v)(d));\n                };\n                throw new Error(\"Failed pattern match at Data.CatList (line 175, column 1 - line 183, column 33): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            if (v instanceof CatNil) {\n                return Control_Applicative.pure(dictApplicative)(CatNil.value);\n            };\n            if (v instanceof CatCons) {\n                var d = (function () {\n                    var $68 = Data_CatQueue[\"null\"](v.value1);\n                    if ($68) {\n                        return CatNil.value;\n                    };\n                    return foldr(link)(CatNil.value)(v.value1);\n                })();\n                return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(cons)(v.value0))(Data_Traversable.sequence(traversableCatList)(dictApplicative)(d));\n            };\n            throw new Error(\"Failed pattern match at Data.CatList (line 175, column 1 - line 183, column 33): \" + [ v.constructor.name ]);\n        };\n    },\n    Functor0: function () {\n        return functorCatList;\n    },\n    Foldable1: function () {\n        return foldableCatList;\n    }\n};\nvar semigroupCatList = {\n    append: append\n};\nvar monoidCatList = {\n    mempty: CatNil.value,\n    Semigroup0: function () {\n        return semigroupCatList;\n    }\n};\nvar monadCatList = {\n    Applicative0: function () {\n        return applicativeCatList;\n    },\n    Bind1: function () {\n        return bindCatList;\n    }\n};\nvar bindCatList = {\n    bind: Data_Function.flip(foldMap(monoidCatList)),\n    Apply0: function () {\n        return applyCatList;\n    }\n};\nvar applyCatList = {\n    apply: Control_Monad.ap(monadCatList),\n    Functor0: function () {\n        return functorCatList;\n    }\n};\nvar applicativeCatList = {\n    pure: singleton,\n    Apply0: function () {\n        return applyCatList;\n    }\n};\nvar fromFoldable = function (dictFoldable) {\n    return function (f) {\n        return Data_Foldable.foldMap(dictFoldable)(monoidCatList)(singleton)(f);\n    };\n};\nvar snoc = function (cat) {\n    return function (a) {\n        return append(cat)(new CatCons(a, Data_CatQueue.empty));\n    };\n};\nvar unfoldable1CatList = {\n    unfoldr1: function (f) {\n        return function (b) {\n            var go = function ($copy_source) {\n                return function ($copy_memo) {\n                    var $tco_var_source = $copy_source;\n                    var $tco_done = false;\n                    var $tco_result;\n                    function $tco_loop(source, memo) {\n                        var v = f(source);\n                        if (v.value1 instanceof Data_Maybe.Nothing) {\n                            $tco_done = true;\n                            return snoc(memo)(v.value0);\n                        };\n                        if (v.value1 instanceof Data_Maybe.Just) {\n                            $tco_var_source = v.value1.value0;\n                            $copy_memo = snoc(memo)(v.value0);\n                            return;\n                        };\n                        throw new Error(\"Failed pattern match at Data.CatList (line 171, column 24 - line 173, column 57): \" + [ v.constructor.name ]);\n                    };\n                    while (!$tco_done) {\n                        $tco_result = $tco_loop($tco_var_source, $copy_memo);\n                    };\n                    return $tco_result;\n                };\n            };\n            return go(b)(CatNil.value);\n        };\n    }\n};\nvar unfoldableCatList = {\n    unfoldr: function (f) {\n        return function (b) {\n            var go = function ($copy_source) {\n                return function ($copy_memo) {\n                    var $tco_var_source = $copy_source;\n                    var $tco_done = false;\n                    var $tco_result;\n                    function $tco_loop(source, memo) {\n                        var v = f(source);\n                        if (v instanceof Data_Maybe.Nothing) {\n                            $tco_done = true;\n                            return memo;\n                        };\n                        if (v instanceof Data_Maybe.Just) {\n                            $tco_var_source = v.value0.value1;\n                            $copy_memo = snoc(memo)(v.value0.value0);\n                            return;\n                        };\n                        throw new Error(\"Failed pattern match at Data.CatList (line 164, column 24 - line 166, column 57): \" + [ v.constructor.name ]);\n                    };\n                    while (!$tco_done) {\n                        $tco_result = $tco_loop($tco_var_source, $copy_memo);\n                    };\n                    return $tco_result;\n                };\n            };\n            return go(b)(CatNil.value);\n        };\n    },\n    Unfoldable10: function () {\n        return unfoldable1CatList;\n    }\n};\nvar altCatList = {\n    alt: append,\n    Functor0: function () {\n        return functorCatList;\n    }\n};\nvar plusCatList = {\n    empty: empty,\n    Alt0: function () {\n        return altCatList;\n    }\n};\nvar alternativeCatList = {\n    Applicative0: function () {\n        return applicativeCatList;\n    },\n    Plus1: function () {\n        return plusCatList;\n    }\n};\nvar monadPlusCatList = {\n    Monad0: function () {\n        return monadCatList;\n    },\n    Alternative1: function () {\n        return alternativeCatList;\n    }\n};\nvar monadZeroCatList = {\n    Monad0: function () {\n        return monadCatList;\n    },\n    Alternative1: function () {\n        return alternativeCatList;\n    },\n    MonadZeroIsDeprecated2: function () {\n        return undefined;\n    }\n};\nmodule.exports = {\n    CatNil: CatNil,\n    CatCons: CatCons,\n    empty: empty,\n    \"null\": $$null,\n    singleton: singleton,\n    length: length,\n    append: append,\n    cons: cons,\n    snoc: snoc,\n    uncons: uncons,\n    fromFoldable: fromFoldable,\n    semigroupCatList: semigroupCatList,\n    monoidCatList: monoidCatList,\n    showCatList: showCatList,\n    foldableCatList: foldableCatList,\n    unfoldableCatList: unfoldableCatList,\n    unfoldable1CatList: unfoldable1CatList,\n    traversableCatList: traversableCatList,\n    functorCatList: functorCatList,\n    applyCatList: applyCatList,\n    applicativeCatList: applicativeCatList,\n    bindCatList: bindCatList,\n    monadCatList: monadCatList,\n    altCatList: altCatList,\n    plusCatList: plusCatList,\n    alternativeCatList: alternativeCatList,\n    monadZeroCatList: monadZeroCatList,\n    monadPlusCatList: monadPlusCatList\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/catenable-lists/v6.0.1/src/Data/CatList.purs?");

/***/ }),

/***/ "./.spago/catenable-lists/v6.0.1/src/Data/CatQueue.purs":
/*!**************************************************************!*\
  !*** ./.spago/catenable-lists/v6.0.1/src/Data/CatQueue.purs ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_List = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List.purs */ \"./.spago/lists/v6.0.1/src/Data/List.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar CatQueue = (function () {\n    function CatQueue(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    CatQueue.create = function (value0) {\n        return function (value1) {\n            return new CatQueue(value0, value1);\n        };\n    };\n    return CatQueue;\n})();\nvar unsnoc = function ($copy_v) {\n    var $tco_done = false;\n    var $tco_result;\n    function $tco_loop(v) {\n        if (v.value1 instanceof Data_List_Types.Cons) {\n            $tco_done = true;\n            return new Data_Maybe.Just(new Data_Tuple.Tuple(v.value1.value0, new CatQueue(v.value0, v.value1.value1)));\n        };\n        if (v.value0 instanceof Data_List_Types.Nil && v.value1 instanceof Data_List_Types.Nil) {\n            $tco_done = true;\n            return Data_Maybe.Nothing.value;\n        };\n        if (v.value1 instanceof Data_List_Types.Nil) {\n            $copy_v = new CatQueue(Data_List_Types.Nil.value, Data_List.reverse(v.value0));\n            return;\n        };\n        throw new Error(\"Failed pattern match at Data.CatQueue (line 93, column 1 - line 93, column 63): \" + [ v.constructor.name ]);\n    };\n    while (!$tco_done) {\n        $tco_result = $tco_loop($copy_v);\n    };\n    return $tco_result;\n};\nvar uncons = function ($copy_v) {\n    var $tco_done = false;\n    var $tco_result;\n    function $tco_loop(v) {\n        if (v.value0 instanceof Data_List_Types.Nil && v.value1 instanceof Data_List_Types.Nil) {\n            $tco_done = true;\n            return Data_Maybe.Nothing.value;\n        };\n        if (v.value0 instanceof Data_List_Types.Nil) {\n            $copy_v = new CatQueue(Data_List.reverse(v.value1), Data_List_Types.Nil.value);\n            return;\n        };\n        if (v.value0 instanceof Data_List_Types.Cons) {\n            $tco_done = true;\n            return new Data_Maybe.Just(new Data_Tuple.Tuple(v.value0.value0, new CatQueue(v.value0.value1, v.value1)));\n        };\n        throw new Error(\"Failed pattern match at Data.CatQueue (line 83, column 1 - line 83, column 63): \" + [ v.constructor.name ]);\n    };\n    while (!$tco_done) {\n        $tco_result = $tco_loop($copy_v);\n    };\n    return $tco_result;\n};\nvar snoc = function (v) {\n    return function (a) {\n        return new CatQueue(v.value0, new Data_List_Types.Cons(a, v.value1));\n    };\n};\nvar showCatQueue = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(CatQueue \" + (Data_Show.show(Data_List_Types.showList(dictShow))(v.value0) + (\" \" + (Data_Show.show(Data_List_Types.showList(dictShow))(v.value1) + \")\")));\n        }\n    };\n};\nvar $$null = function (v) {\n    if (v.value0 instanceof Data_List_Types.Nil && v.value1 instanceof Data_List_Types.Nil) {\n        return true;\n    };\n    return false;\n};\nvar length = function (v) {\n    return Data_List.length(v.value0) + Data_List.length(v.value1) | 0;\n};\nvar functorCatQueue = {\n    map: function (f) {\n        return function (v) {\n            return new CatQueue(Data_Functor.map(Data_List_Types.functorList)(f)(v.value0), Data_Functor.map(Data_List_Types.functorList)(f)(v.value1));\n        };\n    }\n};\nvar foldableCatQueue = {\n    foldMap: function (dictMonoid) {\n        return Data_Foldable.foldMapDefaultL(foldableCatQueue)(dictMonoid);\n    },\n    foldr: function (f) {\n        return Data_Foldable.foldrDefault(foldableCatQueue)(f);\n    },\n    foldl: function (f) {\n        var go = function ($copy_acc) {\n            return function ($copy_q) {\n                var $tco_var_acc = $copy_acc;\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(acc, q) {\n                    var v = uncons(q);\n                    if (v instanceof Data_Maybe.Just) {\n                        $tco_var_acc = f(acc)(v.value0.value0);\n                        $copy_q = v.value0.value1;\n                        return;\n                    };\n                    if (v instanceof Data_Maybe.Nothing) {\n                        $tco_done = true;\n                        return acc;\n                    };\n                    throw new Error(\"Failed pattern match at Data.CatQueue (line 148, column 16 - line 150, column 22): \" + [ v.constructor.name ]);\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($tco_var_acc, $copy_q);\n                };\n                return $tco_result;\n            };\n        };\n        return go;\n    }\n};\nvar semigroupCatQueue = {\n    append: Data_Foldable.foldl(foldableCatQueue)(snoc)\n};\nvar empty = new CatQueue(Data_List_Types.Nil.value, Data_List_Types.Nil.value);\nvar monoidCatQueue = {\n    mempty: empty,\n    Semigroup0: function () {\n        return semigroupCatQueue;\n    }\n};\nvar singleton = snoc(empty);\nvar fromFoldable = function (dictFoldable) {\n    return function (f) {\n        return Data_Foldable.foldMap(dictFoldable)(monoidCatQueue)(singleton)(f);\n    };\n};\nvar traversableCatQueue = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            var $100 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Foldable.foldl(foldableCatQueue)(snoc)(empty));\n            var $101 = Data_Foldable.foldl(foldableCatQueue)(function (acc) {\n                var $103 = Control_Apply.lift2(dictApplicative.Apply0())(snoc)(acc);\n                return function ($104) {\n                    return $103(f($104));\n                };\n            })(Control_Applicative.pure(dictApplicative)(empty));\n            return function ($102) {\n                return $100($101($102));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return Data_Traversable.sequenceDefault(traversableCatQueue)(dictApplicative);\n    },\n    Functor0: function () {\n        return functorCatQueue;\n    },\n    Foldable1: function () {\n        return foldableCatQueue;\n    }\n};\nvar unfoldable1CatQueue = {\n    unfoldr1: function (f) {\n        return function (b) {\n            var go = function ($copy_source) {\n                return function ($copy_memo) {\n                    var $tco_var_source = $copy_source;\n                    var $tco_done = false;\n                    var $tco_result;\n                    function $tco_loop(source, memo) {\n                        var v = f(source);\n                        if (v.value1 instanceof Data_Maybe.Nothing) {\n                            $tco_done = true;\n                            return snoc(memo)(v.value0);\n                        };\n                        if (v.value1 instanceof Data_Maybe.Just) {\n                            $tco_var_source = v.value1.value0;\n                            $copy_memo = snoc(memo)(v.value0);\n                            return;\n                        };\n                        throw new Error(\"Failed pattern match at Data.CatQueue (line 155, column 24 - line 157, column 57): \" + [ v.constructor.name ]);\n                    };\n                    while (!$tco_done) {\n                        $tco_result = $tco_loop($tco_var_source, $copy_memo);\n                    };\n                    return $tco_result;\n                };\n            };\n            return go(b)(empty);\n        };\n    }\n};\nvar unfoldableCatQueue = {\n    unfoldr: function (f) {\n        return function (b) {\n            var go = function ($copy_source) {\n                return function ($copy_memo) {\n                    var $tco_var_source = $copy_source;\n                    var $tco_done = false;\n                    var $tco_result;\n                    function $tco_loop(source, memo) {\n                        var v = f(source);\n                        if (v instanceof Data_Maybe.Nothing) {\n                            $tco_done = true;\n                            return memo;\n                        };\n                        if (v instanceof Data_Maybe.Just) {\n                            $tco_var_source = v.value0.value1;\n                            $copy_memo = snoc(memo)(v.value0.value0);\n                            return;\n                        };\n                        throw new Error(\"Failed pattern match at Data.CatQueue (line 162, column 24 - line 164, column 57): \" + [ v.constructor.name ]);\n                    };\n                    while (!$tco_done) {\n                        $tco_result = $tco_loop($tco_var_source, $copy_memo);\n                    };\n                    return $tco_result;\n                };\n            };\n            return go(b)(empty);\n        };\n    },\n    Unfoldable10: function () {\n        return unfoldable1CatQueue;\n    }\n};\nvar cqEq = function (dictEq) {\n    var elemEq = Data_Eq.eq(dictEq);\n    var go = function ($copy_xs) {\n        return function ($copy_ys) {\n            var $tco_var_xs = $copy_xs;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(xs, ys) {\n                var v = uncons(ys);\n                var v1 = uncons(xs);\n                if (v1 instanceof Data_Maybe.Just && (v instanceof Data_Maybe.Just && elemEq(v1.value0.value0)(v.value0.value0))) {\n                    $tco_var_xs = v1.value0.value1;\n                    $copy_ys = v.value0.value1;\n                    return;\n                };\n                if (v1 instanceof Data_Maybe.Nothing && v instanceof Data_Maybe.Nothing) {\n                    $tco_done = true;\n                    return true;\n                };\n                $tco_done = true;\n                return false;\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_xs, $copy_ys);\n            };\n            return $tco_result;\n        };\n    };\n    return go;\n};\nvar eqCatQueue = function (dictEq) {\n    return {\n        eq: cqEq(dictEq)\n    };\n};\nvar cqCompare = function (dictOrd) {\n    var elemCompare = Data_Ord.compare(dictOrd);\n    var go = function ($copy_xs) {\n        return function ($copy_ys) {\n            var $tco_var_xs = $copy_xs;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(xs, ys) {\n                var v = uncons(ys);\n                var v1 = uncons(xs);\n                if (v1 instanceof Data_Maybe.Just && v instanceof Data_Maybe.Just) {\n                    var v2 = elemCompare(v1.value0.value0)(v.value0.value0);\n                    if (v2 instanceof Data_Ordering.EQ) {\n                        $tco_var_xs = v1.value0.value1;\n                        $copy_ys = v.value0.value1;\n                        return;\n                    };\n                    $tco_done = true;\n                    return v2;\n                };\n                if (v1 instanceof Data_Maybe.Just && v instanceof Data_Maybe.Nothing) {\n                    $tco_done = true;\n                    return Data_Ordering.GT.value;\n                };\n                if (v1 instanceof Data_Maybe.Nothing && v instanceof Data_Maybe.Just) {\n                    $tco_done = true;\n                    return Data_Ordering.LT.value;\n                };\n                if (v1 instanceof Data_Maybe.Nothing && v instanceof Data_Maybe.Nothing) {\n                    $tco_done = true;\n                    return Data_Ordering.EQ.value;\n                };\n                throw new Error(\"Failed pattern match at Data.CatQueue (line 118, column 16 - line 125, column 30): \" + [ v1.constructor.name, v.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_xs, $copy_ys);\n            };\n            return $tco_result;\n        };\n    };\n    return go;\n};\nvar ordCatQueue = function (dictOrd) {\n    return {\n        compare: cqCompare(dictOrd),\n        Eq0: function () {\n            return eqCatQueue(dictOrd.Eq0());\n        }\n    };\n};\nvar cons = function (a) {\n    return function (v) {\n        return new CatQueue(new Data_List_Types.Cons(a, v.value0), v.value1);\n    };\n};\nvar monadCatQueue = {\n    Applicative0: function () {\n        return applicativeCatQueue;\n    },\n    Bind1: function () {\n        return bindCatQueue;\n    }\n};\nvar bindCatQueue = {\n    bind: Data_Function.flip(Data_Foldable.foldMap(foldableCatQueue)(monoidCatQueue)),\n    Apply0: function () {\n        return applyCatQueue;\n    }\n};\nvar applyCatQueue = {\n    apply: Control_Monad.ap(monadCatQueue),\n    Functor0: function () {\n        return functorCatQueue;\n    }\n};\nvar applicativeCatQueue = {\n    pure: singleton,\n    Apply0: function () {\n        return applyCatQueue;\n    }\n};\nvar altCatQueue = {\n    alt: Data_Semigroup.append(semigroupCatQueue),\n    Functor0: function () {\n        return functorCatQueue;\n    }\n};\nvar plusCatQueue = {\n    empty: empty,\n    Alt0: function () {\n        return altCatQueue;\n    }\n};\nvar alternativeCatQueue = {\n    Applicative0: function () {\n        return applicativeCatQueue;\n    },\n    Plus1: function () {\n        return plusCatQueue;\n    }\n};\nvar monadPlusCatQueue = {\n    Monad0: function () {\n        return monadCatQueue;\n    },\n    Alternative1: function () {\n        return alternativeCatQueue;\n    }\n};\nvar monadZeroCatQueue = {\n    Monad0: function () {\n        return monadCatQueue;\n    },\n    Alternative1: function () {\n        return alternativeCatQueue;\n    },\n    MonadZeroIsDeprecated2: function () {\n        return undefined;\n    }\n};\nmodule.exports = {\n    CatQueue: CatQueue,\n    empty: empty,\n    \"null\": $$null,\n    singleton: singleton,\n    length: length,\n    cons: cons,\n    snoc: snoc,\n    uncons: uncons,\n    unsnoc: unsnoc,\n    fromFoldable: fromFoldable,\n    eqCatQueue: eqCatQueue,\n    ordCatQueue: ordCatQueue,\n    semigroupCatQueue: semigroupCatQueue,\n    monoidCatQueue: monoidCatQueue,\n    showCatQueue: showCatQueue,\n    foldableCatQueue: foldableCatQueue,\n    unfoldable1CatQueue: unfoldable1CatQueue,\n    unfoldableCatQueue: unfoldableCatQueue,\n    traversableCatQueue: traversableCatQueue,\n    functorCatQueue: functorCatQueue,\n    applyCatQueue: applyCatQueue,\n    applicativeCatQueue: applicativeCatQueue,\n    bindCatQueue: bindCatQueue,\n    monadCatQueue: monadCatQueue,\n    altCatQueue: altCatQueue,\n    plusCatQueue: plusCatQueue,\n    alternativeCatQueue: alternativeCatQueue,\n    monadZeroCatQueue: monadZeroCatQueue,\n    monadPlusCatQueue: monadPlusCatQueue\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/catenable-lists/v6.0.1/src/Data/CatQueue.purs?");

/***/ }),

/***/ "./.spago/console/v5.0.0/src/Effect/Console.purs":
/*!*******************************************************!*\
  !*** ./.spago/console/v5.0.0/src/Effect/Console.purs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/console/v5.0.0/src/Effect/Console.js */ \"./.spago/console/v5.0.0/src/Effect/Console.js\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar warnShow = function (dictShow) {\n    return function (a) {\n        return $foreign.warn(Data_Show.show(dictShow)(a));\n    };\n};\nvar logShow = function (dictShow) {\n    return function (a) {\n        return $foreign.log(Data_Show.show(dictShow)(a));\n    };\n};\nvar infoShow = function (dictShow) {\n    return function (a) {\n        return $foreign.info(Data_Show.show(dictShow)(a));\n    };\n};\nvar errorShow = function (dictShow) {\n    return function (a) {\n        return $foreign.error(Data_Show.show(dictShow)(a));\n    };\n};\nmodule.exports = {\n    logShow: logShow,\n    warnShow: warnShow,\n    errorShow: errorShow,\n    infoShow: infoShow,\n    log: $foreign.log,\n    warn: $foreign.warn,\n    error: $foreign.error,\n    info: $foreign.info,\n    time: $foreign.time,\n    timeLog: $foreign.timeLog,\n    timeEnd: $foreign.timeEnd,\n    clear: $foreign.clear\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/console/v5.0.0/src/Effect/Console.purs?");

/***/ }),

/***/ "./.spago/const/v5.0.0/src/Data/Const.purs":
/*!*************************************************!*\
  !*** ./.spago/const/v5.0.0/src/Data/Const.purs ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Functor_Invariant = __webpack_require__(/*! ./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs */ \"./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Const = function (x) {\n    return x;\n};\nvar showConst = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Const \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semiringConst = function (dictSemiring) {\n    return dictSemiring;\n};\nvar semigroupoidConst = {\n    compose: function (v) {\n        return function (v1) {\n            return v1;\n        };\n    }\n};\nvar semigroupConst = function (dictSemigroup) {\n    return dictSemigroup;\n};\nvar ringConst = function (dictRing) {\n    return dictRing;\n};\nvar ordConst = function (dictOrd) {\n    return dictOrd;\n};\nvar newtypeConst = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monoidConst = function (dictMonoid) {\n    return dictMonoid;\n};\nvar heytingAlgebraConst = function (dictHeytingAlgebra) {\n    return dictHeytingAlgebra;\n};\nvar functorConst = {\n    map: function (f) {\n        return function (m) {\n            return m;\n        };\n    }\n};\nvar invariantConst = {\n    imap: Data_Functor_Invariant.imapF(functorConst)\n};\nvar euclideanRingConst = function (dictEuclideanRing) {\n    return dictEuclideanRing;\n};\nvar eqConst = function (dictEq) {\n    return dictEq;\n};\nvar eq1Const = function (dictEq) {\n    return {\n        eq1: function (dictEq1) {\n            return Data_Eq.eq(eqConst(dictEq));\n        }\n    };\n};\nvar ord1Const = function (dictOrd) {\n    return {\n        compare1: function (dictOrd1) {\n            return Data_Ord.compare(ordConst(dictOrd));\n        },\n        Eq10: function () {\n            return eq1Const(dictOrd.Eq0());\n        }\n    };\n};\nvar commutativeRingConst = function (dictCommutativeRing) {\n    return dictCommutativeRing;\n};\nvar boundedConst = function (dictBounded) {\n    return dictBounded;\n};\nvar booleanAlgebraConst = function (dictBooleanAlgebra) {\n    return dictBooleanAlgebra;\n};\nvar applyConst = function (dictSemigroup) {\n    return {\n        apply: function (v) {\n            return function (v1) {\n                return Data_Semigroup.append(dictSemigroup)(v)(v1);\n            };\n        },\n        Functor0: function () {\n            return functorConst;\n        }\n    };\n};\nvar applicativeConst = function (dictMonoid) {\n    return {\n        pure: function (v) {\n            return Data_Monoid.mempty(dictMonoid);\n        },\n        Apply0: function () {\n            return applyConst(dictMonoid.Semigroup0());\n        }\n    };\n};\nmodule.exports = {\n    Const: Const,\n    newtypeConst: newtypeConst,\n    eqConst: eqConst,\n    eq1Const: eq1Const,\n    ordConst: ordConst,\n    ord1Const: ord1Const,\n    boundedConst: boundedConst,\n    showConst: showConst,\n    semigroupoidConst: semigroupoidConst,\n    semigroupConst: semigroupConst,\n    monoidConst: monoidConst,\n    semiringConst: semiringConst,\n    ringConst: ringConst,\n    euclideanRingConst: euclideanRingConst,\n    commutativeRingConst: commutativeRingConst,\n    heytingAlgebraConst: heytingAlgebraConst,\n    booleanAlgebraConst: booleanAlgebraConst,\n    functorConst: functorConst,\n    invariantConst: invariantConst,\n    applyConst: applyConst,\n    applicativeConst: applicativeConst\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/const/v5.0.0/src/Data/Const.purs?");

/***/ }),

/***/ "./.spago/contravariant/v5.0.0/src/Data/Functor/Contravariant.purs":
/*!*************************************************************************!*\
  !*** ./.spago/contravariant/v5.0.0/src/Data/Functor/Contravariant.purs ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Void = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Void.purs */ \"./.spago/prelude/v5.0.1/src/Data/Void.purs\");\nvar contravariantConst = {\n    cmap: function (v) {\n        return function (v1) {\n            return v1;\n        };\n    }\n};\nvar cmap = function (dict) {\n    return dict.cmap;\n};\nvar cmapFlipped = function (dictContravariant) {\n    return function (x) {\n        return function (f) {\n            return cmap(dictContravariant)(f)(x);\n        };\n    };\n};\nvar coerce = function (dictContravariant) {\n    return function (dictFunctor) {\n        return function (a) {\n            return Data_Functor.map(dictFunctor)(Data_Void.absurd)(cmap(dictContravariant)(Data_Void.absurd)(a));\n        };\n    };\n};\nvar imapC = function (dictContravariant) {\n    return function (v) {\n        return function (f) {\n            return cmap(dictContravariant)(f);\n        };\n    };\n};\nmodule.exports = {\n    cmap: cmap,\n    cmapFlipped: cmapFlipped,\n    coerce: coerce,\n    imapC: imapC,\n    contravariantConst: contravariantConst\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/contravariant/v5.0.0/src/Data/Functor/Contravariant.purs?");

/***/ }),

/***/ "./.spago/control/v5.0.0/src/Control/Alt.purs":
/*!****************************************************!*\
  !*** ./.spago/control/v5.0.0/src/Control/Alt.purs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar altArray = {\n    alt: Data_Semigroup.append(Data_Semigroup.semigroupArray),\n    Functor0: function () {\n        return Data_Functor.functorArray;\n    }\n};\nvar alt = function (dict) {\n    return dict.alt;\n};\nmodule.exports = {\n    alt: alt,\n    altArray: altArray,\n    map: Data_Functor.map,\n    \"void\": Data_Functor[\"void\"]\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/control/v5.0.0/src/Control/Alt.purs?");

/***/ }),

/***/ "./.spago/control/v5.0.0/src/Control/Alternative.purs":
/*!************************************************************!*\
  !*** ./.spago/control/v5.0.0/src/Control/Alternative.purs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Plus = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Plus.purs */ \"./.spago/control/v5.0.0/src/Control/Plus.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar guard = function (dictAlternative) {\n    return function (v) {\n        if (v) {\n            return Control_Applicative.pure(dictAlternative.Applicative0())(Data_Unit.unit);\n        };\n        if (!v) {\n            return Control_Plus.empty(dictAlternative.Plus1());\n        };\n        throw new Error(\"Failed pattern match at Control.Alternative (line 48, column 1 - line 48, column 54): \" + [ v.constructor.name ]);\n    };\n};\nvar alternativeArray = {\n    Applicative0: function () {\n        return Control_Applicative.applicativeArray;\n    },\n    Plus1: function () {\n        return Control_Plus.plusArray;\n    }\n};\nmodule.exports = {\n    guard: guard,\n    alternativeArray: alternativeArray,\n    alt: Control_Alt.alt,\n    liftA1: Control_Applicative.liftA1,\n    pure: Control_Applicative.pure,\n    unless: Control_Applicative.unless,\n    when: Control_Applicative.when,\n    apply: Control_Apply.apply,\n    empty: Control_Plus.empty,\n    map: Data_Functor.map,\n    \"void\": Data_Functor[\"void\"]\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/control/v5.0.0/src/Control/Alternative.purs?");

/***/ }),

/***/ "./.spago/control/v5.0.0/src/Control/Comonad.purs":
/*!********************************************************!*\
  !*** ./.spago/control/v5.0.0/src/Control/Comonad.purs ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Extend = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Extend.purs */ \"./.spago/control/v5.0.0/src/Control/Extend.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar extract = function (dict) {\n    return dict.extract;\n};\nmodule.exports = {\n    extract: extract,\n    duplicate: Control_Extend.duplicate,\n    extend: Control_Extend.extend,\n    map: Data_Functor.map,\n    \"void\": Data_Functor[\"void\"]\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/control/v5.0.0/src/Control/Comonad.purs?");

/***/ }),

/***/ "./.spago/control/v5.0.0/src/Control/Extend.purs":
/*!*******************************************************!*\
  !*** ./.spago/control/v5.0.0/src/Control/Extend.purs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Extend.js */ \"./.spago/control/v5.0.0/src/Control/Extend.js\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar extendFn = function (dictSemigroup) {\n    return {\n        extend: function (f) {\n            return function (g) {\n                return function (w) {\n                    return f(function (w$prime) {\n                        return g(Data_Semigroup.append(dictSemigroup)(w)(w$prime));\n                    });\n                };\n            };\n        },\n        Functor0: function () {\n            return Data_Functor.functorFn;\n        }\n    };\n};\nvar extendArray = {\n    extend: $foreign.arrayExtend,\n    Functor0: function () {\n        return Data_Functor.functorArray;\n    }\n};\nvar extend = function (dict) {\n    return dict.extend;\n};\nvar extendFlipped = function (dictExtend) {\n    return function (w) {\n        return function (f) {\n            return extend(dictExtend)(f)(w);\n        };\n    };\n};\nvar duplicate = function (dictExtend) {\n    return extend(dictExtend)(Control_Category.identity(Control_Category.categoryFn));\n};\nvar composeCoKleisliFlipped = function (dictExtend) {\n    return function (f) {\n        return function (g) {\n            return function (w) {\n                return f(extend(dictExtend)(g)(w));\n            };\n        };\n    };\n};\nvar composeCoKleisli = function (dictExtend) {\n    return function (f) {\n        return function (g) {\n            return function (w) {\n                return g(extend(dictExtend)(f)(w));\n            };\n        };\n    };\n};\nmodule.exports = {\n    extend: extend,\n    extendFlipped: extendFlipped,\n    composeCoKleisli: composeCoKleisli,\n    composeCoKleisliFlipped: composeCoKleisliFlipped,\n    duplicate: duplicate,\n    extendFn: extendFn,\n    extendArray: extendArray,\n    map: Data_Functor.map,\n    \"void\": Data_Functor[\"void\"]\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/control/v5.0.0/src/Control/Extend.purs?");

/***/ }),

/***/ "./.spago/control/v5.0.0/src/Control/Lazy.purs":
/*!*****************************************************!*\
  !*** ./.spago/control/v5.0.0/src/Control/Lazy.purs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar lazyUnit = {\n    defer: function (v) {\n        return Data_Unit.unit;\n    }\n};\nvar lazyFn = {\n    defer: function (f) {\n        return function (x) {\n            return f(Data_Unit.unit)(x);\n        };\n    }\n};\nvar defer = function (dict) {\n    return dict.defer;\n};\nvar fix = function (dictLazy) {\n    return function (f) {\n        var go = defer(dictLazy)(function (v) {\n            return f(go);\n        });\n        return go;\n    };\n};\nmodule.exports = {\n    defer: defer,\n    fix: fix,\n    lazyFn: lazyFn,\n    lazyUnit: lazyUnit\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/control/v5.0.0/src/Control/Lazy.purs?");

/***/ }),

/***/ "./.spago/control/v5.0.0/src/Control/Plus.purs":
/*!*****************************************************!*\
  !*** ./.spago/control/v5.0.0/src/Control/Plus.purs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar plusArray = {\n    empty: [  ],\n    Alt0: function () {\n        return Control_Alt.altArray;\n    }\n};\nvar empty = function (dict) {\n    return dict.empty;\n};\nmodule.exports = {\n    empty: empty,\n    plusArray: plusArray,\n    alt: Control_Alt.alt,\n    map: Data_Functor.map,\n    \"void\": Data_Functor[\"void\"]\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/control/v5.0.0/src/Control/Plus.purs?");

/***/ }),

/***/ "./.spago/distributive/v5.0.0/src/Data/Distributive.purs":
/*!***************************************************************!*\
  !*** ./.spago/distributive/v5.0.0/src/Data/Distributive.purs ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Type_Equality = __webpack_require__(/*! ./.spago/type-equality/v4.0.0/src/Type/Equality.purs */ \"./.spago/type-equality/v4.0.0/src/Type/Equality.purs\");\nvar distributiveIdentity = {\n    distribute: function (dictFunctor) {\n        var $16 = Data_Functor.map(dictFunctor)(Data_Newtype.unwrap());\n        return function ($17) {\n            return Data_Identity.Identity($16($17));\n        };\n    },\n    collect: function (dictFunctor) {\n        return function (f) {\n            var $18 = Data_Functor.map(dictFunctor)((function () {\n                var $20 = Data_Newtype.unwrap();\n                return function ($21) {\n                    return $20(f($21));\n                };\n            })());\n            return function ($19) {\n                return Data_Identity.Identity($18($19));\n            };\n        };\n    },\n    Functor0: function () {\n        return Data_Identity.functorIdentity;\n    }\n};\nvar distribute = function (dict) {\n    return dict.distribute;\n};\nvar distributiveFunction = {\n    distribute: function (dictFunctor) {\n        return function (a) {\n            return function (e) {\n                return Data_Functor.map(dictFunctor)(function (v) {\n                    return v(e);\n                })(a);\n            };\n        };\n    },\n    collect: function (dictFunctor) {\n        return function (f) {\n            var $22 = distribute(distributiveFunction)(dictFunctor);\n            var $23 = Data_Functor.map(dictFunctor)(f);\n            return function ($24) {\n                return $22($23($24));\n            };\n        };\n    },\n    Functor0: function () {\n        return Data_Functor.functorFn;\n    }\n};\nvar cotraverse = function (dictDistributive) {\n    return function (dictFunctor) {\n        return function (f) {\n            var $25 = Data_Functor.map(dictDistributive.Functor0())(f);\n            var $26 = distribute(dictDistributive)(dictFunctor);\n            return function ($27) {\n                return $25($26($27));\n            };\n        };\n    };\n};\nvar collectDefault = function (dictDistributive) {\n    return function (dictFunctor) {\n        return function (f) {\n            var $28 = distribute(dictDistributive)(dictFunctor);\n            var $29 = Data_Functor.map(dictFunctor)(f);\n            return function ($30) {\n                return $28($29($30));\n            };\n        };\n    };\n};\nvar distributiveTuple = function (dictTypeEquals) {\n    return {\n        collect: function (dictFunctor) {\n            return collectDefault(distributiveTuple(dictTypeEquals))(dictFunctor);\n        },\n        distribute: function (dictFunctor) {\n            var $31 = Data_Tuple.Tuple.create(Type_Equality.from(dictTypeEquals)(Data_Unit.unit));\n            var $32 = Data_Functor.map(dictFunctor)(Data_Tuple.snd);\n            return function ($33) {\n                return $31($32($33));\n            };\n        },\n        Functor0: function () {\n            return Data_Tuple.functorTuple;\n        }\n    };\n};\nvar collect = function (dict) {\n    return dict.collect;\n};\nvar distributeDefault = function (dictDistributive) {\n    return function (dictFunctor) {\n        return collect(dictDistributive)(dictFunctor)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nmodule.exports = {\n    collect: collect,\n    distribute: distribute,\n    distributeDefault: distributeDefault,\n    collectDefault: collectDefault,\n    cotraverse: cotraverse,\n    distributiveIdentity: distributiveIdentity,\n    distributiveFunction: distributiveFunction,\n    distributiveTuple: distributiveTuple\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/distributive/v5.0.0/src/Data/Distributive.purs?");

/***/ }),

/***/ "./.spago/effect/v3.0.0/src/Effect.purs":
/*!**********************************************!*\
  !*** ./.spago/effect/v3.0.0/src/Effect.purs ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect.js */ \"./.spago/effect/v3.0.0/src/Effect.js\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar monadEffect = {\n    Applicative0: function () {\n        return applicativeEffect;\n    },\n    Bind1: function () {\n        return bindEffect;\n    }\n};\nvar bindEffect = {\n    bind: $foreign.bindE,\n    Apply0: function () {\n        return applyEffect;\n    }\n};\nvar applyEffect = {\n    apply: Control_Monad.ap(monadEffect),\n    Functor0: function () {\n        return functorEffect;\n    }\n};\nvar applicativeEffect = {\n    pure: $foreign.pureE,\n    Apply0: function () {\n        return applyEffect;\n    }\n};\nvar functorEffect = {\n    map: Control_Applicative.liftA1(applicativeEffect)\n};\nvar semigroupEffect = function (dictSemigroup) {\n    return {\n        append: Control_Apply.lift2(applyEffect)(Data_Semigroup.append(dictSemigroup))\n    };\n};\nvar monoidEffect = function (dictMonoid) {\n    return {\n        mempty: $foreign.pureE(Data_Monoid.mempty(dictMonoid)),\n        Semigroup0: function () {\n            return semigroupEffect(dictMonoid.Semigroup0());\n        }\n    };\n};\nmodule.exports = {\n    functorEffect: functorEffect,\n    applyEffect: applyEffect,\n    applicativeEffect: applicativeEffect,\n    bindEffect: bindEffect,\n    monadEffect: monadEffect,\n    semigroupEffect: semigroupEffect,\n    monoidEffect: monoidEffect,\n    untilE: $foreign.untilE,\n    whileE: $foreign.whileE,\n    forE: $foreign.forE,\n    foreachE: $foreign.foreachE\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/effect/v3.0.0/src/Effect.purs?");

/***/ }),

/***/ "./.spago/effect/v3.0.0/src/Effect/Class.purs":
/*!****************************************************!*\
  !*** ./.spago/effect/v3.0.0/src/Effect/Class.purs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Effect = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect.purs */ \"./.spago/effect/v3.0.0/src/Effect.purs\");\nvar monadEffectEffect = {\n    liftEffect: Control_Category.identity(Control_Category.categoryFn),\n    Monad0: function () {\n        return Effect.monadEffect;\n    }\n};\nvar liftEffect = function (dict) {\n    return dict.liftEffect;\n};\nmodule.exports = {\n    liftEffect: liftEffect,\n    monadEffectEffect: monadEffectEffect\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/effect/v3.0.0/src/Effect/Class.purs?");

/***/ }),

/***/ "./.spago/either/v5.0.0/src/Data/Either.purs":
/*!***************************************************!*\
  !*** ./.spago/either/v5.0.0/src/Data/Either.purs ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Data_Bounded = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Bounded.purs */ \"./.spago/prelude/v5.0.1/src/Data/Bounded.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Functor_Invariant = __webpack_require__(/*! ./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs */ \"./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs\");\nvar Data_Generic_Rep = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs */ \"./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Left = (function () {\n    function Left(value0) {\n        this.value0 = value0;\n    };\n    Left.create = function (value0) {\n        return new Left(value0);\n    };\n    return Left;\n})();\nvar Right = (function () {\n    function Right(value0) {\n        this.value0 = value0;\n    };\n    Right.create = function (value0) {\n        return new Right(value0);\n    };\n    return Right;\n})();\nvar showEither = function (dictShow) {\n    return function (dictShow1) {\n        return {\n            show: function (v) {\n                if (v instanceof Left) {\n                    return \"(Left \" + (Data_Show.show(dictShow)(v.value0) + \")\");\n                };\n                if (v instanceof Right) {\n                    return \"(Right \" + (Data_Show.show(dictShow1)(v.value0) + \")\");\n                };\n                throw new Error(\"Failed pattern match at Data.Either (line 173, column 1 - line 175, column 46): \" + [ v.constructor.name ]);\n            }\n        };\n    };\n};\nvar note$prime = function (f) {\n    return Data_Maybe[\"maybe'\"](function ($105) {\n        return Left.create(f($105));\n    })(Right.create);\n};\nvar note = function (a) {\n    return Data_Maybe.maybe(new Left(a))(Right.create);\n};\nvar genericEither = {\n    to: function (x) {\n        if (x instanceof Data_Generic_Rep.Inl) {\n            return new Left(x.value0);\n        };\n        if (x instanceof Data_Generic_Rep.Inr) {\n            return new Right(x.value0);\n        };\n        throw new Error(\"Failed pattern match at Data.Either (line 33, column 1 - line 33, column 56): \" + [ x.constructor.name ]);\n    },\n    from: function (x) {\n        if (x instanceof Left) {\n            return new Data_Generic_Rep.Inl(x.value0);\n        };\n        if (x instanceof Right) {\n            return new Data_Generic_Rep.Inr(x.value0);\n        };\n        throw new Error(\"Failed pattern match at Data.Either (line 33, column 1 - line 33, column 56): \" + [ x.constructor.name ]);\n    }\n};\nvar functorEither = {\n    map: function (f) {\n        return function (m) {\n            if (m instanceof Left) {\n                return new Left(m.value0);\n            };\n            if (m instanceof Right) {\n                return new Right(f(m.value0));\n            };\n            throw new Error(\"Failed pattern match at Data.Either (line 31, column 1 - line 31, column 52): \" + [ m.constructor.name ]);\n        };\n    }\n};\nvar invariantEither = {\n    imap: Data_Functor_Invariant.imapF(functorEither)\n};\nvar fromRight$prime = function (v) {\n    return function (v1) {\n        if (v1 instanceof Right) {\n            return v1.value0;\n        };\n        return v(Data_Unit.unit);\n    };\n};\nvar fromRight = function (v) {\n    return function (v1) {\n        if (v1 instanceof Right) {\n            return v1.value0;\n        };\n        return v;\n    };\n};\nvar fromLeft$prime = function (v) {\n    return function (v1) {\n        if (v1 instanceof Left) {\n            return v1.value0;\n        };\n        return v(Data_Unit.unit);\n    };\n};\nvar fromLeft = function (v) {\n    return function (v1) {\n        if (v1 instanceof Left) {\n            return v1.value0;\n        };\n        return v;\n    };\n};\nvar extendEither = {\n    extend: function (v) {\n        return function (v1) {\n            if (v1 instanceof Left) {\n                return new Left(v1.value0);\n            };\n            return new Right(v(v1));\n        };\n    },\n    Functor0: function () {\n        return functorEither;\n    }\n};\nvar eqEither = function (dictEq) {\n    return function (dictEq1) {\n        return {\n            eq: function (x) {\n                return function (y) {\n                    if (x instanceof Left && y instanceof Left) {\n                        return Data_Eq.eq(dictEq)(x.value0)(y.value0);\n                    };\n                    if (x instanceof Right && y instanceof Right) {\n                        return Data_Eq.eq(dictEq1)(x.value0)(y.value0);\n                    };\n                    return false;\n                };\n            }\n        };\n    };\n};\nvar ordEither = function (dictOrd) {\n    return function (dictOrd1) {\n        return {\n            compare: function (x) {\n                return function (y) {\n                    if (x instanceof Left && y instanceof Left) {\n                        return Data_Ord.compare(dictOrd)(x.value0)(y.value0);\n                    };\n                    if (x instanceof Left) {\n                        return Data_Ordering.LT.value;\n                    };\n                    if (y instanceof Left) {\n                        return Data_Ordering.GT.value;\n                    };\n                    if (x instanceof Right && y instanceof Right) {\n                        return Data_Ord.compare(dictOrd1)(x.value0)(y.value0);\n                    };\n                    throw new Error(\"Failed pattern match at Data.Either (line 189, column 1 - line 189, column 64): \" + [ x.constructor.name, y.constructor.name ]);\n                };\n            },\n            Eq0: function () {\n                return eqEither(dictOrd.Eq0())(dictOrd1.Eq0());\n            }\n        };\n    };\n};\nvar eq1Either = function (dictEq) {\n    return {\n        eq1: function (dictEq1) {\n            return Data_Eq.eq(eqEither(dictEq)(dictEq1));\n        }\n    };\n};\nvar ord1Either = function (dictOrd) {\n    return {\n        compare1: function (dictOrd1) {\n            return Data_Ord.compare(ordEither(dictOrd)(dictOrd1));\n        },\n        Eq10: function () {\n            return eq1Either(dictOrd.Eq0());\n        }\n    };\n};\nvar either = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2 instanceof Left) {\n                return v(v2.value0);\n            };\n            if (v2 instanceof Right) {\n                return v1(v2.value0);\n            };\n            throw new Error(\"Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): \" + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);\n        };\n    };\n};\nvar hush = either(Data_Function[\"const\"](Data_Maybe.Nothing.value))(Data_Maybe.Just.create);\nvar isLeft = either(Data_Function[\"const\"](true))(Data_Function[\"const\"](false));\nvar isRight = either(Data_Function[\"const\"](false))(Data_Function[\"const\"](true));\nvar choose = function (dictAlt) {\n    return function (a) {\n        return function (b) {\n            return Control_Alt.alt(dictAlt)(Data_Functor.map(dictAlt.Functor0())(Left.create)(a))(Data_Functor.map(dictAlt.Functor0())(Right.create)(b));\n        };\n    };\n};\nvar boundedEither = function (dictBounded) {\n    return function (dictBounded1) {\n        return {\n            top: new Right(Data_Bounded.top(dictBounded1)),\n            bottom: new Left(Data_Bounded.bottom(dictBounded)),\n            Ord0: function () {\n                return ordEither(dictBounded.Ord0())(dictBounded1.Ord0());\n            }\n        };\n    };\n};\nvar applyEither = {\n    apply: function (v) {\n        return function (v1) {\n            if (v instanceof Left) {\n                return new Left(v.value0);\n            };\n            if (v instanceof Right) {\n                return Data_Functor.map(functorEither)(v.value0)(v1);\n            };\n            throw new Error(\"Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    },\n    Functor0: function () {\n        return functorEither;\n    }\n};\nvar bindEither = {\n    bind: either(function (e) {\n        return function (v) {\n            return new Left(e);\n        };\n    })(function (a) {\n        return function (f) {\n            return f(a);\n        };\n    }),\n    Apply0: function () {\n        return applyEither;\n    }\n};\nvar semigroupEither = function (dictSemigroup) {\n    return {\n        append: function (x) {\n            return function (y) {\n                return Control_Apply.apply(applyEither)(Data_Functor.map(functorEither)(Data_Semigroup.append(dictSemigroup))(x))(y);\n            };\n        }\n    };\n};\nvar applicativeEither = {\n    pure: Right.create,\n    Apply0: function () {\n        return applyEither;\n    }\n};\nvar monadEither = {\n    Applicative0: function () {\n        return applicativeEither;\n    },\n    Bind1: function () {\n        return bindEither;\n    }\n};\nvar altEither = {\n    alt: function (v) {\n        return function (v1) {\n            if (v instanceof Left) {\n                return v1;\n            };\n            return v;\n        };\n    },\n    Functor0: function () {\n        return functorEither;\n    }\n};\nmodule.exports = {\n    Left: Left,\n    Right: Right,\n    either: either,\n    choose: choose,\n    isLeft: isLeft,\n    isRight: isRight,\n    fromLeft: fromLeft,\n    \"fromLeft'\": fromLeft$prime,\n    fromRight: fromRight,\n    \"fromRight'\": fromRight$prime,\n    note: note,\n    \"note'\": note$prime,\n    hush: hush,\n    functorEither: functorEither,\n    genericEither: genericEither,\n    invariantEither: invariantEither,\n    applyEither: applyEither,\n    applicativeEither: applicativeEither,\n    altEither: altEither,\n    bindEither: bindEither,\n    monadEither: monadEither,\n    extendEither: extendEither,\n    showEither: showEither,\n    eqEither: eqEither,\n    eq1Either: eq1Either,\n    ordEither: ordEither,\n    ord1Either: ord1Either,\n    boundedEither: boundedEither,\n    semigroupEither: semigroupEither\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/either/v5.0.0/src/Data/Either.purs?");

/***/ }),

/***/ "./.spago/enums/v5.0.0/src/Data/Enum.purs":
/*!************************************************!*\
  !*** ./.spago/enums/v5.0.0/src/Data/Enum.purs ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/enums/v5.0.0/src/Data/Enum.js */ \"./.spago/enums/v5.0.0/src/Data/Enum.js\");\nvar Control_Alternative = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alternative.purs */ \"./.spago/control/v5.0.0/src/Control/Alternative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Bounded = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Bounded.purs */ \"./.spago/prelude/v5.0.1/src/Data/Bounded.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar Data_Unfoldable1 = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Cardinality = function (x) {\n    return x;\n};\nvar toEnum = function (dict) {\n    return dict.toEnum;\n};\nvar succ = function (dict) {\n    return dict.succ;\n};\nvar upFromIncluding = function (dictEnum) {\n    return function (dictUnfoldable1) {\n        return Data_Unfoldable1.unfoldr1(dictUnfoldable1)(Control_Apply.apply(Control_Apply.applyFn)(Data_Tuple.Tuple.create)(succ(dictEnum)));\n    };\n};\nvar showCardinality = {\n    show: function (v) {\n        return \"(Cardinality \" + (Data_Show.show(Data_Show.showInt)(v) + \")\");\n    }\n};\nvar pred = function (dict) {\n    return dict.pred;\n};\nvar ordCardinality = Data_Ord.ordInt;\nvar newtypeCardinality = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar fromEnum = function (dict) {\n    return dict.fromEnum;\n};\nvar toEnumWithDefaults = function (dictBoundedEnum) {\n    return function (low) {\n        return function (high) {\n            return function (x) {\n                var v = toEnum(dictBoundedEnum)(x);\n                if (v instanceof Data_Maybe.Just) {\n                    return v.value0;\n                };\n                if (v instanceof Data_Maybe.Nothing) {\n                    var $55 = x < fromEnum(dictBoundedEnum)(Data_Bounded.bottom(dictBoundedEnum.Bounded0()));\n                    if ($55) {\n                        return low;\n                    };\n                    return high;\n                };\n                throw new Error(\"Failed pattern match at Data.Enum (line 158, column 33 - line 160, column 62): \" + [ v.constructor.name ]);\n            };\n        };\n    };\n};\nvar eqCardinality = Data_Eq.eqInt;\nvar enumUnit = {\n    succ: Data_Function[\"const\"](Data_Maybe.Nothing.value),\n    pred: Data_Function[\"const\"](Data_Maybe.Nothing.value),\n    Ord0: function () {\n        return Data_Ord.ordUnit;\n    }\n};\nvar enumTuple = function (dictEnum) {\n    return function (dictBoundedEnum) {\n        return {\n            succ: function (v) {\n                return Data_Maybe.maybe(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Function.flip(Data_Tuple.Tuple.create)(Data_Bounded.bottom(dictBoundedEnum.Bounded0())))(succ(dictEnum)(v.value0)))((function () {\n                    var $98 = Data_Tuple.Tuple.create(v.value0);\n                    return function ($99) {\n                        return Data_Maybe.Just.create($98($99));\n                    };\n                })())(succ(dictBoundedEnum.Enum1())(v.value1));\n            },\n            pred: function (v) {\n                return Data_Maybe.maybe(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Function.flip(Data_Tuple.Tuple.create)(Data_Bounded.top(dictBoundedEnum.Bounded0())))(pred(dictEnum)(v.value0)))((function () {\n                    var $100 = Data_Tuple.Tuple.create(v.value0);\n                    return function ($101) {\n                        return Data_Maybe.Just.create($100($101));\n                    };\n                })())(pred(dictBoundedEnum.Enum1())(v.value1));\n            },\n            Ord0: function () {\n                return Data_Tuple.ordTuple(dictEnum.Ord0())((dictBoundedEnum.Enum1()).Ord0());\n            }\n        };\n    };\n};\nvar enumOrdering = {\n    succ: function (v) {\n        if (v instanceof Data_Ordering.LT) {\n            return new Data_Maybe.Just(Data_Ordering.EQ.value);\n        };\n        if (v instanceof Data_Ordering.EQ) {\n            return new Data_Maybe.Just(Data_Ordering.GT.value);\n        };\n        if (v instanceof Data_Ordering.GT) {\n            return Data_Maybe.Nothing.value;\n        };\n        throw new Error(\"Failed pattern match at Data.Enum (line 72, column 1 - line 78, column 20): \" + [ v.constructor.name ]);\n    },\n    pred: function (v) {\n        if (v instanceof Data_Ordering.LT) {\n            return Data_Maybe.Nothing.value;\n        };\n        if (v instanceof Data_Ordering.EQ) {\n            return new Data_Maybe.Just(Data_Ordering.LT.value);\n        };\n        if (v instanceof Data_Ordering.GT) {\n            return new Data_Maybe.Just(Data_Ordering.EQ.value);\n        };\n        throw new Error(\"Failed pattern match at Data.Enum (line 72, column 1 - line 78, column 20): \" + [ v.constructor.name ]);\n    },\n    Ord0: function () {\n        return Data_Ord.ordOrdering;\n    }\n};\nvar enumMaybe = function (dictBoundedEnum) {\n    return {\n        succ: function (v) {\n            if (v instanceof Data_Maybe.Nothing) {\n                return new Data_Maybe.Just(new Data_Maybe.Just(Data_Bounded.bottom(dictBoundedEnum.Bounded0())));\n            };\n            if (v instanceof Data_Maybe.Just) {\n                return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Maybe.Just.create)(succ(dictBoundedEnum.Enum1())(v.value0));\n            };\n            throw new Error(\"Failed pattern match at Data.Enum (line 80, column 1 - line 84, column 32): \" + [ v.constructor.name ]);\n        },\n        pred: function (v) {\n            if (v instanceof Data_Maybe.Nothing) {\n                return Data_Maybe.Nothing.value;\n            };\n            if (v instanceof Data_Maybe.Just) {\n                return new Data_Maybe.Just(pred(dictBoundedEnum.Enum1())(v.value0));\n            };\n            throw new Error(\"Failed pattern match at Data.Enum (line 80, column 1 - line 84, column 32): \" + [ v.constructor.name ]);\n        },\n        Ord0: function () {\n            return Data_Maybe.ordMaybe((dictBoundedEnum.Enum1()).Ord0());\n        }\n    };\n};\nvar enumInt = {\n    succ: function (n) {\n        var $68 = n < Data_Bounded.top(Data_Bounded.boundedInt);\n        if ($68) {\n            return new Data_Maybe.Just(n + 1 | 0);\n        };\n        return Data_Maybe.Nothing.value;\n    },\n    pred: function (n) {\n        var $69 = n > Data_Bounded.bottom(Data_Bounded.boundedInt);\n        if ($69) {\n            return new Data_Maybe.Just(n - 1 | 0);\n        };\n        return Data_Maybe.Nothing.value;\n    },\n    Ord0: function () {\n        return Data_Ord.ordInt;\n    }\n};\nvar enumFromTo = function (dictEnum) {\n    return function (dictUnfoldable1) {\n        var go = function (step) {\n            return function (op) {\n                return function (to) {\n                    return function (a) {\n                        return new Data_Tuple.Tuple(a, Control_Bind.bind(Data_Maybe.bindMaybe)(step(a))(function (a$prime) {\n                            return Data_Functor.voidLeft(Data_Maybe.functorMaybe)(Control_Alternative.guard(Data_Maybe.alternativeMaybe)(op(a$prime)(to)))(a$prime);\n                        }));\n                    };\n                };\n            };\n        };\n        return function (v) {\n            return function (v1) {\n                if (Data_Eq.eq((dictEnum.Ord0()).Eq0())(v)(v1)) {\n                    return Data_Unfoldable1.singleton(dictUnfoldable1)(v);\n                };\n                if (Data_Ord.lessThan(dictEnum.Ord0())(v)(v1)) {\n                    return Data_Unfoldable1.unfoldr1(dictUnfoldable1)(go(succ(dictEnum))(Data_Ord.lessThanOrEq(dictEnum.Ord0()))(v1))(v);\n                };\n                if (Data_Boolean.otherwise) {\n                    return Data_Unfoldable1.unfoldr1(dictUnfoldable1)(go(pred(dictEnum))(Data_Ord.greaterThanOrEq(dictEnum.Ord0()))(v1))(v);\n                };\n                throw new Error(\"Failed pattern match at Data.Enum (line 186, column 14 - line 190, column 51): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n    };\n};\nvar enumFromThenTo = function (dictUnfoldable) {\n    return function (dictFunctor) {\n        return function (dictBoundedEnum) {\n            var go = function (step) {\n                return function (to) {\n                    return function (e) {\n                        if (e <= to) {\n                            return new Data_Maybe.Just(new Data_Tuple.Tuple(e, e + step | 0));\n                        };\n                        if (Data_Boolean.otherwise) {\n                            return Data_Maybe.Nothing.value;\n                        };\n                        throw new Error(\"Failed pattern match at Data.Enum (line 217, column 5 - line 219, column 28): \" + [ step.constructor.name, to.constructor.name, e.constructor.name ]);\n                    };\n                };\n            };\n            return function (a) {\n                return function (b) {\n                    return function (c) {\n                        var c$prime = fromEnum(dictBoundedEnum)(c);\n                        var b$prime = fromEnum(dictBoundedEnum)(b);\n                        var a$prime = fromEnum(dictBoundedEnum)(a);\n                        return Data_Functor.map(dictFunctor)((function () {\n                            var $102 = Data_Maybe.fromJust();\n                            var $103 = toEnum(dictBoundedEnum);\n                            return function ($104) {\n                                return $102($103($104));\n                            };\n                        })())(Data_Unfoldable.unfoldr(dictUnfoldable)(go(b$prime - a$prime | 0)(c$prime))(a$prime));\n                    };\n                };\n            };\n        };\n    };\n};\nvar enumEither = function (dictBoundedEnum) {\n    return function (dictBoundedEnum1) {\n        return {\n            succ: function (v) {\n                if (v instanceof Data_Either.Left) {\n                    return Data_Maybe.maybe(new Data_Maybe.Just(new Data_Either.Right(Data_Bounded.bottom(dictBoundedEnum1.Bounded0()))))(function ($105) {\n                        return Data_Maybe.Just.create(Data_Either.Left.create($105));\n                    })(succ(dictBoundedEnum.Enum1())(v.value0));\n                };\n                if (v instanceof Data_Either.Right) {\n                    return Data_Maybe.maybe(Data_Maybe.Nothing.value)(function ($106) {\n                        return Data_Maybe.Just.create(Data_Either.Right.create($106));\n                    })(succ(dictBoundedEnum1.Enum1())(v.value0));\n                };\n                throw new Error(\"Failed pattern match at Data.Enum (line 86, column 1 - line 90, column 69): \" + [ v.constructor.name ]);\n            },\n            pred: function (v) {\n                if (v instanceof Data_Either.Left) {\n                    return Data_Maybe.maybe(Data_Maybe.Nothing.value)(function ($107) {\n                        return Data_Maybe.Just.create(Data_Either.Left.create($107));\n                    })(pred(dictBoundedEnum.Enum1())(v.value0));\n                };\n                if (v instanceof Data_Either.Right) {\n                    return Data_Maybe.maybe(new Data_Maybe.Just(new Data_Either.Left(Data_Bounded.top(dictBoundedEnum.Bounded0()))))(function ($108) {\n                        return Data_Maybe.Just.create(Data_Either.Right.create($108));\n                    })(pred(dictBoundedEnum1.Enum1())(v.value0));\n                };\n                throw new Error(\"Failed pattern match at Data.Enum (line 86, column 1 - line 90, column 69): \" + [ v.constructor.name ]);\n            },\n            Ord0: function () {\n                return Data_Either.ordEither((dictBoundedEnum.Enum1()).Ord0())((dictBoundedEnum1.Enum1()).Ord0());\n            }\n        };\n    };\n};\nvar enumBoolean = {\n    succ: function (v) {\n        if (!v) {\n            return new Data_Maybe.Just(true);\n        };\n        return Data_Maybe.Nothing.value;\n    },\n    pred: function (v) {\n        if (v) {\n            return new Data_Maybe.Just(false);\n        };\n        return Data_Maybe.Nothing.value;\n    },\n    Ord0: function () {\n        return Data_Ord.ordBoolean;\n    }\n};\nvar downFromIncluding = function (dictEnum) {\n    return function (dictUnfoldable1) {\n        return Data_Unfoldable1.unfoldr1(dictUnfoldable1)(Control_Apply.apply(Control_Apply.applyFn)(Data_Tuple.Tuple.create)(pred(dictEnum)));\n    };\n};\nvar diag = function (a) {\n    return new Data_Tuple.Tuple(a, a);\n};\nvar downFrom = function (dictEnum) {\n    return function (dictUnfoldable) {\n        return Data_Unfoldable.unfoldr(dictUnfoldable)((function () {\n            var $109 = Data_Functor.map(Data_Maybe.functorMaybe)(diag);\n            var $110 = pred(dictEnum);\n            return function ($111) {\n                return $109($110($111));\n            };\n        })());\n    };\n};\nvar upFrom = function (dictEnum) {\n    return function (dictUnfoldable) {\n        return Data_Unfoldable.unfoldr(dictUnfoldable)((function () {\n            var $112 = Data_Functor.map(Data_Maybe.functorMaybe)(diag);\n            var $113 = succ(dictEnum);\n            return function ($114) {\n                return $112($113($114));\n            };\n        })());\n    };\n};\nvar defaultToEnum = function (dictBounded) {\n    return function (dictEnum) {\n        return function (i$prime) {\n            var go = function ($copy_i) {\n                return function ($copy_x) {\n                    var $tco_var_i = $copy_i;\n                    var $tco_done = false;\n                    var $tco_result;\n                    function $tco_loop(i, x) {\n                        var $83 = i === 0;\n                        if ($83) {\n                            $tco_done = true;\n                            return new Data_Maybe.Just(x);\n                        };\n                        var v = succ(dictEnum)(x);\n                        if (v instanceof Data_Maybe.Just) {\n                            $tco_var_i = i - 1 | 0;\n                            $copy_x = v.value0;\n                            return;\n                        };\n                        if (v instanceof Data_Maybe.Nothing) {\n                            $tco_done = true;\n                            return Data_Maybe.Nothing.value;\n                        };\n                        throw new Error(\"Failed pattern match at Data.Enum (line 296, column 12 - line 298, column 33): \" + [ v.constructor.name ]);\n                    };\n                    while (!$tco_done) {\n                        $tco_result = $tco_loop($tco_var_i, $copy_x);\n                    };\n                    return $tco_result;\n                };\n            };\n            var $86 = i$prime < 0;\n            if ($86) {\n                return Data_Maybe.Nothing.value;\n            };\n            return go(i$prime)(Data_Bounded.bottom(dictBounded));\n        };\n    };\n};\nvar defaultSucc = function (toEnum$prime) {\n    return function (fromEnum$prime) {\n        return function (a) {\n            return toEnum$prime(fromEnum$prime(a) + 1 | 0);\n        };\n    };\n};\nvar defaultPred = function (toEnum$prime) {\n    return function (fromEnum$prime) {\n        return function (a) {\n            return toEnum$prime(fromEnum$prime(a) - 1 | 0);\n        };\n    };\n};\nvar defaultFromEnum = function (dictEnum) {\n    var go = function ($copy_i) {\n        return function ($copy_x) {\n            var $tco_var_i = $copy_i;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(i, x) {\n                var v = pred(dictEnum)(x);\n                if (v instanceof Data_Maybe.Just) {\n                    $tco_var_i = i + 1 | 0;\n                    $copy_x = v.value0;\n                    return;\n                };\n                if (v instanceof Data_Maybe.Nothing) {\n                    $tco_done = true;\n                    return i;\n                };\n                throw new Error(\"Failed pattern match at Data.Enum (line 309, column 5 - line 311, column 19): \" + [ v.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_i, $copy_x);\n            };\n            return $tco_result;\n        };\n    };\n    return go(0);\n};\nvar defaultCardinality = function (dictBounded) {\n    return function (dictEnum) {\n        var go = function ($copy_i) {\n            return function ($copy_x) {\n                var $tco_var_i = $copy_i;\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(i, x) {\n                    var v = succ(dictEnum)(x);\n                    if (v instanceof Data_Maybe.Just) {\n                        $tco_var_i = i + 1 | 0;\n                        $copy_x = v.value0;\n                        return;\n                    };\n                    if (v instanceof Data_Maybe.Nothing) {\n                        $tco_done = true;\n                        return i;\n                    };\n                    throw new Error(\"Failed pattern match at Data.Enum (line 276, column 5 - line 278, column 19): \" + [ v.constructor.name ]);\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($tco_var_i, $copy_x);\n                };\n                return $tco_result;\n            };\n        };\n        return Cardinality(go(1)(Data_Bounded.bottom(dictBounded)));\n    };\n};\nvar charToEnum = function (v) {\n    if (v >= Data_Bounded.bottom(Data_Bounded.boundedInt) && v <= Data_Bounded.top(Data_Bounded.boundedInt)) {\n        return new Data_Maybe.Just($foreign.fromCharCode(v));\n    };\n    return Data_Maybe.Nothing.value;\n};\nvar enumChar = {\n    succ: defaultSucc(charToEnum)($foreign.toCharCode),\n    pred: defaultPred(charToEnum)($foreign.toCharCode),\n    Ord0: function () {\n        return Data_Ord.ordChar;\n    }\n};\nvar cardinality = function (dict) {\n    return dict.cardinality;\n};\nvar boundedEnumUnit = {\n    cardinality: 1,\n    toEnum: function (v) {\n        if (v === 0) {\n            return new Data_Maybe.Just(Data_Unit.unit);\n        };\n        return Data_Maybe.Nothing.value;\n    },\n    fromEnum: Data_Function[\"const\"](0),\n    Bounded0: function () {\n        return Data_Bounded.boundedUnit;\n    },\n    Enum1: function () {\n        return enumUnit;\n    }\n};\nvar boundedEnumOrdering = {\n    cardinality: 3,\n    toEnum: function (v) {\n        if (v === 0) {\n            return new Data_Maybe.Just(Data_Ordering.LT.value);\n        };\n        if (v === 1) {\n            return new Data_Maybe.Just(Data_Ordering.EQ.value);\n        };\n        if (v === 2) {\n            return new Data_Maybe.Just(Data_Ordering.GT.value);\n        };\n        return Data_Maybe.Nothing.value;\n    },\n    fromEnum: function (v) {\n        if (v instanceof Data_Ordering.LT) {\n            return 0;\n        };\n        if (v instanceof Data_Ordering.EQ) {\n            return 1;\n        };\n        if (v instanceof Data_Ordering.GT) {\n            return 2;\n        };\n        throw new Error(\"Failed pattern match at Data.Enum (line 137, column 1 - line 145, column 18): \" + [ v.constructor.name ]);\n    },\n    Bounded0: function () {\n        return Data_Bounded.boundedOrdering;\n    },\n    Enum1: function () {\n        return enumOrdering;\n    }\n};\nvar boundedEnumChar = {\n    cardinality: $foreign.toCharCode(Data_Bounded.top(Data_Bounded.boundedChar)) - $foreign.toCharCode(Data_Bounded.bottom(Data_Bounded.boundedChar)) | 0,\n    toEnum: charToEnum,\n    fromEnum: $foreign.toCharCode,\n    Bounded0: function () {\n        return Data_Bounded.boundedChar;\n    },\n    Enum1: function () {\n        return enumChar;\n    }\n};\nvar boundedEnumBoolean = {\n    cardinality: 2,\n    toEnum: function (v) {\n        if (v === 0) {\n            return new Data_Maybe.Just(false);\n        };\n        if (v === 1) {\n            return new Data_Maybe.Just(true);\n        };\n        return Data_Maybe.Nothing.value;\n    },\n    fromEnum: function (v) {\n        if (!v) {\n            return 0;\n        };\n        if (v) {\n            return 1;\n        };\n        throw new Error(\"Failed pattern match at Data.Enum (line 118, column 1 - line 124, column 20): \" + [ v.constructor.name ]);\n    },\n    Bounded0: function () {\n        return Data_Bounded.boundedBoolean;\n    },\n    Enum1: function () {\n        return enumBoolean;\n    }\n};\nmodule.exports = {\n    succ: succ,\n    pred: pred,\n    cardinality: cardinality,\n    toEnum: toEnum,\n    fromEnum: fromEnum,\n    toEnumWithDefaults: toEnumWithDefaults,\n    Cardinality: Cardinality,\n    enumFromTo: enumFromTo,\n    enumFromThenTo: enumFromThenTo,\n    upFrom: upFrom,\n    upFromIncluding: upFromIncluding,\n    downFrom: downFrom,\n    downFromIncluding: downFromIncluding,\n    defaultSucc: defaultSucc,\n    defaultPred: defaultPred,\n    defaultCardinality: defaultCardinality,\n    defaultToEnum: defaultToEnum,\n    defaultFromEnum: defaultFromEnum,\n    enumBoolean: enumBoolean,\n    enumInt: enumInt,\n    enumChar: enumChar,\n    enumUnit: enumUnit,\n    enumOrdering: enumOrdering,\n    enumMaybe: enumMaybe,\n    enumEither: enumEither,\n    enumTuple: enumTuple,\n    boundedEnumBoolean: boundedEnumBoolean,\n    boundedEnumChar: boundedEnumChar,\n    boundedEnumUnit: boundedEnumUnit,\n    boundedEnumOrdering: boundedEnumOrdering,\n    newtypeCardinality: newtypeCardinality,\n    eqCardinality: eqCardinality,\n    ordCardinality: ordCardinality,\n    showCardinality: showCardinality\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/enums/v5.0.0/src/Data/Enum.purs?");

/***/ }),

/***/ "./.spago/exceptions/v5.0.0/src/Effect/Exception.purs":
/*!************************************************************!*\
  !*** ./.spago/exceptions/v5.0.0/src/Effect/Exception.purs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/exceptions/v5.0.0/src/Effect/Exception.js */ \"./.spago/exceptions/v5.0.0/src/Effect/Exception.js\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Effect = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect.purs */ \"./.spago/effect/v3.0.0/src/Effect.purs\");\nvar $$try = function (action) {\n    return $foreign.catchException((function () {\n        var $0 = Control_Applicative.pure(Effect.applicativeEffect);\n        return function ($1) {\n            return $0(Data_Either.Left.create($1));\n        };\n    })())(Data_Functor.map(Effect.functorEffect)(Data_Either.Right.create)(action));\n};\nvar $$throw = function ($2) {\n    return $foreign.throwException($foreign.error($2));\n};\nvar stack = $foreign.stackImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar showError = {\n    show: $foreign.showErrorImpl\n};\nmodule.exports = {\n    stack: stack,\n    \"throw\": $$throw,\n    \"try\": $$try,\n    showError: showError,\n    error: $foreign.error,\n    message: $foreign.message,\n    name: $foreign.name,\n    throwException: $foreign.throwException,\n    catchException: $foreign.catchException\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/exceptions/v5.0.0/src/Effect/Exception.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/Bifoldable.purs":
/*!*********************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/Bifoldable.purs ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Monoid_Conj = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs\");\nvar Data_Monoid_Disj = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs\");\nvar Data_Monoid_Dual = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs\");\nvar Data_Monoid_Endo = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar bifoldr = function (dict) {\n    return dict.bifoldr;\n};\nvar bitraverse_ = function (dictBifoldable) {\n    return function (dictApplicative) {\n        return function (f) {\n            return function (g) {\n                return bifoldr(dictBifoldable)((function () {\n                    var $150 = Control_Apply.applySecond(dictApplicative.Apply0());\n                    return function ($151) {\n                        return $150(f($151));\n                    };\n                })())((function () {\n                    var $152 = Control_Apply.applySecond(dictApplicative.Apply0());\n                    return function ($153) {\n                        return $152(g($153));\n                    };\n                })())(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));\n            };\n        };\n    };\n};\nvar bifor_ = function (dictBifoldable) {\n    return function (dictApplicative) {\n        return function (t) {\n            return function (f) {\n                return function (g) {\n                    return bitraverse_(dictBifoldable)(dictApplicative)(f)(g)(t);\n                };\n            };\n        };\n    };\n};\nvar bisequence_ = function (dictBifoldable) {\n    return function (dictApplicative) {\n        return bitraverse_(dictBifoldable)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn))(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar bifoldl = function (dict) {\n    return dict.bifoldl;\n};\nvar bifoldableTuple = {\n    bifoldMap: function (dictMonoid) {\n        return function (f) {\n            return function (g) {\n                return function (v) {\n                    return Data_Semigroup.append(dictMonoid.Semigroup0())(f(v.value0))(g(v.value1));\n                };\n            };\n        };\n    },\n    bifoldr: function (f) {\n        return function (g) {\n            return function (z) {\n                return function (v) {\n                    return f(v.value0)(g(v.value1)(z));\n                };\n            };\n        };\n    },\n    bifoldl: function (f) {\n        return function (g) {\n            return function (z) {\n                return function (v) {\n                    return g(f(z)(v.value0))(v.value1);\n                };\n            };\n        };\n    }\n};\nvar bifoldableJoker = function (dictFoldable) {\n    return {\n        bifoldr: function (v) {\n            return function (r) {\n                return function (u) {\n                    return function (v1) {\n                        return Data_Foldable.foldr(dictFoldable)(r)(u)(v1);\n                    };\n                };\n            };\n        },\n        bifoldl: function (v) {\n            return function (r) {\n                return function (u) {\n                    return function (v1) {\n                        return Data_Foldable.foldl(dictFoldable)(r)(u)(v1);\n                    };\n                };\n            };\n        },\n        bifoldMap: function (dictMonoid) {\n            return function (v) {\n                return function (r) {\n                    return function (v1) {\n                        return Data_Foldable.foldMap(dictFoldable)(dictMonoid)(r)(v1);\n                    };\n                };\n            };\n        }\n    };\n};\nvar bifoldableEither = {\n    bifoldr: function (v) {\n        return function (v1) {\n            return function (z) {\n                return function (v2) {\n                    if (v2 instanceof Data_Either.Left) {\n                        return v(v2.value0)(z);\n                    };\n                    if (v2 instanceof Data_Either.Right) {\n                        return v1(v2.value0)(z);\n                    };\n                    throw new Error(\"Failed pattern match at Data.Bifoldable (line 62, column 1 - line 68, column 32): \" + [ v.constructor.name, v1.constructor.name, z.constructor.name, v2.constructor.name ]);\n                };\n            };\n        };\n    },\n    bifoldl: function (v) {\n        return function (v1) {\n            return function (z) {\n                return function (v2) {\n                    if (v2 instanceof Data_Either.Left) {\n                        return v(z)(v2.value0);\n                    };\n                    if (v2 instanceof Data_Either.Right) {\n                        return v1(z)(v2.value0);\n                    };\n                    throw new Error(\"Failed pattern match at Data.Bifoldable (line 62, column 1 - line 68, column 32): \" + [ v.constructor.name, v1.constructor.name, z.constructor.name, v2.constructor.name ]);\n                };\n            };\n        };\n    },\n    bifoldMap: function (dictMonoid) {\n        return function (v) {\n            return function (v1) {\n                return function (v2) {\n                    if (v2 instanceof Data_Either.Left) {\n                        return v(v2.value0);\n                    };\n                    if (v2 instanceof Data_Either.Right) {\n                        return v1(v2.value0);\n                    };\n                    throw new Error(\"Failed pattern match at Data.Bifoldable (line 62, column 1 - line 68, column 32): \" + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);\n                };\n            };\n        };\n    }\n};\nvar bifoldableConst = {\n    bifoldr: function (f) {\n        return function (v) {\n            return function (z) {\n                return function (v1) {\n                    return f(v1)(z);\n                };\n            };\n        };\n    },\n    bifoldl: function (f) {\n        return function (v) {\n            return function (z) {\n                return function (v1) {\n                    return f(z)(v1);\n                };\n            };\n        };\n    },\n    bifoldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return function (v1) {\n                    return f(v1);\n                };\n            };\n        };\n    }\n};\nvar bifoldableClown = function (dictFoldable) {\n    return {\n        bifoldr: function (l) {\n            return function (v) {\n                return function (u) {\n                    return function (v1) {\n                        return Data_Foldable.foldr(dictFoldable)(l)(u)(v1);\n                    };\n                };\n            };\n        },\n        bifoldl: function (l) {\n            return function (v) {\n                return function (u) {\n                    return function (v1) {\n                        return Data_Foldable.foldl(dictFoldable)(l)(u)(v1);\n                    };\n                };\n            };\n        },\n        bifoldMap: function (dictMonoid) {\n            return function (l) {\n                return function (v) {\n                    return function (v1) {\n                        return Data_Foldable.foldMap(dictFoldable)(dictMonoid)(l)(v1);\n                    };\n                };\n            };\n        }\n    };\n};\nvar bifoldMapDefaultR = function (dictBifoldable) {\n    return function (dictMonoid) {\n        return function (f) {\n            return function (g) {\n                return bifoldr(dictBifoldable)((function () {\n                    var $154 = Data_Semigroup.append(dictMonoid.Semigroup0());\n                    return function ($155) {\n                        return $154(f($155));\n                    };\n                })())((function () {\n                    var $156 = Data_Semigroup.append(dictMonoid.Semigroup0());\n                    return function ($157) {\n                        return $156(g($157));\n                    };\n                })())(Data_Monoid.mempty(dictMonoid));\n            };\n        };\n    };\n};\nvar bifoldMapDefaultL = function (dictBifoldable) {\n    return function (dictMonoid) {\n        return function (f) {\n            return function (g) {\n                return bifoldl(dictBifoldable)(function (m) {\n                    return function (a) {\n                        return Data_Semigroup.append(dictMonoid.Semigroup0())(m)(f(a));\n                    };\n                })(function (m) {\n                    return function (b) {\n                        return Data_Semigroup.append(dictMonoid.Semigroup0())(m)(g(b));\n                    };\n                })(Data_Monoid.mempty(dictMonoid));\n            };\n        };\n    };\n};\nvar bifoldMap = function (dict) {\n    return dict.bifoldMap;\n};\nvar bifoldableFlip = function (dictBifoldable) {\n    return {\n        bifoldr: function (r) {\n            return function (l) {\n                return function (u) {\n                    return function (v) {\n                        return bifoldr(dictBifoldable)(l)(r)(u)(v);\n                    };\n                };\n            };\n        },\n        bifoldl: function (r) {\n            return function (l) {\n                return function (u) {\n                    return function (v) {\n                        return bifoldl(dictBifoldable)(l)(r)(u)(v);\n                    };\n                };\n            };\n        },\n        bifoldMap: function (dictMonoid) {\n            return function (r) {\n                return function (l) {\n                    return function (v) {\n                        return bifoldMap(dictBifoldable)(dictMonoid)(l)(r)(v);\n                    };\n                };\n            };\n        }\n    };\n};\nvar bifoldlDefault = function (dictBifoldable) {\n    return function (f) {\n        return function (g) {\n            return function (z) {\n                return function (p) {\n                    return Data_Newtype.unwrap()(Data_Newtype.unwrap()(bifoldMap(dictBifoldable)(Data_Monoid_Dual.monoidDual(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn)))((function () {\n                        var $158 = Data_Function.flip(f);\n                        return function ($159) {\n                            return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo($158($159)));\n                        };\n                    })())((function () {\n                        var $160 = Data_Function.flip(g);\n                        return function ($161) {\n                            return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo($160($161)));\n                        };\n                    })())(p)))(z);\n                };\n            };\n        };\n    };\n};\nvar bifoldrDefault = function (dictBifoldable) {\n    return function (f) {\n        return function (g) {\n            return function (z) {\n                return function (p) {\n                    return Data_Newtype.unwrap()(bifoldMap(dictBifoldable)(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn))(function ($162) {\n                        return Data_Monoid_Endo.Endo(f($162));\n                    })(function ($163) {\n                        return Data_Monoid_Endo.Endo(g($163));\n                    })(p))(z);\n                };\n            };\n        };\n    };\n};\nvar bifoldableProduct2 = function (dictBifoldable) {\n    return function (dictBifoldable1) {\n        return {\n            bifoldr: function (l) {\n                return function (r) {\n                    return function (u) {\n                        return function (m) {\n                            return bifoldrDefault(bifoldableProduct2(dictBifoldable)(dictBifoldable1))(l)(r)(u)(m);\n                        };\n                    };\n                };\n            },\n            bifoldl: function (l) {\n                return function (r) {\n                    return function (u) {\n                        return function (m) {\n                            return bifoldlDefault(bifoldableProduct2(dictBifoldable)(dictBifoldable1))(l)(r)(u)(m);\n                        };\n                    };\n                };\n            },\n            bifoldMap: function (dictMonoid) {\n                return function (l) {\n                    return function (r) {\n                        return function (v) {\n                            return Data_Semigroup.append(dictMonoid.Semigroup0())(bifoldMap(dictBifoldable)(dictMonoid)(l)(r)(v.value0))(bifoldMap(dictBifoldable1)(dictMonoid)(l)(r)(v.value1));\n                        };\n                    };\n                };\n            }\n        };\n    };\n};\nvar bifold = function (dictBifoldable) {\n    return function (dictMonoid) {\n        return bifoldMap(dictBifoldable)(dictMonoid)(Control_Category.identity(Control_Category.categoryFn))(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar biany = function (dictBifoldable) {\n    return function (dictBooleanAlgebra) {\n        return function (p) {\n            return function (q) {\n                var $164 = Data_Newtype.unwrap();\n                var $165 = bifoldMap(dictBifoldable)(Data_Monoid_Disj.monoidDisj(dictBooleanAlgebra.HeytingAlgebra0()))(function ($167) {\n                    return Data_Monoid_Disj.Disj(p($167));\n                })(function ($168) {\n                    return Data_Monoid_Disj.Disj(q($168));\n                });\n                return function ($166) {\n                    return $164($165($166));\n                };\n            };\n        };\n    };\n};\nvar biall = function (dictBifoldable) {\n    return function (dictBooleanAlgebra) {\n        return function (p) {\n            return function (q) {\n                var $169 = Data_Newtype.unwrap();\n                var $170 = bifoldMap(dictBifoldable)(Data_Monoid_Conj.monoidConj(dictBooleanAlgebra.HeytingAlgebra0()))(function ($172) {\n                    return Data_Monoid_Conj.Conj(p($172));\n                })(function ($173) {\n                    return Data_Monoid_Conj.Conj(q($173));\n                });\n                return function ($171) {\n                    return $169($170($171));\n                };\n            };\n        };\n    };\n};\nmodule.exports = {\n    bifoldMap: bifoldMap,\n    bifoldl: bifoldl,\n    bifoldr: bifoldr,\n    bifoldrDefault: bifoldrDefault,\n    bifoldlDefault: bifoldlDefault,\n    bifoldMapDefaultR: bifoldMapDefaultR,\n    bifoldMapDefaultL: bifoldMapDefaultL,\n    bifold: bifold,\n    bitraverse_: bitraverse_,\n    bifor_: bifor_,\n    bisequence_: bisequence_,\n    biany: biany,\n    biall: biall,\n    bifoldableClown: bifoldableClown,\n    bifoldableJoker: bifoldableJoker,\n    bifoldableFlip: bifoldableFlip,\n    bifoldableProduct2: bifoldableProduct2,\n    bifoldableEither: bifoldableEither,\n    bifoldableTuple: bifoldableTuple,\n    bifoldableConst: bifoldableConst\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/Bifoldable.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/Bitraversable.purs":
/*!************************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/Bitraversable.purs ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Bifoldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Bifoldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Bifoldable.purs\");\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Const = __webpack_require__(/*! ./.spago/const/v5.0.0/src/Data/Const.purs */ \"./.spago/const/v5.0.0/src/Data/Const.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Functor_Clown = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Clown.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Clown.purs\");\nvar Data_Functor_Flip = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Flip.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Flip.purs\");\nvar Data_Functor_Joker = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Joker.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Joker.purs\");\nvar Data_Functor_Product2 = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Product2.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Product2.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar bitraverse = function (dict) {\n    return dict.bitraverse;\n};\nvar lfor = function (dictBitraversable) {\n    return function (dictApplicative) {\n        return function (t) {\n            return function (f) {\n                return bitraverse(dictBitraversable)(dictApplicative)(f)(Control_Applicative.pure(dictApplicative))(t);\n            };\n        };\n    };\n};\nvar ltraverse = function (dictBitraversable) {\n    return function (dictApplicative) {\n        return function (f) {\n            return bitraverse(dictBitraversable)(dictApplicative)(f)(Control_Applicative.pure(dictApplicative));\n        };\n    };\n};\nvar rfor = function (dictBitraversable) {\n    return function (dictApplicative) {\n        return function (t) {\n            return function (f) {\n                return bitraverse(dictBitraversable)(dictApplicative)(Control_Applicative.pure(dictApplicative))(f)(t);\n            };\n        };\n    };\n};\nvar rtraverse = function (dictBitraversable) {\n    return function (dictApplicative) {\n        return bitraverse(dictBitraversable)(dictApplicative)(Control_Applicative.pure(dictApplicative));\n    };\n};\nvar bitraversableTuple = {\n    bitraverse: function (dictApplicative) {\n        return function (f) {\n            return function (g) {\n                return function (v) {\n                    return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Tuple.Tuple.create)(f(v.value0)))(g(v.value1));\n                };\n            };\n        };\n    },\n    bisequence: function (dictApplicative) {\n        return function (v) {\n            return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Tuple.Tuple.create)(v.value0))(v.value1);\n        };\n    },\n    Bifunctor0: function () {\n        return Data_Bifunctor.bifunctorTuple;\n    },\n    Bifoldable1: function () {\n        return Data_Bifoldable.bifoldableTuple;\n    }\n};\nvar bitraversableJoker = function (dictTraversable) {\n    return {\n        bitraverse: function (dictApplicative) {\n            return function (v) {\n                return function (r) {\n                    return function (v1) {\n                        return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_Joker.Joker)(Data_Traversable.traverse(dictTraversable)(dictApplicative)(r)(v1));\n                    };\n                };\n            };\n        },\n        bisequence: function (dictApplicative) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_Joker.Joker)(Data_Traversable.sequence(dictTraversable)(dictApplicative)(v));\n            };\n        },\n        Bifunctor0: function () {\n            return Data_Functor_Joker.bifunctorJoker(dictTraversable.Functor0());\n        },\n        Bifoldable1: function () {\n            return Data_Bifoldable.bifoldableJoker(dictTraversable.Foldable1());\n        }\n    };\n};\nvar bitraversableEither = {\n    bitraverse: function (dictApplicative) {\n        return function (v) {\n            return function (v1) {\n                return function (v2) {\n                    if (v2 instanceof Data_Either.Left) {\n                        return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Either.Left.create)(v(v2.value0));\n                    };\n                    if (v2 instanceof Data_Either.Right) {\n                        return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Either.Right.create)(v1(v2.value0));\n                    };\n                    throw new Error(\"Failed pattern match at Data.Bitraversable (line 57, column 1 - line 61, column 37): \" + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);\n                };\n            };\n        };\n    },\n    bisequence: function (dictApplicative) {\n        return function (v) {\n            if (v instanceof Data_Either.Left) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Either.Left.create)(v.value0);\n            };\n            if (v instanceof Data_Either.Right) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Either.Right.create)(v.value0);\n            };\n            throw new Error(\"Failed pattern match at Data.Bitraversable (line 57, column 1 - line 61, column 37): \" + [ v.constructor.name ]);\n        };\n    },\n    Bifunctor0: function () {\n        return Data_Bifunctor.bifunctorEither;\n    },\n    Bifoldable1: function () {\n        return Data_Bifoldable.bifoldableEither;\n    }\n};\nvar bitraversableConst = {\n    bitraverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return function (v1) {\n                    return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Const.Const)(f(v1));\n                };\n            };\n        };\n    },\n    bisequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Const.Const)(v);\n        };\n    },\n    Bifunctor0: function () {\n        return Data_Bifunctor.bifunctorConst;\n    },\n    Bifoldable1: function () {\n        return Data_Bifoldable.bifoldableConst;\n    }\n};\nvar bitraversableClown = function (dictTraversable) {\n    return {\n        bitraverse: function (dictApplicative) {\n            return function (l) {\n                return function (v) {\n                    return function (v1) {\n                        return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_Clown.Clown)(Data_Traversable.traverse(dictTraversable)(dictApplicative)(l)(v1));\n                    };\n                };\n            };\n        },\n        bisequence: function (dictApplicative) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_Clown.Clown)(Data_Traversable.sequence(dictTraversable)(dictApplicative)(v));\n            };\n        },\n        Bifunctor0: function () {\n            return Data_Functor_Clown.bifunctorClown(dictTraversable.Functor0());\n        },\n        Bifoldable1: function () {\n            return Data_Bifoldable.bifoldableClown(dictTraversable.Foldable1());\n        }\n    };\n};\nvar bisequenceDefault = function (dictBitraversable) {\n    return function (dictApplicative) {\n        return bitraverse(dictBitraversable)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn))(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar bisequence = function (dict) {\n    return dict.bisequence;\n};\nvar bitraversableFlip = function (dictBitraversable) {\n    return {\n        bitraverse: function (dictApplicative) {\n            return function (r) {\n                return function (l) {\n                    return function (v) {\n                        return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_Flip.Flip)(bitraverse(dictBitraversable)(dictApplicative)(l)(r)(v));\n                    };\n                };\n            };\n        },\n        bisequence: function (dictApplicative) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_Flip.Flip)(bisequence(dictBitraversable)(dictApplicative)(v));\n            };\n        },\n        Bifunctor0: function () {\n            return Data_Functor_Flip.bifunctorFlip(dictBitraversable.Bifunctor0());\n        },\n        Bifoldable1: function () {\n            return Data_Bifoldable.bifoldableFlip(dictBitraversable.Bifoldable1());\n        }\n    };\n};\nvar bitraversableProduct2 = function (dictBitraversable) {\n    return function (dictBitraversable1) {\n        return {\n            bitraverse: function (dictApplicative) {\n                return function (l) {\n                    return function (r) {\n                        return function (v) {\n                            return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_Product2.Product2.create)(bitraverse(dictBitraversable)(dictApplicative)(l)(r)(v.value0)))(bitraverse(dictBitraversable1)(dictApplicative)(l)(r)(v.value1));\n                        };\n                    };\n                };\n            },\n            bisequence: function (dictApplicative) {\n                return function (v) {\n                    return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_Product2.Product2.create)(bisequence(dictBitraversable)(dictApplicative)(v.value0)))(bisequence(dictBitraversable1)(dictApplicative)(v.value1));\n                };\n            },\n            Bifunctor0: function () {\n                return Data_Functor_Product2.bifunctorProduct2(dictBitraversable.Bifunctor0())(dictBitraversable1.Bifunctor0());\n            },\n            Bifoldable1: function () {\n                return Data_Bifoldable.bifoldableProduct2(dictBitraversable.Bifoldable1())(dictBitraversable1.Bifoldable1());\n            }\n        };\n    };\n};\nvar bitraverseDefault = function (dictBitraversable) {\n    return function (dictApplicative) {\n        return function (f) {\n            return function (g) {\n                return function (t) {\n                    return bisequence(dictBitraversable)(dictApplicative)(Data_Bifunctor.bimap(dictBitraversable.Bifunctor0())(f)(g)(t));\n                };\n            };\n        };\n    };\n};\nvar bifor = function (dictBitraversable) {\n    return function (dictApplicative) {\n        return function (t) {\n            return function (f) {\n                return function (g) {\n                    return bitraverse(dictBitraversable)(dictApplicative)(f)(g)(t);\n                };\n            };\n        };\n    };\n};\nmodule.exports = {\n    bitraverse: bitraverse,\n    bisequence: bisequence,\n    bitraverseDefault: bitraverseDefault,\n    bisequenceDefault: bisequenceDefault,\n    ltraverse: ltraverse,\n    rtraverse: rtraverse,\n    bifor: bifor,\n    lfor: lfor,\n    rfor: rfor,\n    bitraversableClown: bitraversableClown,\n    bitraversableJoker: bitraversableJoker,\n    bitraversableFlip: bitraversableFlip,\n    bitraversableProduct2: bitraversableProduct2,\n    bitraversableEither: bitraversableEither,\n    bitraversableTuple: bitraversableTuple,\n    bitraversableConst: bitraversableConst,\n    biall: Data_Bifoldable.biall,\n    biany: Data_Bifoldable.biany,\n    bifold: Data_Bifoldable.bifold,\n    bifoldMap: Data_Bifoldable.bifoldMap,\n    bifoldMapDefaultL: Data_Bifoldable.bifoldMapDefaultL,\n    bifoldMapDefaultR: Data_Bifoldable.bifoldMapDefaultR,\n    bifoldl: Data_Bifoldable.bifoldl,\n    bifoldlDefault: Data_Bifoldable.bifoldlDefault,\n    bifoldr: Data_Bifoldable.bifoldr,\n    bifoldrDefault: Data_Bifoldable.bifoldrDefault,\n    bifor_: Data_Bifoldable.bifor_,\n    bisequence_: Data_Bifoldable.bisequence_,\n    bitraverse_: Data_Bifoldable.bitraverse_\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/Bitraversable.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs":
/*!*******************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.js */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.js\");\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Plus = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Plus.purs */ \"./.spago/control/v5.0.0/src/Control/Plus.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor_Coproduct = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Maybe_First = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe/First.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe/First.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Monoid_Conj = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs\");\nvar Data_Monoid_Disj = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs\");\nvar Data_Monoid_Dual = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs\");\nvar Data_Monoid_Endo = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar foldr = function (dict) {\n    return dict.foldr;\n};\nvar indexr = function (dictFoldable) {\n    return function (idx) {\n        var go = function (a) {\n            return function (cursor) {\n                if (cursor.elem instanceof Data_Maybe.Just) {\n                    return cursor;\n                };\n                var $153 = cursor.pos === idx;\n                if ($153) {\n                    return {\n                        elem: new Data_Maybe.Just(a),\n                        pos: cursor.pos\n                    };\n                };\n                return {\n                    pos: cursor.pos + 1 | 0,\n                    elem: cursor.elem\n                };\n            };\n        };\n        var $312 = foldr(dictFoldable)(go)({\n            elem: Data_Maybe.Nothing.value,\n            pos: 0\n        });\n        return function ($313) {\n            return (function (v) {\n                return v.elem;\n            })($312($313));\n        };\n    };\n};\nvar $$null = function (dictFoldable) {\n    return foldr(dictFoldable)(function (v) {\n        return function (v1) {\n            return false;\n        };\n    })(true);\n};\nvar oneOf = function (dictFoldable) {\n    return function (dictPlus) {\n        return foldr(dictFoldable)(Control_Alt.alt(dictPlus.Alt0()))(Control_Plus.empty(dictPlus));\n    };\n};\nvar oneOfMap = function (dictFoldable) {\n    return function (dictPlus) {\n        return function (f) {\n            return foldr(dictFoldable)((function () {\n                var $314 = Control_Alt.alt(dictPlus.Alt0());\n                return function ($315) {\n                    return $314(f($315));\n                };\n            })())(Control_Plus.empty(dictPlus));\n        };\n    };\n};\nvar traverse_ = function (dictApplicative) {\n    return function (dictFoldable) {\n        return function (f) {\n            return foldr(dictFoldable)((function () {\n                var $316 = Control_Apply.applySecond(dictApplicative.Apply0());\n                return function ($317) {\n                    return $316(f($317));\n                };\n            })())(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));\n        };\n    };\n};\nvar for_ = function (dictApplicative) {\n    return function (dictFoldable) {\n        return Data_Function.flip(traverse_(dictApplicative)(dictFoldable));\n    };\n};\nvar sequence_ = function (dictApplicative) {\n    return function (dictFoldable) {\n        return traverse_(dictApplicative)(dictFoldable)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar foldl = function (dict) {\n    return dict.foldl;\n};\nvar indexl = function (dictFoldable) {\n    return function (idx) {\n        var go = function (cursor) {\n            return function (a) {\n                if (cursor.elem instanceof Data_Maybe.Just) {\n                    return cursor;\n                };\n                var $157 = cursor.pos === idx;\n                if ($157) {\n                    return {\n                        elem: new Data_Maybe.Just(a),\n                        pos: cursor.pos\n                    };\n                };\n                return {\n                    pos: cursor.pos + 1 | 0,\n                    elem: cursor.elem\n                };\n            };\n        };\n        var $318 = foldl(dictFoldable)(go)({\n            elem: Data_Maybe.Nothing.value,\n            pos: 0\n        });\n        return function ($319) {\n            return (function (v) {\n                return v.elem;\n            })($318($319));\n        };\n    };\n};\nvar intercalate = function (dictFoldable) {\n    return function (dictMonoid) {\n        return function (sep) {\n            return function (xs) {\n                var go = function (v) {\n                    return function (x) {\n                        if (v.init) {\n                            return {\n                                init: false,\n                                acc: x\n                            };\n                        };\n                        return {\n                            init: false,\n                            acc: Data_Semigroup.append(dictMonoid.Semigroup0())(v.acc)(Data_Semigroup.append(dictMonoid.Semigroup0())(sep)(x))\n                        };\n                    };\n                };\n                return (foldl(dictFoldable)(go)({\n                    init: true,\n                    acc: Data_Monoid.mempty(dictMonoid)\n                })(xs)).acc;\n            };\n        };\n    };\n};\nvar length = function (dictFoldable) {\n    return function (dictSemiring) {\n        return foldl(dictFoldable)(function (c) {\n            return function (v) {\n                return Data_Semiring.add(dictSemiring)(Data_Semiring.one(dictSemiring))(c);\n            };\n        })(Data_Semiring.zero(dictSemiring));\n    };\n};\nvar maximumBy = function (dictFoldable) {\n    return function (cmp) {\n        var max$prime = function (v) {\n            return function (v1) {\n                if (v instanceof Data_Maybe.Nothing) {\n                    return new Data_Maybe.Just(v1);\n                };\n                if (v instanceof Data_Maybe.Just) {\n                    return new Data_Maybe.Just((function () {\n                        var $164 = Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(v.value0)(v1))(Data_Ordering.GT.value);\n                        if ($164) {\n                            return v.value0;\n                        };\n                        return v1;\n                    })());\n                };\n                throw new Error(\"Failed pattern match at Data.Foldable (line 441, column 3 - line 441, column 27): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n        return foldl(dictFoldable)(max$prime)(Data_Maybe.Nothing.value);\n    };\n};\nvar maximum = function (dictOrd) {\n    return function (dictFoldable) {\n        return maximumBy(dictFoldable)(Data_Ord.compare(dictOrd));\n    };\n};\nvar minimumBy = function (dictFoldable) {\n    return function (cmp) {\n        var min$prime = function (v) {\n            return function (v1) {\n                if (v instanceof Data_Maybe.Nothing) {\n                    return new Data_Maybe.Just(v1);\n                };\n                if (v instanceof Data_Maybe.Just) {\n                    return new Data_Maybe.Just((function () {\n                        var $168 = Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(v.value0)(v1))(Data_Ordering.LT.value);\n                        if ($168) {\n                            return v.value0;\n                        };\n                        return v1;\n                    })());\n                };\n                throw new Error(\"Failed pattern match at Data.Foldable (line 454, column 3 - line 454, column 27): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n        return foldl(dictFoldable)(min$prime)(Data_Maybe.Nothing.value);\n    };\n};\nvar minimum = function (dictOrd) {\n    return function (dictFoldable) {\n        return minimumBy(dictFoldable)(Data_Ord.compare(dictOrd));\n    };\n};\nvar product = function (dictFoldable) {\n    return function (dictSemiring) {\n        return foldl(dictFoldable)(Data_Semiring.mul(dictSemiring))(Data_Semiring.one(dictSemiring));\n    };\n};\nvar sum = function (dictFoldable) {\n    return function (dictSemiring) {\n        return foldl(dictFoldable)(Data_Semiring.add(dictSemiring))(Data_Semiring.zero(dictSemiring));\n    };\n};\nvar foldableTuple = {\n    foldr: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(v.value1)(z);\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(z)(v.value1);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return f(v.value1);\n            };\n        };\n    }\n};\nvar foldableMultiplicative = {\n    foldr: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(v)(z);\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(z)(v);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return f(v);\n            };\n        };\n    }\n};\nvar foldableMaybe = {\n    foldr: function (v) {\n        return function (z) {\n            return function (v1) {\n                if (v1 instanceof Data_Maybe.Nothing) {\n                    return z;\n                };\n                if (v1 instanceof Data_Maybe.Just) {\n                    return v(v1.value0)(z);\n                };\n                throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    foldl: function (v) {\n        return function (z) {\n            return function (v1) {\n                if (v1 instanceof Data_Maybe.Nothing) {\n                    return z;\n                };\n                if (v1 instanceof Data_Maybe.Just) {\n                    return v(z)(v1.value0);\n                };\n                throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (v) {\n            return function (v1) {\n                if (v1 instanceof Data_Maybe.Nothing) {\n                    return Data_Monoid.mempty(dictMonoid);\n                };\n                if (v1 instanceof Data_Maybe.Just) {\n                    return v(v1.value0);\n                };\n                throw new Error(\"Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n    }\n};\nvar foldableIdentity = {\n    foldr: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(v)(z);\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(z)(v);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return f(v);\n            };\n        };\n    }\n};\nvar foldableEither = {\n    foldr: function (v) {\n        return function (z) {\n            return function (v1) {\n                if (v1 instanceof Data_Either.Left) {\n                    return z;\n                };\n                if (v1 instanceof Data_Either.Right) {\n                    return v(v1.value0)(z);\n                };\n                throw new Error(\"Failed pattern match at Data.Foldable (line 181, column 1 - line 187, column 28): \" + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    foldl: function (v) {\n        return function (z) {\n            return function (v1) {\n                if (v1 instanceof Data_Either.Left) {\n                    return z;\n                };\n                if (v1 instanceof Data_Either.Right) {\n                    return v(z)(v1.value0);\n                };\n                throw new Error(\"Failed pattern match at Data.Foldable (line 181, column 1 - line 187, column 28): \" + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (v) {\n            return function (v1) {\n                if (v1 instanceof Data_Either.Left) {\n                    return Data_Monoid.mempty(dictMonoid);\n                };\n                if (v1 instanceof Data_Either.Right) {\n                    return v(v1.value0);\n                };\n                throw new Error(\"Failed pattern match at Data.Foldable (line 181, column 1 - line 187, column 28): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n    }\n};\nvar foldableDual = {\n    foldr: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(v)(z);\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(z)(v);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return f(v);\n            };\n        };\n    }\n};\nvar foldableDisj = {\n    foldr: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(v)(z);\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(z)(v);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return f(v);\n            };\n        };\n    }\n};\nvar foldableConst = {\n    foldr: function (v) {\n        return function (z) {\n            return function (v1) {\n                return z;\n            };\n        };\n    },\n    foldl: function (v) {\n        return function (z) {\n            return function (v1) {\n                return z;\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (v) {\n            return function (v1) {\n                return Data_Monoid.mempty(dictMonoid);\n            };\n        };\n    }\n};\nvar foldableConj = {\n    foldr: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(v)(z);\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(z)(v);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return f(v);\n            };\n        };\n    }\n};\nvar foldableAdditive = {\n    foldr: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(v)(z);\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(z)(v);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return f(v);\n            };\n        };\n    }\n};\nvar foldMapDefaultR = function (dictFoldable) {\n    return function (dictMonoid) {\n        return function (f) {\n            return foldr(dictFoldable)(function (x) {\n                return function (acc) {\n                    return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);\n                };\n            })(Data_Monoid.mempty(dictMonoid));\n        };\n    };\n};\nvar foldableArray = {\n    foldr: $foreign.foldrArray,\n    foldl: $foreign.foldlArray,\n    foldMap: function (dictMonoid) {\n        return foldMapDefaultR(foldableArray)(dictMonoid);\n    }\n};\nvar foldMapDefaultL = function (dictFoldable) {\n    return function (dictMonoid) {\n        return function (f) {\n            return foldl(dictFoldable)(function (acc) {\n                return function (x) {\n                    return Data_Semigroup.append(dictMonoid.Semigroup0())(acc)(f(x));\n                };\n            })(Data_Monoid.mempty(dictMonoid));\n        };\n    };\n};\nvar foldMap = function (dict) {\n    return dict.foldMap;\n};\nvar foldableApp = function (dictFoldable) {\n    return {\n        foldr: function (f) {\n            return function (i) {\n                return function (v) {\n                    return foldr(dictFoldable)(f)(i)(v);\n                };\n            };\n        },\n        foldl: function (f) {\n            return function (i) {\n                return function (v) {\n                    return foldl(dictFoldable)(f)(i)(v);\n                };\n            };\n        },\n        foldMap: function (dictMonoid) {\n            return function (f) {\n                return function (v) {\n                    return foldMap(dictFoldable)(dictMonoid)(f)(v);\n                };\n            };\n        }\n    };\n};\nvar foldableCompose = function (dictFoldable) {\n    return function (dictFoldable1) {\n        return {\n            foldr: function (f) {\n                return function (i) {\n                    return function (v) {\n                        return foldr(dictFoldable)(Data_Function.flip(foldr(dictFoldable1)(f)))(i)(v);\n                    };\n                };\n            },\n            foldl: function (f) {\n                return function (i) {\n                    return function (v) {\n                        return foldl(dictFoldable)(foldl(dictFoldable1)(f))(i)(v);\n                    };\n                };\n            },\n            foldMap: function (dictMonoid) {\n                return function (f) {\n                    return function (v) {\n                        return foldMap(dictFoldable)(dictMonoid)(foldMap(dictFoldable1)(dictMonoid)(f))(v);\n                    };\n                };\n            }\n        };\n    };\n};\nvar foldableCoproduct = function (dictFoldable) {\n    return function (dictFoldable1) {\n        return {\n            foldr: function (f) {\n                return function (z) {\n                    return Data_Functor_Coproduct.coproduct(foldr(dictFoldable)(f)(z))(foldr(dictFoldable1)(f)(z));\n                };\n            },\n            foldl: function (f) {\n                return function (z) {\n                    return Data_Functor_Coproduct.coproduct(foldl(dictFoldable)(f)(z))(foldl(dictFoldable1)(f)(z));\n                };\n            },\n            foldMap: function (dictMonoid) {\n                return function (f) {\n                    return Data_Functor_Coproduct.coproduct(foldMap(dictFoldable)(dictMonoid)(f))(foldMap(dictFoldable1)(dictMonoid)(f));\n                };\n            }\n        };\n    };\n};\nvar foldableFirst = {\n    foldr: function (f) {\n        return function (z) {\n            return function (v) {\n                return foldr(foldableMaybe)(f)(z)(v);\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (z) {\n            return function (v) {\n                return foldl(foldableMaybe)(f)(z)(v);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return foldMap(foldableMaybe)(dictMonoid)(f)(v);\n            };\n        };\n    }\n};\nvar foldableLast = {\n    foldr: function (f) {\n        return function (z) {\n            return function (v) {\n                return foldr(foldableMaybe)(f)(z)(v);\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (z) {\n            return function (v) {\n                return foldl(foldableMaybe)(f)(z)(v);\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return foldMap(foldableMaybe)(dictMonoid)(f)(v);\n            };\n        };\n    }\n};\nvar foldableProduct = function (dictFoldable) {\n    return function (dictFoldable1) {\n        return {\n            foldr: function (f) {\n                return function (z) {\n                    return function (v) {\n                        return foldr(dictFoldable)(f)(foldr(dictFoldable1)(f)(z)(v.value1))(v.value0);\n                    };\n                };\n            },\n            foldl: function (f) {\n                return function (z) {\n                    return function (v) {\n                        return foldl(dictFoldable1)(f)(foldl(dictFoldable)(f)(z)(v.value0))(v.value1);\n                    };\n                };\n            },\n            foldMap: function (dictMonoid) {\n                return function (f) {\n                    return function (v) {\n                        return Data_Semigroup.append(dictMonoid.Semigroup0())(foldMap(dictFoldable)(dictMonoid)(f)(v.value0))(foldMap(dictFoldable1)(dictMonoid)(f)(v.value1));\n                    };\n                };\n            }\n        };\n    };\n};\nvar foldlDefault = function (dictFoldable) {\n    return function (c) {\n        return function (u) {\n            return function (xs) {\n                return Data_Newtype.unwrap()(Data_Newtype.unwrap()(foldMap(dictFoldable)(Data_Monoid_Dual.monoidDual(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn)))((function () {\n                    var $320 = Data_Function.flip(c);\n                    return function ($321) {\n                        return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo($320($321)));\n                    };\n                })())(xs)))(u);\n            };\n        };\n    };\n};\nvar foldrDefault = function (dictFoldable) {\n    return function (c) {\n        return function (u) {\n            return function (xs) {\n                return Data_Newtype.unwrap()(foldMap(dictFoldable)(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn))(function ($322) {\n                    return Data_Monoid_Endo.Endo(c($322));\n                })(xs))(u);\n            };\n        };\n    };\n};\nvar lookup = function (dictFoldable) {\n    return function (dictEq) {\n        return function (a) {\n            var $323 = Data_Newtype.unwrap();\n            var $324 = foldMap(dictFoldable)(Data_Maybe_First.monoidFirst)(function (v) {\n                var $305 = Data_Eq.eq(dictEq)(a)(v.value0);\n                if ($305) {\n                    return new Data_Maybe.Just(v.value1);\n                };\n                return Data_Maybe.Nothing.value;\n            });\n            return function ($325) {\n                return $323($324($325));\n            };\n        };\n    };\n};\nvar surroundMap = function (dictFoldable) {\n    return function (dictSemigroup) {\n        return function (d) {\n            return function (t) {\n                return function (f) {\n                    var joined = function (a) {\n                        return function (m) {\n                            return Data_Semigroup.append(dictSemigroup)(d)(Data_Semigroup.append(dictSemigroup)(t(a))(m));\n                        };\n                    };\n                    return Data_Newtype.unwrap()(foldMap(dictFoldable)(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn))(joined)(f))(d);\n                };\n            };\n        };\n    };\n};\nvar surround = function (dictFoldable) {\n    return function (dictSemigroup) {\n        return function (d) {\n            return surroundMap(dictFoldable)(dictSemigroup)(d)(Control_Category.identity(Control_Category.categoryFn));\n        };\n    };\n};\nvar foldM = function (dictFoldable) {\n    return function (dictMonad) {\n        return function (f) {\n            return function (b0) {\n                return foldl(dictFoldable)(function (b) {\n                    return function (a) {\n                        return Control_Bind.bind(dictMonad.Bind1())(b)(Data_Function.flip(f)(a));\n                    };\n                })(Control_Applicative.pure(dictMonad.Applicative0())(b0));\n            };\n        };\n    };\n};\nvar fold = function (dictFoldable) {\n    return function (dictMonoid) {\n        return foldMap(dictFoldable)(dictMonoid)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar findMap = function (dictFoldable) {\n    return function (p) {\n        var go = function (v) {\n            return function (v1) {\n                if (v instanceof Data_Maybe.Nothing) {\n                    return p(v1);\n                };\n                return v;\n            };\n        };\n        return foldl(dictFoldable)(go)(Data_Maybe.Nothing.value);\n    };\n};\nvar find = function (dictFoldable) {\n    return function (p) {\n        var go = function (v) {\n            return function (v1) {\n                if (v instanceof Data_Maybe.Nothing && p(v1)) {\n                    return new Data_Maybe.Just(v1);\n                };\n                return v;\n            };\n        };\n        return foldl(dictFoldable)(go)(Data_Maybe.Nothing.value);\n    };\n};\nvar any = function (dictFoldable) {\n    return function (dictHeytingAlgebra) {\n        return Data_Newtype.alaF()()()()(Data_Monoid_Disj.Disj)(foldMap(dictFoldable)(Data_Monoid_Disj.monoidDisj(dictHeytingAlgebra)));\n    };\n};\nvar elem = function (dictFoldable) {\n    return function (dictEq) {\n        var $326 = any(dictFoldable)(Data_HeytingAlgebra.heytingAlgebraBoolean);\n        var $327 = Data_Eq.eq(dictEq);\n        return function ($328) {\n            return $326($327($328));\n        };\n    };\n};\nvar notElem = function (dictFoldable) {\n    return function (dictEq) {\n        return function (x) {\n            var $329 = Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean);\n            var $330 = elem(dictFoldable)(dictEq)(x);\n            return function ($331) {\n                return $329($330($331));\n            };\n        };\n    };\n};\nvar or = function (dictFoldable) {\n    return function (dictHeytingAlgebra) {\n        return any(dictFoldable)(dictHeytingAlgebra)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar all = function (dictFoldable) {\n    return function (dictHeytingAlgebra) {\n        return Data_Newtype.alaF()()()()(Data_Monoid_Conj.Conj)(foldMap(dictFoldable)(Data_Monoid_Conj.monoidConj(dictHeytingAlgebra)));\n    };\n};\nvar and = function (dictFoldable) {\n    return function (dictHeytingAlgebra) {\n        return all(dictFoldable)(dictHeytingAlgebra)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nmodule.exports = {\n    foldr: foldr,\n    foldl: foldl,\n    foldMap: foldMap,\n    foldrDefault: foldrDefault,\n    foldlDefault: foldlDefault,\n    foldMapDefaultL: foldMapDefaultL,\n    foldMapDefaultR: foldMapDefaultR,\n    fold: fold,\n    foldM: foldM,\n    traverse_: traverse_,\n    for_: for_,\n    sequence_: sequence_,\n    oneOf: oneOf,\n    oneOfMap: oneOfMap,\n    intercalate: intercalate,\n    surroundMap: surroundMap,\n    surround: surround,\n    and: and,\n    or: or,\n    all: all,\n    any: any,\n    sum: sum,\n    product: product,\n    elem: elem,\n    notElem: notElem,\n    indexl: indexl,\n    indexr: indexr,\n    find: find,\n    findMap: findMap,\n    maximum: maximum,\n    maximumBy: maximumBy,\n    minimum: minimum,\n    minimumBy: minimumBy,\n    \"null\": $$null,\n    length: length,\n    lookup: lookup,\n    foldableArray: foldableArray,\n    foldableMaybe: foldableMaybe,\n    foldableFirst: foldableFirst,\n    foldableLast: foldableLast,\n    foldableAdditive: foldableAdditive,\n    foldableDual: foldableDual,\n    foldableDisj: foldableDisj,\n    foldableConj: foldableConj,\n    foldableMultiplicative: foldableMultiplicative,\n    foldableEither: foldableEither,\n    foldableTuple: foldableTuple,\n    foldableIdentity: foldableIdentity,\n    foldableConst: foldableConst,\n    foldableProduct: foldableProduct,\n    foldableCoproduct: foldableCoproduct,\n    foldableCompose: foldableCompose,\n    foldableApp: foldableApp\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs":
/*!****************************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor_Coproduct = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs\");\nvar Data_FunctorWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Monoid_Conj = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs\");\nvar Data_Monoid_Disj = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs\");\nvar Data_Monoid_Dual = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs\");\nvar Data_Monoid_Endo = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar foldrWithIndex = function (dict) {\n    return dict.foldrWithIndex;\n};\nvar traverseWithIndex_ = function (dictApplicative) {\n    return function (dictFoldableWithIndex) {\n        return function (f) {\n            return foldrWithIndex(dictFoldableWithIndex)(function (i) {\n                var $164 = Control_Apply.applySecond(dictApplicative.Apply0());\n                var $165 = f(i);\n                return function ($166) {\n                    return $164($165($166));\n                };\n            })(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));\n        };\n    };\n};\nvar forWithIndex_ = function (dictApplicative) {\n    return function (dictFoldableWithIndex) {\n        return Data_Function.flip(traverseWithIndex_(dictApplicative)(dictFoldableWithIndex));\n    };\n};\nvar foldrDefault = function (dictFoldableWithIndex) {\n    return function (f) {\n        return foldrWithIndex(dictFoldableWithIndex)(Data_Function[\"const\"](f));\n    };\n};\nvar foldlWithIndex = function (dict) {\n    return dict.foldlWithIndex;\n};\nvar foldlDefault = function (dictFoldableWithIndex) {\n    return function (f) {\n        return foldlWithIndex(dictFoldableWithIndex)(Data_Function[\"const\"](f));\n    };\n};\nvar foldableWithIndexTuple = {\n    foldrWithIndex: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(Data_Unit.unit)(v.value1)(z);\n            };\n        };\n    },\n    foldlWithIndex: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(Data_Unit.unit)(z)(v.value1);\n            };\n        };\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return f(Data_Unit.unit)(v.value1);\n            };\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableTuple;\n    }\n};\nvar foldableWithIndexMultiplicative = {\n    foldrWithIndex: function (f) {\n        return Data_Foldable.foldr(Data_Foldable.foldableMultiplicative)(f(Data_Unit.unit));\n    },\n    foldlWithIndex: function (f) {\n        return Data_Foldable.foldl(Data_Foldable.foldableMultiplicative)(f(Data_Unit.unit));\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldMap(Data_Foldable.foldableMultiplicative)(dictMonoid)(f(Data_Unit.unit));\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableMultiplicative;\n    }\n};\nvar foldableWithIndexMaybe = {\n    foldrWithIndex: function (f) {\n        return Data_Foldable.foldr(Data_Foldable.foldableMaybe)(f(Data_Unit.unit));\n    },\n    foldlWithIndex: function (f) {\n        return Data_Foldable.foldl(Data_Foldable.foldableMaybe)(f(Data_Unit.unit));\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldMap(Data_Foldable.foldableMaybe)(dictMonoid)(f(Data_Unit.unit));\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableMaybe;\n    }\n};\nvar foldableWithIndexLast = {\n    foldrWithIndex: function (f) {\n        return Data_Foldable.foldr(Data_Foldable.foldableLast)(f(Data_Unit.unit));\n    },\n    foldlWithIndex: function (f) {\n        return Data_Foldable.foldl(Data_Foldable.foldableLast)(f(Data_Unit.unit));\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldMap(Data_Foldable.foldableLast)(dictMonoid)(f(Data_Unit.unit));\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableLast;\n    }\n};\nvar foldableWithIndexIdentity = {\n    foldrWithIndex: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(Data_Unit.unit)(v)(z);\n            };\n        };\n    },\n    foldlWithIndex: function (f) {\n        return function (z) {\n            return function (v) {\n                return f(Data_Unit.unit)(z)(v);\n            };\n        };\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return f(Data_Unit.unit)(v);\n            };\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableIdentity;\n    }\n};\nvar foldableWithIndexFirst = {\n    foldrWithIndex: function (f) {\n        return Data_Foldable.foldr(Data_Foldable.foldableFirst)(f(Data_Unit.unit));\n    },\n    foldlWithIndex: function (f) {\n        return Data_Foldable.foldl(Data_Foldable.foldableFirst)(f(Data_Unit.unit));\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldMap(Data_Foldable.foldableFirst)(dictMonoid)(f(Data_Unit.unit));\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableFirst;\n    }\n};\nvar foldableWithIndexEither = {\n    foldrWithIndex: function (v) {\n        return function (z) {\n            return function (v1) {\n                if (v1 instanceof Data_Either.Left) {\n                    return z;\n                };\n                if (v1 instanceof Data_Either.Right) {\n                    return v(Data_Unit.unit)(v1.value0)(z);\n                };\n                throw new Error(\"Failed pattern match at Data.FoldableWithIndex (line 164, column 1 - line 170, column 42): \" + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    foldlWithIndex: function (v) {\n        return function (z) {\n            return function (v1) {\n                if (v1 instanceof Data_Either.Left) {\n                    return z;\n                };\n                if (v1 instanceof Data_Either.Right) {\n                    return v(Data_Unit.unit)(z)(v1.value0);\n                };\n                throw new Error(\"Failed pattern match at Data.FoldableWithIndex (line 164, column 1 - line 170, column 42): \" + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (v) {\n            return function (v1) {\n                if (v1 instanceof Data_Either.Left) {\n                    return Data_Monoid.mempty(dictMonoid);\n                };\n                if (v1 instanceof Data_Either.Right) {\n                    return v(Data_Unit.unit)(v1.value0);\n                };\n                throw new Error(\"Failed pattern match at Data.FoldableWithIndex (line 164, column 1 - line 170, column 42): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableEither;\n    }\n};\nvar foldableWithIndexDual = {\n    foldrWithIndex: function (f) {\n        return Data_Foldable.foldr(Data_Foldable.foldableDual)(f(Data_Unit.unit));\n    },\n    foldlWithIndex: function (f) {\n        return Data_Foldable.foldl(Data_Foldable.foldableDual)(f(Data_Unit.unit));\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldMap(Data_Foldable.foldableDual)(dictMonoid)(f(Data_Unit.unit));\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableDual;\n    }\n};\nvar foldableWithIndexDisj = {\n    foldrWithIndex: function (f) {\n        return Data_Foldable.foldr(Data_Foldable.foldableDisj)(f(Data_Unit.unit));\n    },\n    foldlWithIndex: function (f) {\n        return Data_Foldable.foldl(Data_Foldable.foldableDisj)(f(Data_Unit.unit));\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldMap(Data_Foldable.foldableDisj)(dictMonoid)(f(Data_Unit.unit));\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableDisj;\n    }\n};\nvar foldableWithIndexConst = {\n    foldrWithIndex: function (v) {\n        return function (z) {\n            return function (v1) {\n                return z;\n            };\n        };\n    },\n    foldlWithIndex: function (v) {\n        return function (z) {\n            return function (v1) {\n                return z;\n            };\n        };\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (v) {\n            return function (v1) {\n                return Data_Monoid.mempty(dictMonoid);\n            };\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableConst;\n    }\n};\nvar foldableWithIndexConj = {\n    foldrWithIndex: function (f) {\n        return Data_Foldable.foldr(Data_Foldable.foldableConj)(f(Data_Unit.unit));\n    },\n    foldlWithIndex: function (f) {\n        return Data_Foldable.foldl(Data_Foldable.foldableConj)(f(Data_Unit.unit));\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldMap(Data_Foldable.foldableConj)(dictMonoid)(f(Data_Unit.unit));\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableConj;\n    }\n};\nvar foldableWithIndexAdditive = {\n    foldrWithIndex: function (f) {\n        return Data_Foldable.foldr(Data_Foldable.foldableAdditive)(f(Data_Unit.unit));\n    },\n    foldlWithIndex: function (f) {\n        return Data_Foldable.foldl(Data_Foldable.foldableAdditive)(f(Data_Unit.unit));\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldMap(Data_Foldable.foldableAdditive)(dictMonoid)(f(Data_Unit.unit));\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableAdditive;\n    }\n};\nvar foldWithIndexM = function (dictFoldableWithIndex) {\n    return function (dictMonad) {\n        return function (f) {\n            return function (a0) {\n                return foldlWithIndex(dictFoldableWithIndex)(function (i) {\n                    return function (ma) {\n                        return function (b) {\n                            return Control_Bind.bind(dictMonad.Bind1())(ma)(Data_Function.flip(f(i))(b));\n                        };\n                    };\n                })(Control_Applicative.pure(dictMonad.Applicative0())(a0));\n            };\n        };\n    };\n};\nvar foldMapWithIndexDefaultR = function (dictFoldableWithIndex) {\n    return function (dictMonoid) {\n        return function (f) {\n            return foldrWithIndex(dictFoldableWithIndex)(function (i) {\n                return function (x) {\n                    return function (acc) {\n                        return Data_Semigroup.append(dictMonoid.Semigroup0())(f(i)(x))(acc);\n                    };\n                };\n            })(Data_Monoid.mempty(dictMonoid));\n        };\n    };\n};\nvar foldableWithIndexArray = {\n    foldrWithIndex: function (f) {\n        return function (z) {\n            var $167 = Data_Foldable.foldr(Data_Foldable.foldableArray)(function (v) {\n                return function (y) {\n                    return f(v.value0)(v.value1)(y);\n                };\n            })(z);\n            var $168 = Data_FunctorWithIndex.mapWithIndex(Data_FunctorWithIndex.functorWithIndexArray)(Data_Tuple.Tuple.create);\n            return function ($169) {\n                return $167($168($169));\n            };\n        };\n    },\n    foldlWithIndex: function (f) {\n        return function (z) {\n            var $170 = Data_Foldable.foldl(Data_Foldable.foldableArray)(function (y) {\n                return function (v) {\n                    return f(v.value0)(y)(v.value1);\n                };\n            })(z);\n            var $171 = Data_FunctorWithIndex.mapWithIndex(Data_FunctorWithIndex.functorWithIndexArray)(Data_Tuple.Tuple.create);\n            return function ($172) {\n                return $170($171($172));\n            };\n        };\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableArray;\n    }\n};\nvar foldMapWithIndexDefaultL = function (dictFoldableWithIndex) {\n    return function (dictMonoid) {\n        return function (f) {\n            return foldlWithIndex(dictFoldableWithIndex)(function (i) {\n                return function (acc) {\n                    return function (x) {\n                        return Data_Semigroup.append(dictMonoid.Semigroup0())(acc)(f(i)(x));\n                    };\n                };\n            })(Data_Monoid.mempty(dictMonoid));\n        };\n    };\n};\nvar foldMapWithIndex = function (dict) {\n    return dict.foldMapWithIndex;\n};\nvar foldableWithIndexApp = function (dictFoldableWithIndex) {\n    return {\n        foldrWithIndex: function (f) {\n            return function (z) {\n                return function (v) {\n                    return foldrWithIndex(dictFoldableWithIndex)(f)(z)(v);\n                };\n            };\n        },\n        foldlWithIndex: function (f) {\n            return function (z) {\n                return function (v) {\n                    return foldlWithIndex(dictFoldableWithIndex)(f)(z)(v);\n                };\n            };\n        },\n        foldMapWithIndex: function (dictMonoid) {\n            return function (f) {\n                return function (v) {\n                    return foldMapWithIndex(dictFoldableWithIndex)(dictMonoid)(f)(v);\n                };\n            };\n        },\n        Foldable0: function () {\n            return Data_Foldable.foldableApp(dictFoldableWithIndex.Foldable0());\n        }\n    };\n};\nvar foldableWithIndexCompose = function (dictFoldableWithIndex) {\n    return function (dictFoldableWithIndex1) {\n        return {\n            foldrWithIndex: function (f) {\n                return function (i) {\n                    return function (v) {\n                        return foldrWithIndex(dictFoldableWithIndex)(function (a) {\n                            return Data_Function.flip(foldrWithIndex(dictFoldableWithIndex1)(Data_Tuple.curry(f)(a)));\n                        })(i)(v);\n                    };\n                };\n            },\n            foldlWithIndex: function (f) {\n                return function (i) {\n                    return function (v) {\n                        return foldlWithIndex(dictFoldableWithIndex)((function () {\n                            var $173 = foldlWithIndex(dictFoldableWithIndex1);\n                            var $174 = Data_Tuple.curry(f);\n                            return function ($175) {\n                                return $173($174($175));\n                            };\n                        })())(i)(v);\n                    };\n                };\n            },\n            foldMapWithIndex: function (dictMonoid) {\n                return function (f) {\n                    return function (v) {\n                        return foldMapWithIndex(dictFoldableWithIndex)(dictMonoid)((function () {\n                            var $176 = foldMapWithIndex(dictFoldableWithIndex1)(dictMonoid);\n                            var $177 = Data_Tuple.curry(f);\n                            return function ($178) {\n                                return $176($177($178));\n                            };\n                        })())(v);\n                    };\n                };\n            },\n            Foldable0: function () {\n                return Data_Foldable.foldableCompose(dictFoldableWithIndex.Foldable0())(dictFoldableWithIndex1.Foldable0());\n            }\n        };\n    };\n};\nvar foldableWithIndexCoproduct = function (dictFoldableWithIndex) {\n    return function (dictFoldableWithIndex1) {\n        return {\n            foldrWithIndex: function (f) {\n                return function (z) {\n                    return Data_Functor_Coproduct.coproduct(foldrWithIndex(dictFoldableWithIndex)(function ($179) {\n                        return f(Data_Either.Left.create($179));\n                    })(z))(foldrWithIndex(dictFoldableWithIndex1)(function ($180) {\n                        return f(Data_Either.Right.create($180));\n                    })(z));\n                };\n            },\n            foldlWithIndex: function (f) {\n                return function (z) {\n                    return Data_Functor_Coproduct.coproduct(foldlWithIndex(dictFoldableWithIndex)(function ($181) {\n                        return f(Data_Either.Left.create($181));\n                    })(z))(foldlWithIndex(dictFoldableWithIndex1)(function ($182) {\n                        return f(Data_Either.Right.create($182));\n                    })(z));\n                };\n            },\n            foldMapWithIndex: function (dictMonoid) {\n                return function (f) {\n                    return Data_Functor_Coproduct.coproduct(foldMapWithIndex(dictFoldableWithIndex)(dictMonoid)(function ($183) {\n                        return f(Data_Either.Left.create($183));\n                    }))(foldMapWithIndex(dictFoldableWithIndex1)(dictMonoid)(function ($184) {\n                        return f(Data_Either.Right.create($184));\n                    }));\n                };\n            },\n            Foldable0: function () {\n                return Data_Foldable.foldableCoproduct(dictFoldableWithIndex.Foldable0())(dictFoldableWithIndex1.Foldable0());\n            }\n        };\n    };\n};\nvar foldableWithIndexProduct = function (dictFoldableWithIndex) {\n    return function (dictFoldableWithIndex1) {\n        return {\n            foldrWithIndex: function (f) {\n                return function (z) {\n                    return function (v) {\n                        return foldrWithIndex(dictFoldableWithIndex)(function ($185) {\n                            return f(Data_Either.Left.create($185));\n                        })(foldrWithIndex(dictFoldableWithIndex1)(function ($186) {\n                            return f(Data_Either.Right.create($186));\n                        })(z)(v.value1))(v.value0);\n                    };\n                };\n            },\n            foldlWithIndex: function (f) {\n                return function (z) {\n                    return function (v) {\n                        return foldlWithIndex(dictFoldableWithIndex1)(function ($187) {\n                            return f(Data_Either.Right.create($187));\n                        })(foldlWithIndex(dictFoldableWithIndex)(function ($188) {\n                            return f(Data_Either.Left.create($188));\n                        })(z)(v.value0))(v.value1);\n                    };\n                };\n            },\n            foldMapWithIndex: function (dictMonoid) {\n                return function (f) {\n                    return function (v) {\n                        return Data_Semigroup.append(dictMonoid.Semigroup0())(foldMapWithIndex(dictFoldableWithIndex)(dictMonoid)(function ($189) {\n                            return f(Data_Either.Left.create($189));\n                        })(v.value0))(foldMapWithIndex(dictFoldableWithIndex1)(dictMonoid)(function ($190) {\n                            return f(Data_Either.Right.create($190));\n                        })(v.value1));\n                    };\n                };\n            },\n            Foldable0: function () {\n                return Data_Foldable.foldableProduct(dictFoldableWithIndex.Foldable0())(dictFoldableWithIndex1.Foldable0());\n            }\n        };\n    };\n};\nvar foldlWithIndexDefault = function (dictFoldableWithIndex) {\n    return function (c) {\n        return function (u) {\n            return function (xs) {\n                return Data_Newtype.unwrap()(Data_Newtype.unwrap()(foldMapWithIndex(dictFoldableWithIndex)(Data_Monoid_Dual.monoidDual(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn)))(function (i) {\n                    var $191 = Data_Function.flip(c(i));\n                    return function ($192) {\n                        return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo($191($192)));\n                    };\n                })(xs)))(u);\n            };\n        };\n    };\n};\nvar foldrWithIndexDefault = function (dictFoldableWithIndex) {\n    return function (c) {\n        return function (u) {\n            return function (xs) {\n                return Data_Newtype.unwrap()(foldMapWithIndex(dictFoldableWithIndex)(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn))(function (i) {\n                    var $193 = c(i);\n                    return function ($194) {\n                        return Data_Monoid_Endo.Endo($193($194));\n                    };\n                })(xs))(u);\n            };\n        };\n    };\n};\nvar surroundMapWithIndex = function (dictFoldableWithIndex) {\n    return function (dictSemigroup) {\n        return function (d) {\n            return function (t) {\n                return function (f) {\n                    var joined = function (i) {\n                        return function (a) {\n                            return function (m) {\n                                return Data_Semigroup.append(dictSemigroup)(d)(Data_Semigroup.append(dictSemigroup)(t(i)(a))(m));\n                            };\n                        };\n                    };\n                    return Data_Newtype.unwrap()(foldMapWithIndex(dictFoldableWithIndex)(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn))(joined)(f))(d);\n                };\n            };\n        };\n    };\n};\nvar foldMapDefault = function (dictFoldableWithIndex) {\n    return function (dictMonoid) {\n        return function (f) {\n            return foldMapWithIndex(dictFoldableWithIndex)(dictMonoid)(Data_Function[\"const\"](f));\n        };\n    };\n};\nvar findWithIndex = function (dictFoldableWithIndex) {\n    return function (p) {\n        var go = function (v) {\n            return function (v1) {\n                return function (v2) {\n                    if (v1 instanceof Data_Maybe.Nothing && p(v)(v2)) {\n                        return new Data_Maybe.Just({\n                            index: v,\n                            value: v2\n                        });\n                    };\n                    return v1;\n                };\n            };\n        };\n        return foldlWithIndex(dictFoldableWithIndex)(go)(Data_Maybe.Nothing.value);\n    };\n};\nvar findMapWithIndex = function (dictFoldableWithIndex) {\n    return function (f) {\n        var go = function (v) {\n            return function (v1) {\n                return function (v2) {\n                    if (v1 instanceof Data_Maybe.Nothing) {\n                        return f(v)(v2);\n                    };\n                    return v1;\n                };\n            };\n        };\n        return foldlWithIndex(dictFoldableWithIndex)(go)(Data_Maybe.Nothing.value);\n    };\n};\nvar anyWithIndex = function (dictFoldableWithIndex) {\n    return function (dictHeytingAlgebra) {\n        return function (t) {\n            var $195 = Data_Newtype.unwrap();\n            var $196 = foldMapWithIndex(dictFoldableWithIndex)(Data_Monoid_Disj.monoidDisj(dictHeytingAlgebra))(function (i) {\n                var $198 = t(i);\n                return function ($199) {\n                    return Data_Monoid_Disj.Disj($198($199));\n                };\n            });\n            return function ($197) {\n                return $195($196($197));\n            };\n        };\n    };\n};\nvar allWithIndex = function (dictFoldableWithIndex) {\n    return function (dictHeytingAlgebra) {\n        return function (t) {\n            var $200 = Data_Newtype.unwrap();\n            var $201 = foldMapWithIndex(dictFoldableWithIndex)(Data_Monoid_Conj.monoidConj(dictHeytingAlgebra))(function (i) {\n                var $203 = t(i);\n                return function ($204) {\n                    return Data_Monoid_Conj.Conj($203($204));\n                };\n            });\n            return function ($202) {\n                return $200($201($202));\n            };\n        };\n    };\n};\nmodule.exports = {\n    foldrWithIndex: foldrWithIndex,\n    foldlWithIndex: foldlWithIndex,\n    foldMapWithIndex: foldMapWithIndex,\n    foldrWithIndexDefault: foldrWithIndexDefault,\n    foldlWithIndexDefault: foldlWithIndexDefault,\n    foldMapWithIndexDefaultR: foldMapWithIndexDefaultR,\n    foldMapWithIndexDefaultL: foldMapWithIndexDefaultL,\n    foldWithIndexM: foldWithIndexM,\n    traverseWithIndex_: traverseWithIndex_,\n    forWithIndex_: forWithIndex_,\n    surroundMapWithIndex: surroundMapWithIndex,\n    allWithIndex: allWithIndex,\n    anyWithIndex: anyWithIndex,\n    findWithIndex: findWithIndex,\n    findMapWithIndex: findMapWithIndex,\n    foldrDefault: foldrDefault,\n    foldlDefault: foldlDefault,\n    foldMapDefault: foldMapDefault,\n    foldableWithIndexArray: foldableWithIndexArray,\n    foldableWithIndexMaybe: foldableWithIndexMaybe,\n    foldableWithIndexFirst: foldableWithIndexFirst,\n    foldableWithIndexLast: foldableWithIndexLast,\n    foldableWithIndexAdditive: foldableWithIndexAdditive,\n    foldableWithIndexDual: foldableWithIndexDual,\n    foldableWithIndexDisj: foldableWithIndexDisj,\n    foldableWithIndexConj: foldableWithIndexConj,\n    foldableWithIndexMultiplicative: foldableWithIndexMultiplicative,\n    foldableWithIndexEither: foldableWithIndexEither,\n    foldableWithIndexTuple: foldableWithIndexTuple,\n    foldableWithIndexIdentity: foldableWithIndexIdentity,\n    foldableWithIndexConst: foldableWithIndexConst,\n    foldableWithIndexProduct: foldableWithIndexProduct,\n    foldableWithIndexCoproduct: foldableWithIndexCoproduct,\n    foldableWithIndexCompose: foldableWithIndexCompose,\n    foldableWithIndexApp: foldableWithIndexApp\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs":
/*!***************************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.js */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.js\");\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Const = __webpack_require__(/*! ./.spago/const/v5.0.0/src/Data/Const.purs */ \"./.spago/const/v5.0.0/src/Data/Const.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Functor_App = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/App.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/App.purs\");\nvar Data_Functor_Compose = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Compose.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Compose.purs\");\nvar Data_Functor_Coproduct = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs\");\nvar Data_Functor_Product = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Product.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Product.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Maybe_First = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe/First.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe/First.purs\");\nvar Data_Maybe_Last = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe/Last.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe/Last.purs\");\nvar Data_Monoid_Additive = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Additive.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Additive.purs\");\nvar Data_Monoid_Conj = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs\");\nvar Data_Monoid_Disj = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs\");\nvar Data_Monoid_Dual = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs\");\nvar Data_Monoid_Multiplicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Multiplicative.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Multiplicative.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar mapWithIndex = function (dict) {\n    return dict.mapWithIndex;\n};\nvar mapDefault = function (dictFunctorWithIndex) {\n    return function (f) {\n        return mapWithIndex(dictFunctorWithIndex)(Data_Function[\"const\"](f));\n    };\n};\nvar functorWithIndexTuple = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(Data_Tuple.functorTuple)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return Data_Tuple.functorTuple;\n    }\n};\nvar functorWithIndexProduct = function (dictFunctorWithIndex) {\n    return function (dictFunctorWithIndex1) {\n        return {\n            mapWithIndex: function (f) {\n                return function (v) {\n                    return Data_Bifunctor.bimap(Data_Bifunctor.bifunctorTuple)(mapWithIndex(dictFunctorWithIndex)(function ($28) {\n                        return f(Data_Either.Left.create($28));\n                    }))(mapWithIndex(dictFunctorWithIndex1)(function ($29) {\n                        return f(Data_Either.Right.create($29));\n                    }))(v);\n                };\n            },\n            Functor0: function () {\n                return Data_Functor_Product.functorProduct(dictFunctorWithIndex.Functor0())(dictFunctorWithIndex1.Functor0());\n            }\n        };\n    };\n};\nvar functorWithIndexMultiplicative = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(Data_Monoid_Multiplicative.functorMultiplicative)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return Data_Monoid_Multiplicative.functorMultiplicative;\n    }\n};\nvar functorWithIndexMaybe = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(Data_Maybe.functorMaybe)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return Data_Maybe.functorMaybe;\n    }\n};\nvar functorWithIndexLast = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(Data_Maybe_Last.functorLast)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return Data_Maybe_Last.functorLast;\n    }\n};\nvar functorWithIndexIdentity = {\n    mapWithIndex: function (f) {\n        return function (v) {\n            return f(Data_Unit.unit)(v);\n        };\n    },\n    Functor0: function () {\n        return Data_Identity.functorIdentity;\n    }\n};\nvar functorWithIndexFirst = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(Data_Maybe_First.functorFirst)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return Data_Maybe_First.functorFirst;\n    }\n};\nvar functorWithIndexEither = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(Data_Either.functorEither)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return Data_Either.functorEither;\n    }\n};\nvar functorWithIndexDual = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(Data_Monoid_Dual.functorDual)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return Data_Monoid_Dual.functorDual;\n    }\n};\nvar functorWithIndexDisj = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(Data_Monoid_Disj.functorDisj)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return Data_Monoid_Disj.functorDisj;\n    }\n};\nvar functorWithIndexCoproduct = function (dictFunctorWithIndex) {\n    return function (dictFunctorWithIndex1) {\n        return {\n            mapWithIndex: function (f) {\n                return function (v) {\n                    return Data_Bifunctor.bimap(Data_Bifunctor.bifunctorEither)(mapWithIndex(dictFunctorWithIndex)(function ($30) {\n                        return f(Data_Either.Left.create($30));\n                    }))(mapWithIndex(dictFunctorWithIndex1)(function ($31) {\n                        return f(Data_Either.Right.create($31));\n                    }))(v);\n                };\n            },\n            Functor0: function () {\n                return Data_Functor_Coproduct.functorCoproduct(dictFunctorWithIndex.Functor0())(dictFunctorWithIndex1.Functor0());\n            }\n        };\n    };\n};\nvar functorWithIndexConst = {\n    mapWithIndex: function (v) {\n        return function (v1) {\n            return v1;\n        };\n    },\n    Functor0: function () {\n        return Data_Const.functorConst;\n    }\n};\nvar functorWithIndexConj = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(Data_Monoid_Conj.functorConj)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return Data_Monoid_Conj.functorConj;\n    }\n};\nvar functorWithIndexCompose = function (dictFunctorWithIndex) {\n    return function (dictFunctorWithIndex1) {\n        return {\n            mapWithIndex: function (f) {\n                return function (v) {\n                    return Data_Functor_Compose.Compose(mapWithIndex(dictFunctorWithIndex)((function () {\n                        var $32 = mapWithIndex(dictFunctorWithIndex1);\n                        var $33 = Data_Tuple.curry(f);\n                        return function ($34) {\n                            return $32($33($34));\n                        };\n                    })())(v));\n                };\n            },\n            Functor0: function () {\n                return Data_Functor_Compose.functorCompose(dictFunctorWithIndex.Functor0())(dictFunctorWithIndex1.Functor0());\n            }\n        };\n    };\n};\nvar functorWithIndexArray = {\n    mapWithIndex: $foreign.mapWithIndexArray,\n    Functor0: function () {\n        return Data_Functor.functorArray;\n    }\n};\nvar functorWithIndexApp = function (dictFunctorWithIndex) {\n    return {\n        mapWithIndex: function (f) {\n            return function (v) {\n                return Data_Functor_App.App(mapWithIndex(dictFunctorWithIndex)(f)(v));\n            };\n        },\n        Functor0: function () {\n            return Data_Functor_App.functorApp(dictFunctorWithIndex.Functor0());\n        }\n    };\n};\nvar functorWithIndexAdditive = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(Data_Monoid_Additive.functorAdditive)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return Data_Monoid_Additive.functorAdditive;\n    }\n};\nmodule.exports = {\n    mapWithIndex: mapWithIndex,\n    mapDefault: mapDefault,\n    functorWithIndexArray: functorWithIndexArray,\n    functorWithIndexMaybe: functorWithIndexMaybe,\n    functorWithIndexFirst: functorWithIndexFirst,\n    functorWithIndexLast: functorWithIndexLast,\n    functorWithIndexAdditive: functorWithIndexAdditive,\n    functorWithIndexDual: functorWithIndexDual,\n    functorWithIndexConj: functorWithIndexConj,\n    functorWithIndexDisj: functorWithIndexDisj,\n    functorWithIndexMultiplicative: functorWithIndexMultiplicative,\n    functorWithIndexEither: functorWithIndexEither,\n    functorWithIndexTuple: functorWithIndexTuple,\n    functorWithIndexIdentity: functorWithIndexIdentity,\n    functorWithIndexConst: functorWithIndexConst,\n    functorWithIndexProduct: functorWithIndexProduct,\n    functorWithIndexCoproduct: functorWithIndexCoproduct,\n    functorWithIndexCompose: functorWithIndexCompose,\n    functorWithIndexApp: functorWithIndexApp\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs":
/*!*****************************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Monoid_Dual = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Ord_Max = __webpack_require__(/*! ./.spago/orders/v5.0.0/src/Data/Ord/Max.purs */ \"./.spago/orders/v5.0.0/src/Data/Ord/Max.purs\");\nvar Data_Ord_Min = __webpack_require__(/*! ./.spago/orders/v5.0.0/src/Data/Ord/Min.purs */ \"./.spago/orders/v5.0.0/src/Data/Ord/Min.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar JoinWith = function (x) {\n    return x;\n};\nvar FoldRight1 = (function () {\n    function FoldRight1(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    FoldRight1.create = function (value0) {\n        return function (value1) {\n            return new FoldRight1(value0, value1);\n        };\n    };\n    return FoldRight1;\n})();\nvar Act = function (x) {\n    return x;\n};\nvar semigroupJoinWith = function (dictSemigroup) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                return JoinWith(function (j) {\n                    return Data_Semigroup.append(dictSemigroup)(v(j))(Data_Semigroup.append(dictSemigroup)(j)(v1(j)));\n                });\n            };\n        }\n    };\n};\nvar semigroupAct = function (dictApply) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                return Control_Apply.applySecond(dictApply)(v)(v1);\n            };\n        }\n    };\n};\nvar runFoldRight1 = function (v) {\n    return v.value0(v.value1);\n};\nvar mkFoldRight1 = FoldRight1.create(Data_Function[\"const\"]);\nvar joinee = function (v) {\n    return v;\n};\nvar getAct = function (v) {\n    return v;\n};\nvar foldr1 = function (dict) {\n    return dict.foldr1;\n};\nvar foldl1 = function (dict) {\n    return dict.foldl1;\n};\nvar maximumBy = function (dictFoldable1) {\n    return function (cmp) {\n        return foldl1(dictFoldable1)(function (x) {\n            return function (y) {\n                var $76 = Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(x)(y))(Data_Ordering.GT.value);\n                if ($76) {\n                    return x;\n                };\n                return y;\n            };\n        });\n    };\n};\nvar minimumBy = function (dictFoldable1) {\n    return function (cmp) {\n        return foldl1(dictFoldable1)(function (x) {\n            return function (y) {\n                var $77 = Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(x)(y))(Data_Ordering.LT.value);\n                if ($77) {\n                    return x;\n                };\n                return y;\n            };\n        });\n    };\n};\nvar foldableTuple = {\n    foldMap1: function (dictSemigroup) {\n        return function (f) {\n            return function (v) {\n                return f(v.value1);\n            };\n        };\n    },\n    foldr1: function (v) {\n        return function (v1) {\n            return v1.value1;\n        };\n    },\n    foldl1: function (v) {\n        return function (v1) {\n            return v1.value1;\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableTuple;\n    }\n};\nvar foldableMultiplicative = {\n    foldr1: function (v) {\n        return function (v1) {\n            return v1;\n        };\n    },\n    foldl1: function (v) {\n        return function (v1) {\n            return v1;\n        };\n    },\n    foldMap1: function (dictSemigroup) {\n        return function (f) {\n            return function (v) {\n                return f(v);\n            };\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableMultiplicative;\n    }\n};\nvar foldableIdentity = {\n    foldMap1: function (dictSemigroup) {\n        return function (f) {\n            return function (v) {\n                return f(v);\n            };\n        };\n    },\n    foldl1: function (v) {\n        return function (v1) {\n            return v1;\n        };\n    },\n    foldr1: function (v) {\n        return function (v1) {\n            return v1;\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableIdentity;\n    }\n};\nvar foldableDual = {\n    foldr1: function (v) {\n        return function (v1) {\n            return v1;\n        };\n    },\n    foldl1: function (v) {\n        return function (v1) {\n            return v1;\n        };\n    },\n    foldMap1: function (dictSemigroup) {\n        return function (f) {\n            return function (v) {\n                return f(v);\n            };\n        };\n    },\n    Foldable0: function () {\n        return Data_Foldable.foldableDual;\n    }\n};\nvar foldRight1Semigroup = {\n    append: function (v) {\n        return function (v1) {\n            return new FoldRight1(function (a) {\n                return function (f) {\n                    return v.value0(f(v.value1)(v1.value0(a)(f)))(f);\n                };\n            }, v1.value1);\n        };\n    }\n};\nvar foldMap1DefaultR = function (dictFoldable1) {\n    return function (dictFunctor) {\n        return function (dictSemigroup) {\n            return function (f) {\n                var $115 = foldr1(dictFoldable1)(Data_Semigroup.append(dictSemigroup));\n                var $116 = Data_Functor.map(dictFunctor)(f);\n                return function ($117) {\n                    return $115($116($117));\n                };\n            };\n        };\n    };\n};\nvar foldMap1DefaultL = function (dictFoldable1) {\n    return function (dictFunctor) {\n        return function (dictSemigroup) {\n            return function (f) {\n                var $118 = foldl1(dictFoldable1)(Data_Semigroup.append(dictSemigroup));\n                var $119 = Data_Functor.map(dictFunctor)(f);\n                return function ($120) {\n                    return $118($119($120));\n                };\n            };\n        };\n    };\n};\nvar foldMap1Default = function (dictWarn) {\n    return function (dictFoldable1) {\n        return function (dictFunctor) {\n            return function (dictSemigroup) {\n                return foldMap1DefaultL(dictFoldable1)(dictFunctor)(dictSemigroup);\n            };\n        };\n    };\n};\nvar foldMap1 = function (dict) {\n    return dict.foldMap1;\n};\nvar foldl1Default = function (dictFoldable1) {\n    var $121 = Data_Function.flip((function () {\n        var $123 = Data_Newtype.alaF()()()()(Data_Monoid_Dual.Dual)(foldMap1(dictFoldable1)(Data_Monoid_Dual.semigroupDual(foldRight1Semigroup)))(mkFoldRight1);\n        return function ($124) {\n            return runFoldRight1($123($124));\n        };\n    })());\n    return function ($122) {\n        return $121(Data_Function.flip($122));\n    };\n};\nvar foldr1Default = function (dictFoldable1) {\n    return Data_Function.flip((function () {\n        var $125 = foldMap1(dictFoldable1)(foldRight1Semigroup)(mkFoldRight1);\n        return function ($126) {\n            return runFoldRight1($125($126));\n        };\n    })());\n};\nvar intercalateMap = function (dictFoldable1) {\n    return function (dictSemigroup) {\n        return function (j) {\n            return function (f) {\n                return function (foldable) {\n                    return joinee(foldMap1(dictFoldable1)(semigroupJoinWith(dictSemigroup))(function ($127) {\n                        return JoinWith(Data_Function[\"const\"](f($127)));\n                    })(foldable))(j);\n                };\n            };\n        };\n    };\n};\nvar intercalate = function (dictFoldable1) {\n    return function (dictSemigroup) {\n        return Data_Function.flip(intercalateMap(dictFoldable1)(dictSemigroup))(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar maximum = function (dictOrd) {\n    return function (dictFoldable1) {\n        return Data_Newtype.ala()()()(Data_Ord_Max.Max)(foldMap1(dictFoldable1)(Data_Ord_Max.semigroupMax(dictOrd)));\n    };\n};\nvar minimum = function (dictOrd) {\n    return function (dictFoldable1) {\n        return Data_Newtype.ala()()()(Data_Ord_Min.Min)(foldMap1(dictFoldable1)(Data_Ord_Min.semigroupMin(dictOrd)));\n    };\n};\nvar traverse1_ = function (dictFoldable1) {\n    return function (dictApply) {\n        return function (f) {\n            return function (t) {\n                return Data_Functor.voidRight(dictApply.Functor0())(Data_Unit.unit)(getAct(foldMap1(dictFoldable1)(semigroupAct(dictApply))(function ($128) {\n                    return Act(f($128));\n                })(t)));\n            };\n        };\n    };\n};\nvar for1_ = function (dictFoldable1) {\n    return function (dictApply) {\n        return Data_Function.flip(traverse1_(dictFoldable1)(dictApply));\n    };\n};\nvar sequence1_ = function (dictFoldable1) {\n    return function (dictApply) {\n        return traverse1_(dictFoldable1)(dictApply)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar fold1 = function (dictFoldable1) {\n    return function (dictSemigroup) {\n        return foldMap1(dictFoldable1)(dictSemigroup)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nmodule.exports = {\n    foldMap1: foldMap1,\n    fold1: fold1,\n    foldr1: foldr1,\n    foldl1: foldl1,\n    traverse1_: traverse1_,\n    for1_: for1_,\n    sequence1_: sequence1_,\n    foldr1Default: foldr1Default,\n    foldl1Default: foldl1Default,\n    foldMap1DefaultR: foldMap1DefaultR,\n    foldMap1DefaultL: foldMap1DefaultL,\n    foldMap1Default: foldMap1Default,\n    intercalate: intercalate,\n    intercalateMap: intercalateMap,\n    maximum: maximum,\n    maximumBy: maximumBy,\n    minimum: minimum,\n    minimumBy: minimumBy,\n    foldableDual: foldableDual,\n    foldableMultiplicative: foldableMultiplicative,\n    foldableTuple: foldableTuple,\n    foldableIdentity: foldableIdentity\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs":
/*!********************************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Monoid_Dual = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs\");\nvar Data_Monoid_Multiplicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Multiplicative.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Multiplicative.purs\");\nvar Data_Semigroup_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar traverse1 = function (dict) {\n    return dict.traverse1;\n};\nvar traversableTuple = {\n    traverse1: function (dictApply) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map(dictApply.Functor0())(Data_Tuple.Tuple.create(v.value0))(f(v.value1));\n            };\n        };\n    },\n    sequence1: function (dictApply) {\n        return function (v) {\n            return Data_Functor.map(dictApply.Functor0())(Data_Tuple.Tuple.create(v.value0))(v.value1);\n        };\n    },\n    Foldable10: function () {\n        return Data_Semigroup_Foldable.foldableTuple;\n    },\n    Traversable1: function () {\n        return Data_Traversable.traversableTuple;\n    }\n};\nvar traversableIdentity = {\n    traverse1: function (dictApply) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map(dictApply.Functor0())(Data_Identity.Identity)(f(v));\n            };\n        };\n    },\n    sequence1: function (dictApply) {\n        return function (v) {\n            return Data_Functor.map(dictApply.Functor0())(Data_Identity.Identity)(v);\n        };\n    },\n    Foldable10: function () {\n        return Data_Semigroup_Foldable.foldableIdentity;\n    },\n    Traversable1: function () {\n        return Data_Traversable.traversableIdentity;\n    }\n};\nvar sequence1Default = function (dictTraversable1) {\n    return function (dictApply) {\n        return traverse1(dictTraversable1)(dictApply)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar traversableDual = {\n    traverse1: function (dictApply) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map(dictApply.Functor0())(Data_Monoid_Dual.Dual)(f(v));\n            };\n        };\n    },\n    sequence1: function (dictApply) {\n        return sequence1Default(traversableDual)(dictApply);\n    },\n    Foldable10: function () {\n        return Data_Semigroup_Foldable.foldableDual;\n    },\n    Traversable1: function () {\n        return Data_Traversable.traversableDual;\n    }\n};\nvar traversableMultiplicative = {\n    traverse1: function (dictApply) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map(dictApply.Functor0())(Data_Monoid_Multiplicative.Multiplicative)(f(v));\n            };\n        };\n    },\n    sequence1: function (dictApply) {\n        return sequence1Default(traversableMultiplicative)(dictApply);\n    },\n    Foldable10: function () {\n        return Data_Semigroup_Foldable.foldableMultiplicative;\n    },\n    Traversable1: function () {\n        return Data_Traversable.traversableMultiplicative;\n    }\n};\nvar sequence1 = function (dict) {\n    return dict.sequence1;\n};\nvar traverse1Default = function (dictTraversable1) {\n    return function (dictApply) {\n        return function (f) {\n            return function (ta) {\n                return sequence1(dictTraversable1)(dictApply)(Data_Functor.map((dictTraversable1.Traversable1()).Functor0())(f)(ta));\n            };\n        };\n    };\n};\nmodule.exports = {\n    sequence1: sequence1,\n    traverse1: traverse1,\n    traverse1Default: traverse1Default,\n    sequence1Default: sequence1Default,\n    traversableDual: traversableDual,\n    traversableMultiplicative: traversableMultiplicative,\n    traversableTuple: traversableTuple,\n    traversableIdentity: traversableIdentity\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs":
/*!**********************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.js */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.js\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Const = __webpack_require__(/*! ./.spago/const/v5.0.0/src/Data/Const.purs */ \"./.spago/const/v5.0.0/src/Data/Const.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Functor_App = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/App.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/App.purs\");\nvar Data_Functor_Compose = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Compose.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Compose.purs\");\nvar Data_Functor_Coproduct = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs\");\nvar Data_Functor_Product = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Product.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Product.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Maybe_First = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe/First.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe/First.purs\");\nvar Data_Maybe_Last = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe/Last.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe/Last.purs\");\nvar Data_Monoid_Additive = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Additive.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Additive.purs\");\nvar Data_Monoid_Conj = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs\");\nvar Data_Monoid_Disj = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs\");\nvar Data_Monoid_Dual = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs\");\nvar Data_Monoid_Multiplicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Multiplicative.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Multiplicative.purs\");\nvar Data_Traversable_Accum = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum.purs\");\nvar Data_Traversable_Accum_Internal = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum/Internal.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum/Internal.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar traverse = function (dict) {\n    return dict.traverse;\n};\nvar traversableTuple = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Tuple.Tuple.create(v.value0))(f(v.value1));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Tuple.Tuple.create(v.value0))(v.value1);\n        };\n    },\n    Functor0: function () {\n        return Data_Tuple.functorTuple;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableTuple;\n    }\n};\nvar traversableMultiplicative = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Monoid_Multiplicative.Multiplicative)(f(v));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Monoid_Multiplicative.Multiplicative)(v);\n        };\n    },\n    Functor0: function () {\n        return Data_Monoid_Multiplicative.functorMultiplicative;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableMultiplicative;\n    }\n};\nvar traversableMaybe = {\n    traverse: function (dictApplicative) {\n        return function (v) {\n            return function (v1) {\n                if (v1 instanceof Data_Maybe.Nothing) {\n                    return Control_Applicative.pure(dictApplicative)(Data_Maybe.Nothing.value);\n                };\n                if (v1 instanceof Data_Maybe.Just) {\n                    return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Maybe.Just.create)(v(v1.value0));\n                };\n                throw new Error(\"Failed pattern match at Data.Traversable (line 115, column 1 - line 119, column 33): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            if (v instanceof Data_Maybe.Nothing) {\n                return Control_Applicative.pure(dictApplicative)(Data_Maybe.Nothing.value);\n            };\n            if (v instanceof Data_Maybe.Just) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Maybe.Just.create)(v.value0);\n            };\n            throw new Error(\"Failed pattern match at Data.Traversable (line 115, column 1 - line 119, column 33): \" + [ v.constructor.name ]);\n        };\n    },\n    Functor0: function () {\n        return Data_Maybe.functorMaybe;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableMaybe;\n    }\n};\nvar traversableIdentity = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Identity.Identity)(f(v));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Identity.Identity)(v);\n        };\n    },\n    Functor0: function () {\n        return Data_Identity.functorIdentity;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableIdentity;\n    }\n};\nvar traversableEither = {\n    traverse: function (dictApplicative) {\n        return function (v) {\n            return function (v1) {\n                if (v1 instanceof Data_Either.Left) {\n                    return Control_Applicative.pure(dictApplicative)(new Data_Either.Left(v1.value0));\n                };\n                if (v1 instanceof Data_Either.Right) {\n                    return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Either.Right.create)(v(v1.value0));\n                };\n                throw new Error(\"Failed pattern match at Data.Traversable (line 149, column 1 - line 153, column 36): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            if (v instanceof Data_Either.Left) {\n                return Control_Applicative.pure(dictApplicative)(new Data_Either.Left(v.value0));\n            };\n            if (v instanceof Data_Either.Right) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Either.Right.create)(v.value0);\n            };\n            throw new Error(\"Failed pattern match at Data.Traversable (line 149, column 1 - line 153, column 36): \" + [ v.constructor.name ]);\n        };\n    },\n    Functor0: function () {\n        return Data_Either.functorEither;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableEither;\n    }\n};\nvar traversableDual = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Monoid_Dual.Dual)(f(v));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Monoid_Dual.Dual)(v);\n        };\n    },\n    Functor0: function () {\n        return Data_Monoid_Dual.functorDual;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableDual;\n    }\n};\nvar traversableDisj = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Monoid_Disj.Disj)(f(v));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Monoid_Disj.Disj)(v);\n        };\n    },\n    Functor0: function () {\n        return Data_Monoid_Disj.functorDisj;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableDisj;\n    }\n};\nvar traversableConst = {\n    traverse: function (dictApplicative) {\n        return function (v) {\n            return function (v1) {\n                return Control_Applicative.pure(dictApplicative)(v1);\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Control_Applicative.pure(dictApplicative)(v);\n        };\n    },\n    Functor0: function () {\n        return Data_Const.functorConst;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableConst;\n    }\n};\nvar traversableConj = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Monoid_Conj.Conj)(f(v));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Monoid_Conj.Conj)(v);\n        };\n    },\n    Functor0: function () {\n        return Data_Monoid_Conj.functorConj;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableConj;\n    }\n};\nvar traversableCompose = function (dictTraversable) {\n    return function (dictTraversable1) {\n        return {\n            traverse: function (dictApplicative) {\n                return function (f) {\n                    return function (v) {\n                        return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_Compose.Compose)(traverse(dictTraversable)(dictApplicative)(traverse(dictTraversable1)(dictApplicative)(f))(v));\n                    };\n                };\n            },\n            sequence: function (dictApplicative) {\n                return traverse(traversableCompose(dictTraversable)(dictTraversable1))(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));\n            },\n            Functor0: function () {\n                return Data_Functor_Compose.functorCompose(dictTraversable.Functor0())(dictTraversable1.Functor0());\n            },\n            Foldable1: function () {\n                return Data_Foldable.foldableCompose(dictTraversable.Foldable1())(dictTraversable1.Foldable1());\n            }\n        };\n    };\n};\nvar traversableAdditive = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Monoid_Additive.Additive)(f(v));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Monoid_Additive.Additive)(v);\n        };\n    },\n    Functor0: function () {\n        return Data_Monoid_Additive.functorAdditive;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableAdditive;\n    }\n};\nvar sequenceDefault = function (dictTraversable) {\n    return function (dictApplicative) {\n        return traverse(dictTraversable)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar traversableArray = {\n    traverse: function (dictApplicative) {\n        return $foreign.traverseArrayImpl(Control_Apply.apply(dictApplicative.Apply0()))(Data_Functor.map((dictApplicative.Apply0()).Functor0()))(Control_Applicative.pure(dictApplicative));\n    },\n    sequence: function (dictApplicative) {\n        return sequenceDefault(traversableArray)(dictApplicative);\n    },\n    Functor0: function () {\n        return Data_Functor.functorArray;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableArray;\n    }\n};\nvar sequence = function (dict) {\n    return dict.sequence;\n};\nvar traversableApp = function (dictTraversable) {\n    return {\n        traverse: function (dictApplicative) {\n            return function (f) {\n                return function (v) {\n                    return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_App.App)(traverse(dictTraversable)(dictApplicative)(f)(v));\n                };\n            };\n        },\n        sequence: function (dictApplicative) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_App.App)(sequence(dictTraversable)(dictApplicative)(v));\n            };\n        },\n        Functor0: function () {\n            return Data_Functor_App.functorApp(dictTraversable.Functor0());\n        },\n        Foldable1: function () {\n            return Data_Foldable.foldableApp(dictTraversable.Foldable1());\n        }\n    };\n};\nvar traversableCoproduct = function (dictTraversable) {\n    return function (dictTraversable1) {\n        return {\n            traverse: function (dictApplicative) {\n                return function (f) {\n                    return Data_Functor_Coproduct.coproduct((function () {\n                        var $143 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(function ($146) {\n                            return Data_Functor_Coproduct.Coproduct(Data_Either.Left.create($146));\n                        });\n                        var $144 = traverse(dictTraversable)(dictApplicative)(f);\n                        return function ($145) {\n                            return $143($144($145));\n                        };\n                    })())((function () {\n                        var $147 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(function ($150) {\n                            return Data_Functor_Coproduct.Coproduct(Data_Either.Right.create($150));\n                        });\n                        var $148 = traverse(dictTraversable1)(dictApplicative)(f);\n                        return function ($149) {\n                            return $147($148($149));\n                        };\n                    })());\n                };\n            },\n            sequence: function (dictApplicative) {\n                return Data_Functor_Coproduct.coproduct((function () {\n                    var $151 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(function ($154) {\n                        return Data_Functor_Coproduct.Coproduct(Data_Either.Left.create($154));\n                    });\n                    var $152 = sequence(dictTraversable)(dictApplicative);\n                    return function ($153) {\n                        return $151($152($153));\n                    };\n                })())((function () {\n                    var $155 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(function ($158) {\n                        return Data_Functor_Coproduct.Coproduct(Data_Either.Right.create($158));\n                    });\n                    var $156 = sequence(dictTraversable1)(dictApplicative);\n                    return function ($157) {\n                        return $155($156($157));\n                    };\n                })());\n            },\n            Functor0: function () {\n                return Data_Functor_Coproduct.functorCoproduct(dictTraversable.Functor0())(dictTraversable1.Functor0());\n            },\n            Foldable1: function () {\n                return Data_Foldable.foldableCoproduct(dictTraversable.Foldable1())(dictTraversable1.Foldable1());\n            }\n        };\n    };\n};\nvar traversableFirst = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Maybe_First.First)(traverse(traversableMaybe)(dictApplicative)(f)(v));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Maybe_First.First)(sequence(traversableMaybe)(dictApplicative)(v));\n        };\n    },\n    Functor0: function () {\n        return Data_Maybe_First.functorFirst;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableFirst;\n    }\n};\nvar traversableLast = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Maybe_Last.Last)(traverse(traversableMaybe)(dictApplicative)(f)(v));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Maybe_Last.Last)(sequence(traversableMaybe)(dictApplicative)(v));\n        };\n    },\n    Functor0: function () {\n        return Data_Maybe_Last.functorLast;\n    },\n    Foldable1: function () {\n        return Data_Foldable.foldableLast;\n    }\n};\nvar traversableProduct = function (dictTraversable) {\n    return function (dictTraversable1) {\n        return {\n            traverse: function (dictApplicative) {\n                return function (f) {\n                    return function (v) {\n                        return Control_Apply.lift2(dictApplicative.Apply0())(Data_Functor_Product.product)(traverse(dictTraversable)(dictApplicative)(f)(v.value0))(traverse(dictTraversable1)(dictApplicative)(f)(v.value1));\n                    };\n                };\n            },\n            sequence: function (dictApplicative) {\n                return function (v) {\n                    return Control_Apply.lift2(dictApplicative.Apply0())(Data_Functor_Product.product)(sequence(dictTraversable)(dictApplicative)(v.value0))(sequence(dictTraversable1)(dictApplicative)(v.value1));\n                };\n            },\n            Functor0: function () {\n                return Data_Functor_Product.functorProduct(dictTraversable.Functor0())(dictTraversable1.Functor0());\n            },\n            Foldable1: function () {\n                return Data_Foldable.foldableProduct(dictTraversable.Foldable1())(dictTraversable1.Foldable1());\n            }\n        };\n    };\n};\nvar traverseDefault = function (dictTraversable) {\n    return function (dictApplicative) {\n        return function (f) {\n            return function (ta) {\n                return sequence(dictTraversable)(dictApplicative)(Data_Functor.map(dictTraversable.Functor0())(f)(ta));\n            };\n        };\n    };\n};\nvar mapAccumR = function (dictTraversable) {\n    return function (f) {\n        return function (s0) {\n            return function (xs) {\n                return Data_Traversable_Accum_Internal.stateR(traverse(dictTraversable)(Data_Traversable_Accum_Internal.applicativeStateR)(function (a) {\n                    return function (s) {\n                        return f(s)(a);\n                    };\n                })(xs))(s0);\n            };\n        };\n    };\n};\nvar scanr = function (dictTraversable) {\n    return function (f) {\n        return function (b0) {\n            return function (xs) {\n                return (mapAccumR(dictTraversable)(function (b) {\n                    return function (a) {\n                        var b$prime = f(a)(b);\n                        return {\n                            accum: b$prime,\n                            value: b$prime\n                        };\n                    };\n                })(b0)(xs)).value;\n            };\n        };\n    };\n};\nvar mapAccumL = function (dictTraversable) {\n    return function (f) {\n        return function (s0) {\n            return function (xs) {\n                return Data_Traversable_Accum_Internal.stateL(traverse(dictTraversable)(Data_Traversable_Accum_Internal.applicativeStateL)(function (a) {\n                    return function (s) {\n                        return f(s)(a);\n                    };\n                })(xs))(s0);\n            };\n        };\n    };\n};\nvar scanl = function (dictTraversable) {\n    return function (f) {\n        return function (b0) {\n            return function (xs) {\n                return (mapAccumL(dictTraversable)(function (b) {\n                    return function (a) {\n                        var b$prime = f(b)(a);\n                        return {\n                            accum: b$prime,\n                            value: b$prime\n                        };\n                    };\n                })(b0)(xs)).value;\n            };\n        };\n    };\n};\nvar $$for = function (dictApplicative) {\n    return function (dictTraversable) {\n        return function (x) {\n            return function (f) {\n                return traverse(dictTraversable)(dictApplicative)(f)(x);\n            };\n        };\n    };\n};\nmodule.exports = {\n    traverse: traverse,\n    sequence: sequence,\n    traverseDefault: traverseDefault,\n    sequenceDefault: sequenceDefault,\n    \"for\": $$for,\n    scanl: scanl,\n    scanr: scanr,\n    mapAccumL: mapAccumL,\n    mapAccumR: mapAccumR,\n    traversableArray: traversableArray,\n    traversableMaybe: traversableMaybe,\n    traversableFirst: traversableFirst,\n    traversableLast: traversableLast,\n    traversableAdditive: traversableAdditive,\n    traversableDual: traversableDual,\n    traversableConj: traversableConj,\n    traversableDisj: traversableDisj,\n    traversableMultiplicative: traversableMultiplicative,\n    traversableEither: traversableEither,\n    traversableTuple: traversableTuple,\n    traversableIdentity: traversableIdentity,\n    traversableConst: traversableConst,\n    traversableProduct: traversableProduct,\n    traversableCoproduct: traversableCoproduct,\n    traversableCompose: traversableCompose,\n    traversableApp: traversableApp,\n    all: Data_Foldable.all,\n    and: Data_Foldable.and,\n    any: Data_Foldable.any,\n    elem: Data_Foldable.elem,\n    find: Data_Foldable.find,\n    fold: Data_Foldable.fold,\n    foldMap: Data_Foldable.foldMap,\n    foldMapDefaultL: Data_Foldable.foldMapDefaultL,\n    foldMapDefaultR: Data_Foldable.foldMapDefaultR,\n    foldl: Data_Foldable.foldl,\n    foldlDefault: Data_Foldable.foldlDefault,\n    foldr: Data_Foldable.foldr,\n    foldrDefault: Data_Foldable.foldrDefault,\n    for_: Data_Foldable.for_,\n    intercalate: Data_Foldable.intercalate,\n    maximum: Data_Foldable.maximum,\n    maximumBy: Data_Foldable.maximumBy,\n    minimum: Data_Foldable.minimum,\n    minimumBy: Data_Foldable.minimumBy,\n    notElem: Data_Foldable.notElem,\n    oneOf: Data_Foldable.oneOf,\n    or: Data_Foldable.or,\n    sequence_: Data_Foldable.sequence_,\n    sum: Data_Foldable.sum,\n    traverse_: Data_Foldable.traverse_\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum.purs":
/*!****************************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum.purs ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nmodule.exports = {};\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum/Internal.purs":
/*!*************************************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum/Internal.purs ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar StateR = function (x) {\n    return x;\n};\nvar StateL = function (x) {\n    return x;\n};\nvar stateR = function (v) {\n    return v;\n};\nvar stateL = function (v) {\n    return v;\n};\nvar functorStateR = {\n    map: function (f) {\n        return function (k) {\n            return function (s) {\n                var v = stateR(k)(s);\n                return {\n                    accum: v.accum,\n                    value: f(v.value)\n                };\n            };\n        };\n    }\n};\nvar functorStateL = {\n    map: function (f) {\n        return function (k) {\n            return function (s) {\n                var v = stateL(k)(s);\n                return {\n                    accum: v.accum,\n                    value: f(v.value)\n                };\n            };\n        };\n    }\n};\nvar applyStateR = {\n    apply: function (f) {\n        return function (x) {\n            return function (s) {\n                var v = stateR(x)(s);\n                var v1 = stateR(f)(v.accum);\n                return {\n                    accum: v1.accum,\n                    value: v1.value(v.value)\n                };\n            };\n        };\n    },\n    Functor0: function () {\n        return functorStateR;\n    }\n};\nvar applyStateL = {\n    apply: function (f) {\n        return function (x) {\n            return function (s) {\n                var v = stateL(f)(s);\n                var v1 = stateL(x)(v.accum);\n                return {\n                    accum: v1.accum,\n                    value: v.value(v1.value)\n                };\n            };\n        };\n    },\n    Functor0: function () {\n        return functorStateL;\n    }\n};\nvar applicativeStateR = {\n    pure: function (a) {\n        return function (s) {\n            return {\n                accum: s,\n                value: a\n            };\n        };\n    },\n    Apply0: function () {\n        return applyStateR;\n    }\n};\nvar applicativeStateL = {\n    pure: function (a) {\n        return function (s) {\n            return {\n                accum: s,\n                value: a\n            };\n        };\n    },\n    Apply0: function () {\n        return applyStateL;\n    }\n};\nmodule.exports = {\n    StateL: StateL,\n    stateL: stateL,\n    StateR: StateR,\n    stateR: stateR,\n    functorStateL: functorStateL,\n    applyStateL: applyStateL,\n    applicativeStateL: applicativeStateL,\n    functorStateR: functorStateR,\n    applyStateR: applyStateR,\n    applicativeStateR: applicativeStateR\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum/Internal.purs?");

/***/ }),

/***/ "./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs":
/*!*******************************************************************************!*\
  !*** ./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_FoldableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Functor_App = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/App.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/App.purs\");\nvar Data_Functor_Compose = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Compose.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Compose.purs\");\nvar Data_Functor_Coproduct = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs\");\nvar Data_Functor_Product = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/Product.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/Product.purs\");\nvar Data_FunctorWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Traversable_Accum = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum.purs\");\nvar Data_Traversable_Accum_Internal = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum/Internal.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable/Accum/Internal.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar traverseWithIndexDefault = function (dictTraversableWithIndex) {\n    return function (dictApplicative) {\n        return function (f) {\n            var $64 = Data_Traversable.sequence(dictTraversableWithIndex.Traversable2())(dictApplicative);\n            var $65 = Data_FunctorWithIndex.mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0())(f);\n            return function ($66) {\n                return $64($65($66));\n            };\n        };\n    };\n};\nvar traverseWithIndex = function (dict) {\n    return dict.traverseWithIndex;\n};\nvar traverseDefault = function (dictTraversableWithIndex) {\n    return function (dictApplicative) {\n        return function (f) {\n            return traverseWithIndex(dictTraversableWithIndex)(dictApplicative)(Data_Function[\"const\"](f));\n        };\n    };\n};\nvar traversableWithIndexTuple = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Tuple.Tuple.create(v.value0))(f(Data_Unit.unit)(v.value1));\n            };\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexTuple;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexTuple;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableTuple;\n    }\n};\nvar traversableWithIndexProduct = function (dictTraversableWithIndex) {\n    return function (dictTraversableWithIndex1) {\n        return {\n            traverseWithIndex: function (dictApplicative) {\n                return function (f) {\n                    return function (v) {\n                        return Control_Apply.lift2(dictApplicative.Apply0())(Data_Functor_Product.product)(traverseWithIndex(dictTraversableWithIndex)(dictApplicative)(function ($67) {\n                            return f(Data_Either.Left.create($67));\n                        })(v.value0))(traverseWithIndex(dictTraversableWithIndex1)(dictApplicative)(function ($68) {\n                            return f(Data_Either.Right.create($68));\n                        })(v.value1));\n                    };\n                };\n            },\n            FunctorWithIndex0: function () {\n                return Data_FunctorWithIndex.functorWithIndexProduct(dictTraversableWithIndex.FunctorWithIndex0())(dictTraversableWithIndex1.FunctorWithIndex0());\n            },\n            FoldableWithIndex1: function () {\n                return Data_FoldableWithIndex.foldableWithIndexProduct(dictTraversableWithIndex.FoldableWithIndex1())(dictTraversableWithIndex1.FoldableWithIndex1());\n            },\n            Traversable2: function () {\n                return Data_Traversable.traversableProduct(dictTraversableWithIndex.Traversable2())(dictTraversableWithIndex1.Traversable2());\n            }\n        };\n    };\n};\nvar traversableWithIndexMultiplicative = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return Data_Traversable.traverse(Data_Traversable.traversableMultiplicative)(dictApplicative)(f(Data_Unit.unit));\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexMultiplicative;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexMultiplicative;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableMultiplicative;\n    }\n};\nvar traversableWithIndexMaybe = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return Data_Traversable.traverse(Data_Traversable.traversableMaybe)(dictApplicative)(f(Data_Unit.unit));\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexMaybe;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexMaybe;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableMaybe;\n    }\n};\nvar traversableWithIndexLast = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return Data_Traversable.traverse(Data_Traversable.traversableLast)(dictApplicative)(f(Data_Unit.unit));\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexLast;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexLast;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableLast;\n    }\n};\nvar traversableWithIndexIdentity = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Identity.Identity)(f(Data_Unit.unit)(v));\n            };\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexIdentity;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexIdentity;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableIdentity;\n    }\n};\nvar traversableWithIndexFirst = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return Data_Traversable.traverse(Data_Traversable.traversableFirst)(dictApplicative)(f(Data_Unit.unit));\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexFirst;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexFirst;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableFirst;\n    }\n};\nvar traversableWithIndexEither = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (v) {\n            return function (v1) {\n                if (v1 instanceof Data_Either.Left) {\n                    return Control_Applicative.pure(dictApplicative)(new Data_Either.Left(v1.value0));\n                };\n                if (v1 instanceof Data_Either.Right) {\n                    return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Either.Right.create)(v(Data_Unit.unit)(v1.value0));\n                };\n                throw new Error(\"Failed pattern match at Data.TraversableWithIndex (line 95, column 1 - line 97, column 53): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexEither;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexEither;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableEither;\n    }\n};\nvar traversableWithIndexDual = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return Data_Traversable.traverse(Data_Traversable.traversableDual)(dictApplicative)(f(Data_Unit.unit));\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexDual;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexDual;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableDual;\n    }\n};\nvar traversableWithIndexDisj = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return Data_Traversable.traverse(Data_Traversable.traversableDisj)(dictApplicative)(f(Data_Unit.unit));\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexDisj;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexDisj;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableDisj;\n    }\n};\nvar traversableWithIndexCoproduct = function (dictTraversableWithIndex) {\n    return function (dictTraversableWithIndex1) {\n        return {\n            traverseWithIndex: function (dictApplicative) {\n                return function (f) {\n                    return Data_Functor_Coproduct.coproduct((function () {\n                        var $69 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(function ($72) {\n                            return Data_Functor_Coproduct.Coproduct(Data_Either.Left.create($72));\n                        });\n                        var $70 = traverseWithIndex(dictTraversableWithIndex)(dictApplicative)(function ($73) {\n                            return f(Data_Either.Left.create($73));\n                        });\n                        return function ($71) {\n                            return $69($70($71));\n                        };\n                    })())((function () {\n                        var $74 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(function ($77) {\n                            return Data_Functor_Coproduct.Coproduct(Data_Either.Right.create($77));\n                        });\n                        var $75 = traverseWithIndex(dictTraversableWithIndex1)(dictApplicative)(function ($78) {\n                            return f(Data_Either.Right.create($78));\n                        });\n                        return function ($76) {\n                            return $74($75($76));\n                        };\n                    })());\n                };\n            },\n            FunctorWithIndex0: function () {\n                return Data_FunctorWithIndex.functorWithIndexCoproduct(dictTraversableWithIndex.FunctorWithIndex0())(dictTraversableWithIndex1.FunctorWithIndex0());\n            },\n            FoldableWithIndex1: function () {\n                return Data_FoldableWithIndex.foldableWithIndexCoproduct(dictTraversableWithIndex.FoldableWithIndex1())(dictTraversableWithIndex1.FoldableWithIndex1());\n            },\n            Traversable2: function () {\n                return Data_Traversable.traversableCoproduct(dictTraversableWithIndex.Traversable2())(dictTraversableWithIndex1.Traversable2());\n            }\n        };\n    };\n};\nvar traversableWithIndexConst = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (v) {\n            return function (v1) {\n                return Control_Applicative.pure(dictApplicative)(v1);\n            };\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexConst;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexConst;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableConst;\n    }\n};\nvar traversableWithIndexConj = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return Data_Traversable.traverse(Data_Traversable.traversableConj)(dictApplicative)(f(Data_Unit.unit));\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexConj;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexConj;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableConj;\n    }\n};\nvar traversableWithIndexCompose = function (dictTraversableWithIndex) {\n    return function (dictTraversableWithIndex1) {\n        return {\n            traverseWithIndex: function (dictApplicative) {\n                return function (f) {\n                    return function (v) {\n                        return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_Compose.Compose)(traverseWithIndex(dictTraversableWithIndex)(dictApplicative)((function () {\n                            var $79 = traverseWithIndex(dictTraversableWithIndex1)(dictApplicative);\n                            var $80 = Data_Tuple.curry(f);\n                            return function ($81) {\n                                return $79($80($81));\n                            };\n                        })())(v));\n                    };\n                };\n            },\n            FunctorWithIndex0: function () {\n                return Data_FunctorWithIndex.functorWithIndexCompose(dictTraversableWithIndex.FunctorWithIndex0())(dictTraversableWithIndex1.FunctorWithIndex0());\n            },\n            FoldableWithIndex1: function () {\n                return Data_FoldableWithIndex.foldableWithIndexCompose(dictTraversableWithIndex.FoldableWithIndex1())(dictTraversableWithIndex1.FoldableWithIndex1());\n            },\n            Traversable2: function () {\n                return Data_Traversable.traversableCompose(dictTraversableWithIndex.Traversable2())(dictTraversableWithIndex1.Traversable2());\n            }\n        };\n    };\n};\nvar traversableWithIndexArray = {\n    traverseWithIndex: function (dictApplicative) {\n        return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexArray;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexArray;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableArray;\n    }\n};\nvar traversableWithIndexApp = function (dictTraversableWithIndex) {\n    return {\n        traverseWithIndex: function (dictApplicative) {\n            return function (f) {\n                return function (v) {\n                    return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Functor_App.App)(traverseWithIndex(dictTraversableWithIndex)(dictApplicative)(f)(v));\n                };\n            };\n        },\n        FunctorWithIndex0: function () {\n            return Data_FunctorWithIndex.functorWithIndexApp(dictTraversableWithIndex.FunctorWithIndex0());\n        },\n        FoldableWithIndex1: function () {\n            return Data_FoldableWithIndex.foldableWithIndexApp(dictTraversableWithIndex.FoldableWithIndex1());\n        },\n        Traversable2: function () {\n            return Data_Traversable.traversableApp(dictTraversableWithIndex.Traversable2());\n        }\n    };\n};\nvar traversableWithIndexAdditive = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return Data_Traversable.traverse(Data_Traversable.traversableAdditive)(dictApplicative)(f(Data_Unit.unit));\n        };\n    },\n    FunctorWithIndex0: function () {\n        return Data_FunctorWithIndex.functorWithIndexAdditive;\n    },\n    FoldableWithIndex1: function () {\n        return Data_FoldableWithIndex.foldableWithIndexAdditive;\n    },\n    Traversable2: function () {\n        return Data_Traversable.traversableAdditive;\n    }\n};\nvar mapAccumRWithIndex = function (dictTraversableWithIndex) {\n    return function (f) {\n        return function (s0) {\n            return function (xs) {\n                return Data_Traversable_Accum_Internal.stateR(traverseWithIndex(dictTraversableWithIndex)(Data_Traversable_Accum_Internal.applicativeStateR)(function (i) {\n                    return function (a) {\n                        return function (s) {\n                            return f(i)(s)(a);\n                        };\n                    };\n                })(xs))(s0);\n            };\n        };\n    };\n};\nvar scanrWithIndex = function (dictTraversableWithIndex) {\n    return function (f) {\n        return function (b0) {\n            return function (xs) {\n                return (mapAccumRWithIndex(dictTraversableWithIndex)(function (i) {\n                    return function (b) {\n                        return function (a) {\n                            var b$prime = f(i)(a)(b);\n                            return {\n                                accum: b$prime,\n                                value: b$prime\n                            };\n                        };\n                    };\n                })(b0)(xs)).value;\n            };\n        };\n    };\n};\nvar mapAccumLWithIndex = function (dictTraversableWithIndex) {\n    return function (f) {\n        return function (s0) {\n            return function (xs) {\n                return Data_Traversable_Accum_Internal.stateL(traverseWithIndex(dictTraversableWithIndex)(Data_Traversable_Accum_Internal.applicativeStateL)(function (i) {\n                    return function (a) {\n                        return function (s) {\n                            return f(i)(s)(a);\n                        };\n                    };\n                })(xs))(s0);\n            };\n        };\n    };\n};\nvar scanlWithIndex = function (dictTraversableWithIndex) {\n    return function (f) {\n        return function (b0) {\n            return function (xs) {\n                return (mapAccumLWithIndex(dictTraversableWithIndex)(function (i) {\n                    return function (b) {\n                        return function (a) {\n                            var b$prime = f(i)(b)(a);\n                            return {\n                                accum: b$prime,\n                                value: b$prime\n                            };\n                        };\n                    };\n                })(b0)(xs)).value;\n            };\n        };\n    };\n};\nvar forWithIndex = function (dictApplicative) {\n    return function (dictTraversableWithIndex) {\n        return Data_Function.flip(traverseWithIndex(dictTraversableWithIndex)(dictApplicative));\n    };\n};\nmodule.exports = {\n    traverseWithIndex: traverseWithIndex,\n    traverseWithIndexDefault: traverseWithIndexDefault,\n    forWithIndex: forWithIndex,\n    scanlWithIndex: scanlWithIndex,\n    mapAccumLWithIndex: mapAccumLWithIndex,\n    scanrWithIndex: scanrWithIndex,\n    mapAccumRWithIndex: mapAccumRWithIndex,\n    traverseDefault: traverseDefault,\n    traversableWithIndexArray: traversableWithIndexArray,\n    traversableWithIndexMaybe: traversableWithIndexMaybe,\n    traversableWithIndexFirst: traversableWithIndexFirst,\n    traversableWithIndexLast: traversableWithIndexLast,\n    traversableWithIndexAdditive: traversableWithIndexAdditive,\n    traversableWithIndexDual: traversableWithIndexDual,\n    traversableWithIndexConj: traversableWithIndexConj,\n    traversableWithIndexDisj: traversableWithIndexDisj,\n    traversableWithIndexMultiplicative: traversableWithIndexMultiplicative,\n    traversableWithIndexEither: traversableWithIndexEither,\n    traversableWithIndexTuple: traversableWithIndexTuple,\n    traversableWithIndexIdentity: traversableWithIndexIdentity,\n    traversableWithIndexConst: traversableWithIndexConst,\n    traversableWithIndexProduct: traversableWithIndexProduct,\n    traversableWithIndexCoproduct: traversableWithIndexCoproduct,\n    traversableWithIndexCompose: traversableWithIndexCompose,\n    traversableWithIndexApp: traversableWithIndexApp\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs?");

/***/ }),

/***/ "./.spago/free/v6.0.1/src/Control/Monad/Free.purs":
/*!********************************************************!*\
  !*** ./.spago/free/v6.0.1/src/Control/Monad/Free.purs ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Data_CatList = __webpack_require__(/*! ./.spago/catenable-lists/v6.0.1/src/Data/CatList.purs */ \"./.spago/catenable-lists/v6.0.1/src/Data/CatList.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Unsafe_Coerce = __webpack_require__(/*! ./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs */ \"./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs\");\nvar ExpF = function (x) {\n    return x;\n};\nvar Free = (function () {\n    function Free(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    Free.create = function (value0) {\n        return function (value1) {\n            return new Free(value0, value1);\n        };\n    };\n    return Free;\n})();\nvar Return = (function () {\n    function Return(value0) {\n        this.value0 = value0;\n    };\n    Return.create = function (value0) {\n        return new Return(value0);\n    };\n    return Return;\n})();\nvar Bind = (function () {\n    function Bind(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    Bind.create = function (value0) {\n        return function (value1) {\n            return new Bind(value0, value1);\n        };\n    };\n    return Bind;\n})();\nvar toView = function ($copy_v) {\n    var $tco_done = false;\n    var $tco_result;\n    function $tco_loop(v) {\n        var runExpF = function (v2) {\n            return v2;\n        };\n        var concatF = function (v2) {\n            return function (r) {\n                return new Free(v2.value0, Data_Semigroup.append(Data_CatList.semigroupCatList)(v2.value1)(r));\n            };\n        };\n        if (v.value0 instanceof Return) {\n            var v2 = Data_CatList.uncons(v.value1);\n            if (v2 instanceof Data_Maybe.Nothing) {\n                $tco_done = true;\n                return new Return(v.value0.value0);\n            };\n            if (v2 instanceof Data_Maybe.Just) {\n                $copy_v = concatF(runExpF(v2.value0.value0)(v.value0.value0))(v2.value0.value1);\n                return;\n            };\n            throw new Error(\"Failed pattern match at Control.Monad.Free (line 227, column 7 - line 231, column 64): \" + [ v2.constructor.name ]);\n        };\n        if (v.value0 instanceof Bind) {\n            $tco_done = true;\n            return new Bind(v.value0.value0, function (a) {\n                return concatF(v.value0.value1(a))(v.value1);\n            });\n        };\n        throw new Error(\"Failed pattern match at Control.Monad.Free (line 225, column 3 - line 233, column 56): \" + [ v.value0.constructor.name ]);\n    };\n    while (!$tco_done) {\n        $tco_result = $tco_loop($copy_v);\n    };\n    return $tco_result;\n};\nvar runFreeM = function (dictFunctor) {\n    return function (dictMonadRec) {\n        return function (k) {\n            var go = function (f) {\n                var v = toView(f);\n                if (v instanceof Return) {\n                    return Data_Functor.map((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0())(Control_Monad_Rec_Class.Done.create)(Control_Applicative.pure((dictMonadRec.Monad0()).Applicative0())(v.value0));\n                };\n                if (v instanceof Bind) {\n                    return Data_Functor.map((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0())(Control_Monad_Rec_Class.Loop.create)(k(Data_Functor.map(dictFunctor)(v.value1)(v.value0)));\n                };\n                throw new Error(\"Failed pattern match at Control.Monad.Free (line 194, column 10 - line 196, column 37): \" + [ v.constructor.name ]);\n            };\n            return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(go);\n        };\n    };\n};\nvar runFree = function (dictFunctor) {\n    return function (k) {\n        var go = function ($copy_f) {\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(f) {\n                var v = toView(f);\n                if (v instanceof Return) {\n                    $tco_done = true;\n                    return v.value0;\n                };\n                if (v instanceof Bind) {\n                    $copy_f = k(Data_Functor.map(dictFunctor)(v.value1)(v.value0));\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Control.Monad.Free (line 178, column 10 - line 180, column 33): \" + [ v.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($copy_f);\n            };\n            return $tco_result;\n        };\n        return go;\n    };\n};\nvar resume$prime = function (k) {\n    return function (j) {\n        return function (f) {\n            var v = toView(f);\n            if (v instanceof Return) {\n                return j(v.value0);\n            };\n            if (v instanceof Bind) {\n                return k(v.value0)(v.value1);\n            };\n            throw new Error(\"Failed pattern match at Control.Monad.Free (line 213, column 17 - line 215, column 20): \" + [ v.constructor.name ]);\n        };\n    };\n};\nvar resume = function (dictFunctor) {\n    return resume$prime(function (g) {\n        return function (i) {\n            return new Data_Either.Left(Data_Functor.map(dictFunctor)(i)(g));\n        };\n    })(Data_Either.Right.create);\n};\nvar fromView = function (f) {\n    return new Free(f, Data_CatList.empty);\n};\nvar wrap = function (f) {\n    return fromView(new Bind(f, Unsafe_Coerce.unsafeCoerce));\n};\nvar suspendF = function (dictApplicative) {\n    return function (f) {\n        return wrap(Control_Applicative.pure(dictApplicative)(f));\n    };\n};\nvar freeMonad = {\n    Applicative0: function () {\n        return freeApplicative;\n    },\n    Bind1: function () {\n        return freeBind;\n    }\n};\nvar freeFunctor = {\n    map: function (k) {\n        return function (f) {\n            return Control_Bind.bindFlipped(freeBind)((function () {\n                var $119 = Control_Applicative.pure(freeApplicative);\n                return function ($120) {\n                    return $119(k($120));\n                };\n            })())(f);\n        };\n    }\n};\nvar freeBind = {\n    bind: function (v) {\n        return function (k) {\n            return new Free(v.value0, Data_CatList.snoc(v.value1)(k));\n        };\n    },\n    Apply0: function () {\n        return freeApply;\n    }\n};\nvar freeApply = {\n    apply: Control_Monad.ap(freeMonad),\n    Functor0: function () {\n        return freeFunctor;\n    }\n};\nvar freeApplicative = {\n    pure: function ($121) {\n        return fromView(Return.create($121));\n    },\n    Apply0: function () {\n        return freeApply;\n    }\n};\nvar semigroupFree = function (dictSemigroup) {\n    return {\n        append: Control_Apply.lift2(freeApply)(Data_Semigroup.append(dictSemigroup))\n    };\n};\nvar freeMonadRec = {\n    tailRecM: function (k) {\n        return function (a) {\n            return Control_Bind.bind(freeBind)(k(a))(function (v) {\n                if (v instanceof Control_Monad_Rec_Class.Loop) {\n                    return Control_Monad_Rec_Class.tailRecM(freeMonadRec)(k)(v.value0);\n                };\n                if (v instanceof Control_Monad_Rec_Class.Done) {\n                    return Control_Applicative.pure(freeApplicative)(v.value0);\n                };\n                throw new Error(\"Failed pattern match at Control.Monad.Free (line 86, column 26 - line 88, column 21): \" + [ v.constructor.name ]);\n            });\n        };\n    },\n    Monad0: function () {\n        return freeMonad;\n    }\n};\nvar liftF = function (f) {\n    return fromView(new Bind(f, (function () {\n        var $122 = Control_Applicative.pure(freeApplicative);\n        return function ($123) {\n            return $122($123);\n        };\n    })()));\n};\nvar freeMonadTrans = {\n    lift: function (dictMonad) {\n        return liftF;\n    }\n};\nvar monoidFree = function (dictMonoid) {\n    return {\n        mempty: Control_Applicative.pure(freeApplicative)(Data_Monoid.mempty(dictMonoid)),\n        Semigroup0: function () {\n            return semigroupFree(dictMonoid.Semigroup0());\n        }\n    };\n};\nvar substFree = function (k) {\n    var go = function (f) {\n        var v = toView(f);\n        if (v instanceof Return) {\n            return Control_Applicative.pure(freeApplicative)(v.value0);\n        };\n        if (v instanceof Bind) {\n            return Control_Bind.bind(freeBind)(k(v.value0))(Data_Functor.map(Data_Functor.functorFn)(go)(v.value1));\n        };\n        throw new Error(\"Failed pattern match at Control.Monad.Free (line 168, column 10 - line 170, column 33): \" + [ v.constructor.name ]);\n    };\n    return go;\n};\nvar hoistFree = function (k) {\n    return substFree(function ($124) {\n        return liftF(k($124));\n    });\n};\nvar foldableFree = function (dictFunctor) {\n    return function (dictFoldable) {\n        return {\n            foldMap: function (dictMonoid) {\n                return function (f) {\n                    var go = (function () {\n                        var $125 = resume(dictFunctor);\n                        return function ($126) {\n                            return (function (v) {\n                                if (v instanceof Data_Either.Left) {\n                                    return Data_Foldable.foldMap(dictFoldable)(dictMonoid)(go)(v.value0);\n                                };\n                                if (v instanceof Data_Either.Right) {\n                                    return f(v.value0);\n                                };\n                                throw new Error(\"Failed pattern match at Control.Monad.Free (line 93, column 21 - line 95, column 21): \" + [ v.constructor.name ]);\n                            })($125($126));\n                        };\n                    })();\n                    return go;\n                };\n            },\n            foldl: function (f) {\n                var go = function (r) {\n                    var $127 = resume(dictFunctor);\n                    return function ($128) {\n                        return (function (v) {\n                            if (v instanceof Data_Either.Left) {\n                                return Data_Foldable.foldl(dictFoldable)(go)(r)(v.value0);\n                            };\n                            if (v instanceof Data_Either.Right) {\n                                return f(r)(v.value0);\n                            };\n                            throw new Error(\"Failed pattern match at Control.Monad.Free (line 98, column 23 - line 100, column 23): \" + [ v.constructor.name ]);\n                        })($127($128));\n                    };\n                };\n                return go;\n            },\n            foldr: function (f) {\n                var go = function (r) {\n                    var $129 = resume(dictFunctor);\n                    return function ($130) {\n                        return (function (v) {\n                            if (v instanceof Data_Either.Left) {\n                                return Data_Foldable.foldr(dictFoldable)(Data_Function.flip(go))(r)(v.value0);\n                            };\n                            if (v instanceof Data_Either.Right) {\n                                return f(v.value0)(r);\n                            };\n                            throw new Error(\"Failed pattern match at Control.Monad.Free (line 103, column 23 - line 105, column 23): \" + [ v.constructor.name ]);\n                        })($129($130));\n                    };\n                };\n                return go;\n            }\n        };\n    };\n};\nvar traversableFree = function (dictTraversable) {\n    return {\n        traverse: function (dictApplicative) {\n            return function (f) {\n                var go = (function () {\n                    var $131 = resume(dictTraversable.Functor0());\n                    return function ($132) {\n                        return (function (v) {\n                            if (v instanceof Data_Either.Left) {\n                                return Data_Functor.map((dictApplicative.Apply0()).Functor0())((function () {\n                                    var $133 = Control_Bind.join(freeBind);\n                                    return function ($134) {\n                                        return $133(liftF($134));\n                                    };\n                                })())(Data_Traversable.traverse(dictTraversable)(dictApplicative)(go)(v.value0));\n                            };\n                            if (v instanceof Data_Either.Right) {\n                                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(Control_Applicative.pure(freeApplicative))(f(v.value0));\n                            };\n                            throw new Error(\"Failed pattern match at Control.Monad.Free (line 110, column 21 - line 112, column 30): \" + [ v.constructor.name ]);\n                        })($131($132));\n                    };\n                })();\n                return go;\n            };\n        },\n        sequence: function (dictApplicative) {\n            return function (tma) {\n                return Data_Traversable.traverse(traversableFree(dictTraversable))(dictApplicative)(Control_Category.identity(Control_Category.categoryFn))(tma);\n            };\n        },\n        Functor0: function () {\n            return freeFunctor;\n        },\n        Foldable1: function () {\n            return foldableFree(dictTraversable.Functor0())(dictTraversable.Foldable1());\n        }\n    };\n};\nvar foldFree = function (dictMonadRec) {\n    return function (k) {\n        var go = function (f) {\n            var v = toView(f);\n            if (v instanceof Return) {\n                return Data_Functor.map((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0())(Control_Monad_Rec_Class.Done.create)(Control_Applicative.pure((dictMonadRec.Monad0()).Applicative0())(v.value0));\n            };\n            if (v instanceof Bind) {\n                return Data_Functor.map((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0())(function ($135) {\n                    return Control_Monad_Rec_Class.Loop.create(v.value1($135));\n                })(k(v.value0));\n            };\n            throw new Error(\"Failed pattern match at Control.Monad.Free (line 158, column 10 - line 160, column 37): \" + [ v.constructor.name ]);\n        };\n        return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(go);\n    };\n};\nvar eqFree = function (dictFunctor) {\n    return function (dictEq1) {\n        return function (dictEq) {\n            return {\n                eq: function (x) {\n                    return function (y) {\n                        var v = resume(dictFunctor)(y);\n                        var v1 = resume(dictFunctor)(x);\n                        if (v1 instanceof Data_Either.Left && v instanceof Data_Either.Left) {\n                            return Data_Eq.eq1(dictEq1)(eqFree(dictFunctor)(dictEq1)(dictEq))(v1.value0)(v.value0);\n                        };\n                        if (v1 instanceof Data_Either.Right && v instanceof Data_Either.Right) {\n                            return Data_Eq.eq(dictEq)(v1.value0)(v.value0);\n                        };\n                        return false;\n                    };\n                }\n            };\n        };\n    };\n};\nvar ordFree = function (dictFunctor) {\n    return function (dictOrd1) {\n        return function (dictOrd) {\n            return {\n                compare: function (x) {\n                    return function (y) {\n                        var v = resume(dictFunctor)(y);\n                        var v1 = resume(dictFunctor)(x);\n                        if (v1 instanceof Data_Either.Left && v instanceof Data_Either.Left) {\n                            return Data_Ord.compare1(dictOrd1)(ordFree(dictFunctor)(dictOrd1)(dictOrd))(v1.value0)(v.value0);\n                        };\n                        if (v1 instanceof Data_Either.Left) {\n                            return Data_Ordering.LT.value;\n                        };\n                        if (v instanceof Data_Either.Left) {\n                            return Data_Ordering.GT.value;\n                        };\n                        if (v1 instanceof Data_Either.Right && v instanceof Data_Either.Right) {\n                            return Data_Ord.compare(dictOrd)(v1.value0)(v.value0);\n                        };\n                        throw new Error(\"Failed pattern match at Control.Monad.Free (line 56, column 17 - line 60, column 36): \" + [ v1.constructor.name, v.constructor.name ]);\n                    };\n                },\n                Eq0: function () {\n                    return eqFree(dictFunctor)(dictOrd1.Eq10())(dictOrd.Eq0());\n                }\n            };\n        };\n    };\n};\nvar eq1Free = function (dictFunctor) {\n    return function (dictEq1) {\n        return {\n            eq1: function (dictEq) {\n                return Data_Eq.eq(eqFree(dictFunctor)(dictEq1)(dictEq));\n            }\n        };\n    };\n};\nvar ord1Free = function (dictFunctor) {\n    return function (dictOrd1) {\n        return {\n            compare1: function (dictOrd) {\n                return Data_Ord.compare(ordFree(dictFunctor)(dictOrd1)(dictOrd));\n            },\n            Eq10: function () {\n                return eq1Free(dictFunctor)(dictOrd1.Eq10());\n            }\n        };\n    };\n};\nmodule.exports = {\n    suspendF: suspendF,\n    wrap: wrap,\n    liftF: liftF,\n    hoistFree: hoistFree,\n    foldFree: foldFree,\n    substFree: substFree,\n    runFree: runFree,\n    runFreeM: runFreeM,\n    resume: resume,\n    \"resume'\": resume$prime,\n    eqFree: eqFree,\n    eq1Free: eq1Free,\n    ordFree: ordFree,\n    ord1Free: ord1Free,\n    freeFunctor: freeFunctor,\n    freeBind: freeBind,\n    freeApplicative: freeApplicative,\n    freeApply: freeApply,\n    freeMonad: freeMonad,\n    freeMonadTrans: freeMonadTrans,\n    freeMonadRec: freeMonadRec,\n    foldableFree: foldableFree,\n    traversableFree: traversableFree,\n    semigroupFree: semigroupFree,\n    monoidFree: monoidFree\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/free/v6.0.1/src/Control/Monad/Free.purs?");

/***/ }),

/***/ "./.spago/free/v6.0.1/src/Control/Monad/Trampoline.purs":
/*!**************************************************************!*\
  !*** ./.spago/free/v6.0.1/src/Control/Monad/Trampoline.purs ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Monad_Free = __webpack_require__(/*! ./.spago/free/v6.0.1/src/Control/Monad/Free.purs */ \"./.spago/free/v6.0.1/src/Control/Monad/Free.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar runTrampoline = Control_Monad_Free.runFree(Data_Functor.functorFn)(function (v) {\n    return v(Data_Unit.unit);\n});\nvar done = Control_Applicative.pure(Control_Monad_Free.freeApplicative);\nvar delay = Control_Monad_Free.liftF;\nmodule.exports = {\n    done: done,\n    delay: delay,\n    runTrampoline: runTrampoline\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/free/v6.0.1/src/Control/Monad/Trampoline.purs?");

/***/ }),

/***/ "./.spago/functors/v4.1.1/src/Data/Functor/App.purs":
/*!**********************************************************!*\
  !*** ./.spago/functors/v4.1.1/src/Data/Functor/App.purs ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Unsafe_Coerce = __webpack_require__(/*! ./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs */ \"./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs\");\nvar App = function (x) {\n    return x;\n};\nvar showApp = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(App \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semigroupApp = function (dictApply) {\n    return function (dictSemigroup) {\n        return {\n            append: function (v) {\n                return function (v1) {\n                    return Control_Apply.lift2(dictApply)(Data_Semigroup.append(dictSemigroup))(v)(v1);\n                };\n            }\n        };\n    };\n};\nvar plusApp = function (dictPlus) {\n    return dictPlus;\n};\nvar newtypeApp = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monoidApp = function (dictApplicative) {\n    return function (dictMonoid) {\n        return {\n            mempty: Control_Applicative.pure(dictApplicative)(Data_Monoid.mempty(dictMonoid)),\n            Semigroup0: function () {\n                return semigroupApp(dictApplicative.Apply0())(dictMonoid.Semigroup0());\n            }\n        };\n    };\n};\nvar monadPlusApp = function (dictMonadPlus) {\n    return dictMonadPlus;\n};\nvar monadApp = function (dictMonad) {\n    return dictMonad;\n};\nvar lazyApp = function (dictLazy) {\n    return dictLazy;\n};\nvar hoistLowerApp = Unsafe_Coerce.unsafeCoerce;\nvar hoistLiftApp = Unsafe_Coerce.unsafeCoerce;\nvar hoistApp = function (f) {\n    return function (v) {\n        return f(v);\n    };\n};\nvar functorApp = function (dictFunctor) {\n    return dictFunctor;\n};\nvar extendApp = function (dictExtend) {\n    return dictExtend;\n};\nvar eqApp = function (dictEq1) {\n    return function (dictEq) {\n        return {\n            eq: function (x) {\n                return function (y) {\n                    return Data_Eq.eq1(dictEq1)(dictEq)(x)(y);\n                };\n            }\n        };\n    };\n};\nvar ordApp = function (dictOrd1) {\n    return function (dictOrd) {\n        return {\n            compare: function (x) {\n                return function (y) {\n                    return Data_Ord.compare1(dictOrd1)(dictOrd)(x)(y);\n                };\n            },\n            Eq0: function () {\n                return eqApp(dictOrd1.Eq10())(dictOrd.Eq0());\n            }\n        };\n    };\n};\nvar eq1App = function (dictEq1) {\n    return {\n        eq1: function (dictEq) {\n            return Data_Eq.eq(eqApp(dictEq1)(dictEq));\n        }\n    };\n};\nvar ord1App = function (dictOrd1) {\n    return {\n        compare1: function (dictOrd) {\n            return Data_Ord.compare(ordApp(dictOrd1)(dictOrd));\n        },\n        Eq10: function () {\n            return eq1App(dictOrd1.Eq10());\n        }\n    };\n};\nvar comonadApp = function (dictComonad) {\n    return dictComonad;\n};\nvar bindApp = function (dictBind) {\n    return dictBind;\n};\nvar applyApp = function (dictApply) {\n    return dictApply;\n};\nvar applicativeApp = function (dictApplicative) {\n    return dictApplicative;\n};\nvar alternativeApp = function (dictAlternative) {\n    return dictAlternative;\n};\nvar monadZeroApp = function (dictMonadZero) {\n    return {\n        Monad0: function () {\n            return monadApp(dictMonadZero.Monad0());\n        },\n        Alternative1: function () {\n            return alternativeApp(dictMonadZero.Alternative1());\n        },\n        MonadZeroIsDeprecated2: function () {\n            return undefined;\n        }\n    };\n};\nvar altApp = function (dictAlt) {\n    return dictAlt;\n};\nmodule.exports = {\n    App: App,\n    hoistApp: hoistApp,\n    hoistLiftApp: hoistLiftApp,\n    hoistLowerApp: hoistLowerApp,\n    newtypeApp: newtypeApp,\n    eqApp: eqApp,\n    eq1App: eq1App,\n    ordApp: ordApp,\n    ord1App: ord1App,\n    showApp: showApp,\n    semigroupApp: semigroupApp,\n    monoidApp: monoidApp,\n    monadZeroApp: monadZeroApp,\n    functorApp: functorApp,\n    applyApp: applyApp,\n    applicativeApp: applicativeApp,\n    bindApp: bindApp,\n    monadApp: monadApp,\n    altApp: altApp,\n    plusApp: plusApp,\n    alternativeApp: alternativeApp,\n    monadPlusApp: monadPlusApp,\n    lazyApp: lazyApp,\n    extendApp: extendApp,\n    comonadApp: comonadApp\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/functors/v4.1.1/src/Data/Functor/App.purs?");

/***/ }),

/***/ "./.spago/functors/v4.1.1/src/Data/Functor/Clown.purs":
/*!************************************************************!*\
  !*** ./.spago/functors/v4.1.1/src/Data/Functor/Clown.purs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Functor_Contravariant = __webpack_require__(/*! ./.spago/contravariant/v5.0.0/src/Data/Functor/Contravariant.purs */ \"./.spago/contravariant/v5.0.0/src/Data/Functor/Contravariant.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Clown = function (x) {\n    return x;\n};\nvar showClown = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Clown \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar profunctorClown = function (dictContravariant) {\n    return {\n        dimap: function (f) {\n            return function (v) {\n                return function (v1) {\n                    return Data_Functor_Contravariant.cmap(dictContravariant)(f)(v1);\n                };\n            };\n        }\n    };\n};\nvar ordClown = function (dictOrd) {\n    return dictOrd;\n};\nvar newtypeClown = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar hoistClown = function (f) {\n    return function (v) {\n        return f(v);\n    };\n};\nvar functorClown = {\n    map: function (v) {\n        return function (v1) {\n            return v1;\n        };\n    }\n};\nvar eqClown = function (dictEq) {\n    return dictEq;\n};\nvar bifunctorClown = function (dictFunctor) {\n    return {\n        bimap: function (f) {\n            return function (v) {\n                return function (v1) {\n                    return Data_Functor.map(dictFunctor)(f)(v1);\n                };\n            };\n        }\n    };\n};\nvar biapplyClown = function (dictApply) {\n    return {\n        biapply: function (v) {\n            return function (v1) {\n                return Control_Apply.apply(dictApply)(v)(v1);\n            };\n        },\n        Bifunctor0: function () {\n            return bifunctorClown(dictApply.Functor0());\n        }\n    };\n};\nvar biapplicativeClown = function (dictApplicative) {\n    return {\n        bipure: function (a) {\n            return function (v) {\n                return Control_Applicative.pure(dictApplicative)(a);\n            };\n        },\n        Biapply0: function () {\n            return biapplyClown(dictApplicative.Apply0());\n        }\n    };\n};\nmodule.exports = {\n    Clown: Clown,\n    hoistClown: hoistClown,\n    newtypeClown: newtypeClown,\n    eqClown: eqClown,\n    ordClown: ordClown,\n    showClown: showClown,\n    functorClown: functorClown,\n    bifunctorClown: bifunctorClown,\n    biapplyClown: biapplyClown,\n    biapplicativeClown: biapplicativeClown,\n    profunctorClown: profunctorClown\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/functors/v4.1.1/src/Data/Functor/Clown.purs?");

/***/ }),

/***/ "./.spago/functors/v4.1.1/src/Data/Functor/Compose.purs":
/*!**************************************************************!*\
  !*** ./.spago/functors/v4.1.1/src/Data/Functor/Compose.purs ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Plus = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Plus.purs */ \"./.spago/control/v5.0.0/src/Control/Plus.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Functor_App = __webpack_require__(/*! ./.spago/functors/v4.1.1/src/Data/Functor/App.purs */ \"./.spago/functors/v4.1.1/src/Data/Functor/App.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Compose = function (x) {\n    return x;\n};\nvar showCompose = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Compose \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar newtypeCompose = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar functorCompose = function (dictFunctor) {\n    return function (dictFunctor1) {\n        return {\n            map: function (f) {\n                return function (v) {\n                    return Compose(Data_Functor.map(dictFunctor)(Data_Functor.map(dictFunctor1)(f))(v));\n                };\n            }\n        };\n    };\n};\nvar eqCompose = function (dictEq1) {\n    return function (dictEq11) {\n        return function (dictEq) {\n            return {\n                eq: function (v) {\n                    return function (v1) {\n                        return Data_Eq.eq1(dictEq1)(Data_Functor_App.eqApp(dictEq11)(dictEq))(Data_Functor_App.hoistLiftApp(v))(Data_Functor_App.hoistLiftApp(v1));\n                    };\n                }\n            };\n        };\n    };\n};\nvar ordCompose = function (dictOrd1) {\n    return function (dictOrd11) {\n        return function (dictOrd) {\n            return {\n                compare: function (v) {\n                    return function (v1) {\n                        return Data_Ord.compare1(dictOrd1)(Data_Functor_App.ordApp(dictOrd11)(dictOrd))(Data_Functor_App.hoistLiftApp(v))(Data_Functor_App.hoistLiftApp(v1));\n                    };\n                },\n                Eq0: function () {\n                    return eqCompose(dictOrd1.Eq10())(dictOrd11.Eq10())(dictOrd.Eq0());\n                }\n            };\n        };\n    };\n};\nvar eq1Compose = function (dictEq1) {\n    return function (dictEq11) {\n        return {\n            eq1: function (dictEq) {\n                return Data_Eq.eq(eqCompose(dictEq1)(dictEq11)(dictEq));\n            }\n        };\n    };\n};\nvar ord1Compose = function (dictOrd1) {\n    return function (dictOrd11) {\n        return {\n            compare1: function (dictOrd) {\n                return Data_Ord.compare(ordCompose(dictOrd1)(dictOrd11)(dictOrd));\n            },\n            Eq10: function () {\n                return eq1Compose(dictOrd1.Eq10())(dictOrd11.Eq10());\n            }\n        };\n    };\n};\nvar bihoistCompose = function (dictFunctor) {\n    return function (natF) {\n        return function (natG) {\n            return function (v) {\n                return natF(Data_Functor.map(dictFunctor)(natG)(v));\n            };\n        };\n    };\n};\nvar applyCompose = function (dictApply) {\n    return function (dictApply1) {\n        return {\n            apply: function (v) {\n                return function (v1) {\n                    return Compose(Control_Apply.apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Control_Apply.apply(dictApply1))(v))(v1));\n                };\n            },\n            Functor0: function () {\n                return functorCompose(dictApply.Functor0())(dictApply1.Functor0());\n            }\n        };\n    };\n};\nvar applicativeCompose = function (dictApplicative) {\n    return function (dictApplicative1) {\n        return {\n            pure: (function () {\n                var $51 = Control_Applicative.pure(dictApplicative);\n                var $52 = Control_Applicative.pure(dictApplicative1);\n                return function ($53) {\n                    return Compose($51($52($53)));\n                };\n            })(),\n            Apply0: function () {\n                return applyCompose(dictApplicative.Apply0())(dictApplicative1.Apply0());\n            }\n        };\n    };\n};\nvar altCompose = function (dictAlt) {\n    return function (dictFunctor) {\n        return {\n            alt: function (v) {\n                return function (v1) {\n                    return Compose(Control_Alt.alt(dictAlt)(v)(v1));\n                };\n            },\n            Functor0: function () {\n                return functorCompose(dictAlt.Functor0())(dictFunctor);\n            }\n        };\n    };\n};\nvar plusCompose = function (dictPlus) {\n    return function (dictFunctor) {\n        return {\n            empty: Control_Plus.empty(dictPlus),\n            Alt0: function () {\n                return altCompose(dictPlus.Alt0())(dictFunctor);\n            }\n        };\n    };\n};\nvar alternativeCompose = function (dictAlternative) {\n    return function (dictApplicative) {\n        return {\n            Applicative0: function () {\n                return applicativeCompose(dictAlternative.Applicative0())(dictApplicative);\n            },\n            Plus1: function () {\n                return plusCompose(dictAlternative.Plus1())((dictApplicative.Apply0()).Functor0());\n            }\n        };\n    };\n};\nmodule.exports = {\n    Compose: Compose,\n    bihoistCompose: bihoistCompose,\n    newtypeCompose: newtypeCompose,\n    eqCompose: eqCompose,\n    eq1Compose: eq1Compose,\n    ordCompose: ordCompose,\n    ord1Compose: ord1Compose,\n    showCompose: showCompose,\n    functorCompose: functorCompose,\n    applyCompose: applyCompose,\n    applicativeCompose: applicativeCompose,\n    altCompose: altCompose,\n    plusCompose: plusCompose,\n    alternativeCompose: alternativeCompose\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/functors/v4.1.1/src/Data/Functor/Compose.purs?");

/***/ }),

/***/ "./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs":
/*!****************************************************************!*\
  !*** ./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Comonad = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Comonad.purs */ \"./.spago/control/v5.0.0/src/Control/Comonad.purs\");\nvar Control_Extend = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Extend.purs */ \"./.spago/control/v5.0.0/src/Control/Extend.purs\");\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Coproduct = function (x) {\n    return x;\n};\nvar showCoproduct = function (dictShow) {\n    return function (dictShow1) {\n        return {\n            show: function (v) {\n                if (v instanceof Data_Either.Left) {\n                    return \"(left \" + (Data_Show.show(dictShow)(v.value0) + \")\");\n                };\n                if (v instanceof Data_Either.Right) {\n                    return \"(right \" + (Data_Show.show(dictShow1)(v.value0) + \")\");\n                };\n                throw new Error(\"Failed pattern match at Data.Functor.Coproduct (line 63, column 1 - line 65, column 60): \" + [ v.constructor.name ]);\n            }\n        };\n    };\n};\nvar right = function (ga) {\n    return new Data_Either.Right(ga);\n};\nvar newtypeCoproduct = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar left = function (fa) {\n    return new Data_Either.Left(fa);\n};\nvar functorCoproduct = function (dictFunctor) {\n    return function (dictFunctor1) {\n        return {\n            map: function (f) {\n                return function (v) {\n                    return Data_Bifunctor.bimap(Data_Bifunctor.bifunctorEither)(Data_Functor.map(dictFunctor)(f))(Data_Functor.map(dictFunctor1)(f))(v);\n                };\n            }\n        };\n    };\n};\nvar eq1Coproduct = function (dictEq1) {\n    return function (dictEq11) {\n        return {\n            eq1: function (dictEq) {\n                return function (v) {\n                    return function (v1) {\n                        if (v instanceof Data_Either.Left && v1 instanceof Data_Either.Left) {\n                            return Data_Eq.eq1(dictEq1)(dictEq)(v.value0)(v1.value0);\n                        };\n                        if (v instanceof Data_Either.Right && v1 instanceof Data_Either.Right) {\n                            return Data_Eq.eq1(dictEq11)(dictEq)(v.value0)(v1.value0);\n                        };\n                        return false;\n                    };\n                };\n            }\n        };\n    };\n};\nvar eqCoproduct = function (dictEq1) {\n    return function (dictEq11) {\n        return function (dictEq) {\n            return {\n                eq: Data_Eq.eq1(eq1Coproduct(dictEq1)(dictEq11))(dictEq)\n            };\n        };\n    };\n};\nvar ord1Coproduct = function (dictOrd1) {\n    return function (dictOrd11) {\n        return {\n            compare1: function (dictOrd) {\n                return function (v) {\n                    return function (v1) {\n                        if (v instanceof Data_Either.Left && v1 instanceof Data_Either.Left) {\n                            return Data_Ord.compare1(dictOrd1)(dictOrd)(v.value0)(v1.value0);\n                        };\n                        if (v instanceof Data_Either.Left) {\n                            return Data_Ordering.LT.value;\n                        };\n                        if (v1 instanceof Data_Either.Left) {\n                            return Data_Ordering.GT.value;\n                        };\n                        if (v instanceof Data_Either.Right && v1 instanceof Data_Either.Right) {\n                            return Data_Ord.compare1(dictOrd11)(dictOrd)(v.value0)(v1.value0);\n                        };\n                        throw new Error(\"Failed pattern match at Data.Functor.Coproduct (line 57, column 5 - line 61, column 43): \" + [ v.constructor.name, v1.constructor.name ]);\n                    };\n                };\n            },\n            Eq10: function () {\n                return eq1Coproduct(dictOrd1.Eq10())(dictOrd11.Eq10());\n            }\n        };\n    };\n};\nvar ordCoproduct = function (dictOrd1) {\n    return function (dictOrd11) {\n        return function (dictOrd) {\n            return {\n                compare: Data_Ord.compare1(ord1Coproduct(dictOrd1)(dictOrd11))(dictOrd),\n                Eq0: function () {\n                    return eqCoproduct(dictOrd1.Eq10())(dictOrd11.Eq10())(dictOrd.Eq0());\n                }\n            };\n        };\n    };\n};\nvar coproduct = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2 instanceof Data_Either.Left) {\n                return v(v2.value0);\n            };\n            if (v2 instanceof Data_Either.Right) {\n                return v1(v2.value0);\n            };\n            throw new Error(\"Failed pattern match at Data.Functor.Coproduct (line 27, column 1 - line 27, column 78): \" + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);\n        };\n    };\n};\nvar extendCoproduct = function (dictExtend) {\n    return function (dictExtend1) {\n        return {\n            extend: function (f) {\n                var $61 = coproduct((function () {\n                    var $63 = Control_Extend.extend(dictExtend)(function ($65) {\n                        return f(Coproduct(Data_Either.Left.create($65)));\n                    });\n                    return function ($64) {\n                        return Data_Either.Left.create($63($64));\n                    };\n                })())((function () {\n                    var $66 = Control_Extend.extend(dictExtend1)(function ($68) {\n                        return f(Coproduct(Data_Either.Right.create($68)));\n                    });\n                    return function ($67) {\n                        return Data_Either.Right.create($66($67));\n                    };\n                })());\n                return function ($62) {\n                    return Coproduct($61($62));\n                };\n            },\n            Functor0: function () {\n                return functorCoproduct(dictExtend.Functor0())(dictExtend1.Functor0());\n            }\n        };\n    };\n};\nvar comonadCoproduct = function (dictComonad) {\n    return function (dictComonad1) {\n        return {\n            extract: coproduct(Control_Comonad.extract(dictComonad))(Control_Comonad.extract(dictComonad1)),\n            Extend0: function () {\n                return extendCoproduct(dictComonad.Extend0())(dictComonad1.Extend0());\n            }\n        };\n    };\n};\nvar bihoistCoproduct = function (natF) {\n    return function (natG) {\n        return function (v) {\n            return Data_Bifunctor.bimap(Data_Bifunctor.bifunctorEither)(natF)(natG)(v);\n        };\n    };\n};\nmodule.exports = {\n    Coproduct: Coproduct,\n    left: left,\n    right: right,\n    coproduct: coproduct,\n    bihoistCoproduct: bihoistCoproduct,\n    newtypeCoproduct: newtypeCoproduct,\n    eqCoproduct: eqCoproduct,\n    eq1Coproduct: eq1Coproduct,\n    ordCoproduct: ordCoproduct,\n    ord1Coproduct: ord1Coproduct,\n    showCoproduct: showCoproduct,\n    functorCoproduct: functorCoproduct,\n    extendCoproduct: extendCoproduct,\n    comonadCoproduct: comonadCoproduct\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/functors/v4.1.1/src/Data/Functor/Coproduct.purs?");

/***/ }),

/***/ "./.spago/functors/v4.1.1/src/Data/Functor/Flip.purs":
/*!***********************************************************!*\
  !*** ./.spago/functors/v4.1.1/src/Data/Functor/Flip.purs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Biapplicative = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Control/Biapplicative.purs */ \"./.spago/bifunctors/v5.0.0/src/Control/Biapplicative.purs\");\nvar Control_Biapply = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Control/Biapply.purs */ \"./.spago/bifunctors/v5.0.0/src/Control/Biapply.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Semigroupoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs */ \"./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs\");\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Profunctor = __webpack_require__(/*! ./.spago/profunctor/v5.0.0/src/Data/Profunctor.purs */ \"./.spago/profunctor/v5.0.0/src/Data/Profunctor.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Flip = function (x) {\n    return x;\n};\nvar showFlip = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Flip \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semigroupoidFlip = function (dictSemigroupoid) {\n    return {\n        compose: function (v) {\n            return function (v1) {\n                return Flip(Control_Semigroupoid.compose(dictSemigroupoid)(v1)(v));\n            };\n        }\n    };\n};\nvar ordFlip = function (dictOrd) {\n    return dictOrd;\n};\nvar newtypeFlip = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar functorFlip = function (dictBifunctor) {\n    return {\n        map: function (f) {\n            return function (v) {\n                return Data_Bifunctor.lmap(dictBifunctor)(f)(v);\n            };\n        }\n    };\n};\nvar eqFlip = function (dictEq) {\n    return dictEq;\n};\nvar contravariantFlip = function (dictProfunctor) {\n    return {\n        cmap: function (f) {\n            return function (v) {\n                return Data_Profunctor.lcmap(dictProfunctor)(f)(v);\n            };\n        }\n    };\n};\nvar categoryFlip = function (dictCategory) {\n    return {\n        identity: Control_Category.identity(dictCategory),\n        Semigroupoid0: function () {\n            return semigroupoidFlip(dictCategory.Semigroupoid0());\n        }\n    };\n};\nvar bifunctorFlip = function (dictBifunctor) {\n    return {\n        bimap: function (f) {\n            return function (g) {\n                return function (v) {\n                    return Data_Bifunctor.bimap(dictBifunctor)(g)(f)(v);\n                };\n            };\n        }\n    };\n};\nvar biapplyFlip = function (dictBiapply) {\n    return {\n        biapply: function (v) {\n            return function (v1) {\n                return Control_Biapply.biapply(dictBiapply)(v)(v1);\n            };\n        },\n        Bifunctor0: function () {\n            return bifunctorFlip(dictBiapply.Bifunctor0());\n        }\n    };\n};\nvar biapplicativeFlip = function (dictBiapplicative) {\n    return {\n        bipure: function (a) {\n            return function (b) {\n                return Control_Biapplicative.bipure(dictBiapplicative)(b)(a);\n            };\n        },\n        Biapply0: function () {\n            return biapplyFlip(dictBiapplicative.Biapply0());\n        }\n    };\n};\nmodule.exports = {\n    Flip: Flip,\n    newtypeFlip: newtypeFlip,\n    eqFlip: eqFlip,\n    ordFlip: ordFlip,\n    showFlip: showFlip,\n    functorFlip: functorFlip,\n    bifunctorFlip: bifunctorFlip,\n    biapplyFlip: biapplyFlip,\n    biapplicativeFlip: biapplicativeFlip,\n    contravariantFlip: contravariantFlip,\n    semigroupoidFlip: semigroupoidFlip,\n    categoryFlip: categoryFlip\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/functors/v4.1.1/src/Data/Functor/Flip.purs?");

/***/ }),

/***/ "./.spago/functors/v4.1.1/src/Data/Functor/Joker.purs":
/*!************************************************************!*\
  !*** ./.spago/functors/v4.1.1/src/Data/Functor/Joker.purs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Joker = function (x) {\n    return x;\n};\nvar showJoker = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Joker \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar profunctorJoker = function (dictFunctor) {\n    return {\n        dimap: function (v) {\n            return function (g) {\n                return function (v1) {\n                    return Data_Functor.map(dictFunctor)(g)(v1);\n                };\n            };\n        }\n    };\n};\nvar ordJoker = function (dictOrd) {\n    return dictOrd;\n};\nvar newtypeJoker = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar hoistJoker = function (f) {\n    return function (v) {\n        return f(v);\n    };\n};\nvar functorJoker = function (dictFunctor) {\n    return {\n        map: function (f) {\n            return function (v) {\n                return Data_Functor.map(dictFunctor)(f)(v);\n            };\n        }\n    };\n};\nvar eqJoker = function (dictEq) {\n    return dictEq;\n};\nvar choiceJoker = function (dictFunctor) {\n    return {\n        left: function (v) {\n            return Joker(Data_Functor.map(dictFunctor)(Data_Either.Left.create)(v));\n        },\n        right: function (v) {\n            return Joker(Data_Functor.map(dictFunctor)(Data_Either.Right.create)(v));\n        },\n        Profunctor0: function () {\n            return profunctorJoker(dictFunctor);\n        }\n    };\n};\nvar bifunctorJoker = function (dictFunctor) {\n    return {\n        bimap: function (v) {\n            return function (g) {\n                return function (v1) {\n                    return Data_Functor.map(dictFunctor)(g)(v1);\n                };\n            };\n        }\n    };\n};\nvar biapplyJoker = function (dictApply) {\n    return {\n        biapply: function (v) {\n            return function (v1) {\n                return Control_Apply.apply(dictApply)(v)(v1);\n            };\n        },\n        Bifunctor0: function () {\n            return bifunctorJoker(dictApply.Functor0());\n        }\n    };\n};\nvar biapplicativeJoker = function (dictApplicative) {\n    return {\n        bipure: function (v) {\n            return function (b) {\n                return Control_Applicative.pure(dictApplicative)(b);\n            };\n        },\n        Biapply0: function () {\n            return biapplyJoker(dictApplicative.Apply0());\n        }\n    };\n};\nvar applyJoker = function (dictApply) {\n    return {\n        apply: function (v) {\n            return function (v1) {\n                return Joker(Control_Apply.apply(dictApply)(v)(v1));\n            };\n        },\n        Functor0: function () {\n            return functorJoker(dictApply.Functor0());\n        }\n    };\n};\nvar bindJoker = function (dictBind) {\n    return {\n        bind: function (v) {\n            return function (amb) {\n                return Joker(Control_Bind.bind(dictBind)(v)((function () {\n                    var $47 = Data_Newtype.un()(Joker);\n                    return function ($48) {\n                        return $47(amb($48));\n                    };\n                })()));\n            };\n        },\n        Apply0: function () {\n            return applyJoker(dictBind.Apply0());\n        }\n    };\n};\nvar applicativeJoker = function (dictApplicative) {\n    return {\n        pure: (function () {\n            var $49 = Control_Applicative.pure(dictApplicative);\n            return function ($50) {\n                return Joker($49($50));\n            };\n        })(),\n        Apply0: function () {\n            return applyJoker(dictApplicative.Apply0());\n        }\n    };\n};\nvar monadJoker = function (dictMonad) {\n    return {\n        Applicative0: function () {\n            return applicativeJoker(dictMonad.Applicative0());\n        },\n        Bind1: function () {\n            return bindJoker(dictMonad.Bind1());\n        }\n    };\n};\nmodule.exports = {\n    Joker: Joker,\n    hoistJoker: hoistJoker,\n    newtypeJoker: newtypeJoker,\n    eqJoker: eqJoker,\n    ordJoker: ordJoker,\n    showJoker: showJoker,\n    functorJoker: functorJoker,\n    applyJoker: applyJoker,\n    applicativeJoker: applicativeJoker,\n    bindJoker: bindJoker,\n    monadJoker: monadJoker,\n    bifunctorJoker: bifunctorJoker,\n    biapplyJoker: biapplyJoker,\n    biapplicativeJoker: biapplicativeJoker,\n    profunctorJoker: profunctorJoker,\n    choiceJoker: choiceJoker\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/functors/v4.1.1/src/Data/Functor/Joker.purs?");

/***/ }),

/***/ "./.spago/functors/v4.1.1/src/Data/Functor/Product.purs":
/*!**************************************************************!*\
  !*** ./.spago/functors/v4.1.1/src/Data/Functor/Product.purs ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Product = function (x) {\n    return x;\n};\nvar showProduct = function (dictShow) {\n    return function (dictShow1) {\n        return {\n            show: function (v) {\n                return \"(product \" + (Data_Show.show(dictShow)(v.value0) + (\" \" + (Data_Show.show(dictShow1)(v.value1) + \")\")));\n            }\n        };\n    };\n};\nvar product = function (fa) {\n    return function (ga) {\n        return new Data_Tuple.Tuple(fa, ga);\n    };\n};\nvar newtypeProduct = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar functorProduct = function (dictFunctor) {\n    return function (dictFunctor1) {\n        return {\n            map: function (f) {\n                return function (v) {\n                    return Data_Bifunctor.bimap(Data_Bifunctor.bifunctorTuple)(Data_Functor.map(dictFunctor)(f))(Data_Functor.map(dictFunctor1)(f))(v);\n                };\n            }\n        };\n    };\n};\nvar eq1Product = function (dictEq1) {\n    return function (dictEq11) {\n        return {\n            eq1: function (dictEq) {\n                return function (v) {\n                    return function (v1) {\n                        return Data_Eq.eq1(dictEq1)(dictEq)(v.value0)(v1.value0) && Data_Eq.eq1(dictEq11)(dictEq)(v.value1)(v1.value1);\n                    };\n                };\n            }\n        };\n    };\n};\nvar eqProduct = function (dictEq1) {\n    return function (dictEq11) {\n        return function (dictEq) {\n            return {\n                eq: Data_Eq.eq1(eq1Product(dictEq1)(dictEq11))(dictEq)\n            };\n        };\n    };\n};\nvar ord1Product = function (dictOrd1) {\n    return function (dictOrd11) {\n        return {\n            compare1: function (dictOrd) {\n                return function (v) {\n                    return function (v1) {\n                        var v2 = Data_Ord.compare1(dictOrd1)(dictOrd)(v.value0)(v1.value0);\n                        if (v2 instanceof Data_Ordering.EQ) {\n                            return Data_Ord.compare1(dictOrd11)(dictOrd)(v.value1)(v1.value1);\n                        };\n                        return v2;\n                    };\n                };\n            },\n            Eq10: function () {\n                return eq1Product(dictOrd1.Eq10())(dictOrd11.Eq10());\n            }\n        };\n    };\n};\nvar ordProduct = function (dictOrd1) {\n    return function (dictOrd11) {\n        return function (dictOrd) {\n            return {\n                compare: Data_Ord.compare1(ord1Product(dictOrd1)(dictOrd11))(dictOrd),\n                Eq0: function () {\n                    return eqProduct(dictOrd1.Eq10())(dictOrd11.Eq10())(dictOrd.Eq0());\n                }\n            };\n        };\n    };\n};\nvar bihoistProduct = function (natF) {\n    return function (natG) {\n        return function (v) {\n            return Data_Bifunctor.bimap(Data_Bifunctor.bifunctorTuple)(natF)(natG)(v);\n        };\n    };\n};\nvar applyProduct = function (dictApply) {\n    return function (dictApply1) {\n        return {\n            apply: function (v) {\n                return function (v1) {\n                    return product(Control_Apply.apply(dictApply)(v.value0)(v1.value0))(Control_Apply.apply(dictApply1)(v.value1)(v1.value1));\n                };\n            },\n            Functor0: function () {\n                return functorProduct(dictApply.Functor0())(dictApply1.Functor0());\n            }\n        };\n    };\n};\nvar bindProduct = function (dictBind) {\n    return function (dictBind1) {\n        return {\n            bind: function (v) {\n                return function (f) {\n                    return product(Control_Bind.bind(dictBind)(v.value0)((function () {\n                        var $67 = Data_Newtype.unwrap();\n                        return function ($68) {\n                            return Data_Tuple.fst($67(f($68)));\n                        };\n                    })()))(Control_Bind.bind(dictBind1)(v.value1)((function () {\n                        var $69 = Data_Newtype.unwrap();\n                        return function ($70) {\n                            return Data_Tuple.snd($69(f($70)));\n                        };\n                    })()));\n                };\n            },\n            Apply0: function () {\n                return applyProduct(dictBind.Apply0())(dictBind1.Apply0());\n            }\n        };\n    };\n};\nvar applicativeProduct = function (dictApplicative) {\n    return function (dictApplicative1) {\n        return {\n            pure: function (a) {\n                return product(Control_Applicative.pure(dictApplicative)(a))(Control_Applicative.pure(dictApplicative1)(a));\n            },\n            Apply0: function () {\n                return applyProduct(dictApplicative.Apply0())(dictApplicative1.Apply0());\n            }\n        };\n    };\n};\nvar monadProduct = function (dictMonad) {\n    return function (dictMonad1) {\n        return {\n            Applicative0: function () {\n                return applicativeProduct(dictMonad.Applicative0())(dictMonad1.Applicative0());\n            },\n            Bind1: function () {\n                return bindProduct(dictMonad.Bind1())(dictMonad1.Bind1());\n            }\n        };\n    };\n};\nmodule.exports = {\n    Product: Product,\n    product: product,\n    bihoistProduct: bihoistProduct,\n    newtypeProduct: newtypeProduct,\n    eqProduct: eqProduct,\n    eq1Product: eq1Product,\n    ordProduct: ordProduct,\n    ord1Product: ord1Product,\n    showProduct: showProduct,\n    functorProduct: functorProduct,\n    applyProduct: applyProduct,\n    applicativeProduct: applicativeProduct,\n    bindProduct: bindProduct,\n    monadProduct: monadProduct\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/functors/v4.1.1/src/Data/Functor/Product.purs?");

/***/ }),

/***/ "./.spago/functors/v4.1.1/src/Data/Functor/Product2.purs":
/*!***************************************************************!*\
  !*** ./.spago/functors/v4.1.1/src/Data/Functor/Product2.purs ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Biapplicative = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Control/Biapplicative.purs */ \"./.spago/bifunctors/v5.0.0/src/Control/Biapplicative.purs\");\nvar Control_Biapply = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Control/Biapply.purs */ \"./.spago/bifunctors/v5.0.0/src/Control/Biapply.purs\");\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Profunctor = __webpack_require__(/*! ./.spago/profunctor/v5.0.0/src/Data/Profunctor.purs */ \"./.spago/profunctor/v5.0.0/src/Data/Profunctor.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Product2 = (function () {\n    function Product2(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    Product2.create = function (value0) {\n        return function (value1) {\n            return new Product2(value0, value1);\n        };\n    };\n    return Product2;\n})();\nvar showProduct2 = function (dictShow) {\n    return function (dictShow1) {\n        return {\n            show: function (v) {\n                return \"(Product2 \" + (Data_Show.show(dictShow)(v.value0) + (\" \" + (Data_Show.show(dictShow1)(v.value1) + \")\")));\n            }\n        };\n    };\n};\nvar profunctorProduct2 = function (dictProfunctor) {\n    return function (dictProfunctor1) {\n        return {\n            dimap: function (f) {\n                return function (g) {\n                    return function (v) {\n                        return new Product2(Data_Profunctor.dimap(dictProfunctor)(f)(g)(v.value0), Data_Profunctor.dimap(dictProfunctor1)(f)(g)(v.value1));\n                    };\n                };\n            }\n        };\n    };\n};\nvar functorProduct2 = function (dictFunctor) {\n    return function (dictFunctor1) {\n        return {\n            map: function (f) {\n                return function (v) {\n                    return new Product2(Data_Functor.map(dictFunctor)(f)(v.value0), Data_Functor.map(dictFunctor1)(f)(v.value1));\n                };\n            }\n        };\n    };\n};\nvar eqProduct2 = function (dictEq) {\n    return function (dictEq1) {\n        return {\n            eq: function (x) {\n                return function (y) {\n                    return Data_Eq.eq(dictEq)(x.value0)(y.value0) && Data_Eq.eq(dictEq1)(x.value1)(y.value1);\n                };\n            }\n        };\n    };\n};\nvar ordProduct2 = function (dictOrd) {\n    return function (dictOrd1) {\n        return {\n            compare: function (x) {\n                return function (y) {\n                    var v = Data_Ord.compare(dictOrd)(x.value0)(y.value0);\n                    if (v instanceof Data_Ordering.LT) {\n                        return Data_Ordering.LT.value;\n                    };\n                    if (v instanceof Data_Ordering.GT) {\n                        return Data_Ordering.GT.value;\n                    };\n                    return Data_Ord.compare(dictOrd1)(x.value1)(y.value1);\n                };\n            },\n            Eq0: function () {\n                return eqProduct2(dictOrd.Eq0())(dictOrd1.Eq0());\n            }\n        };\n    };\n};\nvar bifunctorProduct2 = function (dictBifunctor) {\n    return function (dictBifunctor1) {\n        return {\n            bimap: function (f) {\n                return function (g) {\n                    return function (v) {\n                        return new Product2(Data_Bifunctor.bimap(dictBifunctor)(f)(g)(v.value0), Data_Bifunctor.bimap(dictBifunctor1)(f)(g)(v.value1));\n                    };\n                };\n            }\n        };\n    };\n};\nvar biapplyProduct2 = function (dictBiapply) {\n    return function (dictBiapply1) {\n        return {\n            biapply: function (v) {\n                return function (v1) {\n                    return new Product2(Control_Biapply.biapply(dictBiapply)(v.value0)(v1.value0), Control_Biapply.biapply(dictBiapply1)(v.value1)(v1.value1));\n                };\n            },\n            Bifunctor0: function () {\n                return bifunctorProduct2(dictBiapply.Bifunctor0())(dictBiapply1.Bifunctor0());\n            }\n        };\n    };\n};\nvar biapplicativeProduct2 = function (dictBiapplicative) {\n    return function (dictBiapplicative1) {\n        return {\n            bipure: function (a) {\n                return function (b) {\n                    return new Product2(Control_Biapplicative.bipure(dictBiapplicative)(a)(b), Control_Biapplicative.bipure(dictBiapplicative1)(a)(b));\n                };\n            },\n            Biapply0: function () {\n                return biapplyProduct2(dictBiapplicative.Biapply0())(dictBiapplicative1.Biapply0());\n            }\n        };\n    };\n};\nmodule.exports = {\n    Product2: Product2,\n    eqProduct2: eqProduct2,\n    ordProduct2: ordProduct2,\n    showProduct2: showProduct2,\n    functorProduct2: functorProduct2,\n    bifunctorProduct2: bifunctorProduct2,\n    biapplyProduct2: biapplyProduct2,\n    biapplicativeProduct2: biapplicativeProduct2,\n    profunctorProduct2: profunctorProduct2\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/functors/v4.1.1/src/Data/Functor/Product2.purs?");

/***/ }),

/***/ "./.spago/identity/v5.0.0/src/Data/Identity.purs":
/*!*******************************************************!*\
  !*** ./.spago/identity/v5.0.0/src/Data/Identity.purs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Functor_Invariant = __webpack_require__(/*! ./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs */ \"./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Identity = function (x) {\n    return x;\n};\nvar showIdentity = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Identity \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semiringIdentity = function (dictSemiring) {\n    return dictSemiring;\n};\nvar semigroupIdenity = function (dictSemigroup) {\n    return dictSemigroup;\n};\nvar ringIdentity = function (dictRing) {\n    return dictRing;\n};\nvar ordIdentity = function (dictOrd) {\n    return dictOrd;\n};\nvar newtypeIdentity = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monoidIdentity = function (dictMonoid) {\n    return dictMonoid;\n};\nvar lazyIdentity = function (dictLazy) {\n    return dictLazy;\n};\nvar heytingAlgebraIdentity = function (dictHeytingAlgebra) {\n    return dictHeytingAlgebra;\n};\nvar functorIdentity = {\n    map: function (f) {\n        return function (m) {\n            return f(m);\n        };\n    }\n};\nvar invariantIdentity = {\n    imap: Data_Functor_Invariant.imapF(functorIdentity)\n};\nvar extendIdentity = {\n    extend: function (f) {\n        return function (m) {\n            return f(m);\n        };\n    },\n    Functor0: function () {\n        return functorIdentity;\n    }\n};\nvar euclideanRingIdentity = function (dictEuclideanRing) {\n    return dictEuclideanRing;\n};\nvar eqIdentity = function (dictEq) {\n    return dictEq;\n};\nvar eq1Identity = {\n    eq1: function (dictEq) {\n        return Data_Eq.eq(eqIdentity(dictEq));\n    }\n};\nvar ord1Identity = {\n    compare1: function (dictOrd) {\n        return Data_Ord.compare(ordIdentity(dictOrd));\n    },\n    Eq10: function () {\n        return eq1Identity;\n    }\n};\nvar comonadIdentity = {\n    extract: function (v) {\n        return v;\n    },\n    Extend0: function () {\n        return extendIdentity;\n    }\n};\nvar commutativeRingIdentity = function (dictCommutativeRing) {\n    return dictCommutativeRing;\n};\nvar boundedIdentity = function (dictBounded) {\n    return dictBounded;\n};\nvar booleanAlgebraIdentity = function (dictBooleanAlgebra) {\n    return dictBooleanAlgebra;\n};\nvar applyIdentity = {\n    apply: function (v) {\n        return function (v1) {\n            return v(v1);\n        };\n    },\n    Functor0: function () {\n        return functorIdentity;\n    }\n};\nvar bindIdentity = {\n    bind: function (v) {\n        return function (f) {\n            return f(v);\n        };\n    },\n    Apply0: function () {\n        return applyIdentity;\n    }\n};\nvar applicativeIdentity = {\n    pure: Identity,\n    Apply0: function () {\n        return applyIdentity;\n    }\n};\nvar monadIdentity = {\n    Applicative0: function () {\n        return applicativeIdentity;\n    },\n    Bind1: function () {\n        return bindIdentity;\n    }\n};\nvar altIdentity = {\n    alt: function (x) {\n        return function (v) {\n            return x;\n        };\n    },\n    Functor0: function () {\n        return functorIdentity;\n    }\n};\nmodule.exports = {\n    Identity: Identity,\n    newtypeIdentity: newtypeIdentity,\n    eqIdentity: eqIdentity,\n    ordIdentity: ordIdentity,\n    boundedIdentity: boundedIdentity,\n    heytingAlgebraIdentity: heytingAlgebraIdentity,\n    booleanAlgebraIdentity: booleanAlgebraIdentity,\n    semigroupIdenity: semigroupIdenity,\n    monoidIdentity: monoidIdentity,\n    semiringIdentity: semiringIdentity,\n    euclideanRingIdentity: euclideanRingIdentity,\n    ringIdentity: ringIdentity,\n    commutativeRingIdentity: commutativeRingIdentity,\n    lazyIdentity: lazyIdentity,\n    showIdentity: showIdentity,\n    eq1Identity: eq1Identity,\n    ord1Identity: ord1Identity,\n    functorIdentity: functorIdentity,\n    invariantIdentity: invariantIdentity,\n    altIdentity: altIdentity,\n    applyIdentity: applyIdentity,\n    applicativeIdentity: applicativeIdentity,\n    bindIdentity: bindIdentity,\n    monadIdentity: monadIdentity,\n    extendIdentity: extendIdentity,\n    comonadIdentity: comonadIdentity\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/identity/v5.0.0/src/Data/Identity.purs?");

/***/ }),

/***/ "./.spago/integers/v5.0.0/src/Data/Int.purs":
/*!**************************************************!*\
  !*** ./.spago/integers/v5.0.0/src/Data/Int.purs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/integers/v5.0.0/src/Data/Int.js */ \"./.spago/integers/v5.0.0/src/Data/Int.js\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Bounded = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Bounded.purs */ \"./.spago/prelude/v5.0.1/src/Data/Bounded.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Number = __webpack_require__(/*! ./.spago/numbers/v8.0.0/src/Data/Number.purs */ \"./.spago/numbers/v8.0.0/src/Data/Number.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar $$Math = __webpack_require__(/*! ./.spago/math/v3.0.0/src/Math.purs */ \"./.spago/math/v3.0.0/src/Math.purs\");\nvar Radix = function (x) {\n    return x;\n};\nvar Even = (function () {\n    function Even() {\n\n    };\n    Even.value = new Even();\n    return Even;\n})();\nvar Odd = (function () {\n    function Odd() {\n\n    };\n    Odd.value = new Odd();\n    return Odd;\n})();\nvar showParity = {\n    show: function (v) {\n        if (v instanceof Even) {\n            return \"Even\";\n        };\n        if (v instanceof Odd) {\n            return \"Odd\";\n        };\n        throw new Error(\"Failed pattern match at Data.Int (line 111, column 1 - line 113, column 19): \" + [ v.constructor.name ]);\n    }\n};\nvar radix = function (n) {\n    if (n >= 2 && n <= 36) {\n        return new Data_Maybe.Just(n);\n    };\n    if (Data_Boolean.otherwise) {\n        return Data_Maybe.Nothing.value;\n    };\n    throw new Error(\"Failed pattern match at Data.Int (line 192, column 1 - line 192, column 28): \" + [ n.constructor.name ]);\n};\nvar odd = function (x) {\n    return (x & 1) !== 0;\n};\nvar octal = 8;\nvar hexadecimal = 16;\nvar fromStringAs = $foreign.fromStringAsImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar fromString = fromStringAs(10);\nvar fromNumber = $foreign.fromNumberImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar unsafeClamp = function (x) {\n    if (!Data_Number[\"isFinite\"](x)) {\n        return 0;\n    };\n    if (x >= $foreign.toNumber(Data_Bounded.top(Data_Bounded.boundedInt))) {\n        return Data_Bounded.top(Data_Bounded.boundedInt);\n    };\n    if (x <= $foreign.toNumber(Data_Bounded.bottom(Data_Bounded.boundedInt))) {\n        return Data_Bounded.bottom(Data_Bounded.boundedInt);\n    };\n    if (Data_Boolean.otherwise) {\n        return Data_Maybe.fromMaybe(0)(fromNumber(x));\n    };\n    throw new Error(\"Failed pattern match at Data.Int (line 66, column 1 - line 66, column 29): \" + [ x.constructor.name ]);\n};\nvar round = function ($23) {\n    return unsafeClamp($$Math.round($23));\n};\nvar floor = function ($24) {\n    return unsafeClamp($$Math.floor($24));\n};\nvar even = function (x) {\n    return (x & 1) === 0;\n};\nvar parity = function (n) {\n    var $14 = even(n);\n    if ($14) {\n        return Even.value;\n    };\n    return Odd.value;\n};\nvar eqParity = {\n    eq: function (x) {\n        return function (y) {\n            if (x instanceof Even && y instanceof Even) {\n                return true;\n            };\n            if (x instanceof Odd && y instanceof Odd) {\n                return true;\n            };\n            return false;\n        };\n    }\n};\nvar ordParity = {\n    compare: function (x) {\n        return function (y) {\n            if (x instanceof Even && y instanceof Even) {\n                return Data_Ordering.EQ.value;\n            };\n            if (x instanceof Even) {\n                return Data_Ordering.LT.value;\n            };\n            if (y instanceof Even) {\n                return Data_Ordering.GT.value;\n            };\n            if (x instanceof Odd && y instanceof Odd) {\n                return Data_Ordering.EQ.value;\n            };\n            throw new Error(\"Failed pattern match at Data.Int (line 109, column 1 - line 109, column 40): \" + [ x.constructor.name, y.constructor.name ]);\n        };\n    },\n    Eq0: function () {\n        return eqParity;\n    }\n};\nvar semiringParity = {\n    zero: Even.value,\n    add: function (x) {\n        return function (y) {\n            var $19 = Data_Eq.eq(eqParity)(x)(y);\n            if ($19) {\n                return Even.value;\n            };\n            return Odd.value;\n        };\n    },\n    one: Odd.value,\n    mul: function (v) {\n        return function (v1) {\n            if (v instanceof Odd && v1 instanceof Odd) {\n                return Odd.value;\n            };\n            return Even.value;\n        };\n    }\n};\nvar ringParity = {\n    sub: Data_Semiring.add(semiringParity),\n    Semiring0: function () {\n        return semiringParity;\n    }\n};\nvar divisionRingParity = {\n    recip: Control_Category.identity(Control_Category.categoryFn),\n    Ring0: function () {\n        return ringParity;\n    }\n};\nvar decimal = 10;\nvar commutativeRingParity = {\n    Ring0: function () {\n        return ringParity;\n    }\n};\nvar euclideanRingParity = {\n    degree: function (v) {\n        if (v instanceof Even) {\n            return 0;\n        };\n        if (v instanceof Odd) {\n            return 1;\n        };\n        throw new Error(\"Failed pattern match at Data.Int (line 131, column 1 - line 135, column 17): \" + [ v.constructor.name ]);\n    },\n    div: function (x) {\n        return function (v) {\n            return x;\n        };\n    },\n    mod: function (v) {\n        return function (v1) {\n            return Even.value;\n        };\n    },\n    CommutativeRing0: function () {\n        return commutativeRingParity;\n    }\n};\nvar ceil = function ($25) {\n    return unsafeClamp($$Math.ceil($25));\n};\nvar boundedParity = {\n    bottom: Even.value,\n    top: Odd.value,\n    Ord0: function () {\n        return ordParity;\n    }\n};\nvar binary = 2;\nvar base36 = 36;\nmodule.exports = {\n    fromNumber: fromNumber,\n    ceil: ceil,\n    floor: floor,\n    round: round,\n    fromString: fromString,\n    radix: radix,\n    binary: binary,\n    octal: octal,\n    decimal: decimal,\n    hexadecimal: hexadecimal,\n    base36: base36,\n    fromStringAs: fromStringAs,\n    Even: Even,\n    Odd: Odd,\n    parity: parity,\n    even: even,\n    odd: odd,\n    eqParity: eqParity,\n    ordParity: ordParity,\n    showParity: showParity,\n    boundedParity: boundedParity,\n    semiringParity: semiringParity,\n    ringParity: ringParity,\n    commutativeRingParity: commutativeRingParity,\n    euclideanRingParity: euclideanRingParity,\n    divisionRingParity: divisionRingParity,\n    toNumber: $foreign.toNumber,\n    toStringAs: $foreign.toStringAs,\n    quot: $foreign.quot,\n    rem: $foreign.rem,\n    pow: $foreign.pow\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/integers/v5.0.0/src/Data/Int.purs?");

/***/ }),

/***/ "./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs":
/*!*****************************************************************!*\
  !*** ./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar invariantMultiplicative = {\n    imap: function (f) {\n        return function (v) {\n            return function (v1) {\n                return f(v1);\n            };\n        };\n    }\n};\nvar invariantEndo = {\n    imap: function (ab) {\n        return function (ba) {\n            return function (v) {\n                return function ($37) {\n                    return ab(v(ba($37)));\n                };\n            };\n        };\n    }\n};\nvar invariantDual = {\n    imap: function (f) {\n        return function (v) {\n            return function (v1) {\n                return f(v1);\n            };\n        };\n    }\n};\nvar invariantDisj = {\n    imap: function (f) {\n        return function (v) {\n            return function (v1) {\n                return f(v1);\n            };\n        };\n    }\n};\nvar invariantConj = {\n    imap: function (f) {\n        return function (v) {\n            return function (v1) {\n                return f(v1);\n            };\n        };\n    }\n};\nvar invariantAdditive = {\n    imap: function (f) {\n        return function (v) {\n            return function (v1) {\n                return f(v1);\n            };\n        };\n    }\n};\nvar imapF = function (dictFunctor) {\n    return function (f) {\n        return function (v) {\n            return Data_Functor.map(dictFunctor)(f);\n        };\n    };\n};\nvar invariantArray = {\n    imap: imapF(Data_Functor.functorArray)\n};\nvar invariantFn = {\n    imap: imapF(Data_Functor.functorFn)\n};\nvar imap = function (dict) {\n    return dict.imap;\n};\nvar invariantAlternate = function (dictInvariant) {\n    return {\n        imap: function (f) {\n            return function (g) {\n                return function (v) {\n                    return imap(dictInvariant)(f)(g)(v);\n                };\n            };\n        }\n    };\n};\nmodule.exports = {\n    imap: imap,\n    imapF: imapF,\n    invariantFn: invariantFn,\n    invariantArray: invariantArray,\n    invariantAdditive: invariantAdditive,\n    invariantConj: invariantConj,\n    invariantDisj: invariantDisj,\n    invariantDual: invariantDual,\n    invariantEndo: invariantEndo,\n    invariantMultiplicative: invariantMultiplicative,\n    invariantAlternate: invariantAlternate\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs?");

/***/ }),

/***/ "./.spago/lazy/v5.0.0/src/Data/Lazy.purs":
/*!***********************************************!*\
  !*** ./.spago/lazy/v5.0.0/src/Data/Lazy.purs ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/lazy/v5.0.0/src/Data/Lazy.js */ \"./.spago/lazy/v5.0.0/src/Data/Lazy.js\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Data_Bounded = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Bounded.purs */ \"./.spago/prelude/v5.0.1/src/Data/Bounded.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_EuclideanRing = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs */ \"./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Functor_Invariant = __webpack_require__(/*! ./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs */ \"./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ring.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar showLazy = function (dictShow) {\n    return {\n        show: function (x) {\n            return \"(defer \\\\_ -> \" + (Data_Show.show(dictShow)($foreign.force(x)) + \")\");\n        }\n    };\n};\nvar semiringLazy = function (dictSemiring) {\n    return {\n        add: function (a) {\n            return function (b) {\n                return $foreign.defer(function (v) {\n                    return Data_Semiring.add(dictSemiring)($foreign.force(a))($foreign.force(b));\n                });\n            };\n        },\n        zero: $foreign.defer(function (v) {\n            return Data_Semiring.zero(dictSemiring);\n        }),\n        mul: function (a) {\n            return function (b) {\n                return $foreign.defer(function (v) {\n                    return Data_Semiring.mul(dictSemiring)($foreign.force(a))($foreign.force(b));\n                });\n            };\n        },\n        one: $foreign.defer(function (v) {\n            return Data_Semiring.one(dictSemiring);\n        })\n    };\n};\nvar semigroupLazy = function (dictSemigroup) {\n    return {\n        append: function (a) {\n            return function (b) {\n                return $foreign.defer(function (v) {\n                    return Data_Semigroup.append(dictSemigroup)($foreign.force(a))($foreign.force(b));\n                });\n            };\n        }\n    };\n};\nvar ringLazy = function (dictRing) {\n    return {\n        sub: function (a) {\n            return function (b) {\n                return $foreign.defer(function (v) {\n                    return Data_Ring.sub(dictRing)($foreign.force(a))($foreign.force(b));\n                });\n            };\n        },\n        Semiring0: function () {\n            return semiringLazy(dictRing.Semiring0());\n        }\n    };\n};\nvar monoidLazy = function (dictMonoid) {\n    return {\n        mempty: $foreign.defer(function (v) {\n            return Data_Monoid.mempty(dictMonoid);\n        }),\n        Semigroup0: function () {\n            return semigroupLazy(dictMonoid.Semigroup0());\n        }\n    };\n};\nvar lazyLazy = {\n    defer: function (f) {\n        return $foreign.defer(function (v) {\n            return $foreign.force(f(Data_Unit.unit));\n        });\n    }\n};\nvar functorLazy = {\n    map: function (f) {\n        return function (l) {\n            return $foreign.defer(function (v) {\n                return f($foreign.force(l));\n            });\n        };\n    }\n};\nvar functorWithIndexLazy = {\n    mapWithIndex: function (f) {\n        return Data_Functor.map(functorLazy)(f(Data_Unit.unit));\n    },\n    Functor0: function () {\n        return functorLazy;\n    }\n};\nvar invariantLazy = {\n    imap: Data_Functor_Invariant.imapF(functorLazy)\n};\nvar foldableLazy = {\n    foldr: function (f) {\n        return function (z) {\n            return function (l) {\n                return f($foreign.force(l))(z);\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (z) {\n            return function (l) {\n                return f(z)($foreign.force(l));\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (l) {\n                return f($foreign.force(l));\n            };\n        };\n    }\n};\nvar foldableWithIndexLazy = {\n    foldrWithIndex: function (f) {\n        return Data_Foldable.foldr(foldableLazy)(f(Data_Unit.unit));\n    },\n    foldlWithIndex: function (f) {\n        return Data_Foldable.foldl(foldableLazy)(f(Data_Unit.unit));\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldMap(foldableLazy)(dictMonoid)(f(Data_Unit.unit));\n        };\n    },\n    Foldable0: function () {\n        return foldableLazy;\n    }\n};\nvar traversableLazy = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (l) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(function ($43) {\n                    return $foreign.defer(Data_Function[\"const\"]($43));\n                })(f($foreign.force(l)));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (l) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(function ($44) {\n                return $foreign.defer(Data_Function[\"const\"]($44));\n            })($foreign.force(l));\n        };\n    },\n    Functor0: function () {\n        return functorLazy;\n    },\n    Foldable1: function () {\n        return foldableLazy;\n    }\n};\nvar traversableWithIndexLazy = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return Data_Traversable.traverse(traversableLazy)(dictApplicative)(f(Data_Unit.unit));\n        };\n    },\n    FunctorWithIndex0: function () {\n        return functorWithIndexLazy;\n    },\n    FoldableWithIndex1: function () {\n        return foldableWithIndexLazy;\n    },\n    Traversable2: function () {\n        return traversableLazy;\n    }\n};\nvar foldable1Lazy = {\n    foldMap1: function (dictSemigroup) {\n        return function (f) {\n            return function (l) {\n                return f($foreign.force(l));\n            };\n        };\n    },\n    foldr1: function (v) {\n        return function (l) {\n            return $foreign.force(l);\n        };\n    },\n    foldl1: function (v) {\n        return function (l) {\n            return $foreign.force(l);\n        };\n    },\n    Foldable0: function () {\n        return foldableLazy;\n    }\n};\nvar traversable1Lazy = {\n    traverse1: function (dictApply) {\n        return function (f) {\n            return function (l) {\n                return Data_Functor.map(dictApply.Functor0())(function ($45) {\n                    return $foreign.defer(Data_Function[\"const\"]($45));\n                })(f($foreign.force(l)));\n            };\n        };\n    },\n    sequence1: function (dictApply) {\n        return function (l) {\n            return Data_Functor.map(dictApply.Functor0())(function ($46) {\n                return $foreign.defer(Data_Function[\"const\"]($46));\n            })($foreign.force(l));\n        };\n    },\n    Foldable10: function () {\n        return foldable1Lazy;\n    },\n    Traversable1: function () {\n        return traversableLazy;\n    }\n};\nvar extendLazy = {\n    extend: function (f) {\n        return function (x) {\n            return $foreign.defer(function (v) {\n                return f(x);\n            });\n        };\n    },\n    Functor0: function () {\n        return functorLazy;\n    }\n};\nvar eqLazy = function (dictEq) {\n    return {\n        eq: function (x) {\n            return function (y) {\n                return Data_Eq.eq(dictEq)($foreign.force(x))($foreign.force(y));\n            };\n        }\n    };\n};\nvar ordLazy = function (dictOrd) {\n    return {\n        compare: function (x) {\n            return function (y) {\n                return Data_Ord.compare(dictOrd)($foreign.force(x))($foreign.force(y));\n            };\n        },\n        Eq0: function () {\n            return eqLazy(dictOrd.Eq0());\n        }\n    };\n};\nvar eq1Lazy = {\n    eq1: function (dictEq) {\n        return Data_Eq.eq(eqLazy(dictEq));\n    }\n};\nvar ord1Lazy = {\n    compare1: function (dictOrd) {\n        return Data_Ord.compare(ordLazy(dictOrd));\n    },\n    Eq10: function () {\n        return eq1Lazy;\n    }\n};\nvar comonadLazy = {\n    extract: $foreign.force,\n    Extend0: function () {\n        return extendLazy;\n    }\n};\nvar commutativeRingLazy = function (dictCommutativeRing) {\n    return {\n        Ring0: function () {\n            return ringLazy(dictCommutativeRing.Ring0());\n        }\n    };\n};\nvar euclideanRingLazy = function (dictEuclideanRing) {\n    return {\n        degree: (function () {\n            var $47 = Data_EuclideanRing.degree(dictEuclideanRing);\n            return function ($48) {\n                return $47($foreign.force($48));\n            };\n        })(),\n        div: function (a) {\n            return function (b) {\n                return $foreign.defer(function (v) {\n                    return Data_EuclideanRing.div(dictEuclideanRing)($foreign.force(a))($foreign.force(b));\n                });\n            };\n        },\n        mod: function (a) {\n            return function (b) {\n                return $foreign.defer(function (v) {\n                    return Data_EuclideanRing.mod(dictEuclideanRing)($foreign.force(a))($foreign.force(b));\n                });\n            };\n        },\n        CommutativeRing0: function () {\n            return commutativeRingLazy(dictEuclideanRing.CommutativeRing0());\n        }\n    };\n};\nvar boundedLazy = function (dictBounded) {\n    return {\n        top: $foreign.defer(function (v) {\n            return Data_Bounded.top(dictBounded);\n        }),\n        bottom: $foreign.defer(function (v) {\n            return Data_Bounded.bottom(dictBounded);\n        }),\n        Ord0: function () {\n            return ordLazy(dictBounded.Ord0());\n        }\n    };\n};\nvar applyLazy = {\n    apply: function (f) {\n        return function (x) {\n            return $foreign.defer(function (v) {\n                return $foreign.force(f)($foreign.force(x));\n            });\n        };\n    },\n    Functor0: function () {\n        return functorLazy;\n    }\n};\nvar bindLazy = {\n    bind: function (l) {\n        return function (f) {\n            return $foreign.defer(function (v) {\n                return $foreign.force(f($foreign.force(l)));\n            });\n        };\n    },\n    Apply0: function () {\n        return applyLazy;\n    }\n};\nvar heytingAlgebraLazy = function (dictHeytingAlgebra) {\n    return {\n        ff: $foreign.defer(function (v) {\n            return Data_HeytingAlgebra.ff(dictHeytingAlgebra);\n        }),\n        tt: $foreign.defer(function (v) {\n            return Data_HeytingAlgebra.tt(dictHeytingAlgebra);\n        }),\n        implies: function (a) {\n            return function (b) {\n                return Control_Apply.apply(applyLazy)(Data_Functor.map(functorLazy)(Data_HeytingAlgebra.implies(dictHeytingAlgebra))(a))(b);\n            };\n        },\n        conj: function (a) {\n            return function (b) {\n                return Control_Apply.apply(applyLazy)(Data_Functor.map(functorLazy)(Data_HeytingAlgebra.conj(dictHeytingAlgebra))(a))(b);\n            };\n        },\n        disj: function (a) {\n            return function (b) {\n                return Control_Apply.apply(applyLazy)(Data_Functor.map(functorLazy)(Data_HeytingAlgebra.disj(dictHeytingAlgebra))(a))(b);\n            };\n        },\n        not: function (a) {\n            return Data_Functor.map(functorLazy)(Data_HeytingAlgebra.not(dictHeytingAlgebra))(a);\n        }\n    };\n};\nvar booleanAlgebraLazy = function (dictBooleanAlgebra) {\n    return {\n        HeytingAlgebra0: function () {\n            return heytingAlgebraLazy(dictBooleanAlgebra.HeytingAlgebra0());\n        }\n    };\n};\nvar applicativeLazy = {\n    pure: function (a) {\n        return $foreign.defer(function (v) {\n            return a;\n        });\n    },\n    Apply0: function () {\n        return applyLazy;\n    }\n};\nvar monadLazy = {\n    Applicative0: function () {\n        return applicativeLazy;\n    },\n    Bind1: function () {\n        return bindLazy;\n    }\n};\nmodule.exports = {\n    semiringLazy: semiringLazy,\n    ringLazy: ringLazy,\n    commutativeRingLazy: commutativeRingLazy,\n    euclideanRingLazy: euclideanRingLazy,\n    eqLazy: eqLazy,\n    eq1Lazy: eq1Lazy,\n    ordLazy: ordLazy,\n    ord1Lazy: ord1Lazy,\n    boundedLazy: boundedLazy,\n    semigroupLazy: semigroupLazy,\n    monoidLazy: monoidLazy,\n    heytingAlgebraLazy: heytingAlgebraLazy,\n    booleanAlgebraLazy: booleanAlgebraLazy,\n    functorLazy: functorLazy,\n    functorWithIndexLazy: functorWithIndexLazy,\n    foldableLazy: foldableLazy,\n    foldableWithIndexLazy: foldableWithIndexLazy,\n    foldable1Lazy: foldable1Lazy,\n    traversableLazy: traversableLazy,\n    traversableWithIndexLazy: traversableWithIndexLazy,\n    traversable1Lazy: traversable1Lazy,\n    invariantLazy: invariantLazy,\n    applyLazy: applyLazy,\n    applicativeLazy: applicativeLazy,\n    bindLazy: bindLazy,\n    monadLazy: monadLazy,\n    extendLazy: extendLazy,\n    comonadLazy: comonadLazy,\n    showLazy: showLazy,\n    lazyLazy: lazyLazy,\n    defer: $foreign.defer,\n    force: $foreign.force\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/lazy/v5.0.0/src/Data/Lazy.purs?");

/***/ }),

/***/ "./.spago/lists/v6.0.1/src/Data/List.purs":
/*!************************************************!*\
  !*** ./.spago/lists/v6.0.1/src/Data/List.purs ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Lazy = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Lazy.purs */ \"./.spago/control/v5.0.0/src/Control/Lazy.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_FunctorWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_List_Internal = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Internal.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Internal.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_NonEmpty = __webpack_require__(/*! ./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs */ \"./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Pattern = function (x) {\n    return x;\n};\nvar updateAt = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v === 0 && v2 instanceof Data_List_Types.Cons) {\n                return new Data_Maybe.Just(new Data_List_Types.Cons(v1, v2.value1));\n            };\n            if (v2 instanceof Data_List_Types.Cons) {\n                return Data_Functor.map(Data_Maybe.functorMaybe)(function (v3) {\n                    return new Data_List_Types.Cons(v2.value0, v3);\n                })(updateAt(v - 1 | 0)(v1)(v2.value1));\n            };\n            return Data_Maybe.Nothing.value;\n        };\n    };\n};\nvar unzip = Data_Foldable.foldr(Data_List_Types.foldableList)(function (v) {\n    return function (v1) {\n        return new Data_Tuple.Tuple(new Data_List_Types.Cons(v.value0, v1.value0), new Data_List_Types.Cons(v.value1, v1.value1));\n    };\n})(new Data_Tuple.Tuple(Data_List_Types.Nil.value, Data_List_Types.Nil.value));\nvar uncons = function (v) {\n    if (v instanceof Data_List_Types.Nil) {\n        return Data_Maybe.Nothing.value;\n    };\n    if (v instanceof Data_List_Types.Cons) {\n        return new Data_Maybe.Just({\n            head: v.value0,\n            tail: v.value1\n        });\n    };\n    throw new Error(\"Failed pattern match at Data.List (line 263, column 1 - line 263, column 66): \" + [ v.constructor.name ]);\n};\nvar toUnfoldable = function (dictUnfoldable) {\n    return Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {\n        return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {\n            return new Data_Tuple.Tuple(rec.head, rec.tail);\n        })(uncons(xs));\n    });\n};\nvar tail = function (v) {\n    if (v instanceof Data_List_Types.Nil) {\n        return Data_Maybe.Nothing.value;\n    };\n    if (v instanceof Data_List_Types.Cons) {\n        return new Data_Maybe.Just(v.value1);\n    };\n    throw new Error(\"Failed pattern match at Data.List (line 249, column 1 - line 249, column 43): \" + [ v.constructor.name ]);\n};\nvar stripPrefix = function (dictEq) {\n    return function (v) {\n        return function (s) {\n            var go = function (prefix) {\n                return function (input) {\n                    if (prefix instanceof Data_List_Types.Cons && (input instanceof Data_List_Types.Cons && Data_Eq.eq(dictEq)(prefix.value0)(input.value0))) {\n                        return Data_Maybe.Just.create(new Control_Monad_Rec_Class.Loop({\n                            a: prefix.value1,\n                            b: input.value1\n                        }));\n                    };\n                    if (prefix instanceof Data_List_Types.Nil) {\n                        return Data_Maybe.Just.create(new Control_Monad_Rec_Class.Done(input));\n                    };\n                    return Data_Maybe.Nothing.value;\n                };\n            };\n            return Control_Monad_Rec_Class.tailRecM2(Control_Monad_Rec_Class.monadRecMaybe)(go)(v)(s);\n        };\n    };\n};\nvar span = function (v) {\n    return function (v1) {\n        if (v1 instanceof Data_List_Types.Cons && v(v1.value0)) {\n            var v2 = span(v)(v1.value1);\n            return {\n                init: new Data_List_Types.Cons(v1.value0, v2.init),\n                rest: v2.rest\n            };\n        };\n        return {\n            init: Data_List_Types.Nil.value,\n            rest: v1\n        };\n    };\n};\nvar snoc = function (xs) {\n    return function (x) {\n        return Data_Foldable.foldr(Data_List_Types.foldableList)(Data_List_Types.Cons.create)(new Data_List_Types.Cons(x, Data_List_Types.Nil.value))(xs);\n    };\n};\nvar singleton = function (a) {\n    return new Data_List_Types.Cons(a, Data_List_Types.Nil.value);\n};\nvar sortBy = function (cmp) {\n    var merge = function (v) {\n        return function (v1) {\n            if (v instanceof Data_List_Types.Cons && v1 instanceof Data_List_Types.Cons) {\n                if (Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(v.value0)(v1.value0))(Data_Ordering.GT.value)) {\n                    return new Data_List_Types.Cons(v1.value0, merge(v)(v1.value1));\n                };\n                if (Data_Boolean.otherwise) {\n                    return new Data_List_Types.Cons(v.value0, merge(v.value1)(v1));\n                };\n            };\n            if (v instanceof Data_List_Types.Nil) {\n                return v1;\n            };\n            if (v1 instanceof Data_List_Types.Nil) {\n                return v;\n            };\n            throw new Error(\"Failed pattern match at Data.List (line 477, column 3 - line 477, column 38): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    };\n    var mergePairs = function (v) {\n        if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Cons) {\n            return new Data_List_Types.Cons(merge(v.value0)(v.value1.value0), mergePairs(v.value1.value1));\n        };\n        return v;\n    };\n    var mergeAll = function ($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n            if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Nil) {\n                $tco_done = true;\n                return v.value0;\n            };\n            $copy_v = mergePairs(v);\n            return;\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($copy_v);\n        };\n        return $tco_result;\n    };\n    var sequences = function (v) {\n        if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Cons) {\n            if (Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(v.value0)(v.value1.value0))(Data_Ordering.GT.value)) {\n                return descending(v.value1.value0)(singleton(v.value0))(v.value1.value1);\n            };\n            if (Data_Boolean.otherwise) {\n                return ascending(v.value1.value0)(function (v1) {\n                    return new Data_List_Types.Cons(v.value0, v1);\n                })(v.value1.value1);\n            };\n        };\n        return singleton(v);\n    };\n    var descending = function ($copy_a) {\n        return function ($copy_as) {\n            return function ($copy_v) {\n                var $tco_var_a = $copy_a;\n                var $tco_var_as = $copy_as;\n                var $tco_done1 = false;\n                var $tco_result;\n                function $tco_loop(a, as, v) {\n                    if (v instanceof Data_List_Types.Cons && Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(a)(v.value0))(Data_Ordering.GT.value)) {\n                        $tco_var_a = v.value0;\n                        $tco_var_as = new Data_List_Types.Cons(a, as);\n                        $copy_v = v.value1;\n                        return;\n                    };\n                    $tco_done1 = true;\n                    return new Data_List_Types.Cons(new Data_List_Types.Cons(a, as), sequences(v));\n                };\n                while (!$tco_done1) {\n                    $tco_result = $tco_loop($tco_var_a, $tco_var_as, $copy_v);\n                };\n                return $tco_result;\n            };\n        };\n    };\n    var ascending = function ($copy_a) {\n        return function ($copy_as) {\n            return function ($copy_v) {\n                var $tco_var_a = $copy_a;\n                var $tco_var_as = $copy_as;\n                var $tco_done2 = false;\n                var $tco_result;\n                function $tco_loop(a, as, v) {\n                    if (v instanceof Data_List_Types.Cons && Data_Eq.notEq(Data_Ordering.eqOrdering)(cmp(a)(v.value0))(Data_Ordering.GT.value)) {\n                        $tco_var_a = v.value0;\n                        $tco_var_as = function (ys) {\n                            return as(new Data_List_Types.Cons(a, ys));\n                        };\n                        $copy_v = v.value1;\n                        return;\n                    };\n                    $tco_done2 = true;\n                    return new Data_List_Types.Cons(as(singleton(a)), sequences(v));\n                };\n                while (!$tco_done2) {\n                    $tco_result = $tco_loop($tco_var_a, $tco_var_as, $copy_v);\n                };\n                return $tco_result;\n            };\n        };\n    };\n    return function ($345) {\n        return mergeAll(sequences($345));\n    };\n};\nvar sort = function (dictOrd) {\n    return function (xs) {\n        return sortBy(Data_Ord.compare(dictOrd))(xs);\n    };\n};\nvar tails = function (v) {\n    if (v instanceof Data_List_Types.Nil) {\n        return singleton(Data_List_Types.Nil.value);\n    };\n    if (v instanceof Data_List_Types.Cons) {\n        return new Data_List_Types.Cons(v, tails(v.value1));\n    };\n    throw new Error(\"Failed pattern match at Data.List (line 657, column 1 - line 657, column 43): \" + [ v.constructor.name ]);\n};\nvar showPattern = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Pattern \" + (Data_Show.show(Data_List_Types.showList(dictShow))(v) + \")\");\n        }\n    };\n};\nvar reverse = (function () {\n    var go = function ($copy_acc) {\n        return function ($copy_v) {\n            var $tco_var_acc = $copy_acc;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(acc, v) {\n                if (v instanceof Data_List_Types.Nil) {\n                    $tco_done = true;\n                    return acc;\n                };\n                if (v instanceof Data_List_Types.Cons) {\n                    $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);\n                    $copy_v = v.value1;\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Data.List (line 372, column 3 - line 372, column 19): \" + [ acc.constructor.name, v.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_acc, $copy_v);\n            };\n            return $tco_result;\n        };\n    };\n    return go(Data_List_Types.Nil.value);\n})();\nvar take = (function () {\n    var go = function ($copy_acc) {\n        return function ($copy_v) {\n            return function ($copy_v1) {\n                var $tco_var_acc = $copy_acc;\n                var $tco_var_v = $copy_v;\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(acc, v, v1) {\n                    if (v < 1) {\n                        $tco_done = true;\n                        return reverse(acc);\n                    };\n                    if (v1 instanceof Data_List_Types.Nil) {\n                        $tco_done = true;\n                        return reverse(acc);\n                    };\n                    if (v1 instanceof Data_List_Types.Cons) {\n                        $tco_var_acc = new Data_List_Types.Cons(v1.value0, acc);\n                        $tco_var_v = v - 1 | 0;\n                        $copy_v1 = v1.value1;\n                        return;\n                    };\n                    throw new Error(\"Failed pattern match at Data.List (line 524, column 3 - line 524, column 35): \" + [ acc.constructor.name, v.constructor.name, v1.constructor.name ]);\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($tco_var_acc, $tco_var_v, $copy_v1);\n                };\n                return $tco_result;\n            };\n        };\n    };\n    return go(Data_List_Types.Nil.value);\n})();\nvar takeWhile = function (p) {\n    var go = function ($copy_acc) {\n        return function ($copy_v) {\n            var $tco_var_acc = $copy_acc;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(acc, v) {\n                if (v instanceof Data_List_Types.Cons && p(v.value0)) {\n                    $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);\n                    $copy_v = v.value1;\n                    return;\n                };\n                $tco_done = true;\n                return reverse(acc);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_acc, $copy_v);\n            };\n            return $tco_result;\n        };\n    };\n    return go(Data_List_Types.Nil.value);\n};\nvar unsnoc = function (lst) {\n    var go = function ($copy_v) {\n        return function ($copy_v1) {\n            var $tco_var_v = $copy_v;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(v, v1) {\n                if (v instanceof Data_List_Types.Nil) {\n                    $tco_done = true;\n                    return Data_Maybe.Nothing.value;\n                };\n                if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Nil) {\n                    $tco_done = true;\n                    return new Data_Maybe.Just({\n                        revInit: v1,\n                        last: v.value0\n                    });\n                };\n                if (v instanceof Data_List_Types.Cons) {\n                    $tco_var_v = v.value1;\n                    $copy_v1 = new Data_List_Types.Cons(v.value0, v1);\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Data.List (line 274, column 3 - line 274, column 21): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v, $copy_v1);\n            };\n            return $tco_result;\n        };\n    };\n    return Data_Functor.map(Data_Maybe.functorMaybe)(function (h) {\n        return {\n            init: reverse(h.revInit),\n            last: h.last\n        };\n    })(go(lst)(Data_List_Types.Nil.value));\n};\nvar zipWith = function (f) {\n    return function (xs) {\n        return function (ys) {\n            var go = function ($copy_v) {\n                return function ($copy_v1) {\n                    return function ($copy_acc) {\n                        var $tco_var_v = $copy_v;\n                        var $tco_var_v1 = $copy_v1;\n                        var $tco_done = false;\n                        var $tco_result;\n                        function $tco_loop(v, v1, acc) {\n                            if (v instanceof Data_List_Types.Nil) {\n                                $tco_done = true;\n                                return acc;\n                            };\n                            if (v1 instanceof Data_List_Types.Nil) {\n                                $tco_done = true;\n                                return acc;\n                            };\n                            if (v instanceof Data_List_Types.Cons && v1 instanceof Data_List_Types.Cons) {\n                                $tco_var_v = v.value1;\n                                $tco_var_v1 = v1.value1;\n                                $copy_acc = new Data_List_Types.Cons(f(v.value0)(v1.value0), acc);\n                                return;\n                            };\n                            throw new Error(\"Failed pattern match at Data.List (line 795, column 3 - line 795, column 21): \" + [ v.constructor.name, v1.constructor.name, acc.constructor.name ]);\n                        };\n                        while (!$tco_done) {\n                            $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_acc);\n                        };\n                        return $tco_result;\n                    };\n                };\n            };\n            return reverse(go(xs)(ys)(Data_List_Types.Nil.value));\n        };\n    };\n};\nvar zip = zipWith(Data_Tuple.Tuple.create);\nvar zipWithA = function (dictApplicative) {\n    return function (f) {\n        return function (xs) {\n            return function (ys) {\n                return Data_Traversable.sequence(Data_List_Types.traversableList)(dictApplicative)(zipWith(f)(xs)(ys));\n            };\n        };\n    };\n};\nvar range = function (start) {\n    return function (end) {\n        if (start === end) {\n            return singleton(start);\n        };\n        if (Data_Boolean.otherwise) {\n            var go = function ($copy_s) {\n                return function ($copy_e) {\n                    return function ($copy_step) {\n                        return function ($copy_rest) {\n                            var $tco_var_s = $copy_s;\n                            var $tco_var_e = $copy_e;\n                            var $tco_var_step = $copy_step;\n                            var $tco_done = false;\n                            var $tco_result;\n                            function $tco_loop(s, e, step, rest) {\n                                if (s === e) {\n                                    $tco_done = true;\n                                    return new Data_List_Types.Cons(s, rest);\n                                };\n                                if (Data_Boolean.otherwise) {\n                                    $tco_var_s = s + step | 0;\n                                    $tco_var_e = e;\n                                    $tco_var_step = step;\n                                    $copy_rest = new Data_List_Types.Cons(s, rest);\n                                    return;\n                                };\n                                throw new Error(\"Failed pattern match at Data.List (line 152, column 3 - line 153, column 65): \" + [ s.constructor.name, e.constructor.name, step.constructor.name, rest.constructor.name ]);\n                            };\n                            while (!$tco_done) {\n                                $tco_result = $tco_loop($tco_var_s, $tco_var_e, $tco_var_step, $copy_rest);\n                            };\n                            return $tco_result;\n                        };\n                    };\n                };\n            };\n            return go(end)(start)((function () {\n                var $226 = start > end;\n                if ($226) {\n                    return 1;\n                };\n                return -1 | 0;\n            })())(Data_List_Types.Nil.value);\n        };\n        throw new Error(\"Failed pattern match at Data.List (line 148, column 1 - line 148, column 32): \" + [ start.constructor.name, end.constructor.name ]);\n    };\n};\nvar partition = function (p) {\n    return function (xs) {\n        var select = function (x) {\n            return function (v) {\n                var $229 = p(x);\n                if ($229) {\n                    return {\n                        no: v.no,\n                        yes: new Data_List_Types.Cons(x, v.yes)\n                    };\n                };\n                return {\n                    no: new Data_List_Types.Cons(x, v.no),\n                    yes: v.yes\n                };\n            };\n        };\n        return Data_Foldable.foldr(Data_List_Types.foldableList)(select)({\n            no: Data_List_Types.Nil.value,\n            yes: Data_List_Types.Nil.value\n        })(xs);\n    };\n};\nvar $$null = function (v) {\n    if (v instanceof Data_List_Types.Nil) {\n        return true;\n    };\n    return false;\n};\nvar nubBy = function (p) {\n    var go = function ($copy_v) {\n        return function ($copy_acc) {\n            return function ($copy_v1) {\n                var $tco_var_v = $copy_v;\n                var $tco_var_acc = $copy_acc;\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(v, acc, v1) {\n                    if (v1 instanceof Data_List_Types.Nil) {\n                        $tco_done = true;\n                        return acc;\n                    };\n                    if (v1 instanceof Data_List_Types.Cons) {\n                        var v2 = Data_List_Internal.insertAndLookupBy(p)(v1.value0)(v);\n                        if (v2.found) {\n                            $tco_var_v = v2.result;\n                            $tco_var_acc = acc;\n                            $copy_v1 = v1.value1;\n                            return;\n                        };\n                        $tco_var_v = v2.result;\n                        $tco_var_acc = new Data_List_Types.Cons(v1.value0, acc);\n                        $copy_v1 = v1.value1;\n                        return;\n                    };\n                    throw new Error(\"Failed pattern match at Data.List (line 689, column 5 - line 689, column 23): \" + [ v.constructor.name, acc.constructor.name, v1.constructor.name ]);\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($tco_var_v, $tco_var_acc, $copy_v1);\n                };\n                return $tco_result;\n            };\n        };\n    };\n    var $346 = go(Data_List_Internal.emptySet)(Data_List_Types.Nil.value);\n    return function ($347) {\n        return reverse($346($347));\n    };\n};\nvar nub = function (dictOrd) {\n    return nubBy(Data_Ord.compare(dictOrd));\n};\nvar newtypePattern = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar mapWithIndex = Data_FunctorWithIndex.mapWithIndex(Data_List_Types.functorWithIndexList);\nvar mapMaybe = function (f) {\n    var go = function ($copy_acc) {\n        return function ($copy_v) {\n            var $tco_var_acc = $copy_acc;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(acc, v) {\n                if (v instanceof Data_List_Types.Nil) {\n                    $tco_done = true;\n                    return reverse(acc);\n                };\n                if (v instanceof Data_List_Types.Cons) {\n                    var v1 = f(v.value0);\n                    if (v1 instanceof Data_Maybe.Nothing) {\n                        $tco_var_acc = acc;\n                        $copy_v = v.value1;\n                        return;\n                    };\n                    if (v1 instanceof Data_Maybe.Just) {\n                        $tco_var_acc = new Data_List_Types.Cons(v1.value0, acc);\n                        $copy_v = v.value1;\n                        return;\n                    };\n                    throw new Error(\"Failed pattern match at Data.List (line 423, column 5 - line 425, column 32): \" + [ v1.constructor.name ]);\n                };\n                throw new Error(\"Failed pattern match at Data.List (line 421, column 3 - line 421, column 27): \" + [ acc.constructor.name, v.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_acc, $copy_v);\n            };\n            return $tco_result;\n        };\n    };\n    return go(Data_List_Types.Nil.value);\n};\nvar manyRec = function (dictMonadRec) {\n    return function (dictAlternative) {\n        return function (p) {\n            var go = function (acc) {\n                return Control_Bind.bind((dictMonadRec.Monad0()).Bind1())(Control_Alt.alt((dictAlternative.Plus1()).Alt0())(Data_Functor.map(((dictAlternative.Plus1()).Alt0()).Functor0())(Control_Monad_Rec_Class.Loop.create)(p))(Control_Applicative.pure(dictAlternative.Applicative0())(new Control_Monad_Rec_Class.Done(Data_Unit.unit))))(function (aa) {\n                    return Control_Applicative.pure(dictAlternative.Applicative0())(Data_Bifunctor.bimap(Control_Monad_Rec_Class.bifunctorStep)(function (v) {\n                        return new Data_List_Types.Cons(v, acc);\n                    })(function (v) {\n                        return reverse(acc);\n                    })(aa));\n                });\n            };\n            return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(go)(Data_List_Types.Nil.value);\n        };\n    };\n};\nvar someRec = function (dictMonadRec) {\n    return function (dictAlternative) {\n        return function (v) {\n            return Control_Apply.apply((dictAlternative.Applicative0()).Apply0())(Data_Functor.map(((dictAlternative.Plus1()).Alt0()).Functor0())(Data_List_Types.Cons.create)(v))(manyRec(dictMonadRec)(dictAlternative)(v));\n        };\n    };\n};\nvar some = function (dictAlternative) {\n    return function (dictLazy) {\n        return function (v) {\n            return Control_Apply.apply((dictAlternative.Applicative0()).Apply0())(Data_Functor.map(((dictAlternative.Plus1()).Alt0()).Functor0())(Data_List_Types.Cons.create)(v))(Control_Lazy.defer(dictLazy)(function (v1) {\n                return many(dictAlternative)(dictLazy)(v);\n            }));\n        };\n    };\n};\nvar many = function (dictAlternative) {\n    return function (dictLazy) {\n        return function (v) {\n            return Control_Alt.alt((dictAlternative.Plus1()).Alt0())(some(dictAlternative)(dictLazy)(v))(Control_Applicative.pure(dictAlternative.Applicative0())(Data_List_Types.Nil.value));\n        };\n    };\n};\nvar length = Data_Foldable.foldl(Data_List_Types.foldableList)(function (acc) {\n    return function (v) {\n        return acc + 1 | 0;\n    };\n})(0);\nvar last = function ($copy_v) {\n    var $tco_done = false;\n    var $tco_result;\n    function $tco_loop(v) {\n        if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Nil) {\n            $tco_done = true;\n            return new Data_Maybe.Just(v.value0);\n        };\n        if (v instanceof Data_List_Types.Cons) {\n            $copy_v = v.value1;\n            return;\n        };\n        $tco_done = true;\n        return Data_Maybe.Nothing.value;\n    };\n    while (!$tco_done) {\n        $tco_result = $tco_loop($copy_v);\n    };\n    return $tco_result;\n};\nvar insertBy = function (v) {\n    return function (x) {\n        return function (v1) {\n            if (v1 instanceof Data_List_Types.Nil) {\n                return singleton(x);\n            };\n            if (v1 instanceof Data_List_Types.Cons) {\n                var v2 = v(x)(v1.value0);\n                if (v2 instanceof Data_Ordering.GT) {\n                    return new Data_List_Types.Cons(v1.value0, insertBy(v)(x)(v1.value1));\n                };\n                return new Data_List_Types.Cons(x, v1);\n            };\n            throw new Error(\"Failed pattern match at Data.List (line 220, column 1 - line 220, column 68): \" + [ v.constructor.name, x.constructor.name, v1.constructor.name ]);\n        };\n    };\n};\nvar insertAt = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v === 0) {\n                return new Data_Maybe.Just(new Data_List_Types.Cons(v1, v2));\n            };\n            if (v2 instanceof Data_List_Types.Cons) {\n                return Data_Functor.map(Data_Maybe.functorMaybe)(function (v3) {\n                    return new Data_List_Types.Cons(v2.value0, v3);\n                })(insertAt(v - 1 | 0)(v1)(v2.value1));\n            };\n            return Data_Maybe.Nothing.value;\n        };\n    };\n};\nvar insert = function (dictOrd) {\n    return insertBy(Data_Ord.compare(dictOrd));\n};\nvar init = function (lst) {\n    return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {\n        return v.init;\n    })(unsnoc(lst));\n};\nvar index = function ($copy_v) {\n    return function ($copy_v1) {\n        var $tco_var_v = $copy_v;\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v, v1) {\n            if (v instanceof Data_List_Types.Nil) {\n                $tco_done = true;\n                return Data_Maybe.Nothing.value;\n            };\n            if (v instanceof Data_List_Types.Cons && v1 === 0) {\n                $tco_done = true;\n                return new Data_Maybe.Just(v.value0);\n            };\n            if (v instanceof Data_List_Types.Cons) {\n                $tco_var_v = v.value1;\n                $copy_v1 = v1 - 1 | 0;\n                return;\n            };\n            throw new Error(\"Failed pattern match at Data.List (line 285, column 1 - line 285, column 44): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($tco_var_v, $copy_v1);\n        };\n        return $tco_result;\n    };\n};\nvar head = function (v) {\n    if (v instanceof Data_List_Types.Nil) {\n        return Data_Maybe.Nothing.value;\n    };\n    if (v instanceof Data_List_Types.Cons) {\n        return new Data_Maybe.Just(v.value0);\n    };\n    throw new Error(\"Failed pattern match at Data.List (line 234, column 1 - line 234, column 22): \" + [ v.constructor.name ]);\n};\nvar transpose = function (v) {\n    if (v instanceof Data_List_Types.Nil) {\n        return Data_List_Types.Nil.value;\n    };\n    if (v instanceof Data_List_Types.Cons && v.value0 instanceof Data_List_Types.Nil) {\n        return transpose(v.value1);\n    };\n    if (v instanceof Data_List_Types.Cons && v.value0 instanceof Data_List_Types.Cons) {\n        return new Data_List_Types.Cons(new Data_List_Types.Cons(v.value0.value0, mapMaybe(head)(v.value1)), transpose(new Data_List_Types.Cons(v.value0.value1, mapMaybe(tail)(v.value1))));\n    };\n    throw new Error(\"Failed pattern match at Data.List (line 829, column 1 - line 829, column 54): \" + [ v.constructor.name ]);\n};\nvar groupBy = function (v) {\n    return function (v1) {\n        if (v1 instanceof Data_List_Types.Nil) {\n            return Data_List_Types.Nil.value;\n        };\n        if (v1 instanceof Data_List_Types.Cons) {\n            var v2 = span(v(v1.value0))(v1.value1);\n            return new Data_List_Types.Cons(new Data_NonEmpty.NonEmpty(v1.value0, v2.init), groupBy(v)(v2.rest));\n        };\n        throw new Error(\"Failed pattern match at Data.List (line 624, column 1 - line 624, column 80): \" + [ v.constructor.name, v1.constructor.name ]);\n    };\n};\nvar groupAllBy = function (dictOrd) {\n    return function (p) {\n        var $348 = groupBy(p);\n        var $349 = sort(dictOrd);\n        return function ($350) {\n            return $348($349($350));\n        };\n    };\n};\nvar group = function (dictEq) {\n    return groupBy(Data_Eq.eq(dictEq));\n};\nvar groupAll = function (dictOrd) {\n    var $351 = group(dictOrd.Eq0());\n    var $352 = sort(dictOrd);\n    return function ($353) {\n        return $351($352($353));\n    };\n};\nvar group$prime = function (dictWarn) {\n    return function (dictOrd) {\n        return groupAll(dictOrd);\n    };\n};\nvar fromFoldable = function (dictFoldable) {\n    return Data_Foldable.foldr(dictFoldable)(Data_List_Types.Cons.create)(Data_List_Types.Nil.value);\n};\nvar foldM = function (dictMonad) {\n    return function (v) {\n        return function (b) {\n            return function (v1) {\n                if (v1 instanceof Data_List_Types.Nil) {\n                    return Control_Applicative.pure(dictMonad.Applicative0())(b);\n                };\n                if (v1 instanceof Data_List_Types.Cons) {\n                    return Control_Bind.bind(dictMonad.Bind1())(v(b)(v1.value0))(function (b$prime) {\n                        return foldM(dictMonad)(v)(b$prime)(v1.value1);\n                    });\n                };\n                throw new Error(\"Failed pattern match at Data.List (line 840, column 1 - line 840, column 72): \" + [ v.constructor.name, b.constructor.name, v1.constructor.name ]);\n            };\n        };\n    };\n};\nvar findIndex = function (fn) {\n    var go = function ($copy_v) {\n        return function ($copy_v1) {\n            var $tco_var_v = $copy_v;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(v, v1) {\n                if (v1 instanceof Data_List_Types.Cons) {\n                    if (fn(v1.value0)) {\n                        $tco_done = true;\n                        return new Data_Maybe.Just(v);\n                    };\n                    if (Data_Boolean.otherwise) {\n                        $tco_var_v = v + 1 | 0;\n                        $copy_v1 = v1.value1;\n                        return;\n                    };\n                };\n                if (v1 instanceof Data_List_Types.Nil) {\n                    $tco_done = true;\n                    return Data_Maybe.Nothing.value;\n                };\n                throw new Error(\"Failed pattern match at Data.List (line 305, column 3 - line 305, column 35): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v, $copy_v1);\n            };\n            return $tco_result;\n        };\n    };\n    return go(0);\n};\nvar findLastIndex = function (fn) {\n    return function (xs) {\n        return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {\n            return (length(xs) - 1 | 0) - v | 0;\n        })(findIndex(fn)(reverse(xs)));\n    };\n};\nvar filterM = function (dictMonad) {\n    return function (v) {\n        return function (v1) {\n            if (v1 instanceof Data_List_Types.Nil) {\n                return Control_Applicative.pure(dictMonad.Applicative0())(Data_List_Types.Nil.value);\n            };\n            if (v1 instanceof Data_List_Types.Cons) {\n                return Control_Bind.bind(dictMonad.Bind1())(v(v1.value0))(function (b) {\n                    return Control_Bind.bind(dictMonad.Bind1())(filterM(dictMonad)(v)(v1.value1))(function (xs$prime) {\n                        return Control_Applicative.pure(dictMonad.Applicative0())((function () {\n                            if (b) {\n                                return new Data_List_Types.Cons(v1.value0, xs$prime);\n                            };\n                            return xs$prime;\n                        })());\n                    });\n                });\n            };\n            throw new Error(\"Failed pattern match at Data.List (line 407, column 1 - line 407, column 75): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    };\n};\nvar filter = function (p) {\n    var go = function ($copy_acc) {\n        return function ($copy_v) {\n            var $tco_var_acc = $copy_acc;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(acc, v) {\n                if (v instanceof Data_List_Types.Nil) {\n                    $tco_done = true;\n                    return reverse(acc);\n                };\n                if (v instanceof Data_List_Types.Cons) {\n                    if (p(v.value0)) {\n                        $tco_var_acc = new Data_List_Types.Cons(v.value0, acc);\n                        $copy_v = v.value1;\n                        return;\n                    };\n                    if (Data_Boolean.otherwise) {\n                        $tco_var_acc = acc;\n                        $copy_v = v.value1;\n                        return;\n                    };\n                };\n                throw new Error(\"Failed pattern match at Data.List (line 394, column 3 - line 394, column 27): \" + [ acc.constructor.name, v.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_acc, $copy_v);\n            };\n            return $tco_result;\n        };\n    };\n    return go(Data_List_Types.Nil.value);\n};\nvar intersectBy = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v1 instanceof Data_List_Types.Nil) {\n                return Data_List_Types.Nil.value;\n            };\n            if (v2 instanceof Data_List_Types.Nil) {\n                return Data_List_Types.Nil.value;\n            };\n            return filter(function (x) {\n                return Data_Foldable.any(Data_List_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(v(x))(v2);\n            })(v1);\n        };\n    };\n};\nvar intersect = function (dictEq) {\n    return intersectBy(Data_Eq.eq(dictEq));\n};\nvar nubByEq = function (v) {\n    return function (v1) {\n        if (v1 instanceof Data_List_Types.Nil) {\n            return Data_List_Types.Nil.value;\n        };\n        if (v1 instanceof Data_List_Types.Cons) {\n            return new Data_List_Types.Cons(v1.value0, nubByEq(v)(filter(function (y) {\n                return !v(v1.value0)(y);\n            })(v1.value1)));\n        };\n        throw new Error(\"Failed pattern match at Data.List (line 721, column 1 - line 721, column 61): \" + [ v.constructor.name, v1.constructor.name ]);\n    };\n};\nvar nubEq = function (dictEq) {\n    return nubByEq(Data_Eq.eq(dictEq));\n};\nvar eqPattern = function (dictEq) {\n    return {\n        eq: function (x) {\n            return function (y) {\n                return Data_Eq.eq(Data_List_Types.eqList(dictEq))(x)(y);\n            };\n        }\n    };\n};\nvar ordPattern = function (dictOrd) {\n    return {\n        compare: function (x) {\n            return function (y) {\n                return Data_Ord.compare(Data_List_Types.ordList(dictOrd))(x)(y);\n            };\n        },\n        Eq0: function () {\n            return eqPattern(dictOrd.Eq0());\n        }\n    };\n};\nvar elemLastIndex = function (dictEq) {\n    return function (x) {\n        return findLastIndex(function (v) {\n            return Data_Eq.eq(dictEq)(v)(x);\n        });\n    };\n};\nvar elemIndex = function (dictEq) {\n    return function (x) {\n        return findIndex(function (v) {\n            return Data_Eq.eq(dictEq)(v)(x);\n        });\n    };\n};\nvar dropWhile = function (p) {\n    var go = function ($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n            if (v instanceof Data_List_Types.Cons && p(v.value0)) {\n                $copy_v = v.value1;\n                return;\n            };\n            $tco_done = true;\n            return v;\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($copy_v);\n        };\n        return $tco_result;\n    };\n    return go;\n};\nvar dropEnd = function (n) {\n    return function (xs) {\n        return take(length(xs) - n | 0)(xs);\n    };\n};\nvar drop = function ($copy_v) {\n    return function ($copy_v1) {\n        var $tco_var_v = $copy_v;\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v, v1) {\n            if (v < 1) {\n                $tco_done = true;\n                return v1;\n            };\n            if (v1 instanceof Data_List_Types.Nil) {\n                $tco_done = true;\n                return Data_List_Types.Nil.value;\n            };\n            if (v1 instanceof Data_List_Types.Cons) {\n                $tco_var_v = v - 1 | 0;\n                $copy_v1 = v1.value1;\n                return;\n            };\n            throw new Error(\"Failed pattern match at Data.List (line 547, column 1 - line 547, column 42): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($tco_var_v, $copy_v1);\n        };\n        return $tco_result;\n    };\n};\nvar slice = function (start) {\n    return function (end) {\n        return function (xs) {\n            return take(end - start | 0)(drop(start)(xs));\n        };\n    };\n};\nvar takeEnd = function (n) {\n    return function (xs) {\n        return drop(length(xs) - n | 0)(xs);\n    };\n};\nvar deleteBy = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2 instanceof Data_List_Types.Nil) {\n                return Data_List_Types.Nil.value;\n            };\n            if (v2 instanceof Data_List_Types.Cons && v(v1)(v2.value0)) {\n                return v2.value1;\n            };\n            if (v2 instanceof Data_List_Types.Cons) {\n                return new Data_List_Types.Cons(v2.value0, deleteBy(v)(v1)(v2.value1));\n            };\n            throw new Error(\"Failed pattern match at Data.List (line 748, column 1 - line 748, column 67): \" + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);\n        };\n    };\n};\nvar unionBy = function (eq) {\n    return function (xs) {\n        return function (ys) {\n            return Data_Semigroup.append(Data_List_Types.semigroupList)(xs)(Data_Foldable.foldl(Data_List_Types.foldableList)(Data_Function.flip(deleteBy(eq)))(nubByEq(eq)(ys))(xs));\n        };\n    };\n};\nvar union = function (dictEq) {\n    return unionBy(Data_Eq.eq(dictEq));\n};\nvar deleteAt = function (v) {\n    return function (v1) {\n        if (v === 0 && v1 instanceof Data_List_Types.Cons) {\n            return new Data_Maybe.Just(v1.value1);\n        };\n        if (v1 instanceof Data_List_Types.Cons) {\n            return Data_Functor.map(Data_Maybe.functorMaybe)(function (v2) {\n                return new Data_List_Types.Cons(v1.value0, v2);\n            })(deleteAt(v - 1 | 0)(v1.value1));\n        };\n        return Data_Maybe.Nothing.value;\n    };\n};\nvar $$delete = function (dictEq) {\n    return deleteBy(Data_Eq.eq(dictEq));\n};\nvar difference = function (dictEq) {\n    return Data_Foldable.foldl(Data_List_Types.foldableList)(Data_Function.flip($$delete(dictEq)));\n};\nvar concatMap = Data_Function.flip(Control_Bind.bind(Data_List_Types.bindList));\nvar concat = function (v) {\n    return Control_Bind.bind(Data_List_Types.bindList)(v)(Control_Category.identity(Control_Category.categoryFn));\n};\nvar catMaybes = mapMaybe(Control_Category.identity(Control_Category.categoryFn));\nvar alterAt = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v === 0 && v2 instanceof Data_List_Types.Cons) {\n                return Data_Maybe.Just.create((function () {\n                    var v3 = v1(v2.value0);\n                    if (v3 instanceof Data_Maybe.Nothing) {\n                        return v2.value1;\n                    };\n                    if (v3 instanceof Data_Maybe.Just) {\n                        return new Data_List_Types.Cons(v3.value0, v2.value1);\n                    };\n                    throw new Error(\"Failed pattern match at Data.List (line 356, column 3 - line 358, column 23): \" + [ v3.constructor.name ]);\n                })());\n            };\n            if (v2 instanceof Data_List_Types.Cons) {\n                return Data_Functor.map(Data_Maybe.functorMaybe)(function (v3) {\n                    return new Data_List_Types.Cons(v2.value0, v3);\n                })(alterAt(v - 1 | 0)(v1)(v2.value1));\n            };\n            return Data_Maybe.Nothing.value;\n        };\n    };\n};\nvar modifyAt = function (n) {\n    return function (f) {\n        return alterAt(n)(function ($354) {\n            return Data_Maybe.Just.create(f($354));\n        });\n    };\n};\nmodule.exports = {\n    toUnfoldable: toUnfoldable,\n    fromFoldable: fromFoldable,\n    singleton: singleton,\n    range: range,\n    some: some,\n    someRec: someRec,\n    many: many,\n    manyRec: manyRec,\n    \"null\": $$null,\n    length: length,\n    snoc: snoc,\n    insert: insert,\n    insertBy: insertBy,\n    head: head,\n    last: last,\n    tail: tail,\n    init: init,\n    uncons: uncons,\n    unsnoc: unsnoc,\n    index: index,\n    elemIndex: elemIndex,\n    elemLastIndex: elemLastIndex,\n    findIndex: findIndex,\n    findLastIndex: findLastIndex,\n    insertAt: insertAt,\n    deleteAt: deleteAt,\n    updateAt: updateAt,\n    modifyAt: modifyAt,\n    alterAt: alterAt,\n    reverse: reverse,\n    concat: concat,\n    concatMap: concatMap,\n    filter: filter,\n    filterM: filterM,\n    mapMaybe: mapMaybe,\n    catMaybes: catMaybes,\n    mapWithIndex: mapWithIndex,\n    sort: sort,\n    sortBy: sortBy,\n    Pattern: Pattern,\n    stripPrefix: stripPrefix,\n    slice: slice,\n    take: take,\n    takeEnd: takeEnd,\n    takeWhile: takeWhile,\n    drop: drop,\n    dropEnd: dropEnd,\n    dropWhile: dropWhile,\n    span: span,\n    group: group,\n    groupAll: groupAll,\n    \"group'\": group$prime,\n    groupBy: groupBy,\n    groupAllBy: groupAllBy,\n    partition: partition,\n    nub: nub,\n    nubBy: nubBy,\n    nubEq: nubEq,\n    nubByEq: nubByEq,\n    union: union,\n    unionBy: unionBy,\n    \"delete\": $$delete,\n    deleteBy: deleteBy,\n    difference: difference,\n    intersect: intersect,\n    intersectBy: intersectBy,\n    zipWith: zipWith,\n    zipWithA: zipWithA,\n    zip: zip,\n    unzip: unzip,\n    transpose: transpose,\n    foldM: foldM,\n    eqPattern: eqPattern,\n    ordPattern: ordPattern,\n    newtypePattern: newtypePattern,\n    showPattern: showPattern,\n    all: Data_Foldable.all,\n    any: Data_Foldable.any,\n    elem: Data_Foldable.elem,\n    find: Data_Foldable.find,\n    findMap: Data_Foldable.findMap,\n    fold: Data_Foldable.fold,\n    foldMap: Data_Foldable.foldMap,\n    foldl: Data_Foldable.foldl,\n    foldr: Data_Foldable.foldr,\n    intercalate: Data_Foldable.intercalate,\n    notElem: Data_Foldable.notElem,\n    Cons: Data_List_Types.Cons,\n    Nil: Data_List_Types.Nil,\n    scanl: Data_Traversable.scanl,\n    scanr: Data_Traversable.scanr\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/lists/v6.0.1/src/Data/List.purs?");

/***/ }),

/***/ "./.spago/lists/v6.0.1/src/Data/List/Internal.purs":
/*!*********************************************************!*\
  !*** ./.spago/lists/v6.0.1/src/Data/List/Internal.purs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Leaf = (function () {\n    function Leaf() {\n\n    };\n    Leaf.value = new Leaf();\n    return Leaf;\n})();\nvar Two = (function () {\n    function Two(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    Two.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new Two(value0, value1, value2);\n            };\n        };\n    };\n    return Two;\n})();\nvar Three = (function () {\n    function Three(value0, value1, value2, value3, value4) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n        this.value4 = value4;\n    };\n    Three.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return function (value4) {\n                        return new Three(value0, value1, value2, value3, value4);\n                    };\n                };\n            };\n        };\n    };\n    return Three;\n})();\nvar TwoLeft = (function () {\n    function TwoLeft(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TwoLeft.create = function (value0) {\n        return function (value1) {\n            return new TwoLeft(value0, value1);\n        };\n    };\n    return TwoLeft;\n})();\nvar TwoRight = (function () {\n    function TwoRight(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TwoRight.create = function (value0) {\n        return function (value1) {\n            return new TwoRight(value0, value1);\n        };\n    };\n    return TwoRight;\n})();\nvar ThreeLeft = (function () {\n    function ThreeLeft(value0, value1, value2, value3) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n    };\n    ThreeLeft.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return new ThreeLeft(value0, value1, value2, value3);\n                };\n            };\n        };\n    };\n    return ThreeLeft;\n})();\nvar ThreeMiddle = (function () {\n    function ThreeMiddle(value0, value1, value2, value3) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n    };\n    ThreeMiddle.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return new ThreeMiddle(value0, value1, value2, value3);\n                };\n            };\n        };\n    };\n    return ThreeMiddle;\n})();\nvar ThreeRight = (function () {\n    function ThreeRight(value0, value1, value2, value3) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n    };\n    ThreeRight.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return new ThreeRight(value0, value1, value2, value3);\n                };\n            };\n        };\n    };\n    return ThreeRight;\n})();\nvar KickUp = (function () {\n    function KickUp(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    KickUp.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new KickUp(value0, value1, value2);\n            };\n        };\n    };\n    return KickUp;\n})();\nvar fromZipper = function ($copy_v) {\n    return function ($copy_tree) {\n        var $tco_var_v = $copy_v;\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v, tree) {\n            if (v instanceof Data_List_Types.Nil) {\n                $tco_done = true;\n                return tree;\n            };\n            if (v instanceof Data_List_Types.Cons) {\n                if (v.value0 instanceof TwoLeft) {\n                    $tco_var_v = v.value1;\n                    $copy_tree = new Two(tree, v.value0.value0, v.value0.value1);\n                    return;\n                };\n                if (v.value0 instanceof TwoRight) {\n                    $tco_var_v = v.value1;\n                    $copy_tree = new Two(v.value0.value0, v.value0.value1, tree);\n                    return;\n                };\n                if (v.value0 instanceof ThreeLeft) {\n                    $tco_var_v = v.value1;\n                    $copy_tree = new Three(tree, v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3);\n                    return;\n                };\n                if (v.value0 instanceof ThreeMiddle) {\n                    $tco_var_v = v.value1;\n                    $copy_tree = new Three(v.value0.value0, v.value0.value1, tree, v.value0.value2, v.value0.value3);\n                    return;\n                };\n                if (v.value0 instanceof ThreeRight) {\n                    $tco_var_v = v.value1;\n                    $copy_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, tree);\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Data.List.Internal (line 25, column 3 - line 30, column 76): \" + [ v.value0.constructor.name ]);\n            };\n            throw new Error(\"Failed pattern match at Data.List.Internal (line 22, column 1 - line 22, column 63): \" + [ v.constructor.name, tree.constructor.name ]);\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($tco_var_v, $copy_tree);\n        };\n        return $tco_result;\n    };\n};\nvar insertAndLookupBy = function (comp) {\n    return function (k) {\n        return function (orig) {\n            var up = function ($copy_v) {\n                return function ($copy_v1) {\n                    var $tco_var_v = $copy_v;\n                    var $tco_done = false;\n                    var $tco_result;\n                    function $tco_loop(v, v1) {\n                        if (v instanceof Data_List_Types.Nil) {\n                            $tco_done = true;\n                            return new Two(v1.value0, v1.value1, v1.value2);\n                        };\n                        if (v instanceof Data_List_Types.Cons) {\n                            if (v.value0 instanceof TwoLeft) {\n                                $tco_done = true;\n                                return fromZipper(v.value1)(new Three(v1.value0, v1.value1, v1.value2, v.value0.value0, v.value0.value1));\n                            };\n                            if (v.value0 instanceof TwoRight) {\n                                $tco_done = true;\n                                return fromZipper(v.value1)(new Three(v.value0.value0, v.value0.value1, v1.value0, v1.value1, v1.value2));\n                            };\n                            if (v.value0 instanceof ThreeLeft) {\n                                $tco_var_v = v.value1;\n                                $copy_v1 = new KickUp(new Two(v1.value0, v1.value1, v1.value2), v.value0.value0, new Two(v.value0.value1, v.value0.value2, v.value0.value3));\n                                return;\n                            };\n                            if (v.value0 instanceof ThreeMiddle) {\n                                $tco_var_v = v.value1;\n                                $copy_v1 = new KickUp(new Two(v.value0.value0, v.value0.value1, v1.value0), v1.value1, new Two(v1.value2, v.value0.value2, v.value0.value3));\n                                return;\n                            };\n                            if (v.value0 instanceof ThreeRight) {\n                                $tco_var_v = v.value1;\n                                $copy_v1 = new KickUp(new Two(v.value0.value0, v.value0.value1, v.value0.value2), v.value0.value3, new Two(v1.value0, v1.value1, v1.value2));\n                                return;\n                            };\n                            throw new Error(\"Failed pattern match at Data.List.Internal (line 58, column 5 - line 63, column 90): \" + [ v.value0.constructor.name, v1.constructor.name ]);\n                        };\n                        throw new Error(\"Failed pattern match at Data.List.Internal (line 55, column 3 - line 55, column 50): \" + [ v.constructor.name, v1.constructor.name ]);\n                    };\n                    while (!$tco_done) {\n                        $tco_result = $tco_loop($tco_var_v, $copy_v1);\n                    };\n                    return $tco_result;\n                };\n            };\n            var down = function ($copy_ctx) {\n                return function ($copy_v) {\n                    var $tco_var_ctx = $copy_ctx;\n                    var $tco_done1 = false;\n                    var $tco_result;\n                    function $tco_loop(ctx, v) {\n                        if (v instanceof Leaf) {\n                            $tco_done1 = true;\n                            return {\n                                found: false,\n                                result: up(ctx)(new KickUp(Leaf.value, k, Leaf.value))\n                            };\n                        };\n                        if (v instanceof Two) {\n                            var v1 = comp(k)(v.value1);\n                            if (v1 instanceof Data_Ordering.EQ) {\n                                $tco_done1 = true;\n                                return {\n                                    found: true,\n                                    result: orig\n                                };\n                            };\n                            if (v1 instanceof Data_Ordering.LT) {\n                                $tco_var_ctx = new Data_List_Types.Cons(new TwoLeft(v.value1, v.value2), ctx);\n                                $copy_v = v.value0;\n                                return;\n                            };\n                            $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(v.value0, v.value1), ctx);\n                            $copy_v = v.value2;\n                            return;\n                        };\n                        if (v instanceof Three) {\n                            var v1 = comp(k)(v.value1);\n                            if (v1 instanceof Data_Ordering.EQ) {\n                                $tco_done1 = true;\n                                return {\n                                    found: true,\n                                    result: orig\n                                };\n                            };\n                            var v2 = comp(k)(v.value3);\n                            if (v2 instanceof Data_Ordering.EQ) {\n                                $tco_done1 = true;\n                                return {\n                                    found: true,\n                                    result: orig\n                                };\n                            };\n                            if (v1 instanceof Data_Ordering.LT) {\n                                $tco_var_ctx = new Data_List_Types.Cons(new ThreeLeft(v.value1, v.value2, v.value3, v.value4), ctx);\n                                $copy_v = v.value0;\n                                return;\n                            };\n                            if (v1 instanceof Data_Ordering.GT && v2 instanceof Data_Ordering.LT) {\n                                $tco_var_ctx = new Data_List_Types.Cons(new ThreeMiddle(v.value0, v.value1, v.value3, v.value4), ctx);\n                                $copy_v = v.value2;\n                                return;\n                            };\n                            $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(v.value0, v.value1, v.value2, v.value3), ctx);\n                            $copy_v = v.value4;\n                            return;\n                        };\n                        throw new Error(\"Failed pattern match at Data.List.Internal (line 38, column 3 - line 38, column 81): \" + [ ctx.constructor.name, v.constructor.name ]);\n                    };\n                    while (!$tco_done1) {\n                        $tco_result = $tco_loop($tco_var_ctx, $copy_v);\n                    };\n                    return $tco_result;\n                };\n            };\n            return down(Data_List_Types.Nil.value)(orig);\n        };\n    };\n};\nvar emptySet = Leaf.value;\nmodule.exports = {\n    emptySet: emptySet,\n    insertAndLookupBy: insertAndLookupBy\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/lists/v6.0.1/src/Data/List/Internal.purs?");

/***/ }),

/***/ "./.spago/lists/v6.0.1/src/Data/List/Lazy.purs":
/*!*****************************************************!*\
  !*** ./.spago/lists/v6.0.1/src/Data/List/Lazy.purs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Lazy = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Lazy.purs */ \"./.spago/control/v5.0.0/src/Control/Lazy.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_Lazy = __webpack_require__(/*! ./.spago/lazy/v5.0.0/src/Data/Lazy.purs */ \"./.spago/lazy/v5.0.0/src/Data/Lazy.purs\");\nvar Data_List_Internal = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Internal.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Internal.purs\");\nvar Data_List_Lazy_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Lazy/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Lazy/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_NonEmpty = __webpack_require__(/*! ./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs */ \"./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar Pattern = function (x) {\n    return x;\n};\nvar zipWith = function (f) {\n    return function (xs) {\n        return function (ys) {\n            var go = function (v) {\n                return function (v1) {\n                    if (v instanceof Data_List_Lazy_Types.Nil) {\n                        return Data_List_Lazy_Types.Nil.value;\n                    };\n                    if (v1 instanceof Data_List_Lazy_Types.Nil) {\n                        return Data_List_Lazy_Types.Nil.value;\n                    };\n                    if (v instanceof Data_List_Lazy_Types.Cons && v1 instanceof Data_List_Lazy_Types.Cons) {\n                        return new Data_List_Lazy_Types.Cons(f(v.value0)(v1.value0), zipWith(f)(v.value1)(v1.value1));\n                    };\n                    throw new Error(\"Failed pattern match at Data.List.Lazy (line 705, column 3 - line 705, column 35): \" + [ v.constructor.name, v1.constructor.name ]);\n                };\n            };\n            return Control_Apply.apply(Data_Lazy.applyLazy)(Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap()(xs)))(Data_Newtype.unwrap()(ys));\n        };\n    };\n};\nvar zipWithA = function (dictApplicative) {\n    return function (f) {\n        return function (xs) {\n            return function (ys) {\n                return Data_Traversable.sequence(Data_List_Lazy_Types.traversableList)(dictApplicative)(zipWith(f)(xs)(ys));\n            };\n        };\n    };\n};\nvar zip = zipWith(Data_Tuple.Tuple.create);\nvar updateAt = function (n) {\n    return function (x) {\n        return function (xs) {\n            var go = function (v) {\n                return function (v1) {\n                    if (v1 instanceof Data_List_Lazy_Types.Nil) {\n                        return Data_List_Lazy_Types.Nil.value;\n                    };\n                    if (v === 0 && v1 instanceof Data_List_Lazy_Types.Cons) {\n                        return new Data_List_Lazy_Types.Cons(x, v1.value1);\n                    };\n                    if (v1 instanceof Data_List_Lazy_Types.Cons) {\n                        return new Data_List_Lazy_Types.Cons(v1.value0, updateAt(v - 1 | 0)(x)(v1.value1));\n                    };\n                    throw new Error(\"Failed pattern match at Data.List.Lazy (line 361, column 3 - line 361, column 17): \" + [ v.constructor.name, v1.constructor.name ]);\n                };\n            };\n            return Data_Functor.map(Data_Lazy.functorLazy)(go(n))(Data_Newtype.unwrap()(xs));\n        };\n    };\n};\nvar unzip = Data_Foldable.foldr(Data_List_Lazy_Types.foldableList)(function (v) {\n    return function (v1) {\n        return new Data_Tuple.Tuple(Data_List_Lazy_Types.cons(v.value0)(v1.value0), Data_List_Lazy_Types.cons(v.value1)(v1.value1));\n    };\n})(new Data_Tuple.Tuple(Data_List_Lazy_Types.nil, Data_List_Lazy_Types.nil));\nvar uncons = function (xs) {\n    var v = Data_List_Lazy_Types.step(xs);\n    if (v instanceof Data_List_Lazy_Types.Nil) {\n        return Data_Maybe.Nothing.value;\n    };\n    if (v instanceof Data_List_Lazy_Types.Cons) {\n        return new Data_Maybe.Just({\n            head: v.value0,\n            tail: v.value1\n        });\n    };\n    throw new Error(\"Failed pattern match at Data.List.Lazy (line 288, column 13 - line 290, column 44): \" + [ v.constructor.name ]);\n};\nvar toUnfoldable = function (dictUnfoldable) {\n    return Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {\n        return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {\n            return new Data_Tuple.Tuple(rec.head, rec.tail);\n        })(uncons(xs));\n    });\n};\nvar takeWhile = function (p) {\n    var go = function (v) {\n        if (v instanceof Data_List_Lazy_Types.Cons && p(v.value0)) {\n            return new Data_List_Lazy_Types.Cons(v.value0, takeWhile(p)(v.value1));\n        };\n        return Data_List_Lazy_Types.Nil.value;\n    };\n    var $251 = Data_Functor.map(Data_Lazy.functorLazy)(go);\n    var $252 = Data_Newtype.unwrap();\n    return function ($253) {\n        return Data_List_Lazy_Types.List($251($252($253)));\n    };\n};\nvar take = function (n) {\n    var go = function (v) {\n        return function (v1) {\n            if (v1 instanceof Data_List_Lazy_Types.Nil) {\n                return Data_List_Lazy_Types.Nil.value;\n            };\n            if (v1 instanceof Data_List_Lazy_Types.Cons) {\n                return new Data_List_Lazy_Types.Cons(v1.value0, take(v - 1 | 0)(v1.value1));\n            };\n            throw new Error(\"Failed pattern match at Data.List.Lazy (line 505, column 3 - line 505, column 32): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    };\n    var $122 = n <= 0;\n    if ($122) {\n        return Data_Function[\"const\"](Data_List_Lazy_Types.nil);\n    };\n    var $254 = Data_Functor.map(Data_Lazy.functorLazy)(go(n));\n    var $255 = Data_Newtype.unwrap();\n    return function ($256) {\n        return Data_List_Lazy_Types.List($254($255($256)));\n    };\n};\nvar tail = function (xs) {\n    return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {\n        return v.tail;\n    })(uncons(xs));\n};\nvar stripPrefix = function (dictEq) {\n    return function (v) {\n        return function (s) {\n            var go = function (prefix) {\n                return function (input) {\n                    var v1 = Data_List_Lazy_Types.step(prefix);\n                    if (v1 instanceof Data_List_Lazy_Types.Nil) {\n                        return Data_Maybe.Just.create(new Control_Monad_Rec_Class.Done(input));\n                    };\n                    if (v1 instanceof Data_List_Lazy_Types.Cons) {\n                        var v2 = Data_List_Lazy_Types.step(input);\n                        if (v2 instanceof Data_List_Lazy_Types.Cons && Data_Eq.eq(dictEq)(v1.value0)(v2.value0)) {\n                            return Data_Maybe.Just.create(new Control_Monad_Rec_Class.Loop({\n                                a: v1.value1,\n                                b: v2.value1\n                            }));\n                        };\n                        return Data_Maybe.Nothing.value;\n                    };\n                    throw new Error(\"Failed pattern match at Data.List.Lazy (line 487, column 21 - line 491, column 19): \" + [ v1.constructor.name ]);\n                };\n            };\n            return Control_Monad_Rec_Class.tailRecM2(Control_Monad_Rec_Class.monadRecMaybe)(go)(v)(s);\n        };\n    };\n};\nvar span = function (p) {\n    return function (xs) {\n        var v = uncons(xs);\n        if (v instanceof Data_Maybe.Just && p(v.value0.head)) {\n            var v1 = span(p)(v.value0.tail);\n            return {\n                init: Data_List_Lazy_Types.cons(v.value0.head)(v1.init),\n                rest: v1.rest\n            };\n        };\n        return {\n            init: Data_List_Lazy_Types.nil,\n            rest: xs\n        };\n    };\n};\nvar snoc = function (xs) {\n    return function (x) {\n        return Data_Foldable.foldr(Data_List_Lazy_Types.foldableList)(Data_List_Lazy_Types.cons)(Data_List_Lazy_Types.cons(x)(Data_List_Lazy_Types.nil))(xs);\n    };\n};\nvar singleton = function (a) {\n    return Data_List_Lazy_Types.cons(a)(Data_List_Lazy_Types.nil);\n};\nvar showPattern = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Pattern \" + (Data_Show.show(Data_List_Lazy_Types.showList(dictShow))(v) + \")\");\n        }\n    };\n};\nvar scanlLazy = function (f) {\n    return function (acc) {\n        return function (xs) {\n            var go = function (v) {\n                if (v instanceof Data_List_Lazy_Types.Nil) {\n                    return Data_List_Lazy_Types.Nil.value;\n                };\n                if (v instanceof Data_List_Lazy_Types.Cons) {\n                    var acc$prime = f(acc)(v.value0);\n                    return Data_List_Lazy_Types.Cons.create(acc$prime)(scanlLazy(f)(acc$prime)(v.value1));\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 776, column 5 - line 776, column 27): \" + [ v.constructor.name ]);\n            };\n            return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap()(xs));\n        };\n    };\n};\nvar reverse = function (xs) {\n    return Control_Lazy.defer(Data_List_Lazy_Types.lazyList)(function (v) {\n        return Data_Foldable.foldl(Data_List_Lazy_Types.foldableList)(Data_Function.flip(Data_List_Lazy_Types.cons))(Data_List_Lazy_Types.nil)(xs);\n    });\n};\nvar replicateM = function (dictMonad) {\n    return function (n) {\n        return function (m) {\n            if (n < 1) {\n                return Control_Applicative.pure(dictMonad.Applicative0())(Data_List_Lazy_Types.nil);\n            };\n            if (Data_Boolean.otherwise) {\n                return Control_Bind.bind(dictMonad.Bind1())(m)(function (a) {\n                    return Control_Bind.bind(dictMonad.Bind1())(replicateM(dictMonad)(n - 1 | 0)(m))(function (as) {\n                        return Control_Applicative.pure(dictMonad.Applicative0())(Data_List_Lazy_Types.cons(a)(as));\n                    });\n                });\n            };\n            throw new Error(\"Failed pattern match at Data.List.Lazy (line 164, column 1 - line 164, column 62): \" + [ n.constructor.name, m.constructor.name ]);\n        };\n    };\n};\nvar repeat = function (x) {\n    return Control_Lazy.fix(Data_List_Lazy_Types.lazyList)(function (xs) {\n        return Data_List_Lazy_Types.cons(x)(xs);\n    });\n};\nvar replicate = function (i) {\n    return function (xs) {\n        return take(i)(repeat(xs));\n    };\n};\nvar range = function (start) {\n    return function (end) {\n        if (start > end) {\n            var g = function (x) {\n                if (x >= end) {\n                    return new Data_Maybe.Just(new Data_Tuple.Tuple(x, x - 1 | 0));\n                };\n                if (Data_Boolean.otherwise) {\n                    return Data_Maybe.Nothing.value;\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 151, column 13 - line 152, column 38): \" + [ x.constructor.name ]);\n            };\n            return Data_Unfoldable.unfoldr(Data_List_Lazy_Types.unfoldableList)(g)(start);\n        };\n        if (Data_Boolean.otherwise) {\n            var f = function (x) {\n                if (x <= end) {\n                    return new Data_Maybe.Just(new Data_Tuple.Tuple(x, x + 1 | 0));\n                };\n                if (Data_Boolean.otherwise) {\n                    return Data_Maybe.Nothing.value;\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 156, column 5 - line 157, column 30): \" + [ x.constructor.name ]);\n            };\n            return Data_Unfoldable.unfoldr(Data_List_Lazy_Types.unfoldableList)(f)(start);\n        };\n        throw new Error(\"Failed pattern match at Data.List.Lazy (line 148, column 1 - line 148, column 32): \" + [ start.constructor.name, end.constructor.name ]);\n    };\n};\nvar partition = function (f) {\n    var go = function (x) {\n        return function (v) {\n            var $150 = f(x);\n            if ($150) {\n                return {\n                    yes: Data_List_Lazy_Types.cons(x)(v.yes),\n                    no: v.no\n                };\n            };\n            return {\n                yes: v.yes,\n                no: Data_List_Lazy_Types.cons(x)(v.no)\n            };\n        };\n    };\n    return Data_Foldable.foldr(Data_List_Lazy_Types.foldableList)(go)({\n        yes: Data_List_Lazy_Types.nil,\n        no: Data_List_Lazy_Types.nil\n    });\n};\nvar $$null = function ($257) {\n    return Data_Maybe.isNothing(uncons($257));\n};\nvar nubBy = function (p) {\n    var goStep = function (v) {\n        return function (v1) {\n            if (v1 instanceof Data_List_Lazy_Types.Nil) {\n                return Data_List_Lazy_Types.Nil.value;\n            };\n            if (v1 instanceof Data_List_Lazy_Types.Cons) {\n                var v2 = Data_List_Internal.insertAndLookupBy(p)(v1.value0)(v);\n                if (v2.found) {\n                    return Data_List_Lazy_Types.step(go(v2.result)(v1.value1));\n                };\n                return new Data_List_Lazy_Types.Cons(v1.value0, go(v2.result)(v1.value1));\n            };\n            throw new Error(\"Failed pattern match at Data.List.Lazy (line 613, column 5 - line 613, column 23): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    };\n    var go = function (s) {\n        return function (v) {\n            return Data_Functor.map(Data_Lazy.functorLazy)(goStep(s))(v);\n        };\n    };\n    return go(Data_List_Internal.emptySet);\n};\nvar nub = function (dictOrd) {\n    return nubBy(Data_Ord.compare(dictOrd));\n};\nvar newtypePattern = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar mapMaybe = function (f) {\n    var go = function ($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n            if (v instanceof Data_List_Lazy_Types.Nil) {\n                $tco_done = true;\n                return Data_List_Lazy_Types.Nil.value;\n            };\n            if (v instanceof Data_List_Lazy_Types.Cons) {\n                var v1 = f(v.value0);\n                if (v1 instanceof Data_Maybe.Nothing) {\n                    $copy_v = Data_List_Lazy_Types.step(v.value1);\n                    return;\n                };\n                if (v1 instanceof Data_Maybe.Just) {\n                    $tco_done = true;\n                    return new Data_List_Lazy_Types.Cons(v1.value0, mapMaybe(f)(v.value1));\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 448, column 5 - line 450, column 39): \" + [ v1.constructor.name ]);\n            };\n            throw new Error(\"Failed pattern match at Data.List.Lazy (line 446, column 3 - line 446, column 15): \" + [ v.constructor.name ]);\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($copy_v);\n        };\n        return $tco_result;\n    };\n    var $258 = Data_Functor.map(Data_Lazy.functorLazy)(go);\n    var $259 = Data_Newtype.unwrap();\n    return function ($260) {\n        return Data_List_Lazy_Types.List($258($259($260)));\n    };\n};\nvar some = function (dictAlternative) {\n    return function (dictLazy) {\n        return function (v) {\n            return Control_Apply.apply((dictAlternative.Applicative0()).Apply0())(Data_Functor.map(((dictAlternative.Plus1()).Alt0()).Functor0())(Data_List_Lazy_Types.cons)(v))(Control_Lazy.defer(dictLazy)(function (v1) {\n                return many(dictAlternative)(dictLazy)(v);\n            }));\n        };\n    };\n};\nvar many = function (dictAlternative) {\n    return function (dictLazy) {\n        return function (v) {\n            return Control_Alt.alt((dictAlternative.Plus1()).Alt0())(some(dictAlternative)(dictLazy)(v))(Control_Applicative.pure(dictAlternative.Applicative0())(Data_List_Lazy_Types.nil));\n        };\n    };\n};\nvar length = Data_Foldable.foldl(Data_List_Lazy_Types.foldableList)(function (l) {\n    return function (v) {\n        return l + 1 | 0;\n    };\n})(0);\nvar last = (function () {\n    var go = function ($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n            if (v instanceof Data_List_Lazy_Types.Cons) {\n                if ($$null(v.value1)) {\n                    $tco_done = true;\n                    return new Data_Maybe.Just(v.value0);\n                };\n                if (Data_Boolean.otherwise) {\n                    $copy_v = Data_List_Lazy_Types.step(v.value1);\n                    return;\n                };\n            };\n            $tco_done = true;\n            return Data_Maybe.Nothing.value;\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($copy_v);\n        };\n        return $tco_result;\n    };\n    return function ($261) {\n        return go(Data_List_Lazy_Types.step($261));\n    };\n})();\nvar iterate = function (f) {\n    return function (x) {\n        return Control_Lazy.fix(Data_List_Lazy_Types.lazyList)(function (xs) {\n            return Data_List_Lazy_Types.cons(x)(Data_Functor.map(Data_List_Lazy_Types.functorList)(f)(xs));\n        });\n    };\n};\nvar insertAt = function (v) {\n    return function (x) {\n        return function (xs) {\n            if (v === 0) {\n                return Data_List_Lazy_Types.cons(x)(xs);\n            };\n            var go = function (v1) {\n                if (v1 instanceof Data_List_Lazy_Types.Nil) {\n                    return new Data_List_Lazy_Types.Cons(x, Data_List_Lazy_Types.nil);\n                };\n                if (v1 instanceof Data_List_Lazy_Types.Cons) {\n                    return new Data_List_Lazy_Types.Cons(v1.value0, insertAt(v - 1 | 0)(x)(v1.value1));\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 340, column 3 - line 340, column 22): \" + [ v1.constructor.name ]);\n            };\n            return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap()(xs));\n        };\n    };\n};\nvar init = (function () {\n    var go = function (v) {\n        if (v instanceof Data_List_Lazy_Types.Cons) {\n            if ($$null(v.value1)) {\n                return new Data_Maybe.Just(Data_List_Lazy_Types.nil);\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Functor.map(Data_Maybe.functorMaybe)(Data_List_Lazy_Types.cons(v.value0))(go(Data_List_Lazy_Types.step(v.value1)));\n            };\n        };\n        return Data_Maybe.Nothing.value;\n    };\n    return function ($262) {\n        return go(Data_List_Lazy_Types.step($262));\n    };\n})();\nvar index = function (xs) {\n    var go = function ($copy_v) {\n        return function ($copy_v1) {\n            var $tco_var_v = $copy_v;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(v, v1) {\n                if (v instanceof Data_List_Lazy_Types.Nil) {\n                    $tco_done = true;\n                    return Data_Maybe.Nothing.value;\n                };\n                if (v instanceof Data_List_Lazy_Types.Cons && v1 === 0) {\n                    $tco_done = true;\n                    return new Data_Maybe.Just(v.value0);\n                };\n                if (v instanceof Data_List_Lazy_Types.Cons) {\n                    $tco_var_v = Data_List_Lazy_Types.step(v.value1);\n                    $copy_v1 = v1 - 1 | 0;\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 302, column 3 - line 302, column 21): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v, $copy_v1);\n            };\n            return $tco_result;\n        };\n    };\n    return go(Data_List_Lazy_Types.step(xs));\n};\nvar head = function (xs) {\n    return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {\n        return v.head;\n    })(uncons(xs));\n};\nvar transpose = function (xs) {\n    var v = uncons(xs);\n    if (v instanceof Data_Maybe.Nothing) {\n        return xs;\n    };\n    if (v instanceof Data_Maybe.Just) {\n        var v1 = uncons(v.value0.head);\n        if (v1 instanceof Data_Maybe.Nothing) {\n            return transpose(v.value0.tail);\n        };\n        if (v1 instanceof Data_Maybe.Just) {\n            return Data_List_Lazy_Types.cons(Data_List_Lazy_Types.cons(v1.value0.head)(mapMaybe(head)(v.value0.tail)))(transpose(Data_List_Lazy_Types.cons(v1.value0.tail)(mapMaybe(tail)(v.value0.tail))));\n        };\n        throw new Error(\"Failed pattern match at Data.List.Lazy (line 746, column 7 - line 750, column 72): \" + [ v1.constructor.name ]);\n    };\n    throw new Error(\"Failed pattern match at Data.List.Lazy (line 742, column 3 - line 750, column 72): \" + [ v.constructor.name ]);\n};\nvar groupBy = function (eq) {\n    var go = function (v) {\n        if (v instanceof Data_List_Lazy_Types.Nil) {\n            return Data_List_Lazy_Types.Nil.value;\n        };\n        if (v instanceof Data_List_Lazy_Types.Cons) {\n            var v1 = span(eq(v.value0))(v.value1);\n            return new Data_List_Lazy_Types.Cons(Data_Lazy.defer(function (v2) {\n                return new Data_NonEmpty.NonEmpty(v.value0, v1.init);\n            }), groupBy(eq)(v1.rest));\n        };\n        throw new Error(\"Failed pattern match at Data.List.Lazy (line 576, column 3 - line 576, column 15): \" + [ v.constructor.name ]);\n    };\n    var $263 = Data_Functor.map(Data_Lazy.functorLazy)(go);\n    var $264 = Data_Newtype.unwrap();\n    return function ($265) {\n        return Data_List_Lazy_Types.List($263($264($265)));\n    };\n};\nvar group = function (dictEq) {\n    return groupBy(Data_Eq.eq(dictEq));\n};\nvar fromStep = (function () {\n    var $266 = Control_Applicative.pure(Data_Lazy.applicativeLazy);\n    return function ($267) {\n        return Data_List_Lazy_Types.List($266($267));\n    };\n})();\nvar insertBy = function (cmp) {\n    return function (x) {\n        return function (xs) {\n            var go = function (v) {\n                if (v instanceof Data_List_Lazy_Types.Nil) {\n                    return new Data_List_Lazy_Types.Cons(x, Data_List_Lazy_Types.nil);\n                };\n                if (v instanceof Data_List_Lazy_Types.Cons) {\n                    var v1 = cmp(x)(v.value0);\n                    if (v1 instanceof Data_Ordering.GT) {\n                        return new Data_List_Lazy_Types.Cons(v.value0, insertBy(cmp)(x)(v.value1));\n                    };\n                    return new Data_List_Lazy_Types.Cons(x, fromStep(v));\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 238, column 3 - line 238, column 22): \" + [ v.constructor.name ]);\n            };\n            return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap()(xs));\n        };\n    };\n};\nvar insert = function (dictOrd) {\n    return insertBy(Data_Ord.compare(dictOrd));\n};\nvar fromFoldable = function (dictFoldable) {\n    return Data_Foldable.foldr(dictFoldable)(Data_List_Lazy_Types.cons)(Data_List_Lazy_Types.nil);\n};\nvar foldrLazy = function (dictLazy) {\n    return function (op) {\n        return function (z) {\n            var go = function (xs) {\n                var v = Data_List_Lazy_Types.step(xs);\n                if (v instanceof Data_List_Lazy_Types.Cons) {\n                    return Control_Lazy.defer(dictLazy)(function (v1) {\n                        return op(v.value0)(go(v.value1));\n                    });\n                };\n                if (v instanceof Data_List_Lazy_Types.Nil) {\n                    return z;\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 768, column 13 - line 770, column 15): \" + [ v.constructor.name ]);\n            };\n            return go;\n        };\n    };\n};\nvar foldM = function (dictMonad) {\n    return function (f) {\n        return function (b) {\n            return function (xs) {\n                var v = uncons(xs);\n                if (v instanceof Data_Maybe.Nothing) {\n                    return Control_Applicative.pure(dictMonad.Applicative0())(b);\n                };\n                if (v instanceof Data_Maybe.Just) {\n                    return Control_Bind.bind(dictMonad.Bind1())(f(b)(v.value0.head))(function (b$prime) {\n                        return foldM(dictMonad)(f)(b$prime)(v.value0.tail);\n                    });\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 759, column 5 - line 762, column 54): \" + [ v.constructor.name ]);\n            };\n        };\n    };\n};\nvar findIndex = function (fn) {\n    var go = function (n) {\n        return function (list) {\n            return Control_Bind.bind(Data_Maybe.bindMaybe)(uncons(list))(function (o) {\n                var $211 = fn(o.head);\n                if ($211) {\n                    return Control_Applicative.pure(Data_Maybe.applicativeMaybe)(n);\n                };\n                return go(n + 1 | 0)(o.tail);\n            });\n        };\n    };\n    return go(0);\n};\nvar findLastIndex = function (fn) {\n    return function (xs) {\n        return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {\n            return (length(xs) - 1 | 0) - v | 0;\n        })(findIndex(fn)(reverse(xs)));\n    };\n};\nvar filterM = function (dictMonad) {\n    return function (p) {\n        return function (list) {\n            var v = uncons(list);\n            if (v instanceof Data_Maybe.Nothing) {\n                return Control_Applicative.pure(dictMonad.Applicative0())(Data_List_Lazy_Types.nil);\n            };\n            if (v instanceof Data_Maybe.Just) {\n                return Control_Bind.bind(dictMonad.Bind1())(p(v.value0.head))(function (b) {\n                    return Control_Bind.bind(dictMonad.Bind1())(filterM(dictMonad)(p)(v.value0.tail))(function (xs$prime) {\n                        return Control_Applicative.pure(dictMonad.Applicative0())((function () {\n                            if (b) {\n                                return Data_List_Lazy_Types.cons(v.value0.head)(xs$prime);\n                            };\n                            return xs$prime;\n                        })());\n                    });\n                });\n            };\n            throw new Error(\"Failed pattern match at Data.List.Lazy (line 431, column 5 - line 436, column 48): \" + [ v.constructor.name ]);\n        };\n    };\n};\nvar filter = function (p) {\n    var go = function ($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n            if (v instanceof Data_List_Lazy_Types.Nil) {\n                $tco_done = true;\n                return Data_List_Lazy_Types.Nil.value;\n            };\n            if (v instanceof Data_List_Lazy_Types.Cons) {\n                if (p(v.value0)) {\n                    $tco_done = true;\n                    return new Data_List_Lazy_Types.Cons(v.value0, filter(p)(v.value1));\n                };\n                if (Data_Boolean.otherwise) {\n                    $copy_v = Data_List_Lazy_Types.step(v.value1);\n                    return;\n                };\n            };\n            throw new Error(\"Failed pattern match at Data.List.Lazy (line 416, column 3 - line 416, column 15): \" + [ v.constructor.name ]);\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($copy_v);\n        };\n        return $tco_result;\n    };\n    var $268 = Data_Functor.map(Data_Lazy.functorLazy)(go);\n    var $269 = Data_Newtype.unwrap();\n    return function ($270) {\n        return Data_List_Lazy_Types.List($268($269($270)));\n    };\n};\nvar intersectBy = function (eq) {\n    return function (xs) {\n        return function (ys) {\n            return filter(function (x) {\n                return Data_Foldable.any(Data_List_Lazy_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(eq(x))(ys);\n            })(xs);\n        };\n    };\n};\nvar intersect = function (dictEq) {\n    return intersectBy(Data_Eq.eq(dictEq));\n};\nvar nubByEq = function (eq) {\n    var go = function (v) {\n        if (v instanceof Data_List_Lazy_Types.Nil) {\n            return Data_List_Lazy_Types.Nil.value;\n        };\n        if (v instanceof Data_List_Lazy_Types.Cons) {\n            return new Data_List_Lazy_Types.Cons(v.value0, nubByEq(eq)(filter(function (y) {\n                return !eq(v.value0)(y);\n            })(v.value1)));\n        };\n        throw new Error(\"Failed pattern match at Data.List.Lazy (line 633, column 3 - line 633, column 15): \" + [ v.constructor.name ]);\n    };\n    var $271 = Data_Functor.map(Data_Lazy.functorLazy)(go);\n    var $272 = Data_Newtype.unwrap();\n    return function ($273) {\n        return Data_List_Lazy_Types.List($271($272($273)));\n    };\n};\nvar nubEq = function (dictEq) {\n    return nubByEq(Data_Eq.eq(dictEq));\n};\nvar eqPattern = function (dictEq) {\n    return {\n        eq: function (x) {\n            return function (y) {\n                return Data_Eq.eq(Data_List_Lazy_Types.eqList(dictEq))(x)(y);\n            };\n        }\n    };\n};\nvar ordPattern = function (dictOrd) {\n    return {\n        compare: function (x) {\n            return function (y) {\n                return Data_Ord.compare(Data_List_Lazy_Types.ordList(dictOrd))(x)(y);\n            };\n        },\n        Eq0: function () {\n            return eqPattern(dictOrd.Eq0());\n        }\n    };\n};\nvar elemLastIndex = function (dictEq) {\n    return function (x) {\n        return findLastIndex(function (v) {\n            return Data_Eq.eq(dictEq)(v)(x);\n        });\n    };\n};\nvar elemIndex = function (dictEq) {\n    return function (x) {\n        return findIndex(function (v) {\n            return Data_Eq.eq(dictEq)(v)(x);\n        });\n    };\n};\nvar dropWhile = function (p) {\n    var go = function ($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n            if (v instanceof Data_List_Lazy_Types.Cons && p(v.value0)) {\n                $copy_v = Data_List_Lazy_Types.step(v.value1);\n                return;\n            };\n            $tco_done = true;\n            return fromStep(v);\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($copy_v);\n        };\n        return $tco_result;\n    };\n    return function ($274) {\n        return go(Data_List_Lazy_Types.step($274));\n    };\n};\nvar drop = function (n) {\n    var go = function ($copy_v) {\n        return function ($copy_v1) {\n            var $tco_var_v = $copy_v;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(v, v1) {\n                if (v === 0) {\n                    $tco_done = true;\n                    return v1;\n                };\n                if (v1 instanceof Data_List_Lazy_Types.Nil) {\n                    $tco_done = true;\n                    return Data_List_Lazy_Types.Nil.value;\n                };\n                if (v1 instanceof Data_List_Lazy_Types.Cons) {\n                    $tco_var_v = v - 1 | 0;\n                    $copy_v1 = Data_List_Lazy_Types.step(v1.value1);\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 524, column 3 - line 524, column 15): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v, $copy_v1);\n            };\n            return $tco_result;\n        };\n    };\n    var $275 = Data_Functor.map(Data_Lazy.functorLazy)(go(n));\n    var $276 = Data_Newtype.unwrap();\n    return function ($277) {\n        return Data_List_Lazy_Types.List($275($276($277)));\n    };\n};\nvar slice = function (start) {\n    return function (end) {\n        return function (xs) {\n            return take(end - start | 0)(drop(start)(xs));\n        };\n    };\n};\nvar deleteBy = function (eq) {\n    return function (x) {\n        return function (xs) {\n            var go = function (v) {\n                if (v instanceof Data_List_Lazy_Types.Nil) {\n                    return Data_List_Lazy_Types.Nil.value;\n                };\n                if (v instanceof Data_List_Lazy_Types.Cons) {\n                    if (eq(x)(v.value0)) {\n                        return Data_List_Lazy_Types.step(v.value1);\n                    };\n                    if (Data_Boolean.otherwise) {\n                        return new Data_List_Lazy_Types.Cons(v.value0, deleteBy(eq)(x)(v.value1));\n                    };\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 662, column 3 - line 662, column 15): \" + [ v.constructor.name ]);\n            };\n            return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap()(xs));\n        };\n    };\n};\nvar unionBy = function (eq) {\n    return function (xs) {\n        return function (ys) {\n            return Data_Semigroup.append(Data_List_Lazy_Types.semigroupList)(xs)(Data_Foldable.foldl(Data_List_Lazy_Types.foldableList)(Data_Function.flip(deleteBy(eq)))(nubByEq(eq)(ys))(xs));\n        };\n    };\n};\nvar union = function (dictEq) {\n    return unionBy(Data_Eq.eq(dictEq));\n};\nvar deleteAt = function (n) {\n    return function (xs) {\n        var go = function (v) {\n            return function (v1) {\n                if (v1 instanceof Data_List_Lazy_Types.Nil) {\n                    return Data_List_Lazy_Types.Nil.value;\n                };\n                if (v === 0 && v1 instanceof Data_List_Lazy_Types.Cons) {\n                    return Data_List_Lazy_Types.step(v1.value1);\n                };\n                if (v1 instanceof Data_List_Lazy_Types.Cons) {\n                    return new Data_List_Lazy_Types.Cons(v1.value0, deleteAt(v - 1 | 0)(v1.value1));\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy (line 350, column 3 - line 350, column 17): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n        return Data_Functor.map(Data_Lazy.functorLazy)(go(n))(Data_Newtype.unwrap()(xs));\n    };\n};\nvar $$delete = function (dictEq) {\n    return deleteBy(Data_Eq.eq(dictEq));\n};\nvar difference = function (dictEq) {\n    return Data_Foldable.foldl(Data_List_Lazy_Types.foldableList)(Data_Function.flip($$delete(dictEq)));\n};\nvar cycle = function (xs) {\n    return Control_Lazy.fix(Data_List_Lazy_Types.lazyList)(function (ys) {\n        return Data_Semigroup.append(Data_List_Lazy_Types.semigroupList)(xs)(ys);\n    });\n};\nvar concatMap = Data_Function.flip(Control_Bind.bind(Data_List_Lazy_Types.bindList));\nvar concat = function (v) {\n    return Control_Bind.bind(Data_List_Lazy_Types.bindList)(v)(Control_Category.identity(Control_Category.categoryFn));\n};\nvar catMaybes = mapMaybe(Control_Category.identity(Control_Category.categoryFn));\nvar alterAt = function (n) {\n    return function (f) {\n        return function (xs) {\n            var go = function (v) {\n                return function (v1) {\n                    if (v1 instanceof Data_List_Lazy_Types.Nil) {\n                        return Data_List_Lazy_Types.Nil.value;\n                    };\n                    if (v === 0 && v1 instanceof Data_List_Lazy_Types.Cons) {\n                        var v2 = f(v1.value0);\n                        if (v2 instanceof Data_Maybe.Nothing) {\n                            return Data_List_Lazy_Types.step(v1.value1);\n                        };\n                        if (v2 instanceof Data_Maybe.Just) {\n                            return new Data_List_Lazy_Types.Cons(v2.value0, v1.value1);\n                        };\n                        throw new Error(\"Failed pattern match at Data.List.Lazy (line 382, column 22 - line 384, column 26): \" + [ v2.constructor.name ]);\n                    };\n                    if (v1 instanceof Data_List_Lazy_Types.Cons) {\n                        return new Data_List_Lazy_Types.Cons(v1.value0, alterAt(v - 1 | 0)(f)(v1.value1));\n                    };\n                    throw new Error(\"Failed pattern match at Data.List.Lazy (line 381, column 3 - line 381, column 17): \" + [ v.constructor.name, v1.constructor.name ]);\n                };\n            };\n            return Data_Functor.map(Data_Lazy.functorLazy)(go(n))(Data_Newtype.unwrap()(xs));\n        };\n    };\n};\nvar modifyAt = function (n) {\n    return function (f) {\n        return alterAt(n)(function ($278) {\n            return Data_Maybe.Just.create(f($278));\n        });\n    };\n};\nmodule.exports = {\n    toUnfoldable: toUnfoldable,\n    fromFoldable: fromFoldable,\n    singleton: singleton,\n    range: range,\n    replicate: replicate,\n    replicateM: replicateM,\n    some: some,\n    many: many,\n    repeat: repeat,\n    iterate: iterate,\n    cycle: cycle,\n    \"null\": $$null,\n    length: length,\n    snoc: snoc,\n    insert: insert,\n    insertBy: insertBy,\n    head: head,\n    last: last,\n    tail: tail,\n    init: init,\n    uncons: uncons,\n    index: index,\n    elemIndex: elemIndex,\n    elemLastIndex: elemLastIndex,\n    findIndex: findIndex,\n    findLastIndex: findLastIndex,\n    insertAt: insertAt,\n    deleteAt: deleteAt,\n    updateAt: updateAt,\n    modifyAt: modifyAt,\n    alterAt: alterAt,\n    reverse: reverse,\n    concat: concat,\n    concatMap: concatMap,\n    filter: filter,\n    filterM: filterM,\n    mapMaybe: mapMaybe,\n    catMaybes: catMaybes,\n    Pattern: Pattern,\n    stripPrefix: stripPrefix,\n    slice: slice,\n    take: take,\n    takeWhile: takeWhile,\n    drop: drop,\n    dropWhile: dropWhile,\n    span: span,\n    group: group,\n    groupBy: groupBy,\n    partition: partition,\n    nub: nub,\n    nubBy: nubBy,\n    nubEq: nubEq,\n    nubByEq: nubByEq,\n    union: union,\n    unionBy: unionBy,\n    \"delete\": $$delete,\n    deleteBy: deleteBy,\n    difference: difference,\n    intersect: intersect,\n    intersectBy: intersectBy,\n    zipWith: zipWith,\n    zipWithA: zipWithA,\n    zip: zip,\n    unzip: unzip,\n    transpose: transpose,\n    foldM: foldM,\n    foldrLazy: foldrLazy,\n    scanlLazy: scanlLazy,\n    eqPattern: eqPattern,\n    ordPattern: ordPattern,\n    newtypePattern: newtypePattern,\n    showPattern: showPattern,\n    all: Data_Foldable.all,\n    any: Data_Foldable.any,\n    elem: Data_Foldable.elem,\n    find: Data_Foldable.find,\n    findMap: Data_Foldable.findMap,\n    fold: Data_Foldable.fold,\n    foldMap: Data_Foldable.foldMap,\n    foldl: Data_Foldable.foldl,\n    foldr: Data_Foldable.foldr,\n    intercalate: Data_Foldable.intercalate,\n    notElem: Data_Foldable.notElem,\n    List: Data_List_Lazy_Types.List,\n    Cons: Data_List_Lazy_Types.Cons,\n    Nil: Data_List_Lazy_Types.Nil,\n    cons: Data_List_Lazy_Types.cons,\n    nil: Data_List_Lazy_Types.nil,\n    step: Data_List_Lazy_Types.step,\n    scanl: Data_Traversable.scanl,\n    scanr: Data_Traversable.scanr\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/lists/v6.0.1/src/Data/List/Lazy.purs?");

/***/ }),

/***/ "./.spago/lists/v6.0.1/src/Data/List/Lazy/Types.purs":
/*!***********************************************************!*\
  !*** ./.spago/lists/v6.0.1/src/Data/List/Lazy/Types.purs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Lazy = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Lazy.purs */ \"./.spago/control/v5.0.0/src/Control/Lazy.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_FoldableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_FunctorWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs\");\nvar Data_Lazy = __webpack_require__(/*! ./.spago/lazy/v5.0.0/src/Data/Lazy.purs */ \"./.spago/lazy/v5.0.0/src/Data/Lazy.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_NonEmpty = __webpack_require__(/*! ./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs */ \"./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_TraversableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable1 = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs\");\nvar List = function (x) {\n    return x;\n};\nvar Nil = (function () {\n    function Nil() {\n\n    };\n    Nil.value = new Nil();\n    return Nil;\n})();\nvar Cons = (function () {\n    function Cons(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    Cons.create = function (value0) {\n        return function (value1) {\n            return new Cons(value0, value1);\n        };\n    };\n    return Cons;\n})();\nvar NonEmptyList = function (x) {\n    return x;\n};\nvar nil = List(Data_Lazy.defer(function (v) {\n    return Nil.value;\n}));\nvar newtypeNonEmptyList = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar newtypeList = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar step = (function () {\n    var $225 = Data_Newtype.unwrap();\n    return function ($226) {\n        return Data_Lazy.force($225($226));\n    };\n})();\nvar semigroupList = {\n    append: function (xs) {\n        return function (ys) {\n            var go = function (v) {\n                if (v instanceof Nil) {\n                    return step(ys);\n                };\n                if (v instanceof Cons) {\n                    return new Cons(v.value0, Data_Semigroup.append(semigroupList)(v.value1)(ys));\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy.Types (line 104, column 5 - line 104, column 21): \" + [ v.constructor.name ]);\n            };\n            return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap()(xs));\n        };\n    }\n};\nvar monoidList = {\n    mempty: nil,\n    Semigroup0: function () {\n        return semigroupList;\n    }\n};\nvar lazyList = {\n    defer: function (f) {\n        return List(Data_Lazy.defer(function ($227) {\n            return step(f($227));\n        }));\n    }\n};\nvar functorList = {\n    map: function (f) {\n        return function (xs) {\n            var go = function (v) {\n                if (v instanceof Nil) {\n                    return Nil.value;\n                };\n                if (v instanceof Cons) {\n                    return new Cons(f(v.value0), Data_Functor.map(functorList)(f)(v.value1));\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy.Types (line 113, column 5 - line 113, column 17): \" + [ v.constructor.name ]);\n            };\n            return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap()(xs));\n        };\n    }\n};\nvar functorNonEmptyList = {\n    map: function (f) {\n        return function (v) {\n            return Data_Functor.map(Data_Lazy.functorLazy)(Data_Functor.map(Data_NonEmpty.functorNonEmpty(functorList))(f))(v);\n        };\n    }\n};\nvar eq1List = {\n    eq1: function (dictEq) {\n        return function (xs) {\n            return function (ys) {\n                var go = function ($copy_v) {\n                    return function ($copy_v1) {\n                        var $tco_var_v = $copy_v;\n                        var $tco_done = false;\n                        var $tco_result;\n                        function $tco_loop(v, v1) {\n                            if (v instanceof Nil && v1 instanceof Nil) {\n                                $tco_done = true;\n                                return true;\n                            };\n                            if (v instanceof Cons && (v1 instanceof Cons && Data_Eq.eq(dictEq)(v.value0)(v1.value0))) {\n                                $tco_var_v = step(v.value1);\n                                $copy_v1 = step(v1.value1);\n                                return;\n                            };\n                            $tco_done = true;\n                            return false;\n                        };\n                        while (!$tco_done) {\n                            $tco_result = $tco_loop($tco_var_v, $copy_v1);\n                        };\n                        return $tco_result;\n                    };\n                };\n                return go(step(xs))(step(ys));\n            };\n        };\n    }\n};\nvar eq1NonEmptyList = {\n    eq1: function (dictEq) {\n        return function (v) {\n            return function (v1) {\n                return Data_Eq.eq1(Data_Lazy.eq1Lazy)(Data_NonEmpty.eqNonEmpty(eq1List)(dictEq))(v)(v1);\n            };\n        };\n    }\n};\nvar eqList = function (dictEq) {\n    return {\n        eq: Data_Eq.eq1(eq1List)(dictEq)\n    };\n};\nvar eqNonEmptyList = function (dictEq) {\n    return Data_Lazy.eqLazy(Data_NonEmpty.eqNonEmpty(eq1List)(dictEq));\n};\nvar ord1List = {\n    compare1: function (dictOrd) {\n        return function (xs) {\n            return function (ys) {\n                var go = function ($copy_v) {\n                    return function ($copy_v1) {\n                        var $tco_var_v = $copy_v;\n                        var $tco_done = false;\n                        var $tco_result;\n                        function $tco_loop(v, v1) {\n                            if (v instanceof Nil && v1 instanceof Nil) {\n                                $tco_done = true;\n                                return Data_Ordering.EQ.value;\n                            };\n                            if (v instanceof Nil) {\n                                $tco_done = true;\n                                return Data_Ordering.LT.value;\n                            };\n                            if (v1 instanceof Nil) {\n                                $tco_done = true;\n                                return Data_Ordering.GT.value;\n                            };\n                            if (v instanceof Cons && v1 instanceof Cons) {\n                                var v2 = Data_Ord.compare(dictOrd)(v.value0)(v1.value0);\n                                if (v2 instanceof Data_Ordering.EQ) {\n                                    $tco_var_v = step(v.value1);\n                                    $copy_v1 = step(v1.value1);\n                                    return;\n                                };\n                                $tco_done = true;\n                                return v2;\n                            };\n                            throw new Error(\"Failed pattern match at Data.List.Lazy.Types (line 90, column 5 - line 90, column 20): \" + [ v.constructor.name, v1.constructor.name ]);\n                        };\n                        while (!$tco_done) {\n                            $tco_result = $tco_loop($tco_var_v, $copy_v1);\n                        };\n                        return $tco_result;\n                    };\n                };\n                return go(step(xs))(step(ys));\n            };\n        };\n    },\n    Eq10: function () {\n        return eq1List;\n    }\n};\nvar ord1NonEmptyList = {\n    compare1: function (dictOrd) {\n        return function (v) {\n            return function (v1) {\n                return Data_Ord.compare1(Data_Lazy.ord1Lazy)(Data_NonEmpty.ordNonEmpty(ord1List)(dictOrd))(v)(v1);\n            };\n        };\n    },\n    Eq10: function () {\n        return eq1NonEmptyList;\n    }\n};\nvar ordList = function (dictOrd) {\n    return {\n        compare: Data_Ord.compare1(ord1List)(dictOrd),\n        Eq0: function () {\n            return eqList(dictOrd.Eq0());\n        }\n    };\n};\nvar ordNonEmptyList = function (dictOrd) {\n    return Data_Lazy.ordLazy(Data_NonEmpty.ordNonEmpty(ord1List)(dictOrd));\n};\nvar cons = function (x) {\n    return function (xs) {\n        return List(Data_Lazy.defer(function (v) {\n            return new Cons(x, xs);\n        }));\n    };\n};\nvar foldableList = {\n    foldr: function (op) {\n        return function (z) {\n            return function (xs) {\n                var rev = Data_Foldable.foldl(foldableList)(Data_Function.flip(cons))(nil);\n                return Data_Foldable.foldl(foldableList)(Data_Function.flip(op))(z)(rev(xs));\n            };\n        };\n    },\n    foldl: function (op) {\n        var go = function ($copy_b) {\n            return function ($copy_xs) {\n                var $tco_var_b = $copy_b;\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(b, xs) {\n                    var v = step(xs);\n                    if (v instanceof Nil) {\n                        $tco_done = true;\n                        return b;\n                    };\n                    if (v instanceof Cons) {\n                        $tco_var_b = op(b)(v.value0);\n                        $copy_xs = v.value1;\n                        return;\n                    };\n                    throw new Error(\"Failed pattern match at Data.List.Lazy.Types (line 128, column 7 - line 130, column 40): \" + [ v.constructor.name ]);\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($tco_var_b, $copy_xs);\n                };\n                return $tco_result;\n            };\n        };\n        return go;\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldl(foldableList)(function (b) {\n                return function (a) {\n                    return Data_Semigroup.append(dictMonoid.Semigroup0())(b)(f(a));\n                };\n            })(Data_Monoid.mempty(dictMonoid));\n        };\n    }\n};\nvar extendList = {\n    extend: function (f) {\n        return function (l) {\n            var go = function (a) {\n                return function (v) {\n                    var acc$prime = cons(a)(v.acc);\n                    return {\n                        val: cons(f(acc$prime))(v.val),\n                        acc: acc$prime\n                    };\n                };\n            };\n            var v = step(l);\n            if (v instanceof Nil) {\n                return nil;\n            };\n            if (v instanceof Cons) {\n                return cons(f(l))((Data_Foldable.foldr(foldableList)(go)({\n                    val: nil,\n                    acc: nil\n                })(v.value1)).val);\n            };\n            throw new Error(\"Failed pattern match at Data.List.Lazy.Types (line 200, column 5 - line 203, column 55): \" + [ v.constructor.name ]);\n        };\n    },\n    Functor0: function () {\n        return functorList;\n    }\n};\nvar extendNonEmptyList = {\n    extend: function (f) {\n        return function (v) {\n            var go = function (a) {\n                return function (v1) {\n                    return {\n                        val: cons(f(Data_Lazy.defer(function (v2) {\n                            return new Data_NonEmpty.NonEmpty(a, v1.acc);\n                        })))(v1.val),\n                        acc: cons(a)(v1.acc)\n                    };\n                };\n            };\n            var v1 = Data_Lazy.force(v);\n            return NonEmptyList(Data_Lazy.defer(function (v2) {\n                return new Data_NonEmpty.NonEmpty(f(v), (Data_Foldable.foldr(foldableList)(go)({\n                    val: nil,\n                    acc: nil\n                })(v1.value1)).val);\n            }));\n        };\n    },\n    Functor0: function () {\n        return functorNonEmptyList;\n    }\n};\nvar foldableNonEmptyList = {\n    foldr: function (f) {\n        return function (b) {\n            return function (v) {\n                return Data_Foldable.foldr(Data_NonEmpty.foldableNonEmpty(foldableList))(f)(b)(Data_Lazy.force(v));\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (b) {\n            return function (v) {\n                return Data_Foldable.foldl(Data_NonEmpty.foldableNonEmpty(foldableList))(f)(b)(Data_Lazy.force(v));\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return Data_Foldable.foldMap(Data_NonEmpty.foldableNonEmpty(foldableList))(dictMonoid)(f)(Data_Lazy.force(v));\n            };\n        };\n    }\n};\nvar showList = function (dictShow) {\n    return {\n        show: function (xs) {\n            return \"(fromFoldable [\" + ((function () {\n                var v = step(xs);\n                if (v instanceof Nil) {\n                    return \"\";\n                };\n                if (v instanceof Cons) {\n                    return Data_Show.show(dictShow)(v.value0) + Data_Foldable.foldl(foldableList)(function (shown) {\n                        return function (x$prime) {\n                            return shown + (\",\" + Data_Show.show(dictShow)(x$prime));\n                        };\n                    })(\"\")(v.value1);\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy.Types (line 67, column 13 - line 70, column 78): \" + [ v.constructor.name ]);\n            })() + \"])\");\n        }\n    };\n};\nvar showNonEmptyList = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(NonEmptyList \" + (Data_Show.show(Data_Lazy.showLazy(Data_NonEmpty.showNonEmpty(dictShow)(showList(dictShow))))(v) + \")\");\n        }\n    };\n};\nvar showStep = function (dictShow) {\n    return {\n        show: function (v) {\n            if (v instanceof Nil) {\n                return \"Nil\";\n            };\n            if (v instanceof Cons) {\n                return \"(\" + (Data_Show.show(dictShow)(v.value0) + (\" : \" + (Data_Show.show(showList(dictShow))(v.value1) + \")\")));\n            };\n            throw new Error(\"Failed pattern match at Data.List.Lazy.Types (line 37, column 1 - line 39, column 62): \" + [ v.constructor.name ]);\n        }\n    };\n};\nvar foldableWithIndexList = {\n    foldrWithIndex: function (f) {\n        return function (b) {\n            return function (xs) {\n                var v = (function () {\n                    var rev = Data_Foldable.foldl(foldableList)(function (v1) {\n                        return function (a) {\n                            return new Data_Tuple.Tuple(v1.value0 + 1 | 0, cons(a)(v1.value1));\n                        };\n                    });\n                    return rev(new Data_Tuple.Tuple(0, nil))(xs);\n                })();\n                return Data_Tuple.snd(Data_Foldable.foldl(foldableList)(function (v1) {\n                    return function (a) {\n                        return new Data_Tuple.Tuple(v1.value0 - 1 | 0, f(v1.value0 - 1 | 0)(a)(v1.value1));\n                    };\n                })(new Data_Tuple.Tuple(v.value0, b))(v.value1));\n            };\n        };\n    },\n    foldlWithIndex: function (f) {\n        return function (acc) {\n            var $228 = Data_Foldable.foldl(foldableList)(function (v) {\n                return function (a) {\n                    return new Data_Tuple.Tuple(v.value0 + 1 | 0, f(v.value0)(v.value1)(a));\n                };\n            })(new Data_Tuple.Tuple(0, acc));\n            return function ($229) {\n                return Data_Tuple.snd($228($229));\n            };\n        };\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_FoldableWithIndex.foldlWithIndex(foldableWithIndexList)(function (i) {\n                return function (acc) {\n                    var $230 = Data_Semigroup.append(dictMonoid.Semigroup0())(acc);\n                    var $231 = f(i);\n                    return function ($232) {\n                        return $230($231($232));\n                    };\n                };\n            })(Data_Monoid.mempty(dictMonoid));\n        };\n    },\n    Foldable0: function () {\n        return foldableList;\n    }\n};\nvar foldableWithIndexNonEmptyList = {\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return Data_FoldableWithIndex.foldMapWithIndex(Data_NonEmpty.foldableWithIndexNonEmpty(foldableWithIndexList))(dictMonoid)((function () {\n                    var $233 = Data_Maybe.maybe(0)(Data_Semiring.add(Data_Semiring.semiringInt)(1));\n                    return function ($234) {\n                        return f($233($234));\n                    };\n                })())(Data_Lazy.force(v));\n            };\n        };\n    },\n    foldlWithIndex: function (f) {\n        return function (b) {\n            return function (v) {\n                return Data_FoldableWithIndex.foldlWithIndex(Data_NonEmpty.foldableWithIndexNonEmpty(foldableWithIndexList))((function () {\n                    var $235 = Data_Maybe.maybe(0)(Data_Semiring.add(Data_Semiring.semiringInt)(1));\n                    return function ($236) {\n                        return f($235($236));\n                    };\n                })())(b)(Data_Lazy.force(v));\n            };\n        };\n    },\n    foldrWithIndex: function (f) {\n        return function (b) {\n            return function (v) {\n                return Data_FoldableWithIndex.foldrWithIndex(Data_NonEmpty.foldableWithIndexNonEmpty(foldableWithIndexList))((function () {\n                    var $237 = Data_Maybe.maybe(0)(Data_Semiring.add(Data_Semiring.semiringInt)(1));\n                    return function ($238) {\n                        return f($237($238));\n                    };\n                })())(b)(Data_Lazy.force(v));\n            };\n        };\n    },\n    Foldable0: function () {\n        return foldableNonEmptyList;\n    }\n};\nvar functorWithIndexList = {\n    mapWithIndex: function (f) {\n        return Data_FoldableWithIndex.foldrWithIndex(foldableWithIndexList)(function (i) {\n            return function (x) {\n                return function (acc) {\n                    return cons(f(i)(x))(acc);\n                };\n            };\n        })(nil);\n    },\n    Functor0: function () {\n        return functorList;\n    }\n};\nvar functorWithIndexNonEmptyList = {\n    mapWithIndex: function (f) {\n        return function (v) {\n            return NonEmptyList(Data_Lazy.defer(function (v1) {\n                return Data_FunctorWithIndex.mapWithIndex(Data_NonEmpty.functorWithIndex(functorWithIndexList))((function () {\n                    var $239 = Data_Maybe.maybe(0)(Data_Semiring.add(Data_Semiring.semiringInt)(1));\n                    return function ($240) {\n                        return f($239($240));\n                    };\n                })())(Data_Lazy.force(v));\n            }));\n        };\n    },\n    Functor0: function () {\n        return functorNonEmptyList;\n    }\n};\nvar toList = function (v) {\n    return Control_Lazy.defer(lazyList)(function (v1) {\n        var v2 = Data_Lazy.force(v);\n        return cons(v2.value0)(v2.value1);\n    });\n};\nvar semigroupNonEmptyList = {\n    append: function (v) {\n        return function (as$prime) {\n            var v1 = Data_Lazy.force(v);\n            return Data_Lazy.defer(function (v2) {\n                return new Data_NonEmpty.NonEmpty(v1.value0, Data_Semigroup.append(semigroupList)(v1.value1)(toList(as$prime)));\n            });\n        };\n    }\n};\nvar traversableList = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return Data_Foldable.foldr(foldableList)(function (a) {\n                return function (b) {\n                    return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(cons)(f(a)))(b);\n                };\n            })(Control_Applicative.pure(dictApplicative)(nil));\n        };\n    },\n    sequence: function (dictApplicative) {\n        return Data_Traversable.traverse(traversableList)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));\n    },\n    Functor0: function () {\n        return functorList;\n    },\n    Foldable1: function () {\n        return foldableList;\n    }\n};\nvar traversableNonEmptyList = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(function (xxs) {\n                    return NonEmptyList(Data_Lazy.defer(function (v1) {\n                        return xxs;\n                    }));\n                })(Data_Traversable.traverse(Data_NonEmpty.traversableNonEmpty(traversableList))(dictApplicative)(f)(Data_Lazy.force(v)));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return function (v) {\n            return Data_Functor.map((dictApplicative.Apply0()).Functor0())(function (xxs) {\n                return NonEmptyList(Data_Lazy.defer(function (v1) {\n                    return xxs;\n                }));\n            })(Data_Traversable.sequence(Data_NonEmpty.traversableNonEmpty(traversableList))(dictApplicative)(Data_Lazy.force(v)));\n        };\n    },\n    Functor0: function () {\n        return functorNonEmptyList;\n    },\n    Foldable1: function () {\n        return foldableNonEmptyList;\n    }\n};\nvar traversableWithIndexList = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return Data_FoldableWithIndex.foldrWithIndex(foldableWithIndexList)(function (i) {\n                return function (a) {\n                    return function (b) {\n                        return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(cons)(f(i)(a)))(b);\n                    };\n                };\n            })(Control_Applicative.pure(dictApplicative)(nil));\n        };\n    },\n    FunctorWithIndex0: function () {\n        return functorWithIndexList;\n    },\n    FoldableWithIndex1: function () {\n        return foldableWithIndexList;\n    },\n    Traversable2: function () {\n        return traversableList;\n    }\n};\nvar traversableWithIndexNonEmptyList = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(function (xxs) {\n                    return NonEmptyList(Data_Lazy.defer(function (v1) {\n                        return xxs;\n                    }));\n                })(Data_TraversableWithIndex.traverseWithIndex(Data_NonEmpty.traversableWithIndexNonEmpty(traversableWithIndexList))(dictApplicative)((function () {\n                    var $241 = Data_Maybe.maybe(0)(Data_Semiring.add(Data_Semiring.semiringInt)(1));\n                    return function ($242) {\n                        return f($241($242));\n                    };\n                })())(Data_Lazy.force(v)));\n            };\n        };\n    },\n    FunctorWithIndex0: function () {\n        return functorWithIndexNonEmptyList;\n    },\n    FoldableWithIndex1: function () {\n        return foldableWithIndexNonEmptyList;\n    },\n    Traversable2: function () {\n        return traversableNonEmptyList;\n    }\n};\nvar unfoldable1List = {\n    unfoldr1: (function () {\n        var go = function (f) {\n            return function (b) {\n                return Control_Lazy.defer(lazyList)(function (v) {\n                    var v1 = f(b);\n                    if (v1.value1 instanceof Data_Maybe.Just) {\n                        return cons(v1.value0)(go(f)(v1.value1.value0));\n                    };\n                    if (v1.value1 instanceof Data_Maybe.Nothing) {\n                        return cons(v1.value0)(nil);\n                    };\n                    throw new Error(\"Failed pattern match at Data.List.Lazy.Types (line 152, column 28 - line 154, column 33): \" + [ v1.constructor.name ]);\n                });\n            };\n        };\n        return go;\n    })()\n};\nvar unfoldableList = {\n    unfoldr: (function () {\n        var go = function (f) {\n            return function (b) {\n                return Control_Lazy.defer(lazyList)(function (v) {\n                    var v1 = f(b);\n                    if (v1 instanceof Data_Maybe.Nothing) {\n                        return nil;\n                    };\n                    if (v1 instanceof Data_Maybe.Just) {\n                        return cons(v1.value0.value0)(go(f)(v1.value0.value1));\n                    };\n                    throw new Error(\"Failed pattern match at Data.List.Lazy.Types (line 158, column 28 - line 160, column 39): \" + [ v1.constructor.name ]);\n                });\n            };\n        };\n        return go;\n    })(),\n    Unfoldable10: function () {\n        return unfoldable1List;\n    }\n};\nvar unfoldable1NonEmptyList = {\n    unfoldr1: function (f) {\n        return function (b) {\n            return NonEmptyList(Data_Lazy.defer(function (v) {\n                return Data_Unfoldable1.unfoldr1(Data_NonEmpty.unfoldable1NonEmpty(unfoldableList))(f)(b);\n            }));\n        };\n    }\n};\nvar comonadNonEmptyList = {\n    extract: function (v) {\n        return Data_NonEmpty.head(Data_Lazy.force(v));\n    },\n    Extend0: function () {\n        return extendNonEmptyList;\n    }\n};\nvar monadList = {\n    Applicative0: function () {\n        return applicativeList;\n    },\n    Bind1: function () {\n        return bindList;\n    }\n};\nvar bindList = {\n    bind: function (xs) {\n        return function (f) {\n            var go = function (v) {\n                if (v instanceof Nil) {\n                    return Nil.value;\n                };\n                if (v instanceof Cons) {\n                    return step(Data_Semigroup.append(semigroupList)(f(v.value0))(Control_Bind.bind(bindList)(v.value1)(f)));\n                };\n                throw new Error(\"Failed pattern match at Data.List.Lazy.Types (line 181, column 5 - line 181, column 17): \" + [ v.constructor.name ]);\n            };\n            return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap()(xs));\n        };\n    },\n    Apply0: function () {\n        return applyList;\n    }\n};\nvar applyList = {\n    apply: Control_Monad.ap(monadList),\n    Functor0: function () {\n        return functorList;\n    }\n};\nvar applicativeList = {\n    pure: function (a) {\n        return cons(a)(nil);\n    },\n    Apply0: function () {\n        return applyList;\n    }\n};\nvar applyNonEmptyList = {\n    apply: function (v) {\n        return function (v1) {\n            var v2 = Data_Lazy.force(v1);\n            var v3 = Data_Lazy.force(v);\n            return Data_Lazy.defer(function (v4) {\n                return new Data_NonEmpty.NonEmpty(v3.value0(v2.value0), Data_Semigroup.append(semigroupList)(Control_Apply.apply(applyList)(v3.value1)(cons(v2.value0)(nil)))(Control_Apply.apply(applyList)(cons(v3.value0)(v3.value1))(v2.value1)));\n            });\n        };\n    },\n    Functor0: function () {\n        return functorNonEmptyList;\n    }\n};\nvar bindNonEmptyList = {\n    bind: function (v) {\n        return function (f) {\n            var v1 = Data_Lazy.force(v);\n            var v2 = Data_Lazy.force(Data_Newtype.unwrap()(f(v1.value0)));\n            return Data_Lazy.defer(function (v3) {\n                return new Data_NonEmpty.NonEmpty(v2.value0, Data_Semigroup.append(semigroupList)(v2.value1)(Control_Bind.bind(bindList)(v1.value1)(function ($243) {\n                    return toList(f($243));\n                })));\n            });\n        };\n    },\n    Apply0: function () {\n        return applyNonEmptyList;\n    }\n};\nvar altNonEmptyList = {\n    alt: Data_Semigroup.append(semigroupNonEmptyList),\n    Functor0: function () {\n        return functorNonEmptyList;\n    }\n};\nvar altList = {\n    alt: Data_Semigroup.append(semigroupList),\n    Functor0: function () {\n        return functorList;\n    }\n};\nvar plusList = {\n    empty: nil,\n    Alt0: function () {\n        return altList;\n    }\n};\nvar alternativeList = {\n    Applicative0: function () {\n        return applicativeList;\n    },\n    Plus1: function () {\n        return plusList;\n    }\n};\nvar monadPlusList = {\n    Monad0: function () {\n        return monadList;\n    },\n    Alternative1: function () {\n        return alternativeList;\n    }\n};\nvar monadZeroList = {\n    Monad0: function () {\n        return monadList;\n    },\n    Alternative1: function () {\n        return alternativeList;\n    },\n    MonadZeroIsDeprecated2: function () {\n        return undefined;\n    }\n};\nvar applicativeNonEmptyList = {\n    pure: function (a) {\n        return Data_Lazy.defer(function (v) {\n            return Data_NonEmpty.singleton(plusList)(a);\n        });\n    },\n    Apply0: function () {\n        return applyNonEmptyList;\n    }\n};\nvar monadNonEmptyList = {\n    Applicative0: function () {\n        return applicativeNonEmptyList;\n    },\n    Bind1: function () {\n        return bindNonEmptyList;\n    }\n};\nmodule.exports = {\n    List: List,\n    Nil: Nil,\n    Cons: Cons,\n    step: step,\n    nil: nil,\n    cons: cons,\n    NonEmptyList: NonEmptyList,\n    toList: toList,\n    showStep: showStep,\n    newtypeList: newtypeList,\n    showList: showList,\n    eqList: eqList,\n    eq1List: eq1List,\n    ordList: ordList,\n    ord1List: ord1List,\n    lazyList: lazyList,\n    semigroupList: semigroupList,\n    monoidList: monoidList,\n    functorList: functorList,\n    functorWithIndexList: functorWithIndexList,\n    foldableList: foldableList,\n    foldableWithIndexList: foldableWithIndexList,\n    unfoldable1List: unfoldable1List,\n    unfoldableList: unfoldableList,\n    traversableList: traversableList,\n    traversableWithIndexList: traversableWithIndexList,\n    applyList: applyList,\n    applicativeList: applicativeList,\n    bindList: bindList,\n    monadList: monadList,\n    altList: altList,\n    plusList: plusList,\n    alternativeList: alternativeList,\n    monadZeroList: monadZeroList,\n    monadPlusList: monadPlusList,\n    extendList: extendList,\n    newtypeNonEmptyList: newtypeNonEmptyList,\n    eqNonEmptyList: eqNonEmptyList,\n    ordNonEmptyList: ordNonEmptyList,\n    eq1NonEmptyList: eq1NonEmptyList,\n    ord1NonEmptyList: ord1NonEmptyList,\n    showNonEmptyList: showNonEmptyList,\n    functorNonEmptyList: functorNonEmptyList,\n    applyNonEmptyList: applyNonEmptyList,\n    applicativeNonEmptyList: applicativeNonEmptyList,\n    bindNonEmptyList: bindNonEmptyList,\n    monadNonEmptyList: monadNonEmptyList,\n    altNonEmptyList: altNonEmptyList,\n    extendNonEmptyList: extendNonEmptyList,\n    comonadNonEmptyList: comonadNonEmptyList,\n    semigroupNonEmptyList: semigroupNonEmptyList,\n    foldableNonEmptyList: foldableNonEmptyList,\n    traversableNonEmptyList: traversableNonEmptyList,\n    unfoldable1NonEmptyList: unfoldable1NonEmptyList,\n    functorWithIndexNonEmptyList: functorWithIndexNonEmptyList,\n    foldableWithIndexNonEmptyList: foldableWithIndexNonEmptyList,\n    traversableWithIndexNonEmptyList: traversableWithIndexNonEmptyList\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/lists/v6.0.1/src/Data/List/Lazy/Types.purs?");

/***/ }),

/***/ "./.spago/lists/v6.0.1/src/Data/List/NonEmpty.purs":
/*!*********************************************************!*\
  !*** ./.spago/lists/v6.0.1/src/Data/List/NonEmpty.purs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_FunctorWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs\");\nvar Data_List = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List.purs */ \"./.spago/lists/v6.0.1/src/Data/List.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_NonEmpty = __webpack_require__(/*! ./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs */ \"./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Semigroup_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs\");\nvar Data_Semigroup_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar Partial_Unsafe = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.purs\");\nvar zipWith = function (f) {\n    return function (v) {\n        return function (v1) {\n            return new Data_NonEmpty.NonEmpty(f(v.value0)(v1.value0), Data_List.zipWith(f)(v.value1)(v1.value1));\n        };\n    };\n};\nvar zipWithA = function (dictApplicative) {\n    return function (f) {\n        return function (xs) {\n            return function (ys) {\n                return Data_Semigroup_Traversable.sequence1(Data_List_Types.traversable1NonEmptyList)(dictApplicative.Apply0())(zipWith(f)(xs)(ys));\n            };\n        };\n    };\n};\nvar zip = zipWith(Data_Tuple.Tuple.create);\nvar wrappedOperation2 = function (name) {\n    return function (f) {\n        return function (v) {\n            return function (v1) {\n                var v2 = f(new Data_List_Types.Cons(v.value0, v.value1))(new Data_List_Types.Cons(v1.value0, v1.value1));\n                if (v2 instanceof Data_List_Types.Cons) {\n                    return new Data_NonEmpty.NonEmpty(v2.value0, v2.value1);\n                };\n                if (v2 instanceof Data_List_Types.Nil) {\n                    return Partial_Unsafe.unsafeCrashWith(\"Impossible: empty list in NonEmptyList \" + name);\n                };\n                throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 110, column 3 - line 112, column 81): \" + [ v2.constructor.name ]);\n            };\n        };\n    };\n};\nvar wrappedOperation = function (name) {\n    return function (f) {\n        return function (v) {\n            var v1 = f(new Data_List_Types.Cons(v.value0, v.value1));\n            if (v1 instanceof Data_List_Types.Cons) {\n                return new Data_NonEmpty.NonEmpty(v1.value0, v1.value1);\n            };\n            if (v1 instanceof Data_List_Types.Nil) {\n                return Partial_Unsafe.unsafeCrashWith(\"Impossible: empty list in NonEmptyList \" + name);\n            };\n            throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 97, column 3 - line 99, column 81): \" + [ v1.constructor.name ]);\n        };\n    };\n};\nvar updateAt = function (i) {\n    return function (a) {\n        return function (v) {\n            if (i === 0) {\n                return new Data_Maybe.Just(new Data_NonEmpty.NonEmpty(a, v.value1));\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Functor.map(Data_Maybe.functorMaybe)(function ($165) {\n                    return Data_List_Types.NonEmptyList((function (v1) {\n                        return new Data_NonEmpty.NonEmpty(v.value0, v1);\n                    })($165));\n                })(Data_List.updateAt(i - 1 | 0)(a)(v.value1));\n            };\n            throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 203, column 1 - line 203, column 75): \" + [ i.constructor.name, a.constructor.name, v.constructor.name ]);\n        };\n    };\n};\nvar unzip = function (ts) {\n    return new Data_Tuple.Tuple(Data_Functor.map(Data_List_Types.functorNonEmptyList)(Data_Tuple.fst)(ts), Data_Functor.map(Data_List_Types.functorNonEmptyList)(Data_Tuple.snd)(ts));\n};\nvar unsnoc = function (v) {\n    var v1 = Data_List.unsnoc(v.value1);\n    if (v1 instanceof Data_Maybe.Nothing) {\n        return {\n            init: Data_List_Types.Nil.value,\n            last: v.value0\n        };\n    };\n    if (v1 instanceof Data_Maybe.Just) {\n        return {\n            init: new Data_List_Types.Cons(v.value0, v1.value0.init),\n            last: v1.value0.last\n        };\n    };\n    throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 165, column 35 - line 167, column 50): \" + [ v1.constructor.name ]);\n};\nvar unionBy = (function () {\n    var $166 = wrappedOperation2(\"unionBy\");\n    return function ($167) {\n        return $166(Data_List.unionBy($167));\n    };\n})();\nvar union = function (dictEq) {\n    return wrappedOperation2(\"union\")(Data_List.union(dictEq));\n};\nvar uncons = function (v) {\n    return {\n        head: v.value0,\n        tail: v.value1\n    };\n};\nvar toList = function (v) {\n    return new Data_List_Types.Cons(v.value0, v.value1);\n};\nvar toUnfoldable = function (dictUnfoldable) {\n    var $168 = Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {\n        return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {\n            return new Data_Tuple.Tuple(rec.head, rec.tail);\n        })(Data_List.uncons(xs));\n    });\n    return function ($169) {\n        return $168(toList($169));\n    };\n};\nvar tail = function (v) {\n    return v.value1;\n};\nvar sortBy = (function () {\n    var $170 = wrappedOperation(\"sortBy\");\n    return function ($171) {\n        return $170(Data_List.sortBy($171));\n    };\n})();\nvar sort = function (dictOrd) {\n    return function (xs) {\n        return sortBy(Data_Ord.compare(dictOrd))(xs);\n    };\n};\nvar snoc = function (v) {\n    return function (y) {\n        return new Data_NonEmpty.NonEmpty(v.value0, Data_List.snoc(v.value1)(y));\n    };\n};\nvar singleton = (function () {\n    var $172 = Data_NonEmpty.singleton(Data_List_Types.plusList);\n    return function ($173) {\n        return Data_List_Types.NonEmptyList($172($173));\n    };\n})();\nvar snoc$prime = function (v) {\n    return function (y) {\n        if (v instanceof Data_List_Types.Cons) {\n            return new Data_NonEmpty.NonEmpty(v.value0, Data_List.snoc(v.value1)(y));\n        };\n        if (v instanceof Data_List_Types.Nil) {\n            return singleton(y);\n        };\n        throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 145, column 1 - line 145, column 51): \" + [ v.constructor.name, y.constructor.name ]);\n    };\n};\nvar reverse = wrappedOperation(\"reverse\")(Data_List.reverse);\nvar nubEq = function (dictEq) {\n    return wrappedOperation(\"nubEq\")(Data_List.nubEq(dictEq));\n};\nvar nubByEq = (function () {\n    var $174 = wrappedOperation(\"nubByEq\");\n    return function ($175) {\n        return $174(Data_List.nubByEq($175));\n    };\n})();\nvar nubBy = (function () {\n    var $176 = wrappedOperation(\"nubBy\");\n    return function ($177) {\n        return $176(Data_List.nubBy($177));\n    };\n})();\nvar nub = function (dictOrd) {\n    return wrappedOperation(\"nub\")(Data_List.nub(dictOrd));\n};\nvar modifyAt = function (i) {\n    return function (f) {\n        return function (v) {\n            if (i === 0) {\n                return new Data_Maybe.Just(new Data_NonEmpty.NonEmpty(f(v.value0), v.value1));\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Functor.map(Data_Maybe.functorMaybe)(function ($178) {\n                    return Data_List_Types.NonEmptyList((function (v1) {\n                        return new Data_NonEmpty.NonEmpty(v.value0, v1);\n                    })($178));\n                })(Data_List.modifyAt(i - 1 | 0)(f)(v.value1));\n            };\n            throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 208, column 1 - line 208, column 82): \" + [ i.constructor.name, f.constructor.name, v.constructor.name ]);\n        };\n    };\n};\nvar mapWithIndex = Data_FunctorWithIndex.mapWithIndex(Data_List_Types.functorWithIndexNonEmptyList);\nvar lift = function (f) {\n    return function (v) {\n        return f(new Data_List_Types.Cons(v.value0, v.value1));\n    };\n};\nvar mapMaybe = function ($179) {\n    return lift(Data_List.mapMaybe($179));\n};\nvar partition = function ($180) {\n    return lift(Data_List.partition($180));\n};\nvar span = function ($181) {\n    return lift(Data_List.span($181));\n};\nvar take = function ($182) {\n    return lift(Data_List.take($182));\n};\nvar takeWhile = function ($183) {\n    return lift(Data_List.takeWhile($183));\n};\nvar length = function (v) {\n    return 1 + Data_List.length(v.value1) | 0;\n};\nvar last = function (v) {\n    return Data_Maybe.fromMaybe(v.value0)(Data_List.last(v.value1));\n};\nvar intersectBy = (function () {\n    var $184 = wrappedOperation2(\"intersectBy\");\n    return function ($185) {\n        return $184(Data_List.intersectBy($185));\n    };\n})();\nvar intersect = function (dictEq) {\n    return wrappedOperation2(\"intersect\")(Data_List.intersect(dictEq));\n};\nvar insertAt = function (i) {\n    return function (a) {\n        return function (v) {\n            if (i === 0) {\n                return new Data_Maybe.Just(new Data_NonEmpty.NonEmpty(a, new Data_List_Types.Cons(v.value0, v.value1)));\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Functor.map(Data_Maybe.functorMaybe)(function ($186) {\n                    return Data_List_Types.NonEmptyList((function (v1) {\n                        return new Data_NonEmpty.NonEmpty(v.value0, v1);\n                    })($186));\n                })(Data_List.insertAt(i - 1 | 0)(a)(v.value1));\n            };\n            throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 198, column 1 - line 198, column 75): \" + [ i.constructor.name, a.constructor.name, v.constructor.name ]);\n        };\n    };\n};\nvar init = function (v) {\n    return Data_Maybe.maybe(Data_List_Types.Nil.value)(function (v1) {\n        return new Data_List_Types.Cons(v.value0, v1);\n    })(Data_List.init(v.value1));\n};\nvar index = function (v) {\n    return function (i) {\n        if (i === 0) {\n            return new Data_Maybe.Just(v.value0);\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_List.index(v.value1)(i - 1 | 0);\n        };\n        throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 172, column 1 - line 172, column 52): \" + [ v.constructor.name, i.constructor.name ]);\n    };\n};\nvar head = function (v) {\n    return v.value0;\n};\nvar groupBy = (function () {\n    var $187 = wrappedOperation(\"groupBy\");\n    return function ($188) {\n        return $187(Data_List.groupBy($188));\n    };\n})();\nvar groupAllBy = function (dictOrd) {\n    var $189 = wrappedOperation(\"groupAllBy\");\n    var $190 = Data_List.groupAllBy(dictOrd);\n    return function ($191) {\n        return $189($190($191));\n    };\n};\nvar groupAll = function (dictOrd) {\n    return wrappedOperation(\"groupAll\")(Data_List.groupAll(dictOrd));\n};\nvar group$prime = function (dictWarn) {\n    return function (dictOrd) {\n        return groupAll(dictOrd);\n    };\n};\nvar group = function (dictEq) {\n    return wrappedOperation(\"group\")(Data_List.group(dictEq));\n};\nvar fromList = function (v) {\n    if (v instanceof Data_List_Types.Nil) {\n        return Data_Maybe.Nothing.value;\n    };\n    if (v instanceof Data_List_Types.Cons) {\n        return new Data_Maybe.Just(new Data_NonEmpty.NonEmpty(v.value0, v.value1));\n    };\n    throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 126, column 1 - line 126, column 57): \" + [ v.constructor.name ]);\n};\nvar fromFoldable = function (dictFoldable) {\n    var $192 = Data_List.fromFoldable(dictFoldable);\n    return function ($193) {\n        return fromList($192($193));\n    };\n};\nvar foldM = function (dictMonad) {\n    return function (f) {\n        return function (b) {\n            return function (v) {\n                return Control_Bind.bind(dictMonad.Bind1())(f(b)(v.value0))(function (b$prime) {\n                    return Data_List.foldM(dictMonad)(f)(b$prime)(v.value1);\n                });\n            };\n        };\n    };\n};\nvar findLastIndex = function (f) {\n    return function (v) {\n        var v1 = Data_List.findLastIndex(f)(v.value1);\n        if (v1 instanceof Data_Maybe.Just) {\n            return new Data_Maybe.Just(v1.value0 + 1 | 0);\n        };\n        if (v1 instanceof Data_Maybe.Nothing) {\n            if (f(v.value0)) {\n                return new Data_Maybe.Just(0);\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Maybe.Nothing.value;\n            };\n        };\n        throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 192, column 3 - line 196, column 29): \" + [ v1.constructor.name ]);\n    };\n};\nvar findIndex = function (f) {\n    return function (v) {\n        if (f(v.value0)) {\n            return new Data_Maybe.Just(0);\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Functor.map(Data_Maybe.functorMaybe)(function (v1) {\n                return v1 + 1 | 0;\n            })(Data_List.findIndex(f)(v.value1));\n        };\n        throw new Error(\"Failed pattern match at Data.List.NonEmpty (line 185, column 1 - line 185, column 69): \" + [ f.constructor.name, v.constructor.name ]);\n    };\n};\nvar filterM = function (dictMonad) {\n    var $194 = Data_List.filterM(dictMonad);\n    return function ($195) {\n        return lift($194($195));\n    };\n};\nvar filter = function ($196) {\n    return lift(Data_List.filter($196));\n};\nvar elemLastIndex = function (dictEq) {\n    return function (x) {\n        return findLastIndex(function (v) {\n            return Data_Eq.eq(dictEq)(v)(x);\n        });\n    };\n};\nvar elemIndex = function (dictEq) {\n    return function (x) {\n        return findIndex(function (v) {\n            return Data_Eq.eq(dictEq)(v)(x);\n        });\n    };\n};\nvar dropWhile = function ($197) {\n    return lift(Data_List.dropWhile($197));\n};\nvar drop = function ($198) {\n    return lift(Data_List.drop($198));\n};\nvar cons$prime = function (x) {\n    return function (xs) {\n        return new Data_NonEmpty.NonEmpty(x, xs);\n    };\n};\nvar cons = function (y) {\n    return function (v) {\n        return new Data_NonEmpty.NonEmpty(y, new Data_List_Types.Cons(v.value0, v.value1));\n    };\n};\nvar concatMap = Data_Function.flip(Control_Bind.bind(Data_List_Types.bindNonEmptyList));\nvar concat = function (v) {\n    return Control_Bind.bind(Data_List_Types.bindNonEmptyList)(v)(Control_Category.identity(Control_Category.categoryFn));\n};\nvar catMaybes = lift(Data_List.catMaybes);\nvar appendFoldable = function (dictFoldable) {\n    return function (v) {\n        return function (ys) {\n            return new Data_NonEmpty.NonEmpty(v.value0, Data_Semigroup.append(Data_List_Types.semigroupList)(v.value1)(Data_List.fromFoldable(dictFoldable)(ys)));\n        };\n    };\n};\nmodule.exports = {\n    toUnfoldable: toUnfoldable,\n    fromFoldable: fromFoldable,\n    fromList: fromList,\n    toList: toList,\n    singleton: singleton,\n    length: length,\n    cons: cons,\n    \"cons'\": cons$prime,\n    snoc: snoc,\n    \"snoc'\": snoc$prime,\n    head: head,\n    last: last,\n    tail: tail,\n    init: init,\n    uncons: uncons,\n    unsnoc: unsnoc,\n    index: index,\n    elemIndex: elemIndex,\n    elemLastIndex: elemLastIndex,\n    findIndex: findIndex,\n    findLastIndex: findLastIndex,\n    insertAt: insertAt,\n    updateAt: updateAt,\n    modifyAt: modifyAt,\n    reverse: reverse,\n    concat: concat,\n    concatMap: concatMap,\n    filter: filter,\n    filterM: filterM,\n    mapMaybe: mapMaybe,\n    catMaybes: catMaybes,\n    appendFoldable: appendFoldable,\n    mapWithIndex: mapWithIndex,\n    sort: sort,\n    sortBy: sortBy,\n    take: take,\n    takeWhile: takeWhile,\n    drop: drop,\n    dropWhile: dropWhile,\n    span: span,\n    group: group,\n    groupAll: groupAll,\n    \"group'\": group$prime,\n    groupBy: groupBy,\n    groupAllBy: groupAllBy,\n    partition: partition,\n    nub: nub,\n    nubBy: nubBy,\n    nubEq: nubEq,\n    nubByEq: nubByEq,\n    union: union,\n    unionBy: unionBy,\n    intersect: intersect,\n    intersectBy: intersectBy,\n    zipWith: zipWith,\n    zipWithA: zipWithA,\n    zip: zip,\n    unzip: unzip,\n    foldM: foldM,\n    all: Data_Foldable.all,\n    any: Data_Foldable.any,\n    elem: Data_Foldable.elem,\n    find: Data_Foldable.find,\n    findMap: Data_Foldable.findMap,\n    fold: Data_Foldable.fold,\n    foldMap: Data_Foldable.foldMap,\n    foldl: Data_Foldable.foldl,\n    foldr: Data_Foldable.foldr,\n    intercalate: Data_Foldable.intercalate,\n    notElem: Data_Foldable.notElem,\n    NonEmptyList: Data_List_Types.NonEmptyList,\n    fold1: Data_Semigroup_Foldable.fold1,\n    foldMap1: Data_Semigroup_Foldable.foldMap1,\n    for1_: Data_Semigroup_Foldable.for1_,\n    sequence1_: Data_Semigroup_Foldable.sequence1_,\n    traverse1_: Data_Semigroup_Foldable.traverse1_,\n    sequence1: Data_Semigroup_Traversable.sequence1,\n    traverse1: Data_Semigroup_Traversable.traverse1,\n    traverse1Default: Data_Semigroup_Traversable.traverse1Default,\n    scanl: Data_Traversable.scanl,\n    scanr: Data_Traversable.scanr\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/lists/v6.0.1/src/Data/List/NonEmpty.purs?");

/***/ }),

/***/ "./.spago/lists/v6.0.1/src/Data/List/Types.purs":
/*!******************************************************!*\
  !*** ./.spago/lists/v6.0.1/src/Data/List/Types.purs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_FoldableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_FunctorWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_NonEmpty = __webpack_require__(/*! ./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs */ \"./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Semigroup_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_TraversableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Nil = (function () {\n    function Nil() {\n\n    };\n    Nil.value = new Nil();\n    return Nil;\n})();\nvar Cons = (function () {\n    function Cons(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    Cons.create = function (value0) {\n        return function (value1) {\n            return new Cons(value0, value1);\n        };\n    };\n    return Cons;\n})();\nvar NonEmptyList = function (x) {\n    return x;\n};\nvar toList = function (v) {\n    return new Cons(v.value0, v.value1);\n};\nvar newtypeNonEmptyList = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar nelCons = function (a) {\n    return function (v) {\n        return new Data_NonEmpty.NonEmpty(a, new Cons(v.value0, v.value1));\n    };\n};\nvar listMap = function (f) {\n    var chunkedRevMap = function ($copy_chunksAcc) {\n        return function ($copy_v) {\n            var $tco_var_chunksAcc = $copy_chunksAcc;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(chunksAcc, v) {\n                if (v instanceof Cons && (v.value1 instanceof Cons && v.value1.value1 instanceof Cons)) {\n                    $tco_var_chunksAcc = new Cons(v, chunksAcc);\n                    $copy_v = v.value1.value1.value1;\n                    return;\n                };\n                var unrolledMap = function (v1) {\n                    if (v1 instanceof Cons && (v1.value1 instanceof Cons && v1.value1.value1 instanceof Nil)) {\n                        return new Cons(f(v1.value0), new Cons(f(v1.value1.value0), Nil.value));\n                    };\n                    if (v1 instanceof Cons && v1.value1 instanceof Nil) {\n                        return new Cons(f(v1.value0), Nil.value);\n                    };\n                    return Nil.value;\n                };\n                var reverseUnrolledMap = function ($copy_v1) {\n                    return function ($copy_acc) {\n                        var $tco_var_v1 = $copy_v1;\n                        var $tco_done1 = false;\n                        var $tco_result;\n                        function $tco_loop(v1, acc) {\n                            if (v1 instanceof Cons && (v1.value0 instanceof Cons && (v1.value0.value1 instanceof Cons && v1.value0.value1.value1 instanceof Cons))) {\n                                $tco_var_v1 = v1.value1;\n                                $copy_acc = new Cons(f(v1.value0.value0), new Cons(f(v1.value0.value1.value0), new Cons(f(v1.value0.value1.value1.value0), acc)));\n                                return;\n                            };\n                            $tco_done1 = true;\n                            return acc;\n                        };\n                        while (!$tco_done1) {\n                            $tco_result = $tco_loop($tco_var_v1, $copy_acc);\n                        };\n                        return $tco_result;\n                    };\n                };\n                $tco_done = true;\n                return reverseUnrolledMap(chunksAcc)(unrolledMap(v));\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_chunksAcc, $copy_v);\n            };\n            return $tco_result;\n        };\n    };\n    return chunkedRevMap(Nil.value);\n};\nvar functorList = {\n    map: listMap\n};\nvar functorNonEmptyList = Data_NonEmpty.functorNonEmpty(functorList);\nvar foldableList = {\n    foldr: function (f) {\n        return function (b) {\n            var rev = (function () {\n                var go = function ($copy_acc) {\n                    return function ($copy_v) {\n                        var $tco_var_acc = $copy_acc;\n                        var $tco_done = false;\n                        var $tco_result;\n                        function $tco_loop(acc, v) {\n                            if (v instanceof Nil) {\n                                $tco_done = true;\n                                return acc;\n                            };\n                            if (v instanceof Cons) {\n                                $tco_var_acc = new Cons(v.value0, acc);\n                                $copy_v = v.value1;\n                                return;\n                            };\n                            throw new Error(\"Failed pattern match at Data.List.Types (line 108, column 7 - line 108, column 23): \" + [ acc.constructor.name, v.constructor.name ]);\n                        };\n                        while (!$tco_done) {\n                            $tco_result = $tco_loop($tco_var_acc, $copy_v);\n                        };\n                        return $tco_result;\n                    };\n                };\n                return go(Nil.value);\n            })();\n            var $205 = Data_Foldable.foldl(foldableList)(Data_Function.flip(f))(b);\n            return function ($206) {\n                return $205(rev($206));\n            };\n        };\n    },\n    foldl: function (f) {\n        var go = function ($copy_b) {\n            return function ($copy_v) {\n                var $tco_var_b = $copy_b;\n                var $tco_done1 = false;\n                var $tco_result;\n                function $tco_loop(b, v) {\n                    if (v instanceof Nil) {\n                        $tco_done1 = true;\n                        return b;\n                    };\n                    if (v instanceof Cons) {\n                        $tco_var_b = f(b)(v.value0);\n                        $copy_v = v.value1;\n                        return;\n                    };\n                    throw new Error(\"Failed pattern match at Data.List.Types (line 112, column 12 - line 114, column 30): \" + [ v.constructor.name ]);\n                };\n                while (!$tco_done1) {\n                    $tco_result = $tco_loop($tco_var_b, $copy_v);\n                };\n                return $tco_result;\n            };\n        };\n        return go;\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return Data_Foldable.foldl(foldableList)(function (acc) {\n                var $207 = Data_Semigroup.append(dictMonoid.Semigroup0())(acc);\n                return function ($208) {\n                    return $207(f($208));\n                };\n            })(Data_Monoid.mempty(dictMonoid));\n        };\n    }\n};\nvar foldableNonEmptyList = Data_NonEmpty.foldableNonEmpty(foldableList);\nvar foldableWithIndexList = {\n    foldrWithIndex: function (f) {\n        return function (b) {\n            return function (xs) {\n                var v = (function () {\n                    var rev = Data_Foldable.foldl(foldableList)(function (v1) {\n                        return function (a) {\n                            return new Data_Tuple.Tuple(v1.value0 + 1 | 0, new Cons(a, v1.value1));\n                        };\n                    });\n                    return rev(new Data_Tuple.Tuple(0, Nil.value))(xs);\n                })();\n                return Data_Tuple.snd(Data_Foldable.foldl(foldableList)(function (v1) {\n                    return function (a) {\n                        return new Data_Tuple.Tuple(v1.value0 - 1 | 0, f(v1.value0 - 1 | 0)(a)(v1.value1));\n                    };\n                })(new Data_Tuple.Tuple(v.value0, b))(v.value1));\n            };\n        };\n    },\n    foldlWithIndex: function (f) {\n        return function (acc) {\n            var $209 = Data_Foldable.foldl(foldableList)(function (v) {\n                return function (a) {\n                    return new Data_Tuple.Tuple(v.value0 + 1 | 0, f(v.value0)(v.value1)(a));\n                };\n            })(new Data_Tuple.Tuple(0, acc));\n            return function ($210) {\n                return Data_Tuple.snd($209($210));\n            };\n        };\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return Data_FoldableWithIndex.foldlWithIndex(foldableWithIndexList)(function (i) {\n                return function (acc) {\n                    var $211 = Data_Semigroup.append(dictMonoid.Semigroup0())(acc);\n                    var $212 = f(i);\n                    return function ($213) {\n                        return $211($212($213));\n                    };\n                };\n            })(Data_Monoid.mempty(dictMonoid));\n        };\n    },\n    Foldable0: function () {\n        return foldableList;\n    }\n};\nvar foldableWithIndexNonEmptyList = {\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return function (v) {\n                return Data_FoldableWithIndex.foldMapWithIndex(Data_NonEmpty.foldableWithIndexNonEmpty(foldableWithIndexList))(dictMonoid)((function () {\n                    var $214 = Data_Maybe.maybe(0)(Data_Semiring.add(Data_Semiring.semiringInt)(1));\n                    return function ($215) {\n                        return f($214($215));\n                    };\n                })())(v);\n            };\n        };\n    },\n    foldlWithIndex: function (f) {\n        return function (b) {\n            return function (v) {\n                return Data_FoldableWithIndex.foldlWithIndex(Data_NonEmpty.foldableWithIndexNonEmpty(foldableWithIndexList))((function () {\n                    var $216 = Data_Maybe.maybe(0)(Data_Semiring.add(Data_Semiring.semiringInt)(1));\n                    return function ($217) {\n                        return f($216($217));\n                    };\n                })())(b)(v);\n            };\n        };\n    },\n    foldrWithIndex: function (f) {\n        return function (b) {\n            return function (v) {\n                return Data_FoldableWithIndex.foldrWithIndex(Data_NonEmpty.foldableWithIndexNonEmpty(foldableWithIndexList))((function () {\n                    var $218 = Data_Maybe.maybe(0)(Data_Semiring.add(Data_Semiring.semiringInt)(1));\n                    return function ($219) {\n                        return f($218($219));\n                    };\n                })())(b)(v);\n            };\n        };\n    },\n    Foldable0: function () {\n        return foldableNonEmptyList;\n    }\n};\nvar functorWithIndexList = {\n    mapWithIndex: function (f) {\n        return Data_FoldableWithIndex.foldrWithIndex(foldableWithIndexList)(function (i) {\n            return function (x) {\n                return function (acc) {\n                    return new Cons(f(i)(x), acc);\n                };\n            };\n        })(Nil.value);\n    },\n    Functor0: function () {\n        return functorList;\n    }\n};\nvar functorWithIndexNonEmptyList = {\n    mapWithIndex: function (fn) {\n        return function (v) {\n            return NonEmptyList(Data_FunctorWithIndex.mapWithIndex(Data_NonEmpty.functorWithIndex(functorWithIndexList))((function () {\n                var $220 = Data_Maybe.maybe(0)(Data_Semiring.add(Data_Semiring.semiringInt)(1));\n                return function ($221) {\n                    return fn($220($221));\n                };\n            })())(v));\n        };\n    },\n    Functor0: function () {\n        return functorNonEmptyList;\n    }\n};\nvar semigroupList = {\n    append: function (xs) {\n        return function (ys) {\n            return Data_Foldable.foldr(foldableList)(Cons.create)(ys)(xs);\n        };\n    }\n};\nvar monoidList = {\n    mempty: Nil.value,\n    Semigroup0: function () {\n        return semigroupList;\n    }\n};\nvar semigroupNonEmptyList = {\n    append: function (v) {\n        return function (as$prime) {\n            return new Data_NonEmpty.NonEmpty(v.value0, Data_Semigroup.append(semigroupList)(v.value1)(toList(as$prime)));\n        };\n    }\n};\nvar showList = function (dictShow) {\n    return {\n        show: function (v) {\n            if (v instanceof Nil) {\n                return \"Nil\";\n            };\n            return \"(\" + (Data_Foldable.intercalate(foldableList)(Data_Monoid.monoidString)(\" : \")(Data_Functor.map(functorList)(Data_Show.show(dictShow))(v)) + \" : Nil)\");\n        }\n    };\n};\nvar showNonEmptyList = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(NonEmptyList \" + (Data_Show.show(Data_NonEmpty.showNonEmpty(dictShow)(showList(dictShow)))(v) + \")\");\n        }\n    };\n};\nvar traversableList = {\n    traverse: function (dictApplicative) {\n        return function (f) {\n            var $222 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value));\n            var $223 = Data_Foldable.foldl(foldableList)(function (acc) {\n                var $225 = Control_Apply.lift2(dictApplicative.Apply0())(Data_Function.flip(Cons.create))(acc);\n                return function ($226) {\n                    return $225(f($226));\n                };\n            })(Control_Applicative.pure(dictApplicative)(Nil.value));\n            return function ($224) {\n                return $222($223($224));\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return Data_Traversable.traverse(traversableList)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));\n    },\n    Functor0: function () {\n        return functorList;\n    },\n    Foldable1: function () {\n        return foldableList;\n    }\n};\nvar traversableNonEmptyList = Data_NonEmpty.traversableNonEmpty(traversableList);\nvar traversableWithIndexList = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            var rev = Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value);\n            var $227 = Data_Functor.map((dictApplicative.Apply0()).Functor0())(rev);\n            var $228 = Data_FoldableWithIndex.foldlWithIndex(foldableWithIndexList)(function (i) {\n                return function (acc) {\n                    var $230 = Control_Apply.lift2(dictApplicative.Apply0())(Data_Function.flip(Cons.create))(acc);\n                    var $231 = f(i);\n                    return function ($232) {\n                        return $230($231($232));\n                    };\n                };\n            })(Control_Applicative.pure(dictApplicative)(Nil.value));\n            return function ($229) {\n                return $227($228($229));\n            };\n        };\n    },\n    FunctorWithIndex0: function () {\n        return functorWithIndexList;\n    },\n    FoldableWithIndex1: function () {\n        return foldableWithIndexList;\n    },\n    Traversable2: function () {\n        return traversableList;\n    }\n};\nvar traversableWithIndexNonEmptyList = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.map((dictApplicative.Apply0()).Functor0())(NonEmptyList)(Data_TraversableWithIndex.traverseWithIndex(Data_NonEmpty.traversableWithIndexNonEmpty(traversableWithIndexList))(dictApplicative)((function () {\n                    var $233 = Data_Maybe.maybe(0)(Data_Semiring.add(Data_Semiring.semiringInt)(1));\n                    return function ($234) {\n                        return f($233($234));\n                    };\n                })())(v));\n            };\n        };\n    },\n    FunctorWithIndex0: function () {\n        return functorWithIndexNonEmptyList;\n    },\n    FoldableWithIndex1: function () {\n        return foldableWithIndexNonEmptyList;\n    },\n    Traversable2: function () {\n        return traversableNonEmptyList;\n    }\n};\nvar unfoldable1List = {\n    unfoldr1: function (f) {\n        return function (b) {\n            var go = function ($copy_source) {\n                return function ($copy_memo) {\n                    var $tco_var_source = $copy_source;\n                    var $tco_done = false;\n                    var $tco_result;\n                    function $tco_loop(source, memo) {\n                        var v = f(source);\n                        if (v.value1 instanceof Data_Maybe.Just) {\n                            $tco_var_source = v.value1.value0;\n                            $copy_memo = new Cons(v.value0, memo);\n                            return;\n                        };\n                        if (v.value1 instanceof Data_Maybe.Nothing) {\n                            $tco_done = true;\n                            return Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value)(new Cons(v.value0, memo));\n                        };\n                        throw new Error(\"Failed pattern match at Data.List.Types (line 136, column 22 - line 138, column 61): \" + [ v.constructor.name ]);\n                    };\n                    while (!$tco_done) {\n                        $tco_result = $tco_loop($tco_var_source, $copy_memo);\n                    };\n                    return $tco_result;\n                };\n            };\n            return go(b)(Nil.value);\n        };\n    }\n};\nvar unfoldableList = {\n    unfoldr: function (f) {\n        return function (b) {\n            var go = function ($copy_source) {\n                return function ($copy_memo) {\n                    var $tco_var_source = $copy_source;\n                    var $tco_done = false;\n                    var $tco_result;\n                    function $tco_loop(source, memo) {\n                        var v = f(source);\n                        if (v instanceof Data_Maybe.Nothing) {\n                            $tco_done = true;\n                            return Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value)(memo);\n                        };\n                        if (v instanceof Data_Maybe.Just) {\n                            $tco_var_source = v.value0.value1;\n                            $copy_memo = new Cons(v.value0.value0, memo);\n                            return;\n                        };\n                        throw new Error(\"Failed pattern match at Data.List.Types (line 143, column 22 - line 145, column 52): \" + [ v.constructor.name ]);\n                    };\n                    while (!$tco_done) {\n                        $tco_result = $tco_loop($tco_var_source, $copy_memo);\n                    };\n                    return $tco_result;\n                };\n            };\n            return go(b)(Nil.value);\n        };\n    },\n    Unfoldable10: function () {\n        return unfoldable1List;\n    }\n};\nvar unfoldable1NonEmptyList = Data_NonEmpty.unfoldable1NonEmpty(unfoldableList);\nvar foldable1NonEmptyList = Data_NonEmpty.foldable1NonEmpty(foldableList);\nvar extendNonEmptyList = {\n    extend: function (f) {\n        return function (v) {\n            var go = function (a) {\n                return function (v1) {\n                    return {\n                        val: new Cons(f(new Data_NonEmpty.NonEmpty(a, v1.acc)), v1.val),\n                        acc: new Cons(a, v1.acc)\n                    };\n                };\n            };\n            return new Data_NonEmpty.NonEmpty(f(v), (Data_Foldable.foldr(foldableList)(go)({\n                val: Nil.value,\n                acc: Nil.value\n            })(v.value1)).val);\n        };\n    },\n    Functor0: function () {\n        return functorNonEmptyList;\n    }\n};\nvar extendList = {\n    extend: function (v) {\n        return function (v1) {\n            if (v1 instanceof Nil) {\n                return Nil.value;\n            };\n            if (v1 instanceof Cons) {\n                var go = function (a$prime) {\n                    return function (v2) {\n                        var acc$prime = new Cons(a$prime, v2.acc);\n                        return {\n                            val: new Cons(v(acc$prime), v2.val),\n                            acc: acc$prime\n                        };\n                    };\n                };\n                return new Cons(v(v1), (Data_Foldable.foldr(foldableList)(go)({\n                    val: Nil.value,\n                    acc: Nil.value\n                })(v1.value1)).val);\n            };\n            throw new Error(\"Failed pattern match at Data.List.Types (line 183, column 1 - line 190, column 42): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    },\n    Functor0: function () {\n        return functorList;\n    }\n};\nvar eq1List = {\n    eq1: function (dictEq) {\n        return function (xs) {\n            return function (ys) {\n                var go = function ($copy_v) {\n                    return function ($copy_v1) {\n                        return function ($copy_v2) {\n                            var $tco_var_v = $copy_v;\n                            var $tco_var_v1 = $copy_v1;\n                            var $tco_done = false;\n                            var $tco_result;\n                            function $tco_loop(v, v1, v2) {\n                                if (!v2) {\n                                    $tco_done = true;\n                                    return false;\n                                };\n                                if (v instanceof Nil && v1 instanceof Nil) {\n                                    $tco_done = true;\n                                    return v2;\n                                };\n                                if (v instanceof Cons && v1 instanceof Cons) {\n                                    $tco_var_v = v.value1;\n                                    $tco_var_v1 = v1.value1;\n                                    $copy_v2 = v2 && Data_Eq.eq(dictEq)(v1.value0)(v.value0);\n                                    return;\n                                };\n                                $tco_done = true;\n                                return false;\n                            };\n                            while (!$tco_done) {\n                                $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);\n                            };\n                            return $tco_result;\n                        };\n                    };\n                };\n                return go(xs)(ys)(true);\n            };\n        };\n    }\n};\nvar eq1NonEmptyList = Data_NonEmpty.eq1NonEmpty(eq1List);\nvar eqList = function (dictEq) {\n    return {\n        eq: Data_Eq.eq1(eq1List)(dictEq)\n    };\n};\nvar eqNonEmptyList = function (dictEq) {\n    return Data_NonEmpty.eqNonEmpty(eq1List)(dictEq);\n};\nvar ord1List = {\n    compare1: function (dictOrd) {\n        return function (xs) {\n            return function (ys) {\n                var go = function ($copy_v) {\n                    return function ($copy_v1) {\n                        var $tco_var_v = $copy_v;\n                        var $tco_done = false;\n                        var $tco_result;\n                        function $tco_loop(v, v1) {\n                            if (v instanceof Nil && v1 instanceof Nil) {\n                                $tco_done = true;\n                                return Data_Ordering.EQ.value;\n                            };\n                            if (v instanceof Nil) {\n                                $tco_done = true;\n                                return Data_Ordering.LT.value;\n                            };\n                            if (v1 instanceof Nil) {\n                                $tco_done = true;\n                                return Data_Ordering.GT.value;\n                            };\n                            if (v instanceof Cons && v1 instanceof Cons) {\n                                var v2 = Data_Ord.compare(dictOrd)(v.value0)(v1.value0);\n                                if (v2 instanceof Data_Ordering.EQ) {\n                                    $tco_var_v = v.value1;\n                                    $copy_v1 = v1.value1;\n                                    return;\n                                };\n                                $tco_done = true;\n                                return v2;\n                            };\n                            throw new Error(\"Failed pattern match at Data.List.Types (line 61, column 5 - line 61, column 20): \" + [ v.constructor.name, v1.constructor.name ]);\n                        };\n                        while (!$tco_done) {\n                            $tco_result = $tco_loop($tco_var_v, $copy_v1);\n                        };\n                        return $tco_result;\n                    };\n                };\n                return go(xs)(ys);\n            };\n        };\n    },\n    Eq10: function () {\n        return eq1List;\n    }\n};\nvar ord1NonEmptyList = Data_NonEmpty.ord1NonEmpty(ord1List);\nvar ordList = function (dictOrd) {\n    return {\n        compare: Data_Ord.compare1(ord1List)(dictOrd),\n        Eq0: function () {\n            return eqList(dictOrd.Eq0());\n        }\n    };\n};\nvar ordNonEmptyList = function (dictOrd) {\n    return Data_NonEmpty.ordNonEmpty(ord1List)(dictOrd);\n};\nvar comonadNonEmptyList = {\n    extract: function (v) {\n        return v.value0;\n    },\n    Extend0: function () {\n        return extendNonEmptyList;\n    }\n};\nvar applyList = {\n    apply: function (v) {\n        return function (v1) {\n            if (v instanceof Nil) {\n                return Nil.value;\n            };\n            if (v instanceof Cons) {\n                return Data_Semigroup.append(semigroupList)(Data_Functor.map(functorList)(v.value0)(v1))(Control_Apply.apply(applyList)(v.value1)(v1));\n            };\n            throw new Error(\"Failed pattern match at Data.List.Types (line 158, column 1 - line 160, column 48): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    },\n    Functor0: function () {\n        return functorList;\n    }\n};\nvar applyNonEmptyList = {\n    apply: function (v) {\n        return function (v1) {\n            return new Data_NonEmpty.NonEmpty(v.value0(v1.value0), Data_Semigroup.append(semigroupList)(Control_Apply.apply(applyList)(v.value1)(new Cons(v1.value0, Nil.value)))(Control_Apply.apply(applyList)(new Cons(v.value0, v.value1))(v1.value1)));\n        };\n    },\n    Functor0: function () {\n        return functorNonEmptyList;\n    }\n};\nvar bindList = {\n    bind: function (v) {\n        return function (v1) {\n            if (v instanceof Nil) {\n                return Nil.value;\n            };\n            if (v instanceof Cons) {\n                return Data_Semigroup.append(semigroupList)(v1(v.value0))(Control_Bind.bind(bindList)(v.value1)(v1));\n            };\n            throw new Error(\"Failed pattern match at Data.List.Types (line 165, column 1 - line 167, column 37): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    },\n    Apply0: function () {\n        return applyList;\n    }\n};\nvar bindNonEmptyList = {\n    bind: function (v) {\n        return function (f) {\n            var v1 = f(v.value0);\n            return new Data_NonEmpty.NonEmpty(v1.value0, Data_Semigroup.append(semigroupList)(v1.value1)(Control_Bind.bind(bindList)(v.value1)(function ($235) {\n                return toList(f($235));\n            })));\n        };\n    },\n    Apply0: function () {\n        return applyNonEmptyList;\n    }\n};\nvar applicativeList = {\n    pure: function (a) {\n        return new Cons(a, Nil.value);\n    },\n    Apply0: function () {\n        return applyList;\n    }\n};\nvar monadList = {\n    Applicative0: function () {\n        return applicativeList;\n    },\n    Bind1: function () {\n        return bindList;\n    }\n};\nvar altNonEmptyList = {\n    alt: Data_Semigroup.append(semigroupNonEmptyList),\n    Functor0: function () {\n        return functorNonEmptyList;\n    }\n};\nvar altList = {\n    alt: Data_Semigroup.append(semigroupList),\n    Functor0: function () {\n        return functorList;\n    }\n};\nvar plusList = {\n    empty: Nil.value,\n    Alt0: function () {\n        return altList;\n    }\n};\nvar alternativeList = {\n    Applicative0: function () {\n        return applicativeList;\n    },\n    Plus1: function () {\n        return plusList;\n    }\n};\nvar monadPlusList = {\n    Monad0: function () {\n        return monadList;\n    },\n    Alternative1: function () {\n        return alternativeList;\n    }\n};\nvar monadZeroList = {\n    Monad0: function () {\n        return monadList;\n    },\n    Alternative1: function () {\n        return alternativeList;\n    },\n    MonadZeroIsDeprecated2: function () {\n        return undefined;\n    }\n};\nvar applicativeNonEmptyList = {\n    pure: (function () {\n        var $236 = Data_NonEmpty.singleton(plusList);\n        return function ($237) {\n            return NonEmptyList($236($237));\n        };\n    })(),\n    Apply0: function () {\n        return applyNonEmptyList;\n    }\n};\nvar monadNonEmptyList = {\n    Applicative0: function () {\n        return applicativeNonEmptyList;\n    },\n    Bind1: function () {\n        return bindNonEmptyList;\n    }\n};\nvar traversable1NonEmptyList = {\n    traverse1: function (dictApply) {\n        return function (f) {\n            return function (v) {\n                return Data_Functor.mapFlipped(dictApply.Functor0())(Data_Foldable.foldl(foldableList)(function (acc) {\n                    var $238 = Control_Apply.lift2(dictApply)(Data_Function.flip(nelCons))(acc);\n                    return function ($239) {\n                        return $238(f($239));\n                    };\n                })(Data_Functor.map(dictApply.Functor0())(Control_Applicative.pure(applicativeNonEmptyList))(f(v.value0)))(v.value1))(function (v1) {\n                    return Data_Foldable.foldl(foldableList)(Data_Function.flip(nelCons))(Control_Applicative.pure(applicativeNonEmptyList)(v1.value0))(v1.value1);\n                });\n            };\n        };\n    },\n    sequence1: function (dictApply) {\n        return Data_Semigroup_Traversable.traverse1(traversable1NonEmptyList)(dictApply)(Control_Category.identity(Control_Category.categoryFn));\n    },\n    Foldable10: function () {\n        return foldable1NonEmptyList;\n    },\n    Traversable1: function () {\n        return traversableNonEmptyList;\n    }\n};\nmodule.exports = {\n    Nil: Nil,\n    Cons: Cons,\n    NonEmptyList: NonEmptyList,\n    toList: toList,\n    nelCons: nelCons,\n    showList: showList,\n    eqList: eqList,\n    eq1List: eq1List,\n    ordList: ordList,\n    ord1List: ord1List,\n    semigroupList: semigroupList,\n    monoidList: monoidList,\n    functorList: functorList,\n    functorWithIndexList: functorWithIndexList,\n    foldableList: foldableList,\n    foldableWithIndexList: foldableWithIndexList,\n    unfoldable1List: unfoldable1List,\n    unfoldableList: unfoldableList,\n    traversableList: traversableList,\n    traversableWithIndexList: traversableWithIndexList,\n    applyList: applyList,\n    applicativeList: applicativeList,\n    bindList: bindList,\n    monadList: monadList,\n    altList: altList,\n    plusList: plusList,\n    alternativeList: alternativeList,\n    monadZeroList: monadZeroList,\n    monadPlusList: monadPlusList,\n    extendList: extendList,\n    newtypeNonEmptyList: newtypeNonEmptyList,\n    eqNonEmptyList: eqNonEmptyList,\n    ordNonEmptyList: ordNonEmptyList,\n    eq1NonEmptyList: eq1NonEmptyList,\n    ord1NonEmptyList: ord1NonEmptyList,\n    showNonEmptyList: showNonEmptyList,\n    functorNonEmptyList: functorNonEmptyList,\n    applyNonEmptyList: applyNonEmptyList,\n    applicativeNonEmptyList: applicativeNonEmptyList,\n    bindNonEmptyList: bindNonEmptyList,\n    monadNonEmptyList: monadNonEmptyList,\n    altNonEmptyList: altNonEmptyList,\n    extendNonEmptyList: extendNonEmptyList,\n    comonadNonEmptyList: comonadNonEmptyList,\n    semigroupNonEmptyList: semigroupNonEmptyList,\n    foldableNonEmptyList: foldableNonEmptyList,\n    traversableNonEmptyList: traversableNonEmptyList,\n    foldable1NonEmptyList: foldable1NonEmptyList,\n    unfoldable1NonEmptyList: unfoldable1NonEmptyList,\n    functorWithIndexNonEmptyList: functorWithIndexNonEmptyList,\n    foldableWithIndexNonEmptyList: foldableWithIndexNonEmptyList,\n    traversableWithIndexNonEmptyList: traversableWithIndexNonEmptyList,\n    traversable1NonEmptyList: traversable1NonEmptyList\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/lists/v6.0.1/src/Data/List/Types.purs?");

/***/ }),

/***/ "./.spago/math/v3.0.0/src/Math.purs":
/*!******************************************!*\
  !*** ./.spago/math/v3.0.0/src/Math.purs ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/math/v3.0.0/src/Math.js */ \"./.spago/math/v3.0.0/src/Math.js\");\nmodule.exports = {\n    abs: $foreign.abs,\n    acos: $foreign.acos,\n    asin: $foreign.asin,\n    atan: $foreign.atan,\n    atan2: $foreign.atan2,\n    ceil: $foreign.ceil,\n    cos: $foreign.cos,\n    exp: $foreign.exp,\n    floor: $foreign.floor,\n    imul: $foreign.imul,\n    log: $foreign.log,\n    max: $foreign.max,\n    min: $foreign.min,\n    pow: $foreign.pow,\n    round: $foreign.round,\n    sin: $foreign.sin,\n    sqrt: $foreign.sqrt,\n    tan: $foreign.tan,\n    trunc: $foreign.trunc,\n    remainder: $foreign.remainder,\n    e: $foreign.e,\n    ln2: $foreign.ln2,\n    ln10: $foreign.ln10,\n    log2e: $foreign.log2e,\n    log10e: $foreign.log10e,\n    pi: $foreign.pi,\n    tau: $foreign.tau,\n    sqrt1_2: $foreign.sqrt1_2,\n    sqrt2: $foreign.sqrt2\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/math/v3.0.0/src/Math.purs?");

/***/ }),

/***/ "./.spago/maybe/v5.0.0/src/Data/Maybe.purs":
/*!*************************************************!*\
  !*** ./.spago/maybe/v5.0.0/src/Data/Maybe.purs ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Bounded = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Bounded.purs */ \"./.spago/prelude/v5.0.1/src/Data/Bounded.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Functor_Invariant = __webpack_require__(/*! ./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs */ \"./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs\");\nvar Data_Generic_Rep = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs */ \"./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Nothing = (function () {\n    function Nothing() {\n\n    };\n    Nothing.value = new Nothing();\n    return Nothing;\n})();\nvar Just = (function () {\n    function Just(value0) {\n        this.value0 = value0;\n    };\n    Just.create = function (value0) {\n        return new Just(value0);\n    };\n    return Just;\n})();\nvar showMaybe = function (dictShow) {\n    return {\n        show: function (v) {\n            if (v instanceof Just) {\n                return \"(Just \" + (Data_Show.show(dictShow)(v.value0) + \")\");\n            };\n            if (v instanceof Nothing) {\n                return \"Nothing\";\n            };\n            throw new Error(\"Failed pattern match at Data.Maybe (line 216, column 1 - line 218, column 28): \" + [ v.constructor.name ]);\n        }\n    };\n};\nvar semigroupMaybe = function (dictSemigroup) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                if (v instanceof Nothing) {\n                    return v1;\n                };\n                if (v1 instanceof Nothing) {\n                    return v;\n                };\n                if (v instanceof Just && v1 instanceof Just) {\n                    return new Just(Data_Semigroup.append(dictSemigroup)(v.value0)(v1.value0));\n                };\n                throw new Error(\"Failed pattern match at Data.Maybe (line 185, column 1 - line 188, column 43): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        }\n    };\n};\nvar optional = function (dictAlt) {\n    return function (dictApplicative) {\n        return function (a) {\n            return Control_Alt.alt(dictAlt)(Data_Functor.map(dictAlt.Functor0())(Just.create)(a))(Control_Applicative.pure(dictApplicative)(Nothing.value));\n        };\n    };\n};\nvar monoidMaybe = function (dictSemigroup) {\n    return {\n        mempty: Nothing.value,\n        Semigroup0: function () {\n            return semigroupMaybe(dictSemigroup);\n        }\n    };\n};\nvar maybe$prime = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2 instanceof Nothing) {\n                return v(Data_Unit.unit);\n            };\n            if (v2 instanceof Just) {\n                return v1(v2.value0);\n            };\n            throw new Error(\"Failed pattern match at Data.Maybe (line 243, column 1 - line 243, column 62): \" + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);\n        };\n    };\n};\nvar maybe = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2 instanceof Nothing) {\n                return v;\n            };\n            if (v2 instanceof Just) {\n                return v1(v2.value0);\n            };\n            throw new Error(\"Failed pattern match at Data.Maybe (line 230, column 1 - line 230, column 51): \" + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);\n        };\n    };\n};\nvar isNothing = maybe(true)(Data_Function[\"const\"](false));\nvar isJust = maybe(false)(Data_Function[\"const\"](true));\nvar genericMaybe = {\n    to: function (x) {\n        if (x instanceof Data_Generic_Rep.Inl) {\n            return Nothing.value;\n        };\n        if (x instanceof Data_Generic_Rep.Inr) {\n            return new Just(x.value0);\n        };\n        throw new Error(\"Failed pattern match at Data.Maybe (line 220, column 1 - line 220, column 52): \" + [ x.constructor.name ]);\n    },\n    from: function (x) {\n        if (x instanceof Nothing) {\n            return new Data_Generic_Rep.Inl(Data_Generic_Rep.NoArguments.value);\n        };\n        if (x instanceof Just) {\n            return new Data_Generic_Rep.Inr(x.value0);\n        };\n        throw new Error(\"Failed pattern match at Data.Maybe (line 220, column 1 - line 220, column 52): \" + [ x.constructor.name ]);\n    }\n};\nvar functorMaybe = {\n    map: function (v) {\n        return function (v1) {\n            if (v1 instanceof Just) {\n                return new Just(v(v1.value0));\n            };\n            return Nothing.value;\n        };\n    }\n};\nvar invariantMaybe = {\n    imap: Data_Functor_Invariant.imapF(functorMaybe)\n};\nvar fromMaybe$prime = function (a) {\n    return maybe$prime(a)(Control_Category.identity(Control_Category.categoryFn));\n};\nvar fromMaybe = function (a) {\n    return maybe(a)(Control_Category.identity(Control_Category.categoryFn));\n};\nvar fromJust = function (dictPartial) {\n    return function (v) {\n        if (v instanceof Just) {\n            return v.value0;\n        };\n        throw new Error(\"Failed pattern match at Data.Maybe (line 281, column 1 - line 281, column 46): \" + [ v.constructor.name ]);\n    };\n};\nvar extendMaybe = {\n    extend: function (v) {\n        return function (v1) {\n            if (v1 instanceof Nothing) {\n                return Nothing.value;\n            };\n            return new Just(v(v1));\n        };\n    },\n    Functor0: function () {\n        return functorMaybe;\n    }\n};\nvar eqMaybe = function (dictEq) {\n    return {\n        eq: function (x) {\n            return function (y) {\n                if (x instanceof Nothing && y instanceof Nothing) {\n                    return true;\n                };\n                if (x instanceof Just && y instanceof Just) {\n                    return Data_Eq.eq(dictEq)(x.value0)(y.value0);\n                };\n                return false;\n            };\n        }\n    };\n};\nvar ordMaybe = function (dictOrd) {\n    return {\n        compare: function (x) {\n            return function (y) {\n                if (x instanceof Nothing && y instanceof Nothing) {\n                    return Data_Ordering.EQ.value;\n                };\n                if (x instanceof Nothing) {\n                    return Data_Ordering.LT.value;\n                };\n                if (y instanceof Nothing) {\n                    return Data_Ordering.GT.value;\n                };\n                if (x instanceof Just && y instanceof Just) {\n                    return Data_Ord.compare(dictOrd)(x.value0)(y.value0);\n                };\n                throw new Error(\"Failed pattern match at Data.Maybe (line 205, column 1 - line 205, column 51): \" + [ x.constructor.name, y.constructor.name ]);\n            };\n        },\n        Eq0: function () {\n            return eqMaybe(dictOrd.Eq0());\n        }\n    };\n};\nvar eq1Maybe = {\n    eq1: function (dictEq) {\n        return Data_Eq.eq(eqMaybe(dictEq));\n    }\n};\nvar ord1Maybe = {\n    compare1: function (dictOrd) {\n        return Data_Ord.compare(ordMaybe(dictOrd));\n    },\n    Eq10: function () {\n        return eq1Maybe;\n    }\n};\nvar boundedMaybe = function (dictBounded) {\n    return {\n        top: new Just(Data_Bounded.top(dictBounded)),\n        bottom: Nothing.value,\n        Ord0: function () {\n            return ordMaybe(dictBounded.Ord0());\n        }\n    };\n};\nvar applyMaybe = {\n    apply: function (v) {\n        return function (v1) {\n            if (v instanceof Just) {\n                return Data_Functor.map(functorMaybe)(v.value0)(v1);\n            };\n            if (v instanceof Nothing) {\n                return Nothing.value;\n            };\n            throw new Error(\"Failed pattern match at Data.Maybe (line 68, column 1 - line 70, column 30): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    },\n    Functor0: function () {\n        return functorMaybe;\n    }\n};\nvar bindMaybe = {\n    bind: function (v) {\n        return function (v1) {\n            if (v instanceof Just) {\n                return v1(v.value0);\n            };\n            if (v instanceof Nothing) {\n                return Nothing.value;\n            };\n            throw new Error(\"Failed pattern match at Data.Maybe (line 126, column 1 - line 128, column 28): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    },\n    Apply0: function () {\n        return applyMaybe;\n    }\n};\nvar applicativeMaybe = {\n    pure: Just.create,\n    Apply0: function () {\n        return applyMaybe;\n    }\n};\nvar monadMaybe = {\n    Applicative0: function () {\n        return applicativeMaybe;\n    },\n    Bind1: function () {\n        return bindMaybe;\n    }\n};\nvar altMaybe = {\n    alt: function (v) {\n        return function (v1) {\n            if (v instanceof Nothing) {\n                return v1;\n            };\n            return v;\n        };\n    },\n    Functor0: function () {\n        return functorMaybe;\n    }\n};\nvar plusMaybe = {\n    empty: Nothing.value,\n    Alt0: function () {\n        return altMaybe;\n    }\n};\nvar alternativeMaybe = {\n    Applicative0: function () {\n        return applicativeMaybe;\n    },\n    Plus1: function () {\n        return plusMaybe;\n    }\n};\nvar monadZeroMaybe = {\n    Monad0: function () {\n        return monadMaybe;\n    },\n    Alternative1: function () {\n        return alternativeMaybe;\n    },\n    MonadZeroIsDeprecated2: function () {\n        return undefined;\n    }\n};\nmodule.exports = {\n    Nothing: Nothing,\n    Just: Just,\n    maybe: maybe,\n    \"maybe'\": maybe$prime,\n    fromMaybe: fromMaybe,\n    \"fromMaybe'\": fromMaybe$prime,\n    isJust: isJust,\n    isNothing: isNothing,\n    fromJust: fromJust,\n    optional: optional,\n    functorMaybe: functorMaybe,\n    applyMaybe: applyMaybe,\n    applicativeMaybe: applicativeMaybe,\n    altMaybe: altMaybe,\n    plusMaybe: plusMaybe,\n    alternativeMaybe: alternativeMaybe,\n    bindMaybe: bindMaybe,\n    monadMaybe: monadMaybe,\n    monadZeroMaybe: monadZeroMaybe,\n    extendMaybe: extendMaybe,\n    invariantMaybe: invariantMaybe,\n    semigroupMaybe: semigroupMaybe,\n    monoidMaybe: monoidMaybe,\n    eqMaybe: eqMaybe,\n    eq1Maybe: eq1Maybe,\n    ordMaybe: ordMaybe,\n    ord1Maybe: ord1Maybe,\n    boundedMaybe: boundedMaybe,\n    showMaybe: showMaybe,\n    genericMaybe: genericMaybe\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/maybe/v5.0.0/src/Data/Maybe.purs?");

/***/ }),

/***/ "./.spago/maybe/v5.0.0/src/Data/Maybe/First.purs":
/*!*******************************************************!*\
  !*** ./.spago/maybe/v5.0.0/src/Data/Maybe/First.purs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar First = function (x) {\n    return x;\n};\nvar showFirst = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"First (\" + (Data_Show.show(Data_Maybe.showMaybe(dictShow))(v) + \")\");\n        }\n    };\n};\nvar semigroupFirst = {\n    append: function (v) {\n        return function (v1) {\n            if (v instanceof Data_Maybe.Just) {\n                return v;\n            };\n            return v1;\n        };\n    }\n};\nvar ordFirst = function (dictOrd) {\n    return Data_Maybe.ordMaybe(dictOrd);\n};\nvar ord1First = Data_Maybe.ord1Maybe;\nvar newtypeFirst = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monoidFirst = {\n    mempty: Data_Maybe.Nothing.value,\n    Semigroup0: function () {\n        return semigroupFirst;\n    }\n};\nvar monadFirst = Data_Maybe.monadMaybe;\nvar invariantFirst = Data_Maybe.invariantMaybe;\nvar functorFirst = Data_Maybe.functorMaybe;\nvar extendFirst = Data_Maybe.extendMaybe;\nvar eqFirst = function (dictEq) {\n    return Data_Maybe.eqMaybe(dictEq);\n};\nvar eq1First = Data_Maybe.eq1Maybe;\nvar boundedFirst = function (dictBounded) {\n    return Data_Maybe.boundedMaybe(dictBounded);\n};\nvar bindFirst = Data_Maybe.bindMaybe;\nvar applyFirst = Data_Maybe.applyMaybe;\nvar applicativeFirst = Data_Maybe.applicativeMaybe;\nvar altFirst = {\n    alt: Data_Semigroup.append(semigroupFirst),\n    Functor0: function () {\n        return functorFirst;\n    }\n};\nvar plusFirst = {\n    empty: Data_Monoid.mempty(monoidFirst),\n    Alt0: function () {\n        return altFirst;\n    }\n};\nvar alternativeFirst = {\n    Applicative0: function () {\n        return applicativeFirst;\n    },\n    Plus1: function () {\n        return plusFirst;\n    }\n};\nvar monadZeroFirst = {\n    Monad0: function () {\n        return monadFirst;\n    },\n    Alternative1: function () {\n        return alternativeFirst;\n    },\n    MonadZeroIsDeprecated2: function () {\n        return undefined;\n    }\n};\nmodule.exports = {\n    First: First,\n    newtypeFirst: newtypeFirst,\n    eqFirst: eqFirst,\n    eq1First: eq1First,\n    ordFirst: ordFirst,\n    ord1First: ord1First,\n    boundedFirst: boundedFirst,\n    functorFirst: functorFirst,\n    invariantFirst: invariantFirst,\n    applyFirst: applyFirst,\n    applicativeFirst: applicativeFirst,\n    bindFirst: bindFirst,\n    monadFirst: monadFirst,\n    extendFirst: extendFirst,\n    showFirst: showFirst,\n    semigroupFirst: semigroupFirst,\n    monoidFirst: monoidFirst,\n    altFirst: altFirst,\n    plusFirst: plusFirst,\n    alternativeFirst: alternativeFirst,\n    monadZeroFirst: monadZeroFirst\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/maybe/v5.0.0/src/Data/Maybe/First.purs?");

/***/ }),

/***/ "./.spago/maybe/v5.0.0/src/Data/Maybe/Last.purs":
/*!******************************************************!*\
  !*** ./.spago/maybe/v5.0.0/src/Data/Maybe/Last.purs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Last = function (x) {\n    return x;\n};\nvar showLast = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Last \" + (Data_Show.show(Data_Maybe.showMaybe(dictShow))(v) + \")\");\n        }\n    };\n};\nvar semigroupLast = {\n    append: function (v) {\n        return function (v1) {\n            if (v1 instanceof Data_Maybe.Just) {\n                return v1;\n            };\n            if (v1 instanceof Data_Maybe.Nothing) {\n                return v;\n            };\n            throw new Error(\"Failed pattern match at Data.Maybe.Last (line 52, column 1 - line 54, column 36): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    }\n};\nvar ordLast = function (dictOrd) {\n    return Data_Maybe.ordMaybe(dictOrd);\n};\nvar ord1Last = Data_Maybe.ord1Maybe;\nvar newtypeLast = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monoidLast = {\n    mempty: Data_Maybe.Nothing.value,\n    Semigroup0: function () {\n        return semigroupLast;\n    }\n};\nvar monadLast = Data_Maybe.monadMaybe;\nvar invariantLast = Data_Maybe.invariantMaybe;\nvar functorLast = Data_Maybe.functorMaybe;\nvar extendLast = Data_Maybe.extendMaybe;\nvar eqLast = function (dictEq) {\n    return Data_Maybe.eqMaybe(dictEq);\n};\nvar eq1Last = Data_Maybe.eq1Maybe;\nvar boundedLast = function (dictBounded) {\n    return Data_Maybe.boundedMaybe(dictBounded);\n};\nvar bindLast = Data_Maybe.bindMaybe;\nvar applyLast = Data_Maybe.applyMaybe;\nvar applicativeLast = Data_Maybe.applicativeMaybe;\nvar altLast = {\n    alt: Data_Semigroup.append(semigroupLast),\n    Functor0: function () {\n        return functorLast;\n    }\n};\nvar plusLast = {\n    empty: Data_Monoid.mempty(monoidLast),\n    Alt0: function () {\n        return altLast;\n    }\n};\nvar alternativeLast = {\n    Applicative0: function () {\n        return applicativeLast;\n    },\n    Plus1: function () {\n        return plusLast;\n    }\n};\nvar monadZeroLast = {\n    Monad0: function () {\n        return monadLast;\n    },\n    Alternative1: function () {\n        return alternativeLast;\n    },\n    MonadZeroIsDeprecated2: function () {\n        return undefined;\n    }\n};\nmodule.exports = {\n    Last: Last,\n    newtypeLast: newtypeLast,\n    eqLast: eqLast,\n    eq1Last: eq1Last,\n    ordLast: ordLast,\n    ord1Last: ord1Last,\n    boundedLast: boundedLast,\n    functorLast: functorLast,\n    invariantLast: invariantLast,\n    applyLast: applyLast,\n    applicativeLast: applicativeLast,\n    bindLast: bindLast,\n    monadLast: monadLast,\n    extendLast: extendLast,\n    showLast: showLast,\n    semigroupLast: semigroupLast,\n    monoidLast: monoidLast,\n    altLast: altLast,\n    plusLast: plusLast,\n    alternativeLast: alternativeLast,\n    monadZeroLast: monadZeroLast\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/maybe/v5.0.0/src/Data/Maybe/Last.purs?");

/***/ }),

/***/ "./.spago/newtype/v4.0.0/src/Data/Newtype.purs":
/*!*****************************************************!*\
  !*** ./.spago/newtype/v4.0.0/src/Data/Newtype.purs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Safe_Coerce = __webpack_require__(/*! ./.spago/safe-coerce/v1.0.0/src/Safe/Coerce.purs */ \"./.spago/safe-coerce/v1.0.0/src/Safe/Coerce.purs\");\nvar wrap = function (dictNewtype) {\n    return Safe_Coerce.coerce();\n};\nvar unwrap = function (dictNewtype) {\n    return Safe_Coerce.coerce();\n};\nvar underF2 = function (dictCoercible) {\n    return function (dictCoercible1) {\n        return function (dictNewtype) {\n            return function (dictNewtype1) {\n                return function (v) {\n                    return Safe_Coerce.coerce();\n                };\n            };\n        };\n    };\n};\nvar underF = function (dictCoercible) {\n    return function (dictCoercible1) {\n        return function (dictNewtype) {\n            return function (dictNewtype1) {\n                return function (v) {\n                    return Safe_Coerce.coerce();\n                };\n            };\n        };\n    };\n};\nvar under2 = function (dictNewtype) {\n    return function (dictNewtype1) {\n        return function (v) {\n            return Safe_Coerce.coerce();\n        };\n    };\n};\nvar under = function (dictNewtype) {\n    return function (dictNewtype1) {\n        return function (v) {\n            return Safe_Coerce.coerce();\n        };\n    };\n};\nvar un = function (dictNewtype) {\n    return function (v) {\n        return unwrap();\n    };\n};\nvar traverse = function (dictCoercible) {\n    return function (dictNewtype) {\n        return function (v) {\n            return Safe_Coerce.coerce();\n        };\n    };\n};\nvar overF2 = function (dictCoercible) {\n    return function (dictCoercible1) {\n        return function (dictNewtype) {\n            return function (dictNewtype1) {\n                return function (v) {\n                    return Safe_Coerce.coerce();\n                };\n            };\n        };\n    };\n};\nvar overF = function (dictCoercible) {\n    return function (dictCoercible1) {\n        return function (dictNewtype) {\n            return function (dictNewtype1) {\n                return function (v) {\n                    return Safe_Coerce.coerce();\n                };\n            };\n        };\n    };\n};\nvar over2 = function (dictNewtype) {\n    return function (dictNewtype1) {\n        return function (v) {\n            return Safe_Coerce.coerce();\n        };\n    };\n};\nvar over = function (dictNewtype) {\n    return function (dictNewtype1) {\n        return function (v) {\n            return Safe_Coerce.coerce();\n        };\n    };\n};\nvar newtypeMultiplicative = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar newtypeLast = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar newtypeFirst = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar newtypeEndo = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar newtypeDual = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar newtypeDisj = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar newtypeConj = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar newtypeAdditive = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar collect = function (dictCoercible) {\n    return function (dictNewtype) {\n        return function (v) {\n            return Safe_Coerce.coerce();\n        };\n    };\n};\nvar alaF = function (dictCoercible) {\n    return function (dictCoercible1) {\n        return function (dictNewtype) {\n            return function (dictNewtype1) {\n                return function (v) {\n                    return Safe_Coerce.coerce();\n                };\n            };\n        };\n    };\n};\nvar ala = function (dictCoercible) {\n    return function (dictNewtype) {\n        return function (dictNewtype1) {\n            return function (v) {\n                return function (f) {\n                    return Safe_Coerce.coerce()(f(wrap()));\n                };\n            };\n        };\n    };\n};\nmodule.exports = {\n    wrap: wrap,\n    unwrap: unwrap,\n    un: un,\n    ala: ala,\n    alaF: alaF,\n    over: over,\n    overF: overF,\n    under: under,\n    underF: underF,\n    over2: over2,\n    overF2: overF2,\n    under2: under2,\n    underF2: underF2,\n    traverse: traverse,\n    collect: collect,\n    newtypeAdditive: newtypeAdditive,\n    newtypeMultiplicative: newtypeMultiplicative,\n    newtypeConj: newtypeConj,\n    newtypeDisj: newtypeDisj,\n    newtypeDual: newtypeDual,\n    newtypeEndo: newtypeEndo,\n    newtypeFirst: newtypeFirst,\n    newtypeLast: newtypeLast\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/newtype/v4.0.0/src/Data/Newtype.purs?");

/***/ }),

/***/ "./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs":
/*!*******************************************************!*\
  !*** ./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Plus = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Plus.purs */ \"./.spago/control/v5.0.0/src/Control/Plus.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_FoldableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_FunctorWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Semigroup_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Foldable.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_TraversableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar NonEmpty = (function () {\n    function NonEmpty(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    NonEmpty.create = function (value0) {\n        return function (value1) {\n            return new NonEmpty(value0, value1);\n        };\n    };\n    return NonEmpty;\n})();\nvar unfoldable1NonEmpty = function (dictUnfoldable) {\n    return {\n        unfoldr1: function (f) {\n            return function (b) {\n                return Data_Tuple.uncurry(NonEmpty.create)(Data_Functor.map(Data_Tuple.functorTuple)(Data_Unfoldable.unfoldr(dictUnfoldable)(Data_Functor.map(Data_Maybe.functorMaybe)(f)))(f(b)));\n            };\n        }\n    };\n};\nvar tail = function (v) {\n    return v.value1;\n};\nvar singleton = function (dictPlus) {\n    return function (a) {\n        return new NonEmpty(a, Control_Plus.empty(dictPlus));\n    };\n};\nvar showNonEmpty = function (dictShow) {\n    return function (dictShow1) {\n        return {\n            show: function (v) {\n                return \"(NonEmpty \" + (Data_Show.show(dictShow)(v.value0) + (\" \" + (Data_Show.show(dictShow1)(v.value1) + \")\")));\n            }\n        };\n    };\n};\nvar oneOf = function (dictAlternative) {\n    return function (v) {\n        return Control_Alt.alt((dictAlternative.Plus1()).Alt0())(Control_Applicative.pure(dictAlternative.Applicative0())(v.value0))(v.value1);\n    };\n};\nvar head = function (v) {\n    return v.value0;\n};\nvar functorNonEmpty = function (dictFunctor) {\n    return {\n        map: function (f) {\n            return function (m) {\n                return new NonEmpty(f(m.value0), Data_Functor.map(dictFunctor)(f)(m.value1));\n            };\n        }\n    };\n};\nvar functorWithIndex = function (dictFunctorWithIndex) {\n    return {\n        mapWithIndex: function (f) {\n            return function (v) {\n                return new NonEmpty(f(Data_Maybe.Nothing.value)(v.value0), Data_FunctorWithIndex.mapWithIndex(dictFunctorWithIndex)(function ($151) {\n                    return f(Data_Maybe.Just.create($151));\n                })(v.value1));\n            };\n        },\n        Functor0: function () {\n            return functorNonEmpty(dictFunctorWithIndex.Functor0());\n        }\n    };\n};\nvar fromNonEmpty = function (f) {\n    return function (v) {\n        return f(v.value0)(v.value1);\n    };\n};\nvar foldableNonEmpty = function (dictFoldable) {\n    return {\n        foldMap: function (dictMonoid) {\n            return function (f) {\n                return function (v) {\n                    return Data_Semigroup.append(dictMonoid.Semigroup0())(f(v.value0))(Data_Foldable.foldMap(dictFoldable)(dictMonoid)(f)(v.value1));\n                };\n            };\n        },\n        foldl: function (f) {\n            return function (b) {\n                return function (v) {\n                    return Data_Foldable.foldl(dictFoldable)(f)(f(b)(v.value0))(v.value1);\n                };\n            };\n        },\n        foldr: function (f) {\n            return function (b) {\n                return function (v) {\n                    return f(v.value0)(Data_Foldable.foldr(dictFoldable)(f)(b)(v.value1));\n                };\n            };\n        }\n    };\n};\nvar foldableWithIndexNonEmpty = function (dictFoldableWithIndex) {\n    return {\n        foldMapWithIndex: function (dictMonoid) {\n            return function (f) {\n                return function (v) {\n                    return Data_Semigroup.append(dictMonoid.Semigroup0())(f(Data_Maybe.Nothing.value)(v.value0))(Data_FoldableWithIndex.foldMapWithIndex(dictFoldableWithIndex)(dictMonoid)(function ($152) {\n                        return f(Data_Maybe.Just.create($152));\n                    })(v.value1));\n                };\n            };\n        },\n        foldlWithIndex: function (f) {\n            return function (b) {\n                return function (v) {\n                    return Data_FoldableWithIndex.foldlWithIndex(dictFoldableWithIndex)(function ($153) {\n                        return f(Data_Maybe.Just.create($153));\n                    })(f(Data_Maybe.Nothing.value)(b)(v.value0))(v.value1);\n                };\n            };\n        },\n        foldrWithIndex: function (f) {\n            return function (b) {\n                return function (v) {\n                    return f(Data_Maybe.Nothing.value)(v.value0)(Data_FoldableWithIndex.foldrWithIndex(dictFoldableWithIndex)(function ($154) {\n                        return f(Data_Maybe.Just.create($154));\n                    })(b)(v.value1));\n                };\n            };\n        },\n        Foldable0: function () {\n            return foldableNonEmpty(dictFoldableWithIndex.Foldable0());\n        }\n    };\n};\nvar traversableNonEmpty = function (dictTraversable) {\n    return {\n        sequence: function (dictApplicative) {\n            return function (v) {\n                return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(NonEmpty.create)(v.value0))(Data_Traversable.sequence(dictTraversable)(dictApplicative)(v.value1));\n            };\n        },\n        traverse: function (dictApplicative) {\n            return function (f) {\n                return function (v) {\n                    return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(NonEmpty.create)(f(v.value0)))(Data_Traversable.traverse(dictTraversable)(dictApplicative)(f)(v.value1));\n                };\n            };\n        },\n        Functor0: function () {\n            return functorNonEmpty(dictTraversable.Functor0());\n        },\n        Foldable1: function () {\n            return foldableNonEmpty(dictTraversable.Foldable1());\n        }\n    };\n};\nvar traversableWithIndexNonEmpty = function (dictTraversableWithIndex) {\n    return {\n        traverseWithIndex: function (dictApplicative) {\n            return function (f) {\n                return function (v) {\n                    return Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(NonEmpty.create)(f(Data_Maybe.Nothing.value)(v.value0)))(Data_TraversableWithIndex.traverseWithIndex(dictTraversableWithIndex)(dictApplicative)(function ($155) {\n                        return f(Data_Maybe.Just.create($155));\n                    })(v.value1));\n                };\n            };\n        },\n        FunctorWithIndex0: function () {\n            return functorWithIndex(dictTraversableWithIndex.FunctorWithIndex0());\n        },\n        FoldableWithIndex1: function () {\n            return foldableWithIndexNonEmpty(dictTraversableWithIndex.FoldableWithIndex1());\n        },\n        Traversable2: function () {\n            return traversableNonEmpty(dictTraversableWithIndex.Traversable2());\n        }\n    };\n};\nvar foldable1NonEmpty = function (dictFoldable) {\n    return {\n        foldMap1: function (dictSemigroup) {\n            return function (f) {\n                return function (v) {\n                    return Data_Foldable.foldl(dictFoldable)(function (s) {\n                        return function (a1) {\n                            return Data_Semigroup.append(dictSemigroup)(s)(f(a1));\n                        };\n                    })(f(v.value0))(v.value1);\n                };\n            };\n        },\n        foldr1: function (f) {\n            return function (v) {\n                return Data_Maybe.maybe(v.value0)(f(v.value0))(Data_Foldable.foldr(dictFoldable)(function (a1) {\n                    var $156 = Data_Maybe.maybe(a1)(f(a1));\n                    return function ($157) {\n                        return Data_Maybe.Just.create($156($157));\n                    };\n                })(Data_Maybe.Nothing.value)(v.value1));\n            };\n        },\n        foldl1: function (f) {\n            return function (v) {\n                return Data_Foldable.foldl(dictFoldable)(f)(v.value0)(v.value1);\n            };\n        },\n        Foldable0: function () {\n            return foldableNonEmpty(dictFoldable);\n        }\n    };\n};\nvar foldl1 = function (dictFoldable) {\n    return function (dictWarn) {\n        return Data_Semigroup_Foldable.foldl1(foldable1NonEmpty(dictFoldable));\n    };\n};\nvar eqNonEmpty = function (dictEq1) {\n    return function (dictEq) {\n        return {\n            eq: function (x) {\n                return function (y) {\n                    return Data_Eq.eq(dictEq)(x.value0)(y.value0) && Data_Eq.eq1(dictEq1)(dictEq)(x.value1)(y.value1);\n                };\n            }\n        };\n    };\n};\nvar ordNonEmpty = function (dictOrd1) {\n    return function (dictOrd) {\n        return {\n            compare: function (x) {\n                return function (y) {\n                    var v = Data_Ord.compare(dictOrd)(x.value0)(y.value0);\n                    if (v instanceof Data_Ordering.LT) {\n                        return Data_Ordering.LT.value;\n                    };\n                    if (v instanceof Data_Ordering.GT) {\n                        return Data_Ordering.GT.value;\n                    };\n                    return Data_Ord.compare1(dictOrd1)(dictOrd)(x.value1)(y.value1);\n                };\n            },\n            Eq0: function () {\n                return eqNonEmpty(dictOrd1.Eq10())(dictOrd.Eq0());\n            }\n        };\n    };\n};\nvar eq1NonEmpty = function (dictEq1) {\n    return {\n        eq1: function (dictEq) {\n            return Data_Eq.eq(eqNonEmpty(dictEq1)(dictEq));\n        }\n    };\n};\nvar ord1NonEmpty = function (dictOrd1) {\n    return {\n        compare1: function (dictOrd) {\n            return Data_Ord.compare(ordNonEmpty(dictOrd1)(dictOrd));\n        },\n        Eq10: function () {\n            return eq1NonEmpty(dictOrd1.Eq10());\n        }\n    };\n};\nmodule.exports = {\n    NonEmpty: NonEmpty,\n    singleton: singleton,\n    foldl1: foldl1,\n    fromNonEmpty: fromNonEmpty,\n    oneOf: oneOf,\n    head: head,\n    tail: tail,\n    showNonEmpty: showNonEmpty,\n    eqNonEmpty: eqNonEmpty,\n    eq1NonEmpty: eq1NonEmpty,\n    ordNonEmpty: ordNonEmpty,\n    ord1NonEmpty: ord1NonEmpty,\n    functorNonEmpty: functorNonEmpty,\n    functorWithIndex: functorWithIndex,\n    foldableNonEmpty: foldableNonEmpty,\n    foldableWithIndexNonEmpty: foldableWithIndexNonEmpty,\n    traversableNonEmpty: traversableNonEmpty,\n    traversableWithIndexNonEmpty: traversableWithIndexNonEmpty,\n    foldable1NonEmpty: foldable1NonEmpty,\n    unfoldable1NonEmpty: unfoldable1NonEmpty\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/nonempty/v6.0.0/src/Data/NonEmpty.purs?");

/***/ }),

/***/ "./.spago/numbers/v8.0.0/src/Data/Number.purs":
/*!****************************************************!*\
  !*** ./.spago/numbers/v8.0.0/src/Data/Number.purs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/numbers/v8.0.0/src/Data/Number.js */ \"./.spago/numbers/v8.0.0/src/Data/Number.js\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar fromString = function (str) {\n    return $foreign.fromStringImpl(str, $foreign[\"isFinite\"], Data_Maybe.Just.create, Data_Maybe.Nothing.value);\n};\nmodule.exports = {\n    fromString: fromString,\n    nan: $foreign.nan,\n    \"isNaN\": $foreign[\"isNaN\"],\n    infinity: $foreign.infinity,\n    \"isFinite\": $foreign[\"isFinite\"]\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/numbers/v8.0.0/src/Data/Number.purs?");

/***/ }),

/***/ "./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs":
/*!**********************************************************************!*\
  !*** ./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_FoldableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FoldableWithIndex.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_FunctorWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/FunctorWithIndex.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_List = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List.purs */ \"./.spago/lists/v6.0.1/src/Data/List.purs\");\nvar Data_List_Lazy = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Lazy.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Lazy.purs\");\nvar Data_List_Lazy_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Lazy/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Lazy/Types.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_TraversableWithIndex = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/TraversableWithIndex.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar Leaf = (function () {\n    function Leaf() {\n\n    };\n    Leaf.value = new Leaf();\n    return Leaf;\n})();\nvar Two = (function () {\n    function Two(value0, value1, value2, value3) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n    };\n    Two.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return new Two(value0, value1, value2, value3);\n                };\n            };\n        };\n    };\n    return Two;\n})();\nvar Three = (function () {\n    function Three(value0, value1, value2, value3, value4, value5, value6) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n        this.value4 = value4;\n        this.value5 = value5;\n        this.value6 = value6;\n    };\n    Three.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return function (value4) {\n                        return function (value5) {\n                            return function (value6) {\n                                return new Three(value0, value1, value2, value3, value4, value5, value6);\n                            };\n                        };\n                    };\n                };\n            };\n        };\n    };\n    return Three;\n})();\nvar TwoLeft = (function () {\n    function TwoLeft(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TwoLeft.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TwoLeft(value0, value1, value2);\n            };\n        };\n    };\n    return TwoLeft;\n})();\nvar TwoRight = (function () {\n    function TwoRight(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TwoRight.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TwoRight(value0, value1, value2);\n            };\n        };\n    };\n    return TwoRight;\n})();\nvar ThreeLeft = (function () {\n    function ThreeLeft(value0, value1, value2, value3, value4, value5) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n        this.value4 = value4;\n        this.value5 = value5;\n    };\n    ThreeLeft.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return function (value4) {\n                        return function (value5) {\n                            return new ThreeLeft(value0, value1, value2, value3, value4, value5);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    return ThreeLeft;\n})();\nvar ThreeMiddle = (function () {\n    function ThreeMiddle(value0, value1, value2, value3, value4, value5) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n        this.value4 = value4;\n        this.value5 = value5;\n    };\n    ThreeMiddle.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return function (value4) {\n                        return function (value5) {\n                            return new ThreeMiddle(value0, value1, value2, value3, value4, value5);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    return ThreeMiddle;\n})();\nvar ThreeRight = (function () {\n    function ThreeRight(value0, value1, value2, value3, value4, value5) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n        this.value4 = value4;\n        this.value5 = value5;\n    };\n    ThreeRight.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return function (value4) {\n                        return function (value5) {\n                            return new ThreeRight(value0, value1, value2, value3, value4, value5);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    return ThreeRight;\n})();\nvar KickUp = (function () {\n    function KickUp(value0, value1, value2, value3) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n    };\n    KickUp.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return new KickUp(value0, value1, value2, value3);\n                };\n            };\n        };\n    };\n    return KickUp;\n})();\nvar values = function (v) {\n    if (v instanceof Leaf) {\n        return Data_List_Types.Nil.value;\n    };\n    if (v instanceof Two) {\n        return Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value2))(values(v.value3)));\n    };\n    if (v instanceof Three) {\n        return Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value2))(Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value3))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value5))(values(v.value6)))));\n    };\n    throw new Error(\"Failed pattern match at Data.Map.Internal (line 626, column 1 - line 626, column 40): \" + [ v.constructor.name ]);\n};\nvar size = function (v) {\n    if (v instanceof Leaf) {\n        return 0;\n    };\n    if (v instanceof Two) {\n        return (1 + size(v.value0) | 0) + size(v.value3) | 0;\n    };\n    if (v instanceof Three) {\n        return ((2 + size(v.value0) | 0) + size(v.value3) | 0) + size(v.value6) | 0;\n    };\n    throw new Error(\"Failed pattern match at Data.Map.Internal (line 676, column 1 - line 676, column 35): \" + [ v.constructor.name ]);\n};\nvar singleton = function (k) {\n    return function (v) {\n        return new Two(Leaf.value, k, v, Leaf.value);\n    };\n};\nvar toUnfoldable = function (dictUnfoldable) {\n    return function (m) {\n        var go = function ($copy_v) {\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(v) {\n                if (v instanceof Data_List_Types.Nil) {\n                    $tco_done = true;\n                    return Data_Maybe.Nothing.value;\n                };\n                if (v instanceof Data_List_Types.Cons) {\n                    if (v.value0 instanceof Leaf) {\n                        $copy_v = v.value1;\n                        return;\n                    };\n                    if (v.value0 instanceof Two && (v.value0.value0 instanceof Leaf && v.value0.value3 instanceof Leaf)) {\n                        $tco_done = true;\n                        return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value1, v.value0.value2), v.value1));\n                    };\n                    if (v.value0 instanceof Two && v.value0.value0 instanceof Leaf) {\n                        $tco_done = true;\n                        return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value1, v.value0.value2), new Data_List_Types.Cons(v.value0.value3, v.value1)));\n                    };\n                    if (v.value0 instanceof Two) {\n                        $copy_v = new Data_List_Types.Cons(v.value0.value0, new Data_List_Types.Cons(singleton(v.value0.value1)(v.value0.value2), new Data_List_Types.Cons(v.value0.value3, v.value1)));\n                        return;\n                    };\n                    if (v.value0 instanceof Three) {\n                        $copy_v = new Data_List_Types.Cons(v.value0.value0, new Data_List_Types.Cons(singleton(v.value0.value1)(v.value0.value2), new Data_List_Types.Cons(v.value0.value3, new Data_List_Types.Cons(singleton(v.value0.value4)(v.value0.value5), new Data_List_Types.Cons(v.value0.value6, v.value1)))));\n                        return;\n                    };\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 591, column 18 - line 600, column 71): \" + [ v.value0.constructor.name ]);\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 590, column 3 - line 590, column 19): \" + [ v.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($copy_v);\n            };\n            return $tco_result;\n        };\n        return Data_Unfoldable.unfoldr(dictUnfoldable)(go)(new Data_List_Types.Cons(m, Data_List_Types.Nil.value));\n    };\n};\nvar toAscArray = toUnfoldable(Data_Unfoldable.unfoldableArray);\nvar toUnfoldableUnordered = function (dictUnfoldable) {\n    return function (m) {\n        var go = function ($copy_v) {\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(v) {\n                if (v instanceof Data_List_Types.Nil) {\n                    $tco_done = true;\n                    return Data_Maybe.Nothing.value;\n                };\n                if (v instanceof Data_List_Types.Cons) {\n                    if (v.value0 instanceof Leaf) {\n                        $copy_v = v.value1;\n                        return;\n                    };\n                    if (v.value0 instanceof Two) {\n                        $tco_done = true;\n                        return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value1, v.value0.value2), new Data_List_Types.Cons(v.value0.value0, new Data_List_Types.Cons(v.value0.value3, v.value1))));\n                    };\n                    if (v.value0 instanceof Three) {\n                        $tco_done = true;\n                        return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value1, v.value0.value2), new Data_List_Types.Cons(singleton(v.value0.value4)(v.value0.value5), new Data_List_Types.Cons(v.value0.value0, new Data_List_Types.Cons(v.value0.value3, new Data_List_Types.Cons(v.value0.value6, v.value1))))));\n                    };\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 612, column 18 - line 617, column 77): \" + [ v.value0.constructor.name ]);\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 611, column 3 - line 611, column 19): \" + [ v.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($copy_v);\n            };\n            return $tco_result;\n        };\n        return Data_Unfoldable.unfoldr(dictUnfoldable)(go)(new Data_List_Types.Cons(m, Data_List_Types.Nil.value));\n    };\n};\nvar showTree = function (dictShow) {\n    return function (dictShow1) {\n        return function (v) {\n            if (v instanceof Leaf) {\n                return \"Leaf\";\n            };\n            if (v instanceof Two) {\n                return \"Two (\" + (showTree(dictShow)(dictShow1)(v.value0) + (\") (\" + (Data_Show.show(dictShow)(v.value1) + (\") (\" + (Data_Show.show(dictShow1)(v.value2) + (\") (\" + (showTree(dictShow)(dictShow1)(v.value3) + \")\")))))));\n            };\n            if (v instanceof Three) {\n                return \"Three (\" + (showTree(dictShow)(dictShow1)(v.value0) + (\") (\" + (Data_Show.show(dictShow)(v.value1) + (\") (\" + (Data_Show.show(dictShow1)(v.value2) + (\") (\" + (showTree(dictShow)(dictShow1)(v.value3) + (\") (\" + (Data_Show.show(dictShow)(v.value4) + (\") (\" + (Data_Show.show(dictShow1)(v.value5) + (\") (\" + (showTree(dictShow)(dictShow1)(v.value6) + \")\")))))))))))));\n            };\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 164, column 1 - line 164, column 62): \" + [ v.constructor.name ]);\n        };\n    };\n};\nvar showMap = function (dictShow) {\n    return function (dictShow1) {\n        return {\n            show: function (m) {\n                return \"(fromFoldable \" + (Data_Show.show(Data_Show.showArray(Data_Tuple.showTuple(dictShow)(dictShow1)))(toAscArray(m)) + \")\");\n            }\n        };\n    };\n};\nvar lookupLE = function (dictOrd) {\n    return function (k) {\n        var comp = Data_Ord.compare(dictOrd);\n        var go = function (v) {\n            if (v instanceof Leaf) {\n                return Data_Maybe.Nothing.value;\n            };\n            if (v instanceof Two) {\n                var v2 = comp(k)(v.value1);\n                if (v2 instanceof Data_Ordering.EQ) {\n                    return new Data_Maybe.Just({\n                        key: v.value1,\n                        value: v.value2\n                    });\n                };\n                if (v2 instanceof Data_Ordering.GT) {\n                    return Data_Maybe.Just.create(Data_Maybe.fromMaybe({\n                        key: v.value1,\n                        value: v.value2\n                    })(go(v.value3)));\n                };\n                if (v2 instanceof Data_Ordering.LT) {\n                    return go(v.value0);\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 236, column 33 - line 239, column 20): \" + [ v2.constructor.name ]);\n            };\n            if (v instanceof Three) {\n                var v3 = comp(k)(v.value4);\n                if (v3 instanceof Data_Ordering.EQ) {\n                    return new Data_Maybe.Just({\n                        key: v.value4,\n                        value: v.value5\n                    });\n                };\n                if (v3 instanceof Data_Ordering.GT) {\n                    return Data_Maybe.Just.create(Data_Maybe.fromMaybe({\n                        key: v.value4,\n                        value: v.value5\n                    })(go(v.value6)));\n                };\n                if (v3 instanceof Data_Ordering.LT) {\n                    return go(new Two(v.value0, v.value1, v.value2, v.value3));\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 240, column 45 - line 243, column 36): \" + [ v3.constructor.name ]);\n            };\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 235, column 5 - line 235, column 22): \" + [ v.constructor.name ]);\n        };\n        return go;\n    };\n};\nvar lookupGE = function (dictOrd) {\n    return function (k) {\n        var comp = Data_Ord.compare(dictOrd);\n        var go = function (v) {\n            if (v instanceof Leaf) {\n                return Data_Maybe.Nothing.value;\n            };\n            if (v instanceof Two) {\n                var v2 = comp(k)(v.value1);\n                if (v2 instanceof Data_Ordering.EQ) {\n                    return new Data_Maybe.Just({\n                        key: v.value1,\n                        value: v.value2\n                    });\n                };\n                if (v2 instanceof Data_Ordering.LT) {\n                    return Data_Maybe.Just.create(Data_Maybe.fromMaybe({\n                        key: v.value1,\n                        value: v.value2\n                    })(go(v.value0)));\n                };\n                if (v2 instanceof Data_Ordering.GT) {\n                    return go(v.value3);\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 270, column 33 - line 273, column 21): \" + [ v2.constructor.name ]);\n            };\n            if (v instanceof Three) {\n                var v3 = comp(k)(v.value1);\n                if (v3 instanceof Data_Ordering.EQ) {\n                    return new Data_Maybe.Just({\n                        key: v.value1,\n                        value: v.value2\n                    });\n                };\n                if (v3 instanceof Data_Ordering.LT) {\n                    return Data_Maybe.Just.create(Data_Maybe.fromMaybe({\n                        key: v.value1,\n                        value: v.value2\n                    })(go(v.value0)));\n                };\n                if (v3 instanceof Data_Ordering.GT) {\n                    return go(new Two(v.value3, v.value4, v.value5, v.value6));\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 274, column 45 - line 277, column 37): \" + [ v3.constructor.name ]);\n            };\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 269, column 5 - line 269, column 22): \" + [ v.constructor.name ]);\n        };\n        return go;\n    };\n};\nvar lookup = function (dictOrd) {\n    return function (k) {\n        var comp = Data_Ord.compare(dictOrd);\n        var go = function ($copy_v) {\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(v) {\n                if (v instanceof Leaf) {\n                    $tco_done = true;\n                    return Data_Maybe.Nothing.value;\n                };\n                if (v instanceof Two) {\n                    var v2 = comp(k)(v.value1);\n                    if (v2 instanceof Data_Ordering.EQ) {\n                        $tco_done = true;\n                        return new Data_Maybe.Just(v.value2);\n                    };\n                    if (v2 instanceof Data_Ordering.LT) {\n                        $copy_v = v.value0;\n                        return;\n                    };\n                    $copy_v = v.value3;\n                    return;\n                };\n                if (v instanceof Three) {\n                    var v3 = comp(k)(v.value1);\n                    if (v3 instanceof Data_Ordering.EQ) {\n                        $tco_done = true;\n                        return new Data_Maybe.Just(v.value2);\n                    };\n                    var v4 = comp(k)(v.value4);\n                    if (v4 instanceof Data_Ordering.EQ) {\n                        $tco_done = true;\n                        return new Data_Maybe.Just(v.value5);\n                    };\n                    if (v3 instanceof Data_Ordering.LT) {\n                        $copy_v = v.value0;\n                        return;\n                    };\n                    if (v4 instanceof Data_Ordering.GT) {\n                        $copy_v = v.value6;\n                        return;\n                    };\n                    $copy_v = v.value3;\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 211, column 5 - line 211, column 22): \" + [ v.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($copy_v);\n            };\n            return $tco_result;\n        };\n        return go;\n    };\n};\nvar member = function (dictOrd) {\n    return function (k) {\n        return function (m) {\n            return Data_Maybe.isJust(lookup(dictOrd)(k)(m));\n        };\n    };\n};\nvar keys = function (v) {\n    if (v instanceof Leaf) {\n        return Data_List_Types.Nil.value;\n    };\n    if (v instanceof Two) {\n        return Data_Semigroup.append(Data_List_Types.semigroupList)(keys(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value1))(keys(v.value3)));\n    };\n    if (v instanceof Three) {\n        return Data_Semigroup.append(Data_List_Types.semigroupList)(keys(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value1))(Data_Semigroup.append(Data_List_Types.semigroupList)(keys(v.value3))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value4))(keys(v.value6)))));\n    };\n    throw new Error(\"Failed pattern match at Data.Map.Internal (line 620, column 1 - line 620, column 38): \" + [ v.constructor.name ]);\n};\nvar isSubmap = function (dictOrd) {\n    return function (dictEq) {\n        return function (m1) {\n            return function (m2) {\n                var f = function (v) {\n                    return Data_Eq.eq(Data_Maybe.eqMaybe(dictEq))(lookup(dictOrd)(v.value0)(m2))(new Data_Maybe.Just(v.value1));\n                };\n                return Data_Foldable.all(Data_List_Lazy_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(f)(toUnfoldable(Data_List_Lazy_Types.unfoldableList)(m1));\n            };\n        };\n    };\n};\nvar isEmpty = function (v) {\n    if (v instanceof Leaf) {\n        return true;\n    };\n    return false;\n};\nvar functorMap = {\n    map: function (v) {\n        return function (v1) {\n            if (v1 instanceof Leaf) {\n                return Leaf.value;\n            };\n            if (v1 instanceof Two) {\n                return new Two(Data_Functor.map(functorMap)(v)(v1.value0), v1.value1, v(v1.value2), Data_Functor.map(functorMap)(v)(v1.value3));\n            };\n            if (v1 instanceof Three) {\n                return new Three(Data_Functor.map(functorMap)(v)(v1.value0), v1.value1, v(v1.value2), Data_Functor.map(functorMap)(v)(v1.value3), v1.value4, v(v1.value5), Data_Functor.map(functorMap)(v)(v1.value6));\n            };\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 101, column 1 - line 104, column 110): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    }\n};\nvar functorWithIndexMap = {\n    mapWithIndex: function (v) {\n        return function (v1) {\n            if (v1 instanceof Leaf) {\n                return Leaf.value;\n            };\n            if (v1 instanceof Two) {\n                return new Two(Data_FunctorWithIndex.mapWithIndex(functorWithIndexMap)(v)(v1.value0), v1.value1, v(v1.value1)(v1.value2), Data_FunctorWithIndex.mapWithIndex(functorWithIndexMap)(v)(v1.value3));\n            };\n            if (v1 instanceof Three) {\n                return new Three(Data_FunctorWithIndex.mapWithIndex(functorWithIndexMap)(v)(v1.value0), v1.value1, v(v1.value1)(v1.value2), Data_FunctorWithIndex.mapWithIndex(functorWithIndexMap)(v)(v1.value3), v1.value4, v(v1.value4)(v1.value5), Data_FunctorWithIndex.mapWithIndex(functorWithIndexMap)(v)(v1.value6));\n            };\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 106, column 1 - line 109, column 152): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    },\n    Functor0: function () {\n        return functorMap;\n    }\n};\nvar fromZipper = function ($copy_dictOrd) {\n    return function ($copy_v) {\n        return function ($copy_tree) {\n            var $tco_var_dictOrd = $copy_dictOrd;\n            var $tco_var_v = $copy_v;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(dictOrd, v, tree) {\n                if (v instanceof Data_List_Types.Nil) {\n                    $tco_done = true;\n                    return tree;\n                };\n                if (v instanceof Data_List_Types.Cons) {\n                    if (v.value0 instanceof TwoLeft) {\n                        $tco_var_dictOrd = dictOrd;\n                        $tco_var_v = v.value1;\n                        $copy_tree = new Two(tree, v.value0.value0, v.value0.value1, v.value0.value2);\n                        return;\n                    };\n                    if (v.value0 instanceof TwoRight) {\n                        $tco_var_dictOrd = dictOrd;\n                        $tco_var_v = v.value1;\n                        $copy_tree = new Two(v.value0.value0, v.value0.value1, v.value0.value2, tree);\n                        return;\n                    };\n                    if (v.value0 instanceof ThreeLeft) {\n                        $tco_var_dictOrd = dictOrd;\n                        $tco_var_v = v.value1;\n                        $copy_tree = new Three(tree, v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5);\n                        return;\n                    };\n                    if (v.value0 instanceof ThreeMiddle) {\n                        $tco_var_dictOrd = dictOrd;\n                        $tco_var_v = v.value1;\n                        $copy_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, tree, v.value0.value3, v.value0.value4, v.value0.value5);\n                        return;\n                    };\n                    if (v.value0 instanceof ThreeRight) {\n                        $tco_var_dictOrd = dictOrd;\n                        $tco_var_v = v.value1;\n                        $copy_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5, tree);\n                        return;\n                    };\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 432, column 3 - line 437, column 88): \" + [ v.value0.constructor.name ]);\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 429, column 1 - line 429, column 80): \" + [ v.constructor.name, tree.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_dictOrd, $tco_var_v, $copy_tree);\n            };\n            return $tco_result;\n        };\n    };\n};\nvar insert = function (dictOrd) {\n    return function (k) {\n        return function (v) {\n            var up = function ($copy_v1) {\n                return function ($copy_v2) {\n                    var $tco_var_v1 = $copy_v1;\n                    var $tco_done = false;\n                    var $tco_result;\n                    function $tco_loop(v1, v2) {\n                        if (v1 instanceof Data_List_Types.Nil) {\n                            $tco_done = true;\n                            return new Two(v2.value0, v2.value1, v2.value2, v2.value3);\n                        };\n                        if (v1 instanceof Data_List_Types.Cons) {\n                            if (v1.value0 instanceof TwoLeft) {\n                                $tco_done = true;\n                                return fromZipper(dictOrd)(v1.value1)(new Three(v2.value0, v2.value1, v2.value2, v2.value3, v1.value0.value0, v1.value0.value1, v1.value0.value2));\n                            };\n                            if (v1.value0 instanceof TwoRight) {\n                                $tco_done = true;\n                                return fromZipper(dictOrd)(v1.value1)(new Three(v1.value0.value0, v1.value0.value1, v1.value0.value2, v2.value0, v2.value1, v2.value2, v2.value3));\n                            };\n                            if (v1.value0 instanceof ThreeLeft) {\n                                $tco_var_v1 = v1.value1;\n                                $copy_v2 = new KickUp(new Two(v2.value0, v2.value1, v2.value2, v2.value3), v1.value0.value0, v1.value0.value1, new Two(v1.value0.value2, v1.value0.value3, v1.value0.value4, v1.value0.value5));\n                                return;\n                            };\n                            if (v1.value0 instanceof ThreeMiddle) {\n                                $tco_var_v1 = v1.value1;\n                                $copy_v2 = new KickUp(new Two(v1.value0.value0, v1.value0.value1, v1.value0.value2, v2.value0), v2.value1, v2.value2, new Two(v2.value3, v1.value0.value3, v1.value0.value4, v1.value0.value5));\n                                return;\n                            };\n                            if (v1.value0 instanceof ThreeRight) {\n                                $tco_var_v1 = v1.value1;\n                                $copy_v2 = new KickUp(new Two(v1.value0.value0, v1.value0.value1, v1.value0.value2, v1.value0.value3), v1.value0.value4, v1.value0.value5, new Two(v2.value0, v2.value1, v2.value2, v2.value3));\n                                return;\n                            };\n                            throw new Error(\"Failed pattern match at Data.Map.Internal (line 468, column 5 - line 473, column 108): \" + [ v1.value0.constructor.name, v2.constructor.name ]);\n                        };\n                        throw new Error(\"Failed pattern match at Data.Map.Internal (line 465, column 3 - line 465, column 56): \" + [ v1.constructor.name, v2.constructor.name ]);\n                    };\n                    while (!$tco_done) {\n                        $tco_result = $tco_loop($tco_var_v1, $copy_v2);\n                    };\n                    return $tco_result;\n                };\n            };\n            var comp = Data_Ord.compare(dictOrd);\n            var down = function ($copy_ctx) {\n                return function ($copy_v1) {\n                    var $tco_var_ctx = $copy_ctx;\n                    var $tco_done1 = false;\n                    var $tco_result;\n                    function $tco_loop(ctx, v1) {\n                        if (v1 instanceof Leaf) {\n                            $tco_done1 = true;\n                            return up(ctx)(new KickUp(Leaf.value, k, v, Leaf.value));\n                        };\n                        if (v1 instanceof Two) {\n                            var v2 = comp(k)(v1.value1);\n                            if (v2 instanceof Data_Ordering.EQ) {\n                                $tco_done1 = true;\n                                return fromZipper(dictOrd)(ctx)(new Two(v1.value0, k, v, v1.value3));\n                            };\n                            if (v2 instanceof Data_Ordering.LT) {\n                                $tco_var_ctx = new Data_List_Types.Cons(new TwoLeft(v1.value1, v1.value2, v1.value3), ctx);\n                                $copy_v1 = v1.value0;\n                                return;\n                            };\n                            $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(v1.value0, v1.value1, v1.value2), ctx);\n                            $copy_v1 = v1.value3;\n                            return;\n                        };\n                        if (v1 instanceof Three) {\n                            var v3 = comp(k)(v1.value1);\n                            if (v3 instanceof Data_Ordering.EQ) {\n                                $tco_done1 = true;\n                                return fromZipper(dictOrd)(ctx)(new Three(v1.value0, k, v, v1.value3, v1.value4, v1.value5, v1.value6));\n                            };\n                            var v4 = comp(k)(v1.value4);\n                            if (v4 instanceof Data_Ordering.EQ) {\n                                $tco_done1 = true;\n                                return fromZipper(dictOrd)(ctx)(new Three(v1.value0, v1.value1, v1.value2, v1.value3, k, v, v1.value6));\n                            };\n                            if (v3 instanceof Data_Ordering.LT) {\n                                $tco_var_ctx = new Data_List_Types.Cons(new ThreeLeft(v1.value1, v1.value2, v1.value3, v1.value4, v1.value5, v1.value6), ctx);\n                                $copy_v1 = v1.value0;\n                                return;\n                            };\n                            if (v3 instanceof Data_Ordering.GT && v4 instanceof Data_Ordering.LT) {\n                                $tco_var_ctx = new Data_List_Types.Cons(new ThreeMiddle(v1.value0, v1.value1, v1.value2, v1.value4, v1.value5, v1.value6), ctx);\n                                $copy_v1 = v1.value3;\n                                return;\n                            };\n                            $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(v1.value0, v1.value1, v1.value2, v1.value3, v1.value4, v1.value5), ctx);\n                            $copy_v1 = v1.value6;\n                            return;\n                        };\n                        throw new Error(\"Failed pattern match at Data.Map.Internal (line 448, column 3 - line 448, column 55): \" + [ ctx.constructor.name, v1.constructor.name ]);\n                    };\n                    while (!$tco_done1) {\n                        $tco_result = $tco_loop($tco_var_ctx, $copy_v1);\n                    };\n                    return $tco_result;\n                };\n            };\n            return down(Data_List_Types.Nil.value);\n        };\n    };\n};\nvar pop = function (dictOrd) {\n    return function (k) {\n        var up = function ($copy_ctxs) {\n            return function ($copy_tree) {\n                var $tco_var_ctxs = $copy_ctxs;\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(ctxs, tree) {\n                    if (ctxs instanceof Data_List_Types.Nil) {\n                        $tco_done = true;\n                        return tree;\n                    };\n                    if (ctxs instanceof Data_List_Types.Cons) {\n                        if (ctxs.value0 instanceof TwoLeft && (ctxs.value0.value2 instanceof Leaf && tree instanceof Leaf)) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Two(Leaf.value, ctxs.value0.value0, ctxs.value0.value1, Leaf.value));\n                        };\n                        if (ctxs.value0 instanceof TwoRight && (ctxs.value0.value0 instanceof Leaf && tree instanceof Leaf)) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Two(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value));\n                        };\n                        if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Two) {\n                            $tco_var_ctxs = ctxs.value1;\n                            $copy_tree = new Three(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0, ctxs.value0.value2.value1, ctxs.value0.value2.value2, ctxs.value0.value2.value3);\n                            return;\n                        };\n                        if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Two) {\n                            $tco_var_ctxs = ctxs.value1;\n                            $copy_tree = new Three(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3, ctxs.value0.value1, ctxs.value0.value2, tree);\n                            return;\n                        };\n                        if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Three) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Two(new Two(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0), ctxs.value0.value2.value1, ctxs.value0.value2.value2, new Two(ctxs.value0.value2.value3, ctxs.value0.value2.value4, ctxs.value0.value2.value5, ctxs.value0.value2.value6)));\n                        };\n                        if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Three) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Two(new Two(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3), ctxs.value0.value0.value4, ctxs.value0.value0.value5, new Two(ctxs.value0.value0.value6, ctxs.value0.value1, ctxs.value0.value2, tree)));\n                        };\n                        if (ctxs.value0 instanceof ThreeLeft && (ctxs.value0.value2 instanceof Leaf && (ctxs.value0.value5 instanceof Leaf && tree instanceof Leaf))) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value0, ctxs.value0.value1, Leaf.value, ctxs.value0.value3, ctxs.value0.value4, Leaf.value));\n                        };\n                        if (ctxs.value0 instanceof ThreeMiddle && (ctxs.value0.value0 instanceof Leaf && (ctxs.value0.value5 instanceof Leaf && tree instanceof Leaf))) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value, ctxs.value0.value3, ctxs.value0.value4, Leaf.value));\n                        };\n                        if (ctxs.value0 instanceof ThreeRight && (ctxs.value0.value0 instanceof Leaf && (ctxs.value0.value3 instanceof Leaf && tree instanceof Leaf))) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value, ctxs.value0.value4, ctxs.value0.value5, Leaf.value));\n                        };\n                        if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Two) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Two(new Three(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0, ctxs.value0.value2.value1, ctxs.value0.value2.value2, ctxs.value0.value2.value3), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));\n                        };\n                        if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Two) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Two(new Three(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3, ctxs.value0.value1, ctxs.value0.value2, tree), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));\n                        };\n                        if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value5 instanceof Two) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Two(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Three(tree, ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5.value0, ctxs.value0.value5.value1, ctxs.value0.value5.value2, ctxs.value0.value5.value3)));\n                        };\n                        if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value3 instanceof Two) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Two(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Three(ctxs.value0.value3.value0, ctxs.value0.value3.value1, ctxs.value0.value3.value2, ctxs.value0.value3.value3, ctxs.value0.value4, ctxs.value0.value5, tree)));\n                        };\n                        if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Three) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Three(new Two(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0), ctxs.value0.value2.value1, ctxs.value0.value2.value2, new Two(ctxs.value0.value2.value3, ctxs.value0.value2.value4, ctxs.value0.value2.value5, ctxs.value0.value2.value6), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));\n                        };\n                        if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Three) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Three(new Two(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3), ctxs.value0.value0.value4, ctxs.value0.value0.value5, new Two(ctxs.value0.value0.value6, ctxs.value0.value1, ctxs.value0.value2, tree), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));\n                        };\n                        if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value5 instanceof Three) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Three(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Two(tree, ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5.value0), ctxs.value0.value5.value1, ctxs.value0.value5.value2, new Two(ctxs.value0.value5.value3, ctxs.value0.value5.value4, ctxs.value0.value5.value5, ctxs.value0.value5.value6)));\n                        };\n                        if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value3 instanceof Three) {\n                            $tco_done = true;\n                            return fromZipper(dictOrd)(ctxs.value1)(new Three(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Two(ctxs.value0.value3.value0, ctxs.value0.value3.value1, ctxs.value0.value3.value2, ctxs.value0.value3.value3), ctxs.value0.value3.value4, ctxs.value0.value3.value5, new Two(ctxs.value0.value3.value6, ctxs.value0.value4, ctxs.value0.value5, tree)));\n                        };\n                        throw new Error(\"Failed pattern match at Data.Map.Internal (line 525, column 9 - line 542, column 136): \" + [ ctxs.value0.constructor.name, tree.constructor.name ]);\n                    };\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 522, column 5 - line 542, column 136): \" + [ ctxs.constructor.name ]);\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($tco_var_ctxs, $copy_tree);\n                };\n                return $tco_result;\n            };\n        };\n        var removeMaxNode = function ($copy_ctx) {\n            return function ($copy_m) {\n                var $tco_var_ctx = $copy_ctx;\n                var $tco_done1 = false;\n                var $tco_result;\n                function $tco_loop(ctx, m) {\n                    if (m instanceof Two && (m.value0 instanceof Leaf && m.value3 instanceof Leaf)) {\n                        $tco_done1 = true;\n                        return up(ctx)(Leaf.value);\n                    };\n                    if (m instanceof Two) {\n                        $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(m.value0, m.value1, m.value2), ctx);\n                        $copy_m = m.value3;\n                        return;\n                    };\n                    if (m instanceof Three && (m.value0 instanceof Leaf && (m.value3 instanceof Leaf && m.value6 instanceof Leaf))) {\n                        $tco_done1 = true;\n                        return up(new Data_List_Types.Cons(new TwoRight(Leaf.value, m.value1, m.value2), ctx))(Leaf.value);\n                    };\n                    if (m instanceof Three) {\n                        $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(m.value0, m.value1, m.value2, m.value3, m.value4, m.value5), ctx);\n                        $copy_m = m.value6;\n                        return;\n                    };\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 554, column 5 - line 558, column 107): \" + [ m.constructor.name ]);\n                };\n                while (!$tco_done1) {\n                    $tco_result = $tco_loop($tco_var_ctx, $copy_m);\n                };\n                return $tco_result;\n            };\n        };\n        var maxNode = function ($copy_m) {\n            var $tco_done2 = false;\n            var $tco_result;\n            function $tco_loop(m) {\n                if (m instanceof Two && m.value3 instanceof Leaf) {\n                    $tco_done2 = true;\n                    return {\n                        key: m.value1,\n                        value: m.value2\n                    };\n                };\n                if (m instanceof Two) {\n                    $copy_m = m.value3;\n                    return;\n                };\n                if (m instanceof Three && m.value6 instanceof Leaf) {\n                    $tco_done2 = true;\n                    return {\n                        key: m.value4,\n                        value: m.value5\n                    };\n                };\n                if (m instanceof Three) {\n                    $copy_m = m.value6;\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 545, column 33 - line 549, column 45): \" + [ m.constructor.name ]);\n            };\n            while (!$tco_done2) {\n                $tco_result = $tco_loop($copy_m);\n            };\n            return $tco_result;\n        };\n        var comp = Data_Ord.compare(dictOrd);\n        var down = function ($copy_ctx) {\n            return function ($copy_m) {\n                var $tco_var_ctx = $copy_ctx;\n                var $tco_done3 = false;\n                var $tco_result;\n                function $tco_loop(ctx, m) {\n                    if (m instanceof Leaf) {\n                        $tco_done3 = true;\n                        return Data_Maybe.Nothing.value;\n                    };\n                    if (m instanceof Two) {\n                        var v = comp(k)(m.value1);\n                        if (m.value3 instanceof Leaf && v instanceof Data_Ordering.EQ) {\n                            $tco_done3 = true;\n                            return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, up(ctx)(Leaf.value)));\n                        };\n                        if (v instanceof Data_Ordering.EQ) {\n                            var max = maxNode(m.value0);\n                            $tco_done3 = true;\n                            return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, removeMaxNode(new Data_List_Types.Cons(new TwoLeft(max.key, max.value, m.value3), ctx))(m.value0)));\n                        };\n                        if (v instanceof Data_Ordering.LT) {\n                            $tco_var_ctx = new Data_List_Types.Cons(new TwoLeft(m.value1, m.value2, m.value3), ctx);\n                            $copy_m = m.value0;\n                            return;\n                        };\n                        $tco_var_ctx = new Data_List_Types.Cons(new TwoRight(m.value0, m.value1, m.value2), ctx);\n                        $copy_m = m.value3;\n                        return;\n                    };\n                    if (m instanceof Three) {\n                        var leaves = (function () {\n                            if (m.value0 instanceof Leaf && (m.value3 instanceof Leaf && m.value6 instanceof Leaf)) {\n                                return true;\n                            };\n                            return false;\n                        })();\n                        var v = comp(k)(m.value4);\n                        var v3 = comp(k)(m.value1);\n                        if (leaves && v3 instanceof Data_Ordering.EQ) {\n                            $tco_done3 = true;\n                            return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, fromZipper(dictOrd)(ctx)(new Two(Leaf.value, m.value4, m.value5, Leaf.value))));\n                        };\n                        if (leaves && v instanceof Data_Ordering.EQ) {\n                            $tco_done3 = true;\n                            return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value5, fromZipper(dictOrd)(ctx)(new Two(Leaf.value, m.value1, m.value2, Leaf.value))));\n                        };\n                        if (v3 instanceof Data_Ordering.EQ) {\n                            var max = maxNode(m.value0);\n                            $tco_done3 = true;\n                            return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, removeMaxNode(new Data_List_Types.Cons(new ThreeLeft(max.key, max.value, m.value3, m.value4, m.value5, m.value6), ctx))(m.value0)));\n                        };\n                        if (v instanceof Data_Ordering.EQ) {\n                            var max = maxNode(m.value3);\n                            $tco_done3 = true;\n                            return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value5, removeMaxNode(new Data_List_Types.Cons(new ThreeMiddle(m.value0, m.value1, m.value2, max.key, max.value, m.value6), ctx))(m.value3)));\n                        };\n                        if (v3 instanceof Data_Ordering.LT) {\n                            $tco_var_ctx = new Data_List_Types.Cons(new ThreeLeft(m.value1, m.value2, m.value3, m.value4, m.value5, m.value6), ctx);\n                            $copy_m = m.value0;\n                            return;\n                        };\n                        if (v3 instanceof Data_Ordering.GT && v instanceof Data_Ordering.LT) {\n                            $tco_var_ctx = new Data_List_Types.Cons(new ThreeMiddle(m.value0, m.value1, m.value2, m.value4, m.value5, m.value6), ctx);\n                            $copy_m = m.value3;\n                            return;\n                        };\n                        $tco_var_ctx = new Data_List_Types.Cons(new ThreeRight(m.value0, m.value1, m.value2, m.value3, m.value4, m.value5), ctx);\n                        $copy_m = m.value6;\n                        return;\n                    };\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 495, column 34 - line 518, column 80): \" + [ m.constructor.name ]);\n                };\n                while (!$tco_done3) {\n                    $tco_result = $tco_loop($tco_var_ctx, $copy_m);\n                };\n                return $tco_result;\n            };\n        };\n        return down(Data_List_Types.Nil.value);\n    };\n};\nvar foldableMap = {\n    foldl: function (f) {\n        return function (z) {\n            return function (m) {\n                return Data_Foldable.foldl(Data_List_Types.foldableList)(f)(z)(values(m));\n            };\n        };\n    },\n    foldr: function (f) {\n        return function (z) {\n            return function (m) {\n                return Data_Foldable.foldr(Data_List_Types.foldableList)(f)(z)(values(m));\n            };\n        };\n    },\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            return function (m) {\n                return Data_Foldable.foldMap(Data_List_Types.foldableList)(dictMonoid)(f)(values(m));\n            };\n        };\n    }\n};\nvar traversableMap = {\n    traverse: function (dictApplicative) {\n        return function (v) {\n            return function (v1) {\n                if (v1 instanceof Leaf) {\n                    return Control_Applicative.pure(dictApplicative)(Leaf.value);\n                };\n                if (v1 instanceof Two) {\n                    return Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(Two.create)(Data_Traversable.traverse(traversableMap)(dictApplicative)(v)(v1.value0)))(Control_Applicative.pure(dictApplicative)(v1.value1)))(v(v1.value2)))(Data_Traversable.traverse(traversableMap)(dictApplicative)(v)(v1.value3));\n                };\n                if (v1 instanceof Three) {\n                    return Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(Three.create)(Data_Traversable.traverse(traversableMap)(dictApplicative)(v)(v1.value0)))(Control_Applicative.pure(dictApplicative)(v1.value1)))(v(v1.value2)))(Data_Traversable.traverse(traversableMap)(dictApplicative)(v)(v1.value3)))(Control_Applicative.pure(dictApplicative)(v1.value4)))(v(v1.value5)))(Data_Traversable.traverse(traversableMap)(dictApplicative)(v)(v1.value6));\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 127, column 1 - line 142, column 31): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    sequence: function (dictApplicative) {\n        return Data_Traversable.traverse(traversableMap)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));\n    },\n    Functor0: function () {\n        return functorMap;\n    },\n    Foldable1: function () {\n        return foldableMap;\n    }\n};\nvar foldSubmapBy = function (dictOrd) {\n    return function (appendFn) {\n        return function (memptyValue) {\n            return function (kmin) {\n                return function (kmax) {\n                    return function (f) {\n                        var tooSmall = (function () {\n                            if (kmin instanceof Data_Maybe.Just) {\n                                return function (k) {\n                                    return Data_Ord.lessThan(dictOrd)(k)(kmin.value0);\n                                };\n                            };\n                            if (kmin instanceof Data_Maybe.Nothing) {\n                                return Data_Function[\"const\"](false);\n                            };\n                            throw new Error(\"Failed pattern match at Data.Map.Internal (line 333, column 7 - line 337, column 22): \" + [ kmin.constructor.name ]);\n                        })();\n                        var tooLarge = (function () {\n                            if (kmax instanceof Data_Maybe.Just) {\n                                return function (k) {\n                                    return Data_Ord.greaterThan(dictOrd)(k)(kmax.value0);\n                                };\n                            };\n                            if (kmax instanceof Data_Maybe.Nothing) {\n                                return Data_Function[\"const\"](false);\n                            };\n                            throw new Error(\"Failed pattern match at Data.Map.Internal (line 340, column 7 - line 344, column 22): \" + [ kmax.constructor.name ]);\n                        })();\n                        var inBounds = (function () {\n                            if (kmin instanceof Data_Maybe.Just && kmax instanceof Data_Maybe.Just) {\n                                return function (k) {\n                                    return Data_Ord.lessThanOrEq(dictOrd)(kmin.value0)(k) && Data_Ord.lessThanOrEq(dictOrd)(k)(kmax.value0);\n                                };\n                            };\n                            if (kmin instanceof Data_Maybe.Just && kmax instanceof Data_Maybe.Nothing) {\n                                return function (k) {\n                                    return Data_Ord.lessThanOrEq(dictOrd)(kmin.value0)(k);\n                                };\n                            };\n                            if (kmin instanceof Data_Maybe.Nothing && kmax instanceof Data_Maybe.Just) {\n                                return function (k) {\n                                    return Data_Ord.lessThanOrEq(dictOrd)(k)(kmax.value0);\n                                };\n                            };\n                            if (kmin instanceof Data_Maybe.Nothing && kmax instanceof Data_Maybe.Nothing) {\n                                return Data_Function[\"const\"](true);\n                            };\n                            throw new Error(\"Failed pattern match at Data.Map.Internal (line 347, column 7 - line 355, column 21): \" + [ kmin.constructor.name, kmax.constructor.name ]);\n                        })();\n                        var go = function (v) {\n                            if (v instanceof Leaf) {\n                                return memptyValue;\n                            };\n                            if (v instanceof Two) {\n                                return appendFn(appendFn((function () {\n                                    var $639 = tooSmall(v.value1);\n                                    if ($639) {\n                                        return memptyValue;\n                                    };\n                                    return go(v.value0);\n                                })())((function () {\n                                    var $640 = inBounds(v.value1);\n                                    if ($640) {\n                                        return f(v.value1)(v.value2);\n                                    };\n                                    return memptyValue;\n                                })()))((function () {\n                                    var $641 = tooLarge(v.value1);\n                                    if ($641) {\n                                        return memptyValue;\n                                    };\n                                    return go(v.value3);\n                                })());\n                            };\n                            if (v instanceof Three) {\n                                return appendFn(appendFn(appendFn(appendFn((function () {\n                                    var $646 = tooSmall(v.value1);\n                                    if ($646) {\n                                        return memptyValue;\n                                    };\n                                    return go(v.value0);\n                                })())((function () {\n                                    var $647 = inBounds(v.value1);\n                                    if ($647) {\n                                        return f(v.value1)(v.value2);\n                                    };\n                                    return memptyValue;\n                                })()))((function () {\n                                    var $648 = tooSmall(v.value4) || tooLarge(v.value1);\n                                    if ($648) {\n                                        return memptyValue;\n                                    };\n                                    return go(v.value3);\n                                })()))((function () {\n                                    var $649 = inBounds(v.value4);\n                                    if ($649) {\n                                        return f(v.value4)(v.value5);\n                                    };\n                                    return memptyValue;\n                                })()))((function () {\n                                    var $650 = tooLarge(v.value4);\n                                    if ($650) {\n                                        return memptyValue;\n                                    };\n                                    return go(v.value6);\n                                })());\n                            };\n                            throw new Error(\"Failed pattern match at Data.Map.Internal (line 373, column 10 - line 385, column 67): \" + [ v.constructor.name ]);\n                        };\n                        return go;\n                    };\n                };\n            };\n        };\n    };\n};\nvar foldSubmap = function (dictOrd) {\n    return function (dictMonoid) {\n        return foldSubmapBy(dictOrd)(Data_Semigroup.append(dictMonoid.Semigroup0()))(Data_Monoid.mempty(dictMonoid));\n    };\n};\nvar findMin = (function () {\n    var go = function ($copy_v) {\n        return function ($copy_v1) {\n            var $tco_var_v = $copy_v;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(v, v1) {\n                if (v1 instanceof Leaf) {\n                    $tco_done = true;\n                    return v;\n                };\n                if (v1 instanceof Two) {\n                    $tco_var_v = new Data_Maybe.Just({\n                        key: v1.value1,\n                        value: v1.value2\n                    });\n                    $copy_v1 = v1.value0;\n                    return;\n                };\n                if (v1 instanceof Three) {\n                    $tco_var_v = new Data_Maybe.Just({\n                        key: v1.value1,\n                        value: v1.value2\n                    });\n                    $copy_v1 = v1.value0;\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 308, column 5 - line 308, column 22): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v, $copy_v1);\n            };\n            return $tco_result;\n        };\n    };\n    return go(Data_Maybe.Nothing.value);\n})();\nvar lookupGT = function (dictOrd) {\n    return function (k) {\n        var comp = Data_Ord.compare(dictOrd);\n        var go = function (v) {\n            if (v instanceof Leaf) {\n                return Data_Maybe.Nothing.value;\n            };\n            if (v instanceof Two) {\n                var v2 = comp(k)(v.value1);\n                if (v2 instanceof Data_Ordering.EQ) {\n                    return findMin(v.value3);\n                };\n                if (v2 instanceof Data_Ordering.LT) {\n                    return Data_Maybe.Just.create(Data_Maybe.fromMaybe({\n                        key: v.value1,\n                        value: v.value2\n                    })(go(v.value0)));\n                };\n                if (v2 instanceof Data_Ordering.GT) {\n                    return go(v.value3);\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 287, column 33 - line 290, column 21): \" + [ v2.constructor.name ]);\n            };\n            if (v instanceof Three) {\n                var v3 = comp(k)(v.value1);\n                if (v3 instanceof Data_Ordering.EQ) {\n                    return findMin(new Two(v.value3, v.value4, v.value5, v.value6));\n                };\n                if (v3 instanceof Data_Ordering.LT) {\n                    return Data_Maybe.Just.create(Data_Maybe.fromMaybe({\n                        key: v.value1,\n                        value: v.value2\n                    })(go(v.value0)));\n                };\n                if (v3 instanceof Data_Ordering.GT) {\n                    return go(new Two(v.value3, v.value4, v.value5, v.value6));\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 291, column 45 - line 294, column 37): \" + [ v3.constructor.name ]);\n            };\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 286, column 5 - line 286, column 22): \" + [ v.constructor.name ]);\n        };\n        return go;\n    };\n};\nvar findMax = (function () {\n    var go = function ($copy_v) {\n        return function ($copy_v1) {\n            var $tco_var_v = $copy_v;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(v, v1) {\n                if (v1 instanceof Leaf) {\n                    $tco_done = true;\n                    return v;\n                };\n                if (v1 instanceof Two) {\n                    $tco_var_v = new Data_Maybe.Just({\n                        key: v1.value1,\n                        value: v1.value2\n                    });\n                    $copy_v1 = v1.value3;\n                    return;\n                };\n                if (v1 instanceof Three) {\n                    $tco_var_v = new Data_Maybe.Just({\n                        key: v1.value4,\n                        value: v1.value5\n                    });\n                    $copy_v1 = v1.value6;\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 300, column 5 - line 300, column 22): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_v, $copy_v1);\n            };\n            return $tco_result;\n        };\n    };\n    return go(Data_Maybe.Nothing.value);\n})();\nvar lookupLT = function (dictOrd) {\n    return function (k) {\n        var comp = Data_Ord.compare(dictOrd);\n        var go = function (v) {\n            if (v instanceof Leaf) {\n                return Data_Maybe.Nothing.value;\n            };\n            if (v instanceof Two) {\n                var v2 = comp(k)(v.value1);\n                if (v2 instanceof Data_Ordering.EQ) {\n                    return findMax(v.value0);\n                };\n                if (v2 instanceof Data_Ordering.GT) {\n                    return Data_Maybe.Just.create(Data_Maybe.fromMaybe({\n                        key: v.value1,\n                        value: v.value2\n                    })(go(v.value3)));\n                };\n                if (v2 instanceof Data_Ordering.LT) {\n                    return go(v.value0);\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 253, column 33 - line 256, column 20): \" + [ v2.constructor.name ]);\n            };\n            if (v instanceof Three) {\n                var v3 = comp(k)(v.value4);\n                if (v3 instanceof Data_Ordering.EQ) {\n                    return findMax(new Two(v.value0, v.value1, v.value2, v.value3));\n                };\n                if (v3 instanceof Data_Ordering.GT) {\n                    return Data_Maybe.Just.create(Data_Maybe.fromMaybe({\n                        key: v.value4,\n                        value: v.value5\n                    })(go(v.value6)));\n                };\n                if (v3 instanceof Data_Ordering.LT) {\n                    return go(new Two(v.value0, v.value1, v.value2, v.value3));\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 257, column 45 - line 260, column 36): \" + [ v3.constructor.name ]);\n            };\n            throw new Error(\"Failed pattern match at Data.Map.Internal (line 252, column 5 - line 252, column 22): \" + [ v.constructor.name ]);\n        };\n        return go;\n    };\n};\nvar eqMap = function (dictEq) {\n    return function (dictEq1) {\n        return {\n            eq: function (m1) {\n                return function (m2) {\n                    return Data_Eq.eq(Data_Eq.eqArray(Data_Tuple.eqTuple(dictEq)(dictEq1)))(toAscArray(m1))(toAscArray(m2));\n                };\n            }\n        };\n    };\n};\nvar ordMap = function (dictOrd) {\n    return function (dictOrd1) {\n        return {\n            compare: function (m1) {\n                return function (m2) {\n                    return Data_Ord.compare(Data_Ord.ordArray(Data_Tuple.ordTuple(dictOrd)(dictOrd1)))(toAscArray(m1))(toAscArray(m2));\n                };\n            },\n            Eq0: function () {\n                return eqMap(dictOrd.Eq0())(dictOrd1.Eq0());\n            }\n        };\n    };\n};\nvar eq1Map = function (dictEq) {\n    return {\n        eq1: function (dictEq1) {\n            return Data_Eq.eq(eqMap(dictEq)(dictEq1));\n        }\n    };\n};\nvar ord1Map = function (dictOrd) {\n    return {\n        compare1: function (dictOrd1) {\n            return Data_Ord.compare(ordMap(dictOrd)(dictOrd1));\n        },\n        Eq10: function () {\n            return eq1Map(dictOrd.Eq0());\n        }\n    };\n};\nvar empty = Leaf.value;\nvar fromFoldable = function (dictOrd) {\n    return function (dictFoldable) {\n        return Data_Foldable.foldl(dictFoldable)(function (m) {\n            return function (v) {\n                return insert(dictOrd)(v.value0)(v.value1)(m);\n            };\n        })(empty);\n    };\n};\nvar filterWithKey = function (dictOrd) {\n    return function (predicate) {\n        var $764 = fromFoldable(dictOrd)(Data_List_Lazy_Types.foldableList);\n        var $765 = Data_List_Lazy.filter(Data_Tuple.uncurry(predicate));\n        var $766 = toUnfoldable(Data_List_Lazy_Types.unfoldableList);\n        return function ($767) {\n            return $764($765($766($767)));\n        };\n    };\n};\nvar filter = function (dictOrd) {\n    return function (predicate) {\n        return filterWithKey(dictOrd)(Data_Function[\"const\"](predicate));\n    };\n};\nvar filterKeys = function (dictOrd) {\n    return function (predicate) {\n        return filterWithKey(dictOrd)(function ($768) {\n            return Data_Function[\"const\"](predicate($768));\n        });\n    };\n};\nvar fromFoldableWithIndex = function (dictOrd) {\n    return function (dictFoldableWithIndex) {\n        return Data_FoldableWithIndex.foldlWithIndex(dictFoldableWithIndex)(function (k) {\n            return function (m) {\n                return function (v) {\n                    return insert(dictOrd)(k)(v)(m);\n                };\n            };\n        })(empty);\n    };\n};\nvar intersectionWith = function (dictOrd) {\n    return function (f) {\n        return function (m1) {\n            return function (m2) {\n                var go = function ($copy_v) {\n                    return function ($copy_v1) {\n                        return function ($copy_m) {\n                            var $tco_var_v = $copy_v;\n                            var $tco_var_v1 = $copy_v1;\n                            var $tco_done = false;\n                            var $tco_result;\n                            function $tco_loop(v, v1, m) {\n                                if (v instanceof Data_List_Types.Nil) {\n                                    $tco_done = true;\n                                    return m;\n                                };\n                                if (v1 instanceof Data_List_Types.Nil) {\n                                    $tco_done = true;\n                                    return m;\n                                };\n                                if (v instanceof Data_List_Types.Cons && v1 instanceof Data_List_Types.Cons) {\n                                    var v2 = Data_Ord.compare(dictOrd)(v.value0.value0)(v1.value0.value0);\n                                    if (v2 instanceof Data_Ordering.LT) {\n                                        $tco_var_v = v.value1;\n                                        $tco_var_v1 = v1;\n                                        $copy_m = m;\n                                        return;\n                                    };\n                                    if (v2 instanceof Data_Ordering.EQ) {\n                                        $tco_var_v = v.value1;\n                                        $tco_var_v1 = v1.value1;\n                                        $copy_m = insert(dictOrd)(v.value0.value0)(f(v.value0.value1)(v1.value0.value1))(m);\n                                        return;\n                                    };\n                                    if (v2 instanceof Data_Ordering.GT) {\n                                        $tco_var_v = v;\n                                        $tco_var_v1 = v1.value1;\n                                        $copy_m = m;\n                                        return;\n                                    };\n                                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 655, column 5 - line 658, column 27): \" + [ v2.constructor.name ]);\n                                };\n                                throw new Error(\"Failed pattern match at Data.Map.Internal (line 652, column 3 - line 652, column 17): \" + [ v.constructor.name, v1.constructor.name, m.constructor.name ]);\n                            };\n                            while (!$tco_done) {\n                                $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_m);\n                            };\n                            return $tco_result;\n                        };\n                    };\n                };\n                return go(toUnfoldable(Data_List_Types.unfoldableList)(m1))(toUnfoldable(Data_List_Types.unfoldableList)(m2))(empty);\n            };\n        };\n    };\n};\nvar intersection = function (dictOrd) {\n    return intersectionWith(dictOrd)(Data_Function[\"const\"]);\n};\nvar $$delete = function (dictOrd) {\n    return function (k) {\n        return function (m) {\n            return Data_Maybe.maybe(m)(Data_Tuple.snd)(pop(dictOrd)(k)(m));\n        };\n    };\n};\nvar difference = function (dictOrd) {\n    return function (m1) {\n        return function (m2) {\n            return Data_Foldable.foldl(Data_List_Types.foldableList)(Data_Function.flip($$delete(dictOrd)))(m1)(keys(m2));\n        };\n    };\n};\nvar checkValid = function (tree) {\n    var allHeights = function (v) {\n        if (v instanceof Leaf) {\n            return Control_Applicative.pure(Data_List_Types.applicativeList)(0);\n        };\n        if (v instanceof Two) {\n            return Data_Functor.map(Data_List_Types.functorList)(function (n) {\n                return n + 1 | 0;\n            })(Data_Semigroup.append(Data_List_Types.semigroupList)(allHeights(v.value0))(allHeights(v.value3)));\n        };\n        if (v instanceof Three) {\n            return Data_Functor.map(Data_List_Types.functorList)(function (n) {\n                return n + 1 | 0;\n            })(Data_Semigroup.append(Data_List_Types.semigroupList)(allHeights(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(allHeights(v.value3))(allHeights(v.value6))));\n        };\n        throw new Error(\"Failed pattern match at Data.Map.Internal (line 199, column 3 - line 199, column 36): \" + [ v.constructor.name ]);\n    };\n    return Data_List.length(Data_List.nub(Data_Ord.ordInt)(allHeights(tree))) === 1;\n};\nvar asList = Control_Category.identity(Control_Category.categoryFn);\nvar foldableWithIndexMap = {\n    foldlWithIndex: function (f) {\n        return function (z) {\n            return function (m) {\n                return Data_Foldable.foldl(Data_List_Types.foldableList)((function () {\n                    var $769 = Data_Function.flip(f);\n                    return function ($770) {\n                        return Data_Tuple.uncurry($769($770));\n                    };\n                })())(z)(asList(toUnfoldable(Data_List_Types.unfoldableList)(m)));\n            };\n        };\n    },\n    foldrWithIndex: function (f) {\n        return function (z) {\n            return function (m) {\n                return Data_Foldable.foldr(Data_List_Types.foldableList)(Data_Tuple.uncurry(f))(z)(asList(toUnfoldable(Data_List_Types.unfoldableList)(m)));\n            };\n        };\n    },\n    foldMapWithIndex: function (dictMonoid) {\n        return function (f) {\n            return function (m) {\n                return Data_Foldable.foldMap(Data_List_Types.foldableList)(dictMonoid)(Data_Tuple.uncurry(f))(asList(toUnfoldable(Data_List_Types.unfoldableList)(m)));\n            };\n        };\n    },\n    Foldable0: function () {\n        return foldableMap;\n    }\n};\nvar mapMaybeWithKey = function (dictOrd) {\n    return function (f) {\n        return Data_FoldableWithIndex.foldrWithIndex(foldableWithIndexMap)(function (k) {\n            return function (a) {\n                return function (acc) {\n                    return Data_Maybe.maybe(acc)(function (b) {\n                        return insert(dictOrd)(k)(b)(acc);\n                    })(f(k)(a));\n                };\n            };\n        })(empty);\n    };\n};\nvar mapMaybe = function (dictOrd) {\n    var $771 = mapMaybeWithKey(dictOrd);\n    return function ($772) {\n        return $771(Data_Function[\"const\"]($772));\n    };\n};\nvar catMaybes = function (dictOrd) {\n    return mapMaybe(dictOrd)(Control_Category.identity(Control_Category.categoryFn));\n};\nvar traversableWithIndexMap = {\n    traverseWithIndex: function (dictApplicative) {\n        return function (v) {\n            return function (v1) {\n                if (v1 instanceof Leaf) {\n                    return Control_Applicative.pure(dictApplicative)(Leaf.value);\n                };\n                if (v1 instanceof Two) {\n                    return Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(Two.create)(Data_TraversableWithIndex.traverseWithIndex(traversableWithIndexMap)(dictApplicative)(v)(v1.value0)))(Control_Applicative.pure(dictApplicative)(v1.value1)))(v(v1.value1)(v1.value2)))(Data_TraversableWithIndex.traverseWithIndex(traversableWithIndexMap)(dictApplicative)(v)(v1.value3));\n                };\n                if (v1 instanceof Three) {\n                    return Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Control_Apply.apply(dictApplicative.Apply0())(Data_Functor.map((dictApplicative.Apply0()).Functor0())(Three.create)(Data_TraversableWithIndex.traverseWithIndex(traversableWithIndexMap)(dictApplicative)(v)(v1.value0)))(Control_Applicative.pure(dictApplicative)(v1.value1)))(v(v1.value1)(v1.value2)))(Data_TraversableWithIndex.traverseWithIndex(traversableWithIndexMap)(dictApplicative)(v)(v1.value3)))(Control_Applicative.pure(dictApplicative)(v1.value4)))(v(v1.value4)(v1.value5)))(Data_TraversableWithIndex.traverseWithIndex(traversableWithIndexMap)(dictApplicative)(v)(v1.value6));\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 144, column 1 - line 158, column 40): \" + [ v.constructor.name, v1.constructor.name ]);\n            };\n        };\n    },\n    FunctorWithIndex0: function () {\n        return functorWithIndexMap;\n    },\n    FoldableWithIndex1: function () {\n        return foldableWithIndexMap;\n    },\n    Traversable2: function () {\n        return traversableMap;\n    }\n};\nvar applyMap = function (dictOrd) {\n    return {\n        apply: intersectionWith(dictOrd)(Control_Category.identity(Control_Category.categoryFn)),\n        Functor0: function () {\n            return functorMap;\n        }\n    };\n};\nvar bindMap = function (dictOrd) {\n    return {\n        bind: function (m) {\n            return function (f) {\n                return mapMaybeWithKey(dictOrd)(function (k) {\n                    var $773 = lookup(dictOrd)(k);\n                    return function ($774) {\n                        return $773(f($774));\n                    };\n                })(m);\n            };\n        },\n        Apply0: function () {\n            return applyMap(dictOrd);\n        }\n    };\n};\nvar alter = function (dictOrd) {\n    return function (f) {\n        return function (k) {\n            return function (m) {\n                var v = f(lookup(dictOrd)(k)(m));\n                if (v instanceof Data_Maybe.Nothing) {\n                    return $$delete(dictOrd)(k)(m);\n                };\n                if (v instanceof Data_Maybe.Just) {\n                    return insert(dictOrd)(k)(v.value0)(m);\n                };\n                throw new Error(\"Failed pattern match at Data.Map.Internal (line 563, column 15 - line 565, column 25): \" + [ v.constructor.name ]);\n            };\n        };\n    };\n};\nvar fromFoldableWith = function (dictOrd) {\n    return function (dictFoldable) {\n        return function (f) {\n            var combine = function (v) {\n                return function (v1) {\n                    if (v1 instanceof Data_Maybe.Just) {\n                        return Data_Maybe.Just.create(f(v)(v1.value0));\n                    };\n                    if (v1 instanceof Data_Maybe.Nothing) {\n                        return new Data_Maybe.Just(v);\n                    };\n                    throw new Error(\"Failed pattern match at Data.Map.Internal (line 580, column 3 - line 580, column 38): \" + [ v.constructor.name, v1.constructor.name ]);\n                };\n            };\n            return Data_Foldable.foldl(dictFoldable)(function (m) {\n                return function (v) {\n                    return alter(dictOrd)(combine(v.value1))(v.value0)(m);\n                };\n            })(empty);\n        };\n    };\n};\nvar insertWith = function (dictOrd) {\n    return function (f) {\n        return function (k) {\n            return function (v) {\n                return alter(dictOrd)((function () {\n                    var $775 = Data_Maybe.maybe(v)(Data_Function.flip(f)(v));\n                    return function ($776) {\n                        return Data_Maybe.Just.create($775($776));\n                    };\n                })())(k);\n            };\n        };\n    };\n};\nvar unionWith = function (dictOrd) {\n    return function (f) {\n        return function (m1) {\n            return function (m2) {\n                var go = function (m) {\n                    return function (v) {\n                        return alter(dictOrd)((function () {\n                            var $777 = Data_Maybe.maybe(v.value1)(f(v.value1));\n                            return function ($778) {\n                                return Data_Maybe.Just.create($777($778));\n                            };\n                        })())(v.value0)(m);\n                    };\n                };\n                return Data_Foldable.foldl(Data_List_Types.foldableList)(go)(m2)(toUnfoldable(Data_List_Types.unfoldableList)(m1));\n            };\n        };\n    };\n};\nvar union = function (dictOrd) {\n    return unionWith(dictOrd)(Data_Function[\"const\"]);\n};\nvar submap = function (dictOrd) {\n    return function (kmin) {\n        return function (kmax) {\n            return foldSubmapBy(dictOrd)(union(dictOrd))(empty)(kmin)(kmax)(singleton);\n        };\n    };\n};\nvar unions = function (dictOrd) {\n    return function (dictFoldable) {\n        return Data_Foldable.foldl(dictFoldable)(union(dictOrd))(empty);\n    };\n};\nvar update = function (dictOrd) {\n    return function (f) {\n        return function (k) {\n            return function (m) {\n                return alter(dictOrd)(Data_Maybe.maybe(Data_Maybe.Nothing.value)(f))(k)(m);\n            };\n        };\n    };\n};\nvar altMap = function (dictOrd) {\n    return {\n        alt: union(dictOrd),\n        Functor0: function () {\n            return functorMap;\n        }\n    };\n};\nvar plusMap = function (dictOrd) {\n    return {\n        empty: empty,\n        Alt0: function () {\n            return altMap(dictOrd);\n        }\n    };\n};\nmodule.exports = {\n    showTree: showTree,\n    empty: empty,\n    isEmpty: isEmpty,\n    singleton: singleton,\n    checkValid: checkValid,\n    insert: insert,\n    insertWith: insertWith,\n    lookup: lookup,\n    lookupLE: lookupLE,\n    lookupLT: lookupLT,\n    lookupGE: lookupGE,\n    lookupGT: lookupGT,\n    findMin: findMin,\n    findMax: findMax,\n    foldSubmap: foldSubmap,\n    submap: submap,\n    fromFoldable: fromFoldable,\n    fromFoldableWith: fromFoldableWith,\n    fromFoldableWithIndex: fromFoldableWithIndex,\n    toUnfoldable: toUnfoldable,\n    toUnfoldableUnordered: toUnfoldableUnordered,\n    \"delete\": $$delete,\n    pop: pop,\n    member: member,\n    alter: alter,\n    update: update,\n    keys: keys,\n    values: values,\n    union: union,\n    unionWith: unionWith,\n    unions: unions,\n    intersection: intersection,\n    intersectionWith: intersectionWith,\n    difference: difference,\n    isSubmap: isSubmap,\n    size: size,\n    filterWithKey: filterWithKey,\n    filterKeys: filterKeys,\n    filter: filter,\n    mapMaybeWithKey: mapMaybeWithKey,\n    mapMaybe: mapMaybe,\n    catMaybes: catMaybes,\n    eq1Map: eq1Map,\n    eqMap: eqMap,\n    ord1Map: ord1Map,\n    ordMap: ordMap,\n    showMap: showMap,\n    altMap: altMap,\n    plusMap: plusMap,\n    functorMap: functorMap,\n    functorWithIndexMap: functorWithIndexMap,\n    applyMap: applyMap,\n    bindMap: bindMap,\n    foldableMap: foldableMap,\n    foldableWithIndexMap: foldableWithIndexMap,\n    traversableMap: traversableMap,\n    traversableWithIndexMap: traversableWithIndexMap\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs?");

/***/ }),

/***/ "./.spago/ordered-collections/v2.0.1/src/Data/Set.purs":
/*!*************************************************************!*\
  !*** ./.spago/ordered-collections/v2.0.1/src/Data/Set.purs ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Control_Monad_ST_Internal = __webpack_require__(/*! ./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs */ \"./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs\");\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_Array_ST = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array/ST.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array/ST.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_List = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List.purs */ \"./.spago/lists/v6.0.1/src/Data/List.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Map_Internal = __webpack_require__(/*! ./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs */ \"./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar $$Set = function (x) {\n    return x;\n};\nvar union = function (dictOrd) {\n    return function (v) {\n        return function (v1) {\n            return Data_Map_Internal.union(dictOrd)(v)(v1);\n        };\n    };\n};\nvar toMap = function (v) {\n    return v;\n};\nvar toList = function (v) {\n    return Data_Map_Internal.keys(v);\n};\nvar toUnfoldable = function (dictUnfoldable) {\n    var $66 = Data_List.toUnfoldable(dictUnfoldable);\n    return function ($67) {\n        return $66(toList($67));\n    };\n};\nvar size = function (v) {\n    return Data_Map_Internal.size(v);\n};\nvar singleton = function (a) {\n    return Data_Map_Internal.singleton(a)(Data_Unit.unit);\n};\nvar showSet = function (dictShow) {\n    return {\n        show: function (s) {\n            return \"(fromFoldable \" + (Data_Show.show(Data_Show.showArray(dictShow))(toUnfoldable(Data_Unfoldable.unfoldableArray)(s)) + \")\");\n        }\n    };\n};\nvar semigroupSet = function (dictOrd) {\n    return {\n        append: union(dictOrd)\n    };\n};\nvar member = function (dictOrd) {\n    return function (a) {\n        return function (v) {\n            return Data_Map_Internal.member(dictOrd)(a)(v);\n        };\n    };\n};\nvar isEmpty = function (v) {\n    return Data_Map_Internal.isEmpty(v);\n};\nvar insert = function (dictOrd) {\n    return function (a) {\n        return function (v) {\n            return Data_Map_Internal.insert(dictOrd)(a)(Data_Unit.unit)(v);\n        };\n    };\n};\nvar fromMap = $$Set;\nvar foldableSet = {\n    foldMap: function (dictMonoid) {\n        return function (f) {\n            var $68 = Data_Foldable.foldMap(Data_List_Types.foldableList)(dictMonoid)(f);\n            return function ($69) {\n                return $68(toList($69));\n            };\n        };\n    },\n    foldl: function (f) {\n        return function (x) {\n            var $70 = Data_Foldable.foldl(Data_List_Types.foldableList)(f)(x);\n            return function ($71) {\n                return $70(toList($71));\n            };\n        };\n    },\n    foldr: function (f) {\n        return function (x) {\n            var $72 = Data_Foldable.foldr(Data_List_Types.foldableList)(f)(x);\n            return function ($73) {\n                return $72(toList($73));\n            };\n        };\n    }\n};\nvar findMin = function (v) {\n    return Data_Functor.map(Data_Maybe.functorMaybe)(function (v1) {\n        return v1.key;\n    })(Data_Map_Internal.findMin(v));\n};\nvar findMax = function (v) {\n    return Data_Functor.map(Data_Maybe.functorMaybe)(function (v1) {\n        return v1.key;\n    })(Data_Map_Internal.findMax(v));\n};\nvar filter = function (dictOrd) {\n    return function (f) {\n        return function (v) {\n            return Data_Map_Internal.filterWithKey(dictOrd)(function (k) {\n                return function (v1) {\n                    return f(k);\n                };\n            })(v);\n        };\n    };\n};\nvar eqSet = function (dictEq) {\n    return {\n        eq: function (v) {\n            return function (v1) {\n                return Data_Eq.eq(Data_Map_Internal.eqMap(dictEq)(Data_Eq.eqUnit))(v)(v1);\n            };\n        }\n    };\n};\nvar ordSet = function (dictOrd) {\n    return {\n        compare: function (s1) {\n            return function (s2) {\n                return Data_Ord.compare(Data_List_Types.ordList(dictOrd))(toList(s1))(toList(s2));\n            };\n        },\n        Eq0: function () {\n            return eqSet(dictOrd.Eq0());\n        }\n    };\n};\nvar eq1Set = {\n    eq1: function (dictEq) {\n        return Data_Eq.eq(eqSet(dictEq));\n    }\n};\nvar ord1Set = {\n    compare1: function (dictOrd) {\n        return Data_Ord.compare(ordSet(dictOrd));\n    },\n    Eq10: function () {\n        return eq1Set;\n    }\n};\nvar empty = Data_Map_Internal.empty;\nvar fromFoldable = function (dictFoldable) {\n    return function (dictOrd) {\n        return Data_Foldable.foldl(dictFoldable)(function (m) {\n            return function (a) {\n                return insert(dictOrd)(a)(m);\n            };\n        })(empty);\n    };\n};\nvar intersection = function (dictOrd) {\n    return function (s1) {\n        return function (s2) {\n            var toArray = (function () {\n                var $74 = Data_Array.fromFoldable(Data_List_Types.foldableList);\n                return function ($75) {\n                    return $74(toList($75));\n                };\n            })();\n            var rs = toArray(s2);\n            var rl = Data_Array.length(rs);\n            var ls = toArray(s1);\n            var ll = Data_Array.length(ls);\n            var intersect = function (acc) {\n                var go = function (l) {\n                    return function (r) {\n                        var $61 = l < ll && r < rl;\n                        if ($61) {\n                            var v = Data_Ord.compare(dictOrd)(ls[l])(rs[r]);\n                            if (v instanceof Data_Ordering.EQ) {\n                                return function __do() {\n                                    Data_Array_ST.push(ls[l])(acc)();\n                                    return new Control_Monad_Rec_Class.Loop({\n                                        a: l + 1 | 0,\n                                        b: r + 1 | 0\n                                    });\n                                };\n                            };\n                            if (v instanceof Data_Ordering.LT) {\n                                return Control_Applicative.pure(Control_Monad_ST_Internal.applicativeST)(new Control_Monad_Rec_Class.Loop({\n                                    a: l + 1 | 0,\n                                    b: r\n                                }));\n                            };\n                            if (v instanceof Data_Ordering.GT) {\n                                return Control_Applicative.pure(Control_Monad_ST_Internal.applicativeST)(new Control_Monad_Rec_Class.Loop({\n                                    a: l,\n                                    b: r + 1 | 0\n                                }));\n                            };\n                            throw new Error(\"Failed pattern match at Data.Set (line 179, column 12 - line 184, column 43): \" + [ v.constructor.name ]);\n                        };\n                        return Control_Applicative.pure(Control_Monad_ST_Internal.applicativeST)(new Control_Monad_Rec_Class.Done(acc));\n                    };\n                };\n                return Control_Monad_Rec_Class.tailRecM2(Control_Monad_ST_Internal.monadRecST)(go)(0)(0);\n            };\n            return fromFoldable(Data_Foldable.foldableArray)(dictOrd)(Control_Bind.bind(Control_Monad_ST_Internal.bindST)(Control_Bind.bind(Control_Monad_ST_Internal.bindST)(Data_Array_ST[\"new\"])(intersect))(Data_Array_ST.unsafeFreeze)());\n        };\n    };\n};\nvar map = function (dictOrd) {\n    return function (f) {\n        return Data_Foldable.foldl(foldableSet)(function (m) {\n            return function (a) {\n                return insert(dictOrd)(f(a))(m);\n            };\n        })(empty);\n    };\n};\nvar mapMaybe = function (dictOrd) {\n    return function (f) {\n        return Data_Foldable.foldr(foldableSet)(function (a) {\n            return function (acc) {\n                return Data_Maybe.maybe(acc)(function (b) {\n                    return insert(dictOrd)(b)(acc);\n                })(f(a));\n            };\n        })(empty);\n    };\n};\nvar monoidSet = function (dictOrd) {\n    return {\n        mempty: empty,\n        Semigroup0: function () {\n            return semigroupSet(dictOrd);\n        }\n    };\n};\nvar unions = function (dictFoldable) {\n    return function (dictOrd) {\n        return Data_Foldable.foldl(dictFoldable)(union(dictOrd))(empty);\n    };\n};\nvar $$delete = function (dictOrd) {\n    return function (a) {\n        return function (v) {\n            return Data_Map_Internal[\"delete\"](dictOrd)(a)(v);\n        };\n    };\n};\nvar difference = function (dictOrd) {\n    return function (s1) {\n        return function (s2) {\n            return Data_Foldable.foldl(Data_List_Types.foldableList)(Data_Function.flip($$delete(dictOrd)))(s1)(toList(s2));\n        };\n    };\n};\nvar subset = function (dictOrd) {\n    return function (s1) {\n        return function (s2) {\n            return isEmpty(difference(dictOrd)(s1)(s2));\n        };\n    };\n};\nvar properSubset = function (dictOrd) {\n    return function (s1) {\n        return function (s2) {\n            return subset(dictOrd)(s1)(s2) && Data_Eq.notEq(eqSet(dictOrd.Eq0()))(s1)(s2);\n        };\n    };\n};\nvar checkValid = function (v) {\n    return Data_Map_Internal.checkValid(v);\n};\nvar catMaybes = function (dictOrd) {\n    return mapMaybe(dictOrd)(Control_Category.identity(Control_Category.categoryFn));\n};\nmodule.exports = {\n    fromFoldable: fromFoldable,\n    toUnfoldable: toUnfoldable,\n    empty: empty,\n    isEmpty: isEmpty,\n    singleton: singleton,\n    map: map,\n    checkValid: checkValid,\n    insert: insert,\n    member: member,\n    \"delete\": $$delete,\n    size: size,\n    findMin: findMin,\n    findMax: findMax,\n    union: union,\n    unions: unions,\n    difference: difference,\n    subset: subset,\n    properSubset: properSubset,\n    intersection: intersection,\n    filter: filter,\n    mapMaybe: mapMaybe,\n    catMaybes: catMaybes,\n    toMap: toMap,\n    fromMap: fromMap,\n    eqSet: eqSet,\n    eq1Set: eq1Set,\n    showSet: showSet,\n    ordSet: ordSet,\n    ord1Set: ord1Set,\n    monoidSet: monoidSet,\n    semigroupSet: semigroupSet,\n    foldableSet: foldableSet\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/ordered-collections/v2.0.1/src/Data/Set.purs?");

/***/ }),

/***/ "./.spago/orders/v5.0.0/src/Data/Ord/Max.purs":
/*!****************************************************!*\
  !*** ./.spago/orders/v5.0.0/src/Data/Ord/Max.purs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Bounded = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Bounded.purs */ \"./.spago/prelude/v5.0.1/src/Data/Bounded.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Max = function (x) {\n    return x;\n};\nvar showMax = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Max \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semigroupMax = function (dictOrd) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                return Data_Ord.max(dictOrd)(v)(v1);\n            };\n        }\n    };\n};\nvar newtypeMax = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monoidMax = function (dictBounded) {\n    return {\n        mempty: Data_Bounded.bottom(dictBounded),\n        Semigroup0: function () {\n            return semigroupMax(dictBounded.Ord0());\n        }\n    };\n};\nvar eqMax = function (dictEq) {\n    return dictEq;\n};\nvar ordMax = function (dictOrd) {\n    return {\n        compare: function (v) {\n            return function (v1) {\n                return Data_Ord.compare(dictOrd)(v)(v1);\n            };\n        },\n        Eq0: function () {\n            return eqMax(dictOrd.Eq0());\n        }\n    };\n};\nmodule.exports = {\n    Max: Max,\n    newtypeMax: newtypeMax,\n    eqMax: eqMax,\n    ordMax: ordMax,\n    semigroupMax: semigroupMax,\n    monoidMax: monoidMax,\n    showMax: showMax\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/orders/v5.0.0/src/Data/Ord/Max.purs?");

/***/ }),

/***/ "./.spago/orders/v5.0.0/src/Data/Ord/Min.purs":
/*!****************************************************!*\
  !*** ./.spago/orders/v5.0.0/src/Data/Ord/Min.purs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Bounded = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Bounded.purs */ \"./.spago/prelude/v5.0.1/src/Data/Bounded.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Min = function (x) {\n    return x;\n};\nvar showMin = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Min \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semigroupMin = function (dictOrd) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                return Data_Ord.min(dictOrd)(v)(v1);\n            };\n        }\n    };\n};\nvar newtypeMin = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monoidMin = function (dictBounded) {\n    return {\n        mempty: Data_Bounded.top(dictBounded),\n        Semigroup0: function () {\n            return semigroupMin(dictBounded.Ord0());\n        }\n    };\n};\nvar eqMin = function (dictEq) {\n    return dictEq;\n};\nvar ordMin = function (dictOrd) {\n    return {\n        compare: function (v) {\n            return function (v1) {\n                return Data_Ord.compare(dictOrd)(v)(v1);\n            };\n        },\n        Eq0: function () {\n            return eqMin(dictOrd.Eq0());\n        }\n    };\n};\nmodule.exports = {\n    Min: Min,\n    newtypeMin: newtypeMin,\n    eqMin: eqMin,\n    ordMin: ordMin,\n    semigroupMin: semigroupMin,\n    monoidMin: monoidMin,\n    showMin: showMin\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/orders/v5.0.0/src/Data/Ord/Min.purs?");

/***/ }),

/***/ "./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs":
/*!************************************************************!*\
  !*** ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Lazy = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Lazy.purs */ \"./.spago/control/v5.0.0/src/Control/Lazy.purs\");\nvar Control_Monad_Error_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs\");\nvar Control_Monad_Except_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs\");\nvar Control_Monad_State_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs\");\nvar Control_Monad_State_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Trans.purs\");\nvar Control_Monad_Trans_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Text_Parsing_Parser_Pos = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Pos.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Pos.purs\");\nvar ParseState = (function () {\n    function ParseState(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    ParseState.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new ParseState(value0, value1, value2);\n            };\n        };\n    };\n    return ParseState;\n})();\nvar ParseError = (function () {\n    function ParseError(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    ParseError.create = function (value0) {\n        return function (value1) {\n            return new ParseError(value0, value1);\n        };\n    };\n    return ParseError;\n})();\nvar ParserT = function (x) {\n    return x;\n};\nvar showParseError = {\n    show: function (v) {\n        return \"(ParseError \" + (Data_Show.show(Data_Show.showString)(v.value0) + (\" \" + (Data_Show.show(Text_Parsing_Parser_Pos.showPosition)(v.value1) + \")\")));\n    }\n};\nvar parseErrorPosition = function (v) {\n    return v.value1;\n};\nvar parseErrorMessage = function (v) {\n    return v.value0;\n};\nvar newtypeParserT = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar runParserT = function (dictMonad) {\n    return function (s) {\n        return function (p) {\n            var initialState = new ParseState(s, Text_Parsing_Parser_Pos.initialPos, false);\n            return Control_Monad_State_Trans.evalStateT(((dictMonad.Bind1()).Apply0()).Functor0())(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap()(p)))(initialState);\n        };\n    };\n};\nvar runParser = function (s) {\n    var $88 = Data_Newtype.unwrap();\n    var $89 = runParserT(Data_Identity.monadIdentity)(s);\n    return function ($90) {\n        return $88($89($90));\n    };\n};\nvar monadTransParserT = {\n    lift: function (dictMonad) {\n        var $91 = Control_Monad_Trans_Class.lift(Control_Monad_Except_Trans.monadTransExceptT)(Control_Monad_State_Trans.monadStateT(dictMonad));\n        var $92 = Control_Monad_Trans_Class.lift(Control_Monad_State_Trans.monadTransStateT)(dictMonad);\n        return function ($93) {\n            return ParserT($91($92($93)));\n        };\n    }\n};\nvar monadThrowParserT = function (dictMonad) {\n    return Control_Monad_Except_Trans.monadThrowExceptT(Control_Monad_State_Trans.monadStateT(dictMonad));\n};\nvar monadStateParserT = function (dictMonad) {\n    return Control_Monad_Except_Trans.monadStateExceptT(Control_Monad_State_Trans.monadStateStateT(dictMonad));\n};\nvar position = function (dictMonad) {\n    return Control_Monad_State_Class.gets(monadStateParserT(dictMonad))(function (v) {\n        return v.value1;\n    });\n};\nvar monadRecParserT = function (dictMonadRec) {\n    return Control_Monad_Except_Trans.monadRecExceptT(Control_Monad_State_Trans.monadRecStateT(dictMonadRec));\n};\nvar monadParserT = function (dictMonad) {\n    return Control_Monad_Except_Trans.monadExceptT(Control_Monad_State_Trans.monadStateT(dictMonad));\n};\nvar monadErrorParserT = function (dictMonad) {\n    return Control_Monad_Except_Trans.monadErrorExceptT(Control_Monad_State_Trans.monadStateT(dictMonad));\n};\nvar region = function (dictMonad) {\n    return function (context) {\n        return function (p) {\n            return Control_Monad_Error_Class.catchError(monadErrorParserT(dictMonad))(p)(function (err) {\n                return Control_Monad_Error_Class.throwError(monadThrowParserT(dictMonad))(context(err));\n            });\n        };\n    };\n};\nvar mapParserT = (function () {\n    var $94 = Data_Newtype.over()()(ParserT);\n    return function ($95) {\n        return $94(Control_Monad_Except_Trans.mapExceptT(Control_Monad_State_Trans.mapStateT($95)));\n    };\n})();\nvar lazyParserT = {\n    defer: function (f) {\n        return Control_Lazy.defer(Control_Monad_State_Trans.lazyStateT)((function () {\n            var $96 = Data_Newtype.unwrap();\n            return function ($97) {\n                return Control_Monad_Except_Trans.runExceptT($96(f($97)));\n            };\n        })());\n    }\n};\nvar hoistParserT = mapParserT;\nvar functorParserT = function (dictFunctor) {\n    return Control_Monad_Except_Trans.functorExceptT(Control_Monad_State_Trans.functorStateT(dictFunctor));\n};\nvar failWithPosition = function (dictMonad) {\n    return function (message) {\n        return function (pos) {\n            return Control_Monad_Error_Class.throwError(monadThrowParserT(dictMonad))(new ParseError(message, pos));\n        };\n    };\n};\nvar eqParseError = {\n    eq: function (x) {\n        return function (y) {\n            return x.value0 === y.value0 && Data_Eq.eq(Text_Parsing_Parser_Pos.eqPosition)(x.value1)(y.value1);\n        };\n    }\n};\nvar ordParseError = {\n    compare: function (x) {\n        return function (y) {\n            var v = Data_Ord.compare(Data_Ord.ordString)(x.value0)(y.value0);\n            if (v instanceof Data_Ordering.LT) {\n                return Data_Ordering.LT.value;\n            };\n            if (v instanceof Data_Ordering.GT) {\n                return Data_Ordering.GT.value;\n            };\n            return Data_Ord.compare(Text_Parsing_Parser_Pos.ordPosition)(x.value1)(y.value1);\n        };\n    },\n    Eq0: function () {\n        return eqParseError;\n    }\n};\nvar consume = function (dictMonad) {\n    return Control_Monad_State_Class.modify_(monadStateParserT(dictMonad))(function (v) {\n        return new ParseState(v.value0, v.value1, true);\n    });\n};\nvar bindParserT = function (dictMonad) {\n    return Control_Monad_Except_Trans.bindExceptT(Control_Monad_State_Trans.monadStateT(dictMonad));\n};\nvar fail = function (dictMonad) {\n    return function (message) {\n        return Control_Bind.bindFlipped(bindParserT(dictMonad))(failWithPosition(dictMonad)(message))(position(dictMonad));\n    };\n};\nvar applyParserT = function (dictMonad) {\n    return Control_Monad_Except_Trans.applyExceptT(Control_Monad_State_Trans.monadStateT(dictMonad));\n};\nvar semigroupParserT = function (dictMonad) {\n    return function (dictSemigroup) {\n        return {\n            append: Control_Apply.lift2(applyParserT(dictMonad))(Data_Semigroup.append(dictSemigroup))\n        };\n    };\n};\nvar applicativeParserT = function (dictMonad) {\n    return Control_Monad_Except_Trans.applicativeExceptT(Control_Monad_State_Trans.monadStateT(dictMonad));\n};\nvar monoidParserT = function (dictMonad) {\n    return function (dictMonoid) {\n        return {\n            mempty: Control_Applicative.pure(applicativeParserT(dictMonad))(Data_Monoid.mempty(dictMonoid)),\n            Semigroup0: function () {\n                return semigroupParserT(dictMonad)(dictMonoid.Semigroup0());\n            }\n        };\n    };\n};\nvar altParserT = function (dictMonad) {\n    return {\n        alt: function (p1) {\n            return function (p2) {\n                return ParserT(Control_Monad_Except_Trans.ExceptT(Control_Monad_State_Trans.StateT(function (v) {\n                    return Control_Bind.bind(dictMonad.Bind1())(Control_Monad_State_Trans.runStateT(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap()(p1)))(new ParseState(v.value0, v.value1, false)))(function (v1) {\n                        if (v1.value0 instanceof Data_Either.Left && !v1.value1.value2) {\n                            return Control_Monad_State_Trans.runStateT(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap()(p2)))(v);\n                        };\n                        return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v1.value0, v1.value1));\n                    });\n                })));\n            };\n        },\n        Functor0: function () {\n            return functorParserT(((dictMonad.Bind1()).Apply0()).Functor0());\n        }\n    };\n};\nvar plusParserT = function (dictMonad) {\n    return {\n        empty: fail(dictMonad)(\"No alternative\"),\n        Alt0: function () {\n            return altParserT(dictMonad);\n        }\n    };\n};\nvar alternativeParserT = function (dictMonad) {\n    return {\n        Applicative0: function () {\n            return applicativeParserT(dictMonad);\n        },\n        Plus1: function () {\n            return plusParserT(dictMonad);\n        }\n    };\n};\nvar monadPlusParserT = function (dictMonad) {\n    return {\n        Monad0: function () {\n            return monadParserT(dictMonad);\n        },\n        Alternative1: function () {\n            return alternativeParserT(dictMonad);\n        }\n    };\n};\nvar monadZeroParserT = function (dictMonad) {\n    return {\n        Monad0: function () {\n            return monadParserT(dictMonad);\n        },\n        Alternative1: function () {\n            return alternativeParserT(dictMonad);\n        },\n        MonadZeroIsDeprecated2: function () {\n            return undefined;\n        }\n    };\n};\nmodule.exports = {\n    ParseError: ParseError,\n    parseErrorMessage: parseErrorMessage,\n    parseErrorPosition: parseErrorPosition,\n    ParseState: ParseState,\n    ParserT: ParserT,\n    runParser: runParser,\n    runParserT: runParserT,\n    hoistParserT: hoistParserT,\n    mapParserT: mapParserT,\n    consume: consume,\n    position: position,\n    fail: fail,\n    failWithPosition: failWithPosition,\n    region: region,\n    showParseError: showParseError,\n    eqParseError: eqParseError,\n    ordParseError: ordParseError,\n    newtypeParserT: newtypeParserT,\n    lazyParserT: lazyParserT,\n    semigroupParserT: semigroupParserT,\n    monoidParserT: monoidParserT,\n    functorParserT: functorParserT,\n    applyParserT: applyParserT,\n    applicativeParserT: applicativeParserT,\n    bindParserT: bindParserT,\n    monadParserT: monadParserT,\n    monadRecParserT: monadRecParserT,\n    monadStateParserT: monadStateParserT,\n    monadThrowParserT: monadThrowParserT,\n    monadErrorParserT: monadErrorParserT,\n    altParserT: altParserT,\n    plusParserT: plusParserT,\n    alternativeParserT: alternativeParserT,\n    monadZeroParserT: monadZeroParserT,\n    monadPlusParserT: monadPlusParserT,\n    monadTransParserT: monadTransParserT\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs?");

/***/ }),

/***/ "./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs":
/*!************************************************************************!*\
  !*** ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_Except_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs\");\nvar Control_Monad_State_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Trans.purs\");\nvar Control_Plus = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Plus.purs */ \"./.spago/control/v5.0.0/src/Control/Plus.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_List = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List.purs */ \"./.spago/lists/v6.0.1/src/Data/List.purs\");\nvar Data_List_NonEmpty = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/NonEmpty.purs */ \"./.spago/lists/v6.0.1/src/Data/List/NonEmpty.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Text_Parsing_Parser = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs\");\nvar withErrorMessage = function (dictMonad) {\n    return function (p) {\n        return function (msg) {\n            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(p)(Text_Parsing_Parser.fail(dictMonad)(\"Expected \" + msg));\n        };\n    };\n};\nvar tryRethrow = function (dictMonad) {\n    return function (p) {\n        return Text_Parsing_Parser.ParserT(Control_Monad_Except_Trans.ExceptT(Control_Monad_State_Trans.StateT(function (v) {\n            return Control_Bind.bind(dictMonad.Bind1())(Control_Monad_State_Trans.runStateT(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap()(p)))(v))(function (v1) {\n                if (v1.value0 instanceof Data_Either.Left) {\n                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(new Data_Either.Left(new Text_Parsing_Parser.ParseError(v1.value0.value0.value0, v.value1)), new Text_Parsing_Parser.ParseState(v1.value1.value0, v1.value1.value1, v.value2)));\n                };\n                return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v1.value0, v1.value1));\n            });\n        })));\n    };\n};\nvar $$try = function (dictMonad) {\n    return function (p) {\n        return Text_Parsing_Parser.ParserT(Control_Monad_Except_Trans.ExceptT(Control_Monad_State_Trans.StateT(function (v) {\n            return Control_Bind.bind(dictMonad.Bind1())(Control_Monad_State_Trans.runStateT(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap()(p)))(v))(function (v1) {\n                if (v1.value0 instanceof Data_Either.Left) {\n                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v1.value0, new Text_Parsing_Parser.ParseState(v1.value1.value0, v1.value1.value1, v.value2)));\n                };\n                return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v1.value0, v1.value1));\n            });\n        })));\n    };\n};\nvar skipMany1 = function (dictMonad) {\n    return function (p) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(skipMany(dictMonad)(p))(function () {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Unit.unit);\n            });\n        });\n    };\n};\nvar skipMany = function (dictMonad) {\n    return function (p) {\n        return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(skipMany1(dictMonad)(p))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Unit.unit));\n    };\n};\nvar sepEndBy1 = function (dictMonad) {\n    return function (p) {\n        return function (sep) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (a) {\n                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(sep)(function () {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(sepEndBy(dictMonad)(p)(sep))(function (as) {\n                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_NonEmpty[\"cons'\"](a)(as));\n                    });\n                }))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_NonEmpty.singleton(a)));\n            });\n        };\n    };\n};\nvar sepEndBy = function (dictMonad) {\n    return function (p) {\n        return function (sep) {\n            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty.toList)(sepEndBy1(dictMonad)(p)(sep)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_Types.Nil.value));\n        };\n    };\n};\nvar sepBy1 = function (dictMonad) {\n    return function (p) {\n        return function (sep) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (a) {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Data_List.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(sep)(p)))(function (as) {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_NonEmpty[\"cons'\"](a)(as));\n                });\n            });\n        };\n    };\n};\nvar sepBy = function (dictMonad) {\n    return function (p) {\n        return function (sep) {\n            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty.toList)(sepBy1(dictMonad)(p)(sep)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_Types.Nil.value));\n        };\n    };\n};\nvar optional = function (dictMonad) {\n    return function (p) {\n        return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor[\"void\"](Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(p))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Unit.unit));\n    };\n};\nvar option = function (dictMonad) {\n    return function (a) {\n        return function (p) {\n            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(p)(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a));\n        };\n    };\n};\nvar optionMaybe = function (dictMonad) {\n    return function (p) {\n        return option(dictMonad)(Data_Maybe.Nothing.value)(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Maybe.Just.create)(p));\n    };\n};\nvar notFollowedBy = function (dictMonad) {\n    return function (p) {\n        return $$try(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))($$try(dictMonad)(p))(Text_Parsing_Parser.fail(dictMonad)(\"Negated parser succeeded\")))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Unit.unit)));\n    };\n};\nvar manyTill = function (dictMonad) {\n    return function (p) {\n        return function (end) {\n            var scan = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(end)(Data_List_Types.Nil.value))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (x) {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(scan)(function (xs) {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(new Data_List_Types.Cons(x, xs));\n                });\n            }));\n            return scan;\n        };\n    };\n};\nvar many1Till = function (dictMonad) {\n    return function (p) {\n        return function (end) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (x) {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(manyTill(dictMonad)(p)(end))(function (xs) {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_List_NonEmpty[\"cons'\"](x)(xs));\n                });\n            });\n        };\n    };\n};\nvar many1 = function (dictMonad) {\n    return function (p) {\n        return Control_Apply.apply(Text_Parsing_Parser.applyParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_List_NonEmpty[\"cons'\"])(p))(Data_List.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(p));\n    };\n};\nvar lookAhead = function (dictMonad) {\n    return function (p) {\n        return Text_Parsing_Parser.ParserT(Control_Monad_Except_Trans.ExceptT(Control_Monad_State_Trans.StateT(function (s) {\n            return Control_Bind.bind(dictMonad.Bind1())(Control_Monad_State_Trans.runStateT(Control_Monad_Except_Trans.runExceptT(Data_Newtype.unwrap()(p)))(s))(function (v) {\n                return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v.value0, s));\n            });\n        })));\n    };\n};\nvar endBy1 = function (dictMonad) {\n    return function (p) {\n        return function (sep) {\n            return many1(dictMonad)(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(dictMonad))(p)(sep));\n        };\n    };\n};\nvar endBy = function (dictMonad) {\n    return function (p) {\n        return function (sep) {\n            return Data_List.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(dictMonad))(p)(sep));\n        };\n    };\n};\nvar choice = function (dictFoldable) {\n    return function (dictMonad) {\n        return Data_Foldable.foldl(dictFoldable)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad)))(Control_Plus.empty(Text_Parsing_Parser.plusParserT(dictMonad)));\n    };\n};\nvar chainr1$prime = function (dictMonad) {\n    return function (p) {\n        return function (f) {\n            return function (a) {\n                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(f)(function (f$prime) {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(chainr1(dictMonad)(p)(f))(function (a$prime) {\n                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(f$prime(a)(a$prime));\n                    });\n                }))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a));\n            };\n        };\n    };\n};\nvar chainr1 = function (dictMonad) {\n    return function (p) {\n        return function (f) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (a) {\n                return chainr1$prime(dictMonad)(p)(f)(a);\n            });\n        };\n    };\n};\nvar chainr = function (dictMonad) {\n    return function (p) {\n        return function (f) {\n            return function (a) {\n                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(chainr1(dictMonad)(p)(f))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a));\n            };\n        };\n    };\n};\nvar chainl1$prime = function (dictMonad) {\n    return function (p) {\n        return function (f) {\n            return function (a) {\n                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(f)(function (f$prime) {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (a$prime) {\n                        return chainl1$prime(dictMonad)(p)(f)(f$prime(a)(a$prime));\n                    });\n                }))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a));\n            };\n        };\n    };\n};\nvar chainl1 = function (dictMonad) {\n    return function (p) {\n        return function (f) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(p)(function (a) {\n                return chainl1$prime(dictMonad)(p)(f)(a);\n            });\n        };\n    };\n};\nvar chainl = function (dictMonad) {\n    return function (p) {\n        return function (f) {\n            return function (a) {\n                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(chainl1(dictMonad)(p)(f))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a));\n            };\n        };\n    };\n};\nvar between = function (dictMonad) {\n    return function (open) {\n        return function (close) {\n            return function (p) {\n                return Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(dictMonad))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(open)(p))(close);\n            };\n        };\n    };\n};\nvar asErrorMessage = function (dictMonad) {\n    return Data_Function.flip(withErrorMessage(dictMonad));\n};\nmodule.exports = {\n    withErrorMessage: withErrorMessage,\n    asErrorMessage: asErrorMessage,\n    between: between,\n    option: option,\n    optional: optional,\n    optionMaybe: optionMaybe,\n    \"try\": $$try,\n    tryRethrow: tryRethrow,\n    lookAhead: lookAhead,\n    many1: many1,\n    sepBy: sepBy,\n    sepBy1: sepBy1,\n    sepEndBy: sepEndBy,\n    sepEndBy1: sepEndBy1,\n    endBy1: endBy1,\n    endBy: endBy,\n    chainr: chainr,\n    chainl: chainl,\n    chainl1: chainl1,\n    \"chainl1'\": chainl1$prime,\n    chainr1: chainr1,\n    \"chainr1'\": chainr1$prime,\n    choice: choice,\n    skipMany: skipMany,\n    skipMany1: skipMany1,\n    notFollowedBy: notFollowedBy,\n    manyTill: manyTill,\n    many1Till: many1Till\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs?");

/***/ }),

/***/ "./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Expr.purs":
/*!*****************************************************************!*\
  !*** ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Expr.purs ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Text_Parsing_Parser = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs\");\nvar Text_Parsing_Parser_Combinators = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs\");\nvar AssocNone = (function () {\n    function AssocNone() {\n\n    };\n    AssocNone.value = new AssocNone();\n    return AssocNone;\n})();\nvar AssocLeft = (function () {\n    function AssocLeft() {\n\n    };\n    AssocLeft.value = new AssocLeft();\n    return AssocLeft;\n})();\nvar AssocRight = (function () {\n    function AssocRight() {\n\n    };\n    AssocRight.value = new AssocRight();\n    return AssocRight;\n})();\nvar Infix = (function () {\n    function Infix(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    Infix.create = function (value0) {\n        return function (value1) {\n            return new Infix(value0, value1);\n        };\n    };\n    return Infix;\n})();\nvar Prefix = (function () {\n    function Prefix(value0) {\n        this.value0 = value0;\n    };\n    Prefix.create = function (value0) {\n        return new Prefix(value0);\n    };\n    return Prefix;\n})();\nvar Postfix = (function () {\n    function Postfix(value0) {\n        this.value0 = value0;\n    };\n    Postfix.create = function (value0) {\n        return new Postfix(value0);\n    };\n    return Postfix;\n})();\nvar termP = function (dictMonad) {\n    return function (prefixP) {\n        return function (term) {\n            return function (postfixP) {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(prefixP)(function (pre) {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(term)(function (x) {\n                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(postfixP)(function (post) {\n                            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(post(pre(x)));\n                        });\n                    });\n                });\n            };\n        };\n    };\n};\nvar splitOp = function (v) {\n    return function (accum) {\n        if (v instanceof Infix && v.value1 instanceof AssocNone) {\n            return {\n                rassoc: accum.rassoc,\n                lassoc: accum.lassoc,\n                nassoc: new Data_List_Types.Cons(v.value0, accum.nassoc),\n                prefix: accum.prefix,\n                postfix: accum.postfix\n            };\n        };\n        if (v instanceof Infix && v.value1 instanceof AssocLeft) {\n            return {\n                rassoc: accum.rassoc,\n                lassoc: new Data_List_Types.Cons(v.value0, accum.lassoc),\n                nassoc: accum.nassoc,\n                prefix: accum.prefix,\n                postfix: accum.postfix\n            };\n        };\n        if (v instanceof Infix && v.value1 instanceof AssocRight) {\n            return {\n                rassoc: new Data_List_Types.Cons(v.value0, accum.rassoc),\n                lassoc: accum.lassoc,\n                nassoc: accum.nassoc,\n                prefix: accum.prefix,\n                postfix: accum.postfix\n            };\n        };\n        if (v instanceof Prefix) {\n            return {\n                rassoc: accum.rassoc,\n                lassoc: accum.lassoc,\n                nassoc: accum.nassoc,\n                prefix: new Data_List_Types.Cons(v.value0, accum.prefix),\n                postfix: accum.postfix\n            };\n        };\n        if (v instanceof Postfix) {\n            return {\n                rassoc: accum.rassoc,\n                lassoc: accum.lassoc,\n                nassoc: accum.nassoc,\n                prefix: accum.prefix,\n                postfix: new Data_List_Types.Cons(v.value0, accum.postfix)\n            };\n        };\n        throw new Error(\"Failed pattern match at Text.Parsing.Parser.Expr (line 69, column 1 - line 69, column 80): \" + [ v.constructor.name, accum.constructor.name ]);\n    };\n};\nvar rassocP1 = function (dictMonad) {\n    return function (x) {\n        return function (rassocOp) {\n            return function (prefixP) {\n                return function (term) {\n                    return function (postfixP) {\n                        return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(rassocP(dictMonad)(x)(rassocOp)(prefixP)(term)(postfixP))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(x));\n                    };\n                };\n            };\n        };\n    };\n};\nvar rassocP = function (dictMonad) {\n    return function (x) {\n        return function (rassocOp) {\n            return function (prefixP) {\n                return function (term) {\n                    return function (postfixP) {\n                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(rassocOp)(function (f) {\n                            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(termP(dictMonad)(prefixP)(term)(postfixP))(function (z) {\n                                return rassocP1(dictMonad)(z)(rassocOp)(prefixP)(term)(postfixP);\n                            }))(function (y) {\n                                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(f(x)(y));\n                            });\n                        });\n                    };\n                };\n            };\n        };\n    };\n};\nvar nassocP = function (dictMonad) {\n    return function (x) {\n        return function (nassocOp) {\n            return function (prefixP) {\n                return function (term) {\n                    return function (postfixP) {\n                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(nassocOp)(function (f) {\n                            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(termP(dictMonad)(prefixP)(term)(postfixP))(function (y) {\n                                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(f(x)(y));\n                            });\n                        });\n                    };\n                };\n            };\n        };\n    };\n};\nvar lassocP1 = function (dictMonad) {\n    return function (x) {\n        return function (lassocOp) {\n            return function (prefixP) {\n                return function (term) {\n                    return function (postfixP) {\n                        return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(lassocP(dictMonad)(x)(lassocOp)(prefixP)(term)(postfixP))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(x));\n                    };\n                };\n            };\n        };\n    };\n};\nvar lassocP = function (dictMonad) {\n    return function (x) {\n        return function (lassocOp) {\n            return function (prefixP) {\n                return function (term) {\n                    return function (postfixP) {\n                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(lassocOp)(function (f) {\n                            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(termP(dictMonad)(prefixP)(term)(postfixP))(function (y) {\n                                return lassocP1(dictMonad)(f(x)(y))(lassocOp)(prefixP)(term)(postfixP);\n                            });\n                        });\n                    };\n                };\n            };\n        };\n    };\n};\nvar makeParser = function (dictMonad) {\n    return function (term) {\n        return function (ops) {\n            var accum = Data_Foldable.foldr(Data_Foldable.foldableArray)(splitOp)({\n                rassoc: Data_List_Types.Nil.value,\n                lassoc: Data_List_Types.Nil.value,\n                nassoc: Data_List_Types.Nil.value,\n                prefix: Data_List_Types.Nil.value,\n                postfix: Data_List_Types.Nil.value\n            })(ops);\n            var lassocOp = Text_Parsing_Parser_Combinators.choice(Data_List_Types.foldableList)(dictMonad)(accum.lassoc);\n            var nassocOp = Text_Parsing_Parser_Combinators.choice(Data_List_Types.foldableList)(dictMonad)(accum.nassoc);\n            var postfixOp = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Text_Parsing_Parser_Combinators.choice(Data_List_Types.foldableList)(dictMonad)(accum.postfix))(\"\");\n            var postfixP = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(postfixOp)(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Control_Category.identity(Control_Category.categoryFn)));\n            var prefixOp = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Text_Parsing_Parser_Combinators.choice(Data_List_Types.foldableList)(dictMonad)(accum.prefix))(\"\");\n            var prefixP = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(prefixOp)(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Control_Category.identity(Control_Category.categoryFn)));\n            var rassocOp = Text_Parsing_Parser_Combinators.choice(Data_List_Types.foldableList)(dictMonad)(accum.rassoc);\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(termP(dictMonad)(prefixP)(term)(postfixP))(function (x) {\n                return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(rassocP(dictMonad)(x)(rassocOp)(prefixP)(term)(postfixP))(lassocP(dictMonad)(x)(lassocOp)(prefixP)(term)(postfixP)))(nassocP(dictMonad)(x)(nassocOp)(prefixP)(term)(postfixP)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(x)))(\"operator\");\n            });\n        };\n    };\n};\nvar buildExprParser = function (dictMonad) {\n    return function (operators) {\n        return function (simpleExpr) {\n            return Data_Foldable.foldl(Data_Foldable.foldableArray)(makeParser(dictMonad))(simpleExpr)(operators);\n        };\n    };\n};\nmodule.exports = {\n    AssocNone: AssocNone,\n    AssocLeft: AssocLeft,\n    AssocRight: AssocRight,\n    Infix: Infix,\n    Prefix: Prefix,\n    Postfix: Postfix,\n    buildExprParser: buildExprParser\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Expr.purs?");

/***/ }),

/***/ "./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Language.purs":
/*!*********************************************************************!*\
  !*** ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Language.purs ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Text_Parsing_Parser = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs\");\nvar Text_Parsing_Parser_String = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs\");\nvar Text_Parsing_Parser_Token = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Token.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Token.purs\");\nvar emptyDef = (function () {\n    var op$prime = function (dictMonad) {\n        return Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(dictMonad)([ \":\", \"!\", \"#\", \"$\", \"%\", \"&\", \"*\", \"+\", \".\", \"/\", \"<\", \"=\", \">\", \"?\", \"@\", \"\\\\\", \"^\", \"|\", \"-\", \"~\" ]);\n    };\n    return {\n        commentStart: \"\",\n        commentEnd: \"\",\n        commentLine: \"\",\n        nestedComments: true,\n        identStart: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.letter(Data_Identity.monadIdentity))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\"_\")),\n        identLetter: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)([ \"_\", \"'\" ])),\n        opStart: op$prime(Data_Identity.monadIdentity),\n        opLetter: op$prime(Data_Identity.monadIdentity),\n        reservedOpNames: [  ],\n        reservedNames: [  ],\n        caseSensitive: true\n    };\n})();\nvar haskellStyle = (function () {\n    var op$prime = function (dictMonad) {\n        return Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(dictMonad)([ \":\", \"!\", \"#\", \"$\", \"%\", \"&\", \"*\", \"+\", \".\", \"/\", \"<\", \"=\", \">\", \"?\", \"@\", \"\\\\\", \"^\", \"|\", \"-\", \"~\" ]);\n    };\n    var v = Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef);\n    return {\n        commentStart: \"{-\",\n        commentEnd: \"-}\",\n        commentLine: \"--\",\n        nestedComments: true,\n        identStart: Text_Parsing_Parser_Token.letter(Data_Identity.monadIdentity),\n        identLetter: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)([ \"_\", \"'\" ])),\n        opStart: op$prime(Data_Identity.monadIdentity),\n        opLetter: op$prime(Data_Identity.monadIdentity),\n        reservedNames: [  ],\n        reservedOpNames: [  ],\n        caseSensitive: true\n    };\n})();\nvar haskell98Def = (function () {\n    var v = Text_Parsing_Parser_Token.unGenLanguageDef(haskellStyle);\n    return {\n        commentStart: v.commentStart,\n        commentEnd: v.commentEnd,\n        commentLine: v.commentLine,\n        nestedComments: v.nestedComments,\n        identStart: v.identStart,\n        identLetter: v.identLetter,\n        opStart: v.opStart,\n        opLetter: v.opLetter,\n        reservedNames: [ \"let\", \"in\", \"case\", \"of\", \"if\", \"then\", \"else\", \"data\", \"type\", \"class\", \"default\", \"deriving\", \"do\", \"import\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"module\", \"newtype\", \"where\", \"primitive\" ],\n        reservedOpNames: [ \"::\", \"..\", \"=\", \"\\\\\", \"|\", \"<-\", \"->\", \"@\", \"~\", \"=>\" ],\n        caseSensitive: v.caseSensitive\n    };\n})();\nvar haskellDef = {\n    commentStart: haskell98Def.commentStart,\n    commentEnd: haskell98Def.commentEnd,\n    commentLine: haskell98Def.commentLine,\n    nestedComments: haskell98Def.nestedComments,\n    identStart: haskell98Def.identStart,\n    identLetter: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(haskell98Def.identLetter)(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\"#\")),\n    opStart: haskell98Def.opStart,\n    opLetter: haskell98Def.opLetter,\n    reservedNames: Data_Semigroup.append(Data_Semigroup.semigroupArray)(haskell98Def.reservedNames)([ \"foreign\", \"import\", \"export\", \"primitive\", \"_ccall_\", \"_casm_\", \"forall\" ]),\n    reservedOpNames: haskell98Def.reservedOpNames,\n    caseSensitive: haskell98Def.caseSensitive\n};\nvar haskell = Text_Parsing_Parser_Token.makeTokenParser(Data_Identity.monadIdentity)(haskellDef);\nvar javaStyle = (function () {\n    var v = Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef);\n    return {\n        commentStart: \"/*\",\n        commentEnd: \"*/\",\n        commentLine: \"//\",\n        nestedComments: true,\n        identStart: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.letter(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)([ \"_\", \"$\" ])),\n        identLetter: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)([ \"_\", \"$\" ])),\n        opStart: v.opStart,\n        opLetter: v.opLetter,\n        reservedNames: [  ],\n        reservedOpNames: [  ],\n        caseSensitive: false\n    };\n})();\nmodule.exports = {\n    haskellDef: haskellDef,\n    haskell: haskell,\n    emptyDef: emptyDef,\n    haskellStyle: haskellStyle,\n    javaStyle: javaStyle\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Language.purs?");

/***/ }),

/***/ "./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Pos.purs":
/*!****************************************************************!*\
  !*** ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Pos.purs ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_EuclideanRing = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs */ \"./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_String_Common = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Common.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Common.purs\");\nvar Position = function (x) {\n    return x;\n};\nvar updatePosString = function (pos$prime) {\n    return function (str) {\n        var updatePosChar = function (v) {\n            return function (c) {\n                if (c === \"\\x0a\") {\n                    return {\n                        line: v.line + 1 | 0,\n                        column: 1\n                    };\n                };\n                if (c === \"\\x0d\") {\n                    return {\n                        line: v.line + 1 | 0,\n                        column: 1\n                    };\n                };\n                if (c === \"\\x09\") {\n                    return {\n                        line: v.line,\n                        column: (v.column + 8 | 0) - Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(v.column - 1 | 0)(8) | 0\n                    };\n                };\n                return {\n                    line: v.line,\n                    column: v.column + 1 | 0\n                };\n            };\n        };\n        return Data_Foldable.foldl(Data_Foldable.foldableArray)(updatePosChar)(pos$prime)(Data_String_Common.split(Data_Newtype.wrap()(\"\"))(str));\n    };\n};\nvar showPosition = {\n    show: function (v) {\n        return \"(Position { line: \" + (Data_Show.show(Data_Show.showInt)(v.line) + (\", column: \" + (Data_Show.show(Data_Show.showInt)(v.column) + \" })\")));\n    }\n};\nvar initialPos = {\n    line: 1,\n    column: 1\n};\nvar genericPosition = {\n    to: function (x) {\n        return x;\n    },\n    from: function (x) {\n        return x;\n    }\n};\nvar eqPosition = {\n    eq: function (x) {\n        return function (y) {\n            return x.column === y.column && x.line === y.line;\n        };\n    }\n};\nvar ordPosition = {\n    compare: function (x) {\n        return function (y) {\n            var v = Data_Ord.compare(Data_Ord.ordInt)(x.column)(y.column);\n            if (v instanceof Data_Ordering.LT) {\n                return Data_Ordering.LT.value;\n            };\n            if (v instanceof Data_Ordering.GT) {\n                return Data_Ordering.GT.value;\n            };\n            return Data_Ord.compare(Data_Ord.ordInt)(x.line)(y.line);\n        };\n    },\n    Eq0: function () {\n        return eqPosition;\n    }\n};\nmodule.exports = {\n    Position: Position,\n    initialPos: initialPos,\n    updatePosString: updatePosString,\n    genericPosition: genericPosition,\n    showPosition: showPosition,\n    eqPosition: eqPosition,\n    ordPosition: ordPosition\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Pos.purs?");

/***/ }),

/***/ "./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs":
/*!*******************************************************************!*\
  !*** ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_State_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs\");\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_String_CodePoints = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs\");\nvar Data_String_CodeUnits = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs\");\nvar Data_String_Common = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Common.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Common.purs\");\nvar Text_Parsing_Parser = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs\");\nvar Text_Parsing_Parser_Combinators = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs\");\nvar Text_Parsing_Parser_Pos = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Pos.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Pos.purs\");\nvar uncons = function (dict) {\n    return dict.uncons;\n};\nvar stripPrefix = function (dict) {\n    return dict.stripPrefix;\n};\nvar stringLikeString = {\n    uncons: Data_String_CodeUnits.uncons,\n    drop: Data_String_CodePoints.drop,\n    stripPrefix: Data_String_CodeUnits.stripPrefix,\n    \"null\": Data_String_Common[\"null\"]\n};\nvar string = function (dictStringLike) {\n    return function (dictMonad) {\n        return function (str) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.gets(Text_Parsing_Parser.monadStateParserT(dictMonad))(function (v) {\n                return v.value0;\n            }))(function (input) {\n                var v = stripPrefix(dictStringLike)(Data_Newtype.wrap()(str))(input);\n                if (v instanceof Data_Maybe.Just) {\n                    return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.modify_(Text_Parsing_Parser.monadStateParserT(dictMonad))(function (v1) {\n                        return new Text_Parsing_Parser.ParseState(v.value0, Text_Parsing_Parser_Pos.updatePosString(v1.value1)(str), true);\n                    }))(function () {\n                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(str);\n                    });\n                };\n                return Text_Parsing_Parser.fail(dictMonad)(\"Expected \" + Data_Show.show(Data_Show.showString)(str));\n            });\n        };\n    };\n};\nvar $$null = function (dict) {\n    return dict[\"null\"];\n};\nvar eof = function (dictStringLike) {\n    return function (dictMonad) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.gets(Text_Parsing_Parser.monadStateParserT(dictMonad))(function (v) {\n            return v.value0;\n        }))(function (input) {\n            return Control_Applicative.unless(Text_Parsing_Parser.applicativeParserT(dictMonad))($$null(dictStringLike)(input))(Text_Parsing_Parser.fail(dictMonad)(\"Expected EOF\"));\n        });\n    };\n};\nvar drop = function (dict) {\n    return dict.drop;\n};\nvar anyChar = function (dictStringLike) {\n    return function (dictMonad) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.gets(Text_Parsing_Parser.monadStateParserT(dictMonad))(function (v) {\n            return v.value0;\n        }))(function (input) {\n            var v = uncons(dictStringLike)(input);\n            if (v instanceof Data_Maybe.Nothing) {\n                return Text_Parsing_Parser.fail(dictMonad)(\"Unexpected EOF\");\n            };\n            if (v instanceof Data_Maybe.Just) {\n                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.modify_(Text_Parsing_Parser.monadStateParserT(dictMonad))(function (v1) {\n                    return new Text_Parsing_Parser.ParseState(v.value0.tail, Text_Parsing_Parser_Pos.updatePosString(v1.value1)(Data_String_CodeUnits.singleton(v.value0.head)), true);\n                }))(function () {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v.value0.head);\n                });\n            };\n            throw new Error(\"Failed pattern match at Text.Parsing.Parser.String (line 56, column 3 - line 63, column 16): \" + [ v.constructor.name ]);\n        });\n    };\n};\nvar satisfy = function (dictStringLike) {\n    return function (dictMonad) {\n        return function (f) {\n            return Text_Parsing_Parser_Combinators.tryRethrow(dictMonad)(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(anyChar(dictStringLike)(dictMonad))(function (c) {\n                var $56 = f(c);\n                if ($56) {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(c);\n                };\n                return Text_Parsing_Parser.fail(dictMonad)(\"Character '\" + (Data_String_CodeUnits.singleton(c) + \"' did not satisfy predicate\"));\n            }));\n        };\n    };\n};\nvar $$char = function (dictStringLike) {\n    return function (dictMonad) {\n        return function (c) {\n            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfy(dictStringLike)(dictMonad)(function (v) {\n                return v === c;\n            }))(Data_Show.show(Data_Show.showChar)(c));\n        };\n    };\n};\nvar noneOf = function (dictStringLike) {\n    return function (dictMonad) {\n        return function (ss) {\n            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfy(dictStringLike)(dictMonad)(Data_Function.flip(Data_Foldable.notElem(Data_Foldable.foldableArray)(Data_Eq.eqChar))(ss)))(\"none of \" + Data_Show.show(Data_Show.showArray(Data_Show.showChar))(ss));\n        };\n    };\n};\nvar oneOf = function (dictStringLike) {\n    return function (dictMonad) {\n        return function (ss) {\n            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfy(dictStringLike)(dictMonad)(Data_Function.flip(Data_Foldable.elem(Data_Foldable.foldableArray)(Data_Eq.eqChar))(ss)))(\"one of \" + Data_Show.show(Data_Show.showArray(Data_Show.showChar))(ss));\n        };\n    };\n};\nvar whiteSpace = function (dictStringLike) {\n    return function (dictMonad) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Data_Array.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(satisfy(dictStringLike)(dictMonad)(function (c) {\n            return c === \"\\x0a\" || (c === \"\\x0d\" || (c === \" \" || c === \"\\x09\"));\n        })))(function (cs) {\n            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_String_CodeUnits.fromCharArray(cs));\n        });\n    };\n};\nvar skipSpaces = function (dictStringLike) {\n    return function (dictMonad) {\n        return Data_Functor[\"void\"](Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(whiteSpace(dictStringLike)(dictMonad));\n    };\n};\nmodule.exports = {\n    drop: drop,\n    \"null\": $$null,\n    stripPrefix: stripPrefix,\n    uncons: uncons,\n    eof: eof,\n    string: string,\n    anyChar: anyChar,\n    satisfy: satisfy,\n    \"char\": $$char,\n    whiteSpace: whiteSpace,\n    skipSpaces: skipSpaces,\n    oneOf: oneOf,\n    noneOf: noneOf,\n    stringLikeString: stringLikeString\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs?");

/***/ }),

/***/ "./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Token.purs":
/*!******************************************************************!*\
  !*** ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Token.purs ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Alternative = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alternative.purs */ \"./.spago/control/v5.0.0/src/Control/Alternative.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Lazy = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Lazy.purs */ \"./.spago/control/v5.0.0/src/Control/Lazy.purs\");\nvar Control_Monad_State_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs\");\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Char = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/Char.purs */ \"./.spago/strings/v5.0.0/src/Data/Char.purs\");\nvar Data_CodePoint_Unicode = __webpack_require__(/*! ./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs */ \"./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Int = __webpack_require__(/*! ./.spago/integers/v5.0.0/src/Data/Int.purs */ \"./.spago/integers/v5.0.0/src/Data/Int.purs\");\nvar Data_List = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List.purs */ \"./.spago/lists/v6.0.1/src/Data/List.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Ring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ring.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_String_CodePoints = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs\");\nvar Data_String_CodeUnits = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs\");\nvar Data_String_Common = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Common.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Common.purs\");\nvar Data_String_Unicode = __webpack_require__(/*! ./.spago/unicode/v5.0.0/src/Data/String/Unicode.purs */ \"./.spago/unicode/v5.0.0/src/Data/String/Unicode.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar $$Math = __webpack_require__(/*! ./.spago/math/v3.0.0/src/Math.purs */ \"./.spago/math/v3.0.0/src/Math.purs\");\nvar Text_Parsing_Parser = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs\");\nvar Text_Parsing_Parser_Combinators = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs\");\nvar Text_Parsing_Parser_String = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs\");\nvar LanguageDef = function (x) {\n    return x;\n};\nvar unGenLanguageDef = function (v) {\n    return v;\n};\nvar token = function (dictMonad) {\n    return function (tokpos) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.gets(Text_Parsing_Parser.monadStateParserT(dictMonad))(function (v) {\n            return v.value0;\n        }))(function (input) {\n            var v = Data_List.uncons(input);\n            if (v instanceof Data_Maybe.Nothing) {\n                return Text_Parsing_Parser.fail(dictMonad)(\"Unexpected EOF\");\n            };\n            if (v instanceof Data_Maybe.Just) {\n                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Monad_State_Class.modify_(Text_Parsing_Parser.monadStateParserT(dictMonad))(function (v1) {\n                    return new Text_Parsing_Parser.ParseState(v.value0.tail, tokpos(v.value0.head), true);\n                }))(function () {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v.value0.head);\n                });\n            };\n            throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 56, column 3 - line 61, column 16): \" + [ v.constructor.name ]);\n        });\n    };\n};\nvar when = function (dictMonad) {\n    return function (tokpos) {\n        return function (f) {\n            return Text_Parsing_Parser_Combinators.tryRethrow(dictMonad)(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(token(dictMonad)(tokpos))(function (a) {\n                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Alternative.guard(Text_Parsing_Parser.alternativeParserT(dictMonad))(f(a)))(function () {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(a);\n                });\n            }));\n        };\n    };\n};\nvar theReservedNames = function (dictMonad) {\n    return function (v) {\n        if (v.caseSensitive) {\n            return Data_Array.sort(Data_Ord.ordString)(v.reservedNames);\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Array.sort(Data_Ord.ordString)(Data_Functor.map(Data_Functor.functorArray)(Data_String_Common.toLower)(v.reservedNames));\n        };\n        throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 728, column 1 - line 728, column 82): \" + [ v.constructor.name ]);\n    };\n};\nvar satisfyCP = function (dictMonad) {\n    return function (p) {\n        return Text_Parsing_Parser_String.satisfy(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(function ($117) {\n            return p(Data_String_CodePoints.codePointFromChar($117));\n        });\n    };\n};\nvar simpleSpace = function (dictMonad) {\n    return Text_Parsing_Parser_Combinators.skipMany1(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isSpace));\n};\nvar space = function (dictMonad) {\n    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isSpace))(\"space\");\n};\nvar upper = function (dictMonad) {\n    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isUpper))(\"uppercase letter\");\n};\nvar oneLineComment = function (dictMonad) {\n    return function (v) {\n        return Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_Combinators[\"try\"](dictMonad)(Text_Parsing_Parser_String.string(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(v.commentLine)))(Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_String.satisfy(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(function (v1) {\n            return v1 !== \"\\x0a\";\n        })));\n    };\n};\nvar octDigit = function (dictMonad) {\n    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isOctDigit))(\"oct digit\");\n};\nvar match = function (dictMonad) {\n    return function (dictEq) {\n        return function (tokpos) {\n            return function (tok) {\n                return when(dictMonad)(tokpos)(function (v) {\n                    return Data_Eq.eq(dictEq)(v)(tok);\n                });\n            };\n        };\n    };\n};\nvar letter = function (dictMonad) {\n    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isAlpha))(\"letter\");\n};\nvar isReserved = function ($copy_names) {\n    return function ($copy_name) {\n        var $tco_var_names = $copy_names;\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(names, name) {\n            var v = Data_Array.uncons(names);\n            if (v instanceof Data_Maybe.Nothing) {\n                $tco_done = true;\n                return false;\n            };\n            if (v instanceof Data_Maybe.Just) {\n                var v1 = Data_Ord.compare(Data_Ord.ordString)(v.value0.head)(name);\n                if (v1 instanceof Data_Ordering.LT) {\n                    $tco_var_names = v.value0.tail;\n                    $copy_name = name;\n                    return;\n                };\n                if (v1 instanceof Data_Ordering.EQ) {\n                    $tco_done = true;\n                    return true;\n                };\n                if (v1 instanceof Data_Ordering.GT) {\n                    $tco_done = true;\n                    return false;\n                };\n                throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 723, column 39 - line 726, column 53): \" + [ v1.constructor.name ]);\n            };\n            throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 721, column 5 - line 726, column 53): \" + [ v.constructor.name ]);\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($tco_var_names, $copy_name);\n        };\n        return $tco_result;\n    };\n};\nvar isReservedName = function (dictMonad) {\n    return function (v) {\n        return function (name) {\n            var caseName = (function () {\n                if (v.caseSensitive) {\n                    return name;\n                };\n                if (Data_Boolean.otherwise) {\n                    return Data_String_Common.toLower(name);\n                };\n                throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 716, column 5 - line 717, column 57): \" + [  ]);\n            })();\n            return isReserved(theReservedNames(dictMonad)(v))(caseName);\n        };\n    };\n};\nvar inCommentSingle = function (dictMonad) {\n    return function (v) {\n        var startEnd = Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_String_CodeUnits.toCharArray(v.commentEnd))(Data_String_CodeUnits.toCharArray(v.commentStart));\n        return Control_Lazy.fix(Text_Parsing_Parser.lazyParserT)(function (p) {\n            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor[\"void\"](Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_Combinators[\"try\"](dictMonad)(Text_Parsing_Parser_String.string(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(v.commentEnd))))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_Combinators.skipMany1(dictMonad)(Text_Parsing_Parser_String.noneOf(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(startEnd)))(p)))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(startEnd))(p)))(\"end of comment\");\n        });\n    };\n};\nvar multiLineComment = function (dictMonad) {\n    return function (v) {\n        return Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_Combinators[\"try\"](dictMonad)(Text_Parsing_Parser_String.string(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(v.commentStart)))(inComment(dictMonad)(v));\n    };\n};\nvar inCommentMulti = function (dictMonad) {\n    return function (v) {\n        var startEnd = Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_String_CodeUnits.toCharArray(v.commentEnd))(Data_String_CodeUnits.toCharArray(v.commentStart));\n        return Control_Lazy.fix(Text_Parsing_Parser.lazyParserT)(function (p) {\n            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor[\"void\"](Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_Combinators[\"try\"](dictMonad)(Text_Parsing_Parser_String.string(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(v.commentEnd))))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(multiLineComment(dictMonad)(v))(p)))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_Combinators.skipMany1(dictMonad)(Text_Parsing_Parser_String.noneOf(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(startEnd)))(p)))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(startEnd))(p)))(\"end of comment\");\n        });\n    };\n};\nvar inComment = function (dictMonad) {\n    return function (v) {\n        if (v.nestedComments) {\n            return inCommentMulti(dictMonad)(v);\n        };\n        return inCommentSingle(dictMonad)(v);\n    };\n};\nvar whiteSpace$prime = function (dictMonad) {\n    return function (v) {\n        if (Data_String_Common[\"null\"](v.commentLine) && Data_String_Common[\"null\"](v.commentStart)) {\n            return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(simpleSpace(dictMonad))(\"\"));\n        };\n        if (Data_String_Common[\"null\"](v.commentLine)) {\n            return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(simpleSpace(dictMonad))(multiLineComment(dictMonad)(v)))(\"\"));\n        };\n        if (Data_String_Common[\"null\"](v.commentStart)) {\n            return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(simpleSpace(dictMonad))(oneLineComment(dictMonad)(v)))(\"\"));\n        };\n        if (Data_Boolean.otherwise) {\n            return Text_Parsing_Parser_Combinators.skipMany(dictMonad)(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(simpleSpace(dictMonad))(oneLineComment(dictMonad)(v)))(multiLineComment(dictMonad)(v)))(\"\"));\n        };\n        throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 737, column 1 - line 737, column 86): \" + [ v.constructor.name ]);\n    };\n};\nvar hexDigit = function (dictMonad) {\n    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isHexDigit))(\"hex digit\");\n};\nvar digit = function (dictMonad) {\n    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isDecDigit))(\"digit\");\n};\nvar makeTokenParser = function (dictMonad) {\n    return function (v) {\n        var stringLetter = Text_Parsing_Parser_String.satisfy(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(function (c) {\n            return c !== \"\\\"\" && (c !== \"\\\\\" && c > \"\\x1a\");\n        });\n        var sign = function (dictRing) {\n            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"-\"))(Data_Ring.negate(dictRing)))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"+\"))(Control_Category.identity(Control_Category.categoryFn))))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Control_Category.identity(Control_Category.categoryFn)));\n        };\n        var oper = (function () {\n            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(v.opStart)(function (c) {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Data_Array.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(v.opLetter))(function (cs) {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_String_CodeUnits.singleton(c) + Data_String_CodeUnits.fromCharArray(cs));\n                });\n            });\n            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(go)(\"operator\");\n        })();\n        var number = function (base) {\n            return function (baseDigit) {\n                var folder = function (v1) {\n                    return function (v2) {\n                        if (v1 instanceof Data_Maybe.Nothing) {\n                            return Data_Maybe.Nothing.value;\n                        };\n                        if (v1 instanceof Data_Maybe.Just) {\n                            return Data_Functor.map(Data_Maybe.functorMaybe)(function (v3) {\n                                return (base * v1.value0 | 0) + v3 | 0;\n                            })(Data_CodePoint_Unicode.hexDigitToInt(Data_String_CodePoints.codePointFromChar(v2)));\n                        };\n                        throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 603, column 9 - line 603, column 49): \" + [ v1.constructor.name, v2.constructor.name ]);\n                    };\n                };\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Data_Array.some(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(baseDigit))(function (digits) {\n                    return Data_Maybe.maybe(Text_Parsing_Parser.fail(dictMonad)(\"not digits\"))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad)))(Data_Foldable.foldl(Data_Foldable.foldableArray)(folder)(new Data_Maybe.Just(0))(digits));\n                });\n            };\n        };\n        var octal = Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(dictMonad)([ \"o\", \"O\" ]))(number(8)(octDigit(dictMonad)));\n        var lexeme = function (p) {\n            return Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(dictMonad))(p)(whiteSpace$prime(dictMonad)(v));\n        };\n        var reservedOp = function (name) {\n            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String.string(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(name))(function () {\n                return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Text_Parsing_Parser_Combinators.notFollowedBy(dictMonad)(v.opLetter))(\"end of \" + name);\n            });\n            return lexeme(Text_Parsing_Parser_Combinators[\"try\"](dictMonad)(go));\n        };\n        var symbol = function (name) {\n            return Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(lexeme(Text_Parsing_Parser_String.string(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(name)))(name);\n        };\n        var parens = function (p) {\n            return Text_Parsing_Parser_Combinators.between(dictMonad)(symbol(\"(\"))(symbol(\")\"))(p);\n        };\n        var semi = symbol(\";\");\n        var semiSep = function (p) {\n            return Text_Parsing_Parser_Combinators.sepBy(dictMonad)(p)(semi);\n        };\n        var semiSep1 = function (p) {\n            return Text_Parsing_Parser_Combinators.sepBy1(dictMonad)(p)(semi);\n        };\n        var isReservedOp = function (name) {\n            return isReserved(Data_Array.sort(Data_Ord.ordString)(v.reservedOpNames))(name);\n        };\n        var operator = (function () {\n            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(oper)(function (name) {\n                var $85 = isReservedOp(name);\n                if ($85) {\n                    return Text_Parsing_Parser.fail(dictMonad)(\"reserved operator \" + name);\n                };\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(name);\n            });\n            return lexeme(Text_Parsing_Parser_Combinators[\"try\"](dictMonad)(go));\n        })();\n        var ident = (function () {\n            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(v.identStart)(function (c) {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Data_Array.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(v.identLetter))(function (cs) {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_String_CodeUnits.singleton(c) + Data_String_CodeUnits.fromCharArray(cs));\n                });\n            });\n            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(go)(\"identifier\");\n        })();\n        var identifier = (function () {\n            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(ident)(function (name) {\n                var $86 = isReservedName(dictMonad)(v)(name);\n                if ($86) {\n                    return Text_Parsing_Parser.fail(dictMonad)(\"reserved word \" + Data_Show.show(Data_Show.showString)(name));\n                };\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(name);\n            });\n            return lexeme(Text_Parsing_Parser_Combinators[\"try\"](dictMonad)(go));\n        })();\n        var hexadecimal = Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(dictMonad)([ \"x\", \"X\" ]))(number(16)(hexDigit(dictMonad)));\n        var fraction = (function () {\n            var op = function (v1) {\n                return function (v2) {\n                    if (v2 instanceof Data_Maybe.Nothing) {\n                        return Data_Maybe.Nothing.value;\n                    };\n                    if (v2 instanceof Data_Maybe.Just) {\n                        return Control_Bind.bind(Data_Maybe.bindMaybe)(Data_CodePoint_Unicode.hexDigitToInt(Data_String_CodePoints.codePointFromChar(v1)))(function (int$prime) {\n                            return Control_Applicative.pure(Data_Maybe.applicativeMaybe)((v2.value0 + Data_Int.toNumber(int$prime)) / 10.0);\n                        });\n                    };\n                    throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 553, column 9 - line 553, column 51): \" + [ v1.constructor.name, v2.constructor.name ]);\n                };\n            };\n            return Text_Parsing_Parser_Combinators.asErrorMessage(dictMonad)(\"fraction\")(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\".\"))(function () {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Data_Array.some(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(digit(dictMonad)))(\"fraction\"))(function (digits) {\n                    return Data_Maybe.maybe(Text_Parsing_Parser.fail(dictMonad)(\"not digit\"))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad)))(Data_Foldable.foldr(Data_Foldable.foldableArray)(op)(new Data_Maybe.Just(0.0))(digits));\n                });\n            }));\n        })();\n        var escapeGap = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Data_Array.some(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(space(dictMonad)))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"\\\\\")))(\"end of string gap\");\n        var escapeEmpty = Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"&\");\n        var escMap = Data_Array.zip([ \"a\", \"b\", \"f\", \"n\", \"r\", \"t\", \"v\", \"\\\\\", \"\\\"\", \"'\" ])([ \"\\x07\", \"\\x08\", \"\\x0c\", \"\\x0a\", \"\\x0d\", \"\\x09\", \"\\x0b\", \"\\\\\", \"\\\"\", \"'\" ]);\n        var dot = symbol(\".\");\n        var decimal = number(10)(digit(dictMonad));\n        var exponent$prime = (function () {\n            var power = function (e) {\n                if (e < 0) {\n                    return 1.0 / power(-e | 0);\n                };\n                if (Data_Boolean.otherwise) {\n                    return $$Math.pow(10.0)(Data_Int.toNumber(e));\n                };\n                throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 566, column 9 - line 566, column 31): \" + [ e.constructor.name ]);\n            };\n            return Text_Parsing_Parser_Combinators.asErrorMessage(dictMonad)(\"exponent\")(Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String.oneOf(Text_Parsing_Parser_String.stringLikeString)(dictMonad)([ \"e\", \"E\" ]))(function () {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(sign(Data_Ring.ringInt))(function (f) {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(decimal)(\"exponent\"))(function (e) {\n                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(power(f(e)));\n                    });\n                });\n            }));\n        })();\n        var fractExponent = function (n) {\n            var justExponent = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(exponent$prime)(function (expo) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Int.toNumber(n) * expo);\n            });\n            var fractExponent$prime = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(fraction)(function (fract) {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_Combinators.option(dictMonad)(1.0)(exponent$prime))(function (expo) {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))((Data_Int.toNumber(n) + fract) * expo);\n                });\n            });\n            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(fractExponent$prime)(justExponent);\n        };\n        var fractFloat = function (n) {\n            return Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Either.Right.create)(fractExponent(n));\n        };\n        var decimalFloat = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(decimal)(function (n) {\n            return Text_Parsing_Parser_Combinators.option(dictMonad)(new Data_Either.Left(n))(fractFloat(n));\n        });\n        var zeroNumFloat = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Either.Left.create)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(hexadecimal)(octal)))(decimalFloat))(fractFloat(0)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(new Data_Either.Left(0)));\n        var natFloat = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"0\"))(zeroNumFloat))(decimalFloat);\n        var naturalOrFloat = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(lexeme(natFloat))(\"number\");\n        var floating = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(decimal)(fractExponent);\n        var $$float = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(lexeme(floating))(\"float\");\n        var zeroNumber = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"0\"))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(hexadecimal)(octal))(decimal))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(0))))(\"\");\n        var nat = Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(zeroNumber)(decimal);\n        var $$int = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(lexeme(sign(Data_Ring.ringInt)))(function (f) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(nat)(function (n) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(f(n));\n            });\n        });\n        var integer = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(lexeme($$int))(\"integer\");\n        var natural = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(lexeme(nat))(\"natural\");\n        var comma = symbol(\",\");\n        var commaSep = function (p) {\n            return Text_Parsing_Parser_Combinators.sepBy(dictMonad)(p)(comma);\n        };\n        var commaSep1 = function (p) {\n            return Text_Parsing_Parser_Combinators.sepBy1(dictMonad)(p)(comma);\n        };\n        var colon = symbol(\":\");\n        var charNum = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(decimal)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"o\"))(number(8)(octDigit(dictMonad)))))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"x\"))(number(16)(hexDigit(dictMonad)))))(function (code) {\n            var $91 = code > 1114111;\n            if ($91) {\n                return Text_Parsing_Parser.fail(dictMonad)(\"invalid escape sequence\");\n            };\n            var v1 = Data_Char.fromCharCode(code);\n            if (v1 instanceof Data_Maybe.Just) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v1.value0);\n            };\n            if (v1 instanceof Data_Maybe.Nothing) {\n                return Text_Parsing_Parser.fail(dictMonad)(\"invalid character code (should not happen)\");\n            };\n            throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 451, column 17 - line 453, column 81): \" + [ v1.constructor.name ]);\n        });\n        var charLetter = Text_Parsing_Parser_String.satisfy(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(function (c) {\n            return c !== \"'\" && (c !== \"\\\\\" && c > \"\\x1a\");\n        });\n        var charEsc = (function () {\n            var parseEsc = function (v1) {\n                return Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(v1.value0))(v1.value1);\n            };\n            return Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(dictMonad)(Data_Functor.map(Data_Functor.functorArray)(parseEsc)(escMap));\n        })();\n        var charControl = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"^\"))(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(upper(dictMonad))(function (code) {\n                var v1 = Data_Char.fromCharCode((Data_Char.toCharCode(code) - Data_Char.toCharCode(\"A\") | 0) + 1 | 0);\n                if (v1 instanceof Data_Maybe.Just) {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(v1.value0);\n                };\n                if (v1 instanceof Data_Maybe.Nothing) {\n                    return Text_Parsing_Parser.fail(dictMonad)(\"invalid character code (should not happen)\");\n                };\n                throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 440, column 9 - line 442, column 73): \" + [ v1.constructor.name ]);\n            });\n        });\n        var caseString = function (name) {\n            if (v.caseSensitive) {\n                return Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_String.string(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(name))(name);\n            };\n            if (Data_Boolean.otherwise) {\n                var msg = Data_Show.show(Data_Show.showString)(name);\n                var caseChar = function (c) {\n                    var v1 = function (v2) {\n                        if (Data_Boolean.otherwise) {\n                            return Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(c);\n                        };\n                        throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 307, column 1 - line 307, column 92): \" + [ c.constructor.name ]);\n                    };\n                    var $102 = Data_CodePoint_Unicode.isAlpha(Data_String_CodePoints.codePointFromChar(c));\n                    if ($102) {\n                        var $103 = Data_String_CodeUnits.toChar(Data_String_Unicode.toLowerSimple(Data_String_CodeUnits.singleton(c)));\n                        if ($103 instanceof Data_Maybe.Just) {\n                            var $104 = Data_String_CodeUnits.toChar(Data_String_Unicode.toUpperSimple(Data_String_CodeUnits.singleton(c)));\n                            if ($104 instanceof Data_Maybe.Just) {\n                                return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)($103.value0))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)($104.value0));\n                            };\n                            return v1(true);\n                        };\n                        return v1(true);\n                    };\n                    return v1(true);\n                };\n                var walk = function (name$prime) {\n                    var v1 = Data_String_CodeUnits.uncons(name$prime);\n                    if (v1 instanceof Data_Maybe.Nothing) {\n                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_Unit.unit);\n                    };\n                    if (v1 instanceof Data_Maybe.Just) {\n                        return Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(caseChar(v1.value0.head))(msg))(walk(v1.value0.tail));\n                    };\n                    throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 657, column 22 - line 659, column 86): \" + [ v1.constructor.name ]);\n                };\n                return Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(walk(name))(name);\n            };\n            throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 652, column 5 - line 652, column 52): \" + [ name.constructor.name ]);\n        };\n        var reserved = function (name) {\n            var go = Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(caseString(name))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Text_Parsing_Parser_Combinators.notFollowedBy(dictMonad)(v.identLetter))(\"end of \" + name));\n            return lexeme(Text_Parsing_Parser_Combinators[\"try\"](dictMonad)(go));\n        };\n        var brackets = function (p) {\n            return Text_Parsing_Parser_Combinators.between(dictMonad)(symbol(\"[\"))(symbol(\"]\"))(p);\n        };\n        var braces = function (p) {\n            return Text_Parsing_Parser_Combinators.between(dictMonad)(symbol(\"{\"))(symbol(\"}\"))(p);\n        };\n        var ascii3codes = [ \"NUL\", \"SOH\", \"STX\", \"ETX\", \"EOT\", \"ENQ\", \"ACK\", \"BEL\", \"DLE\", \"DC1\", \"DC2\", \"DC3\", \"DC4\", \"NAK\", \"SYN\", \"ETB\", \"CAN\", \"SUB\", \"ESC\", \"DEL\" ];\n        var ascii3 = [ \"\\x00\", \"\\x01\", \"\\x02\", \"\\x03\", \"\\x04\", \"\\x05\", \"\\x06\", \"\\x07\", \"\\x10\", \"\\x11\", \"\\x12\", \"\\x13\", \"\\x14\", \"\\x15\", \"\\x16\", \"\\x17\", \"\\x18\", \"\\x1a\", \"\\x1b\", \"\\x7f\" ];\n        var ascii2codes = [ \"BS\", \"HT\", \"LF\", \"VT\", \"FF\", \"CR\", \"SO\", \"SI\", \"EM\", \"FS\", \"GS\", \"RS\", \"US\", \"SP\" ];\n        var ascii2 = [ \"\\x08\", \"\\x09\", \"\\x0a\", \"\\x0b\", \"\\x0c\", \"\\x0d\", \"\\x0e\", \"\\x0f\", \"\\x19\", \"\\x1c\", \"\\x1d\", \"\\x1e\", \"\\x1f\", \" \" ];\n        var asciiMap = Data_Array.zip(Data_Semigroup.append(Data_Semigroup.semigroupArray)(ascii3codes)(ascii2codes))(Data_Semigroup.append(Data_Semigroup.semigroupArray)(ascii3)(ascii2));\n        var charAscii = (function () {\n            var parseAscii = function (v1) {\n                return Text_Parsing_Parser_Combinators[\"try\"](dictMonad)(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Text_Parsing_Parser_String.string(Text_Parsing_Parser_String.stringLikeString)(dictMonad)(v1.value0))(v1.value1));\n            };\n            return Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(dictMonad)(Data_Functor.map(Data_Functor.functorArray)(parseAscii)(asciiMap));\n        })();\n        var escapeCode = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(charEsc)(charNum))(charAscii))(charControl))(\"escape code\");\n        var charEscape = Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(dictMonad))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"\\\\\"))(escapeCode);\n        var characterChar = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(charLetter)(charEscape))(\"literal character\");\n        var charLiteral = (function () {\n            var go = Text_Parsing_Parser_Combinators.between(dictMonad)(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"'\"))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"'\"))(\"end of character\"))(characterChar);\n            return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(lexeme(go))(\"character\");\n        })();\n        var stringEscape = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"\\\\\"))(function () {\n            return Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(escapeGap)(Data_Maybe.Nothing.value))(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(escapeEmpty)(Data_Maybe.Nothing.value)))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Maybe.Just.create)(escapeCode));\n        });\n        var stringChar = Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Control_Alt.alt(Text_Parsing_Parser.altParserT(dictMonad))(Data_Functor.map(Text_Parsing_Parser.functorParserT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Maybe.Just.create)(stringLetter))(stringEscape))(\"string character\");\n        var stringLiteral = (function () {\n            var folder = function (v1) {\n                return function (chars) {\n                    if (v1 instanceof Data_Maybe.Nothing) {\n                        return chars;\n                    };\n                    if (v1 instanceof Data_Maybe.Just) {\n                        return new Data_List_Types.Cons(v1.value0, chars);\n                    };\n                    throw new Error(\"Failed pattern match at Text.Parsing.Parser.Token (line 407, column 9 - line 407, column 55): \" + [ v1.constructor.name, chars.constructor.name ]);\n                };\n            };\n            var go = Control_Bind.bind(Text_Parsing_Parser.bindParserT(dictMonad))(Text_Parsing_Parser_Combinators.between(dictMonad)(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"\\\"\"))(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(dictMonad)(\"\\\"\"))(\"end of string\"))(Data_List.many(Text_Parsing_Parser.alternativeParserT(dictMonad))(Text_Parsing_Parser.lazyParserT)(stringChar)))(function (maybeChars) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(dictMonad))(Data_String_CodeUnits.fromCharArray(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Foldable.foldr(Data_List_Types.foldableList)(folder)(Data_List_Types.Nil.value)(maybeChars))));\n            });\n            return lexeme(Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(go)(\"literal string\"));\n        })();\n        var angles = function (p) {\n            return Text_Parsing_Parser_Combinators.between(dictMonad)(symbol(\"<\"))(symbol(\">\"))(p);\n        };\n        return {\n            identifier: identifier,\n            reserved: reserved,\n            operator: operator,\n            reservedOp: reservedOp,\n            charLiteral: charLiteral,\n            stringLiteral: stringLiteral,\n            natural: natural,\n            integer: integer,\n            \"float\": $$float,\n            naturalOrFloat: naturalOrFloat,\n            decimal: decimal,\n            hexadecimal: hexadecimal,\n            octal: octal,\n            symbol: symbol,\n            lexeme: lexeme,\n            whiteSpace: whiteSpace$prime(dictMonad)(v),\n            parens: parens,\n            braces: braces,\n            angles: angles,\n            brackets: brackets,\n            semi: semi,\n            comma: comma,\n            colon: colon,\n            dot: dot,\n            semiSep: semiSep,\n            semiSep1: semiSep1,\n            commaSep: commaSep,\n            commaSep1: commaSep1\n        };\n    };\n};\nvar alphaNum = function (dictMonad) {\n    return Text_Parsing_Parser_Combinators.withErrorMessage(dictMonad)(satisfyCP(dictMonad)(Data_CodePoint_Unicode.isAlphaNum))(\"letter or digit\");\n};\nmodule.exports = {\n    token: token,\n    when: when,\n    match: match,\n    LanguageDef: LanguageDef,\n    unGenLanguageDef: unGenLanguageDef,\n    makeTokenParser: makeTokenParser,\n    digit: digit,\n    hexDigit: hexDigit,\n    octDigit: octDigit,\n    upper: upper,\n    space: space,\n    letter: letter,\n    alphaNum: alphaNum\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Token.purs?");

/***/ }),

/***/ "./.spago/partial/v3.0.0/src/Partial.purs":
/*!************************************************!*\
  !*** ./.spago/partial/v3.0.0/src/Partial.purs ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial.js */ \"./.spago/partial/v3.0.0/src/Partial.js\");\nvar crashWith = function (dictPartial) {\n    return $foreign[\"_crashWith\"];\n};\nvar crash = function (dictPartial) {\n    return crashWith()(\"Partial.crash: partial function\");\n};\nmodule.exports = {\n    crash: crash,\n    crashWith: crashWith\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/partial/v3.0.0/src/Partial.purs?");

/***/ }),

/***/ "./.spago/partial/v3.0.0/src/Partial/Unsafe.purs":
/*!*******************************************************!*\
  !*** ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.js */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.js\");\nvar Partial = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial.purs */ \"./.spago/partial/v3.0.0/src/Partial.purs\");\nvar unsafePartial = $foreign[\"_unsafePartial\"];\nvar unsafeCrashWith = function (msg) {\n    return unsafePartial(function (dictPartial) {\n        return Partial.crashWith()(msg);\n    });\n};\nmodule.exports = {\n    unsafePartial: unsafePartial,\n    unsafeCrashWith: unsafeCrashWith\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/partial/v3.0.0/src/Partial/Unsafe.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Control/Applicative.purs":
/*!************************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Control/Applicative.purs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar pure = function (dict) {\n    return dict.pure;\n};\nvar unless = function (dictApplicative) {\n    return function (v) {\n        return function (v1) {\n            if (!v) {\n                return v1;\n            };\n            if (v) {\n                return pure(dictApplicative)(Data_Unit.unit);\n            };\n            throw new Error(\"Failed pattern match at Control.Applicative (line 66, column 1 - line 66, column 65): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    };\n};\nvar when = function (dictApplicative) {\n    return function (v) {\n        return function (v1) {\n            if (v) {\n                return v1;\n            };\n            if (!v) {\n                return pure(dictApplicative)(Data_Unit.unit);\n            };\n            throw new Error(\"Failed pattern match at Control.Applicative (line 61, column 1 - line 61, column 63): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    };\n};\nvar liftA1 = function (dictApplicative) {\n    return function (f) {\n        return function (a) {\n            return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);\n        };\n    };\n};\nvar applicativeProxy = {\n    pure: function (v) {\n        return Type_Proxy[\"Proxy\"].value;\n    },\n    Apply0: function () {\n        return Control_Apply.applyProxy;\n    }\n};\nvar applicativeFn = {\n    pure: function (x) {\n        return function (v) {\n            return x;\n        };\n    },\n    Apply0: function () {\n        return Control_Apply.applyFn;\n    }\n};\nvar applicativeArray = {\n    pure: function (x) {\n        return [ x ];\n    },\n    Apply0: function () {\n        return Control_Apply.applyArray;\n    }\n};\nmodule.exports = {\n    pure: pure,\n    liftA1: liftA1,\n    unless: unless,\n    when: when,\n    applicativeFn: applicativeFn,\n    applicativeArray: applicativeArray,\n    applicativeProxy: applicativeProxy,\n    apply: Control_Apply.apply,\n    map: Data_Functor.map,\n    \"void\": Data_Functor[\"void\"]\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Control/Applicative.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Control/Apply.purs":
/*!******************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Control/Apply.purs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.js */ \"./.spago/prelude/v5.0.1/src/Control/Apply.js\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar applyProxy = {\n    apply: function (v) {\n        return function (v1) {\n            return Type_Proxy[\"Proxy\"].value;\n        };\n    },\n    Functor0: function () {\n        return Data_Functor.functorProxy;\n    }\n};\nvar applyFn = {\n    apply: function (f) {\n        return function (g) {\n            return function (x) {\n                return f(x)(g(x));\n            };\n        };\n    },\n    Functor0: function () {\n        return Data_Functor.functorFn;\n    }\n};\nvar applyArray = {\n    apply: $foreign.arrayApply,\n    Functor0: function () {\n        return Data_Functor.functorArray;\n    }\n};\nvar apply = function (dict) {\n    return dict.apply;\n};\nvar applyFirst = function (dictApply) {\n    return function (a) {\n        return function (b) {\n            return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function[\"const\"])(a))(b);\n        };\n    };\n};\nvar applySecond = function (dictApply) {\n    return function (a) {\n        return function (b) {\n            return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function[\"const\"](Control_Category.identity(Control_Category.categoryFn)))(a))(b);\n        };\n    };\n};\nvar lift2 = function (dictApply) {\n    return function (f) {\n        return function (a) {\n            return function (b) {\n                return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(f)(a))(b);\n            };\n        };\n    };\n};\nvar lift3 = function (dictApply) {\n    return function (f) {\n        return function (a) {\n            return function (b) {\n                return function (c) {\n                    return apply(dictApply)(apply(dictApply)(Data_Functor.map(dictApply.Functor0())(f)(a))(b))(c);\n                };\n            };\n        };\n    };\n};\nvar lift4 = function (dictApply) {\n    return function (f) {\n        return function (a) {\n            return function (b) {\n                return function (c) {\n                    return function (d) {\n                        return apply(dictApply)(apply(dictApply)(apply(dictApply)(Data_Functor.map(dictApply.Functor0())(f)(a))(b))(c))(d);\n                    };\n                };\n            };\n        };\n    };\n};\nvar lift5 = function (dictApply) {\n    return function (f) {\n        return function (a) {\n            return function (b) {\n                return function (c) {\n                    return function (d) {\n                        return function (e) {\n                            return apply(dictApply)(apply(dictApply)(apply(dictApply)(apply(dictApply)(Data_Functor.map(dictApply.Functor0())(f)(a))(b))(c))(d))(e);\n                        };\n                    };\n                };\n            };\n        };\n    };\n};\nmodule.exports = {\n    apply: apply,\n    applyFirst: applyFirst,\n    applySecond: applySecond,\n    lift2: lift2,\n    lift3: lift3,\n    lift4: lift4,\n    lift5: lift5,\n    applyFn: applyFn,\n    applyArray: applyArray,\n    applyProxy: applyProxy,\n    map: Data_Functor.map,\n    \"void\": Data_Functor[\"void\"]\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Control/Apply.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Control/Bind.purs":
/*!*****************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Control/Bind.purs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.js */ \"./.spago/prelude/v5.0.1/src/Control/Bind.js\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar discard = function (dict) {\n    return dict.discard;\n};\nvar bindProxy = {\n    bind: function (v) {\n        return function (v1) {\n            return Type_Proxy[\"Proxy\"].value;\n        };\n    },\n    Apply0: function () {\n        return Control_Apply.applyProxy;\n    }\n};\nvar bindFn = {\n    bind: function (m) {\n        return function (f) {\n            return function (x) {\n                return f(m(x))(x);\n            };\n        };\n    },\n    Apply0: function () {\n        return Control_Apply.applyFn;\n    }\n};\nvar bindArray = {\n    bind: $foreign.arrayBind,\n    Apply0: function () {\n        return Control_Apply.applyArray;\n    }\n};\nvar bind = function (dict) {\n    return dict.bind;\n};\nvar bindFlipped = function (dictBind) {\n    return Data_Function.flip(bind(dictBind));\n};\nvar composeKleisliFlipped = function (dictBind) {\n    return function (f) {\n        return function (g) {\n            return function (a) {\n                return bindFlipped(dictBind)(f)(g(a));\n            };\n        };\n    };\n};\nvar composeKleisli = function (dictBind) {\n    return function (f) {\n        return function (g) {\n            return function (a) {\n                return bind(dictBind)(f(a))(g);\n            };\n        };\n    };\n};\nvar discardProxy = {\n    discard: function (dictBind) {\n        return bind(dictBind);\n    }\n};\nvar discardProxy2 = {\n    discard: function (dictBind) {\n        return bind(dictBind);\n    }\n};\nvar discardProxy3 = {\n    discard: function (dictBind) {\n        return bind(dictBind);\n    }\n};\nvar discardUnit = {\n    discard: function (dictBind) {\n        return bind(dictBind);\n    }\n};\nvar ifM = function (dictBind) {\n    return function (cond) {\n        return function (t) {\n            return function (f) {\n                return bind(dictBind)(cond)(function (cond$prime) {\n                    if (cond$prime) {\n                        return t;\n                    };\n                    return f;\n                });\n            };\n        };\n    };\n};\nvar join = function (dictBind) {\n    return function (m) {\n        return bind(dictBind)(m)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nmodule.exports = {\n    bind: bind,\n    bindFlipped: bindFlipped,\n    discard: discard,\n    join: join,\n    composeKleisli: composeKleisli,\n    composeKleisliFlipped: composeKleisliFlipped,\n    ifM: ifM,\n    bindFn: bindFn,\n    bindArray: bindArray,\n    bindProxy: bindProxy,\n    discardUnit: discardUnit,\n    discardProxy: discardProxy,\n    discardProxy2: discardProxy2,\n    discardProxy3: discardProxy3,\n    liftA1: Control_Applicative.liftA1,\n    pure: Control_Applicative.pure,\n    unless: Control_Applicative.unless,\n    when: Control_Applicative.when,\n    apply: Control_Apply.apply,\n    map: Data_Functor.map,\n    \"void\": Data_Functor[\"void\"]\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Control/Bind.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Control/Category.purs":
/*!*********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Control/Category.purs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Semigroupoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs */ \"./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs\");\nvar identity = function (dict) {\n    return dict.identity;\n};\nvar categoryFn = {\n    identity: function (x) {\n        return x;\n    },\n    Semigroupoid0: function () {\n        return Control_Semigroupoid.semigroupoidFn;\n    }\n};\nmodule.exports = {\n    identity: identity,\n    categoryFn: categoryFn,\n    compose: Control_Semigroupoid.compose\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Control/Category.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Control/Monad.purs":
/*!******************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Control/Monad.purs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar whenM = function (dictMonad) {\n    return function (mb) {\n        return function (m) {\n            return Control_Bind.bind(dictMonad.Bind1())(mb)(function (b) {\n                return Control_Applicative.when(dictMonad.Applicative0())(b)(m);\n            });\n        };\n    };\n};\nvar unlessM = function (dictMonad) {\n    return function (mb) {\n        return function (m) {\n            return Control_Bind.bind(dictMonad.Bind1())(mb)(function (b) {\n                return Control_Applicative.unless(dictMonad.Applicative0())(b)(m);\n            });\n        };\n    };\n};\nvar monadProxy = {\n    Applicative0: function () {\n        return Control_Applicative.applicativeProxy;\n    },\n    Bind1: function () {\n        return Control_Bind.bindProxy;\n    }\n};\nvar monadFn = {\n    Applicative0: function () {\n        return Control_Applicative.applicativeFn;\n    },\n    Bind1: function () {\n        return Control_Bind.bindFn;\n    }\n};\nvar monadArray = {\n    Applicative0: function () {\n        return Control_Applicative.applicativeArray;\n    },\n    Bind1: function () {\n        return Control_Bind.bindArray;\n    }\n};\nvar liftM1 = function (dictMonad) {\n    return function (f) {\n        return function (a) {\n            return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {\n                return Control_Applicative.pure(dictMonad.Applicative0())(f(a$prime));\n            });\n        };\n    };\n};\nvar ap = function (dictMonad) {\n    return function (f) {\n        return function (a) {\n            return Control_Bind.bind(dictMonad.Bind1())(f)(function (f$prime) {\n                return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {\n                    return Control_Applicative.pure(dictMonad.Applicative0())(f$prime(a$prime));\n                });\n            });\n        };\n    };\n};\nmodule.exports = {\n    liftM1: liftM1,\n    whenM: whenM,\n    unlessM: unlessM,\n    ap: ap,\n    monadFn: monadFn,\n    monadArray: monadArray,\n    monadProxy: monadProxy,\n    liftA1: Control_Applicative.liftA1,\n    pure: Control_Applicative.pure,\n    unless: Control_Applicative.unless,\n    when: Control_Applicative.when,\n    apply: Control_Apply.apply,\n    bind: Control_Bind.bind,\n    ifM: Control_Bind.ifM,\n    join: Control_Bind.join,\n    map: Data_Functor.map,\n    \"void\": Data_Functor[\"void\"]\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Control/Monad.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs":
/*!*************************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar semigroupoidFn = {\n    compose: function (f) {\n        return function (g) {\n            return function (x) {\n                return f(g(x));\n            };\n        };\n    }\n};\nvar compose = function (dict) {\n    return dict.compose;\n};\nvar composeFlipped = function (dictSemigroupoid) {\n    return function (f) {\n        return function (g) {\n            return compose(dictSemigroupoid)(g)(f);\n        };\n    };\n};\nmodule.exports = {\n    compose: compose,\n    composeFlipped: composeFlipped,\n    semigroupoidFn: semigroupoidFn\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Boolean.purs":
/*!*****************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Boolean.purs ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar otherwise = true;\nmodule.exports = {\n    otherwise: otherwise\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Boolean.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Bounded.purs":
/*!*****************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Bounded.purs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Bounded.js */ \"./.spago/prelude/v5.0.1/src/Data/Bounded.js\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Record_Unsafe = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Record/Unsafe.purs */ \"./.spago/prelude/v5.0.1/src/Record/Unsafe.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar topRecord = function (dict) {\n    return dict.topRecord;\n};\nvar top = function (dict) {\n    return dict.top;\n};\nvar boundedUnit = {\n    top: Data_Unit.unit,\n    bottom: Data_Unit.unit,\n    Ord0: function () {\n        return Data_Ord.ordUnit;\n    }\n};\nvar boundedRecordNil = {\n    topRecord: function (v) {\n        return function (v1) {\n            return {};\n        };\n    },\n    bottomRecord: function (v) {\n        return function (v1) {\n            return {};\n        };\n    },\n    OrdRecord0: function () {\n        return Data_Ord.ordRecordNil;\n    }\n};\nvar boundedProxy3 = {\n    bottom: Type_Proxy.Proxy3.value,\n    top: Type_Proxy.Proxy3.value,\n    Ord0: function () {\n        return Data_Ord.ordProxy3;\n    }\n};\nvar boundedProxy2 = {\n    bottom: Type_Proxy.Proxy2.value,\n    top: Type_Proxy.Proxy2.value,\n    Ord0: function () {\n        return Data_Ord.ordProxy2;\n    }\n};\nvar boundedProxy = {\n    bottom: Type_Proxy[\"Proxy\"].value,\n    top: Type_Proxy[\"Proxy\"].value,\n    Ord0: function () {\n        return Data_Ord.ordProxy;\n    }\n};\nvar boundedOrdering = {\n    top: Data_Ordering.GT.value,\n    bottom: Data_Ordering.LT.value,\n    Ord0: function () {\n        return Data_Ord.ordOrdering;\n    }\n};\nvar boundedNumber = {\n    top: $foreign.topNumber,\n    bottom: $foreign.bottomNumber,\n    Ord0: function () {\n        return Data_Ord.ordNumber;\n    }\n};\nvar boundedInt = {\n    top: $foreign.topInt,\n    bottom: $foreign.bottomInt,\n    Ord0: function () {\n        return Data_Ord.ordInt;\n    }\n};\nvar boundedChar = {\n    top: $foreign.topChar,\n    bottom: $foreign.bottomChar,\n    Ord0: function () {\n        return Data_Ord.ordChar;\n    }\n};\nvar boundedBoolean = {\n    top: true,\n    bottom: false,\n    Ord0: function () {\n        return Data_Ord.ordBoolean;\n    }\n};\nvar bottomRecord = function (dict) {\n    return dict.bottomRecord;\n};\nvar boundedRecord = function (dictRowToList) {\n    return function (dictBoundedRecord) {\n        return {\n            top: topRecord(dictBoundedRecord)(Type_Proxy[\"Proxy\"].value)(Type_Proxy[\"Proxy\"].value),\n            bottom: bottomRecord(dictBoundedRecord)(Type_Proxy[\"Proxy\"].value)(Type_Proxy[\"Proxy\"].value),\n            Ord0: function () {\n                return Data_Ord.ordRecord()(dictBoundedRecord.OrdRecord0());\n            }\n        };\n    };\n};\nvar bottom = function (dict) {\n    return dict.bottom;\n};\nvar boundedRecordCons = function (dictIsSymbol) {\n    return function (dictBounded) {\n        return function (dictCons) {\n            return function (dictCons1) {\n                return function (dictBoundedRecord) {\n                    return {\n                        topRecord: function (v) {\n                            return function (rowProxy) {\n                                var tail = topRecord(dictBoundedRecord)(Type_Proxy[\"Proxy\"].value)(rowProxy);\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var insert = Record_Unsafe.unsafeSet(key);\n                                return insert(top(dictBounded))(tail);\n                            };\n                        },\n                        bottomRecord: function (v) {\n                            return function (rowProxy) {\n                                var tail = bottomRecord(dictBoundedRecord)(Type_Proxy[\"Proxy\"].value)(rowProxy);\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var insert = Record_Unsafe.unsafeSet(key);\n                                return insert(bottom(dictBounded))(tail);\n                            };\n                        },\n                        OrdRecord0: function () {\n                            return Data_Ord.ordRecordCons(dictBoundedRecord.OrdRecord0())()(dictIsSymbol)(dictBounded.Ord0());\n                        }\n                    };\n                };\n            };\n        };\n    };\n};\nmodule.exports = {\n    bottom: bottom,\n    top: top,\n    bottomRecord: bottomRecord,\n    topRecord: topRecord,\n    boundedBoolean: boundedBoolean,\n    boundedInt: boundedInt,\n    boundedChar: boundedChar,\n    boundedOrdering: boundedOrdering,\n    boundedUnit: boundedUnit,\n    boundedNumber: boundedNumber,\n    boundedProxy: boundedProxy,\n    boundedProxy2: boundedProxy2,\n    boundedProxy3: boundedProxy3,\n    boundedRecordNil: boundedRecordNil,\n    boundedRecordCons: boundedRecordCons,\n    boundedRecord: boundedRecord,\n    EQ: Data_Ord.EQ,\n    GT: Data_Ord.GT,\n    LT: Data_Ord.LT,\n    compare: Data_Ord.compare\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Bounded.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/CommutativeRing.purs":
/*!*************************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/CommutativeRing.purs ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Ring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ring.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar commutativeRingUnit = {\n    Ring0: function () {\n        return Data_Ring.ringUnit;\n    }\n};\nvar commutativeRingRecordNil = {\n    RingRecord0: function () {\n        return Data_Ring.ringRecordNil;\n    }\n};\nvar commutativeRingRecordCons = function (dictIsSymbol) {\n    return function (dictCons) {\n        return function (dictCommutativeRingRecord) {\n            return function (dictCommutativeRing) {\n                return {\n                    RingRecord0: function () {\n                        return Data_Ring.ringRecordCons(dictIsSymbol)()(dictCommutativeRingRecord.RingRecord0())(dictCommutativeRing.Ring0());\n                    }\n                };\n            };\n        };\n    };\n};\nvar commutativeRingRecord = function (dictRowToList) {\n    return function (dictCommutativeRingRecord) {\n        return {\n            Ring0: function () {\n                return Data_Ring.ringRecord()(dictCommutativeRingRecord.RingRecord0());\n            }\n        };\n    };\n};\nvar commutativeRingProxy3 = {\n    Ring0: function () {\n        return Data_Ring.ringProxy3;\n    }\n};\nvar commutativeRingProxy2 = {\n    Ring0: function () {\n        return Data_Ring.ringProxy2;\n    }\n};\nvar commutativeRingProxy = {\n    Ring0: function () {\n        return Data_Ring.ringProxy;\n    }\n};\nvar commutativeRingNumber = {\n    Ring0: function () {\n        return Data_Ring.ringNumber;\n    }\n};\nvar commutativeRingInt = {\n    Ring0: function () {\n        return Data_Ring.ringInt;\n    }\n};\nvar commutativeRingFn = function (dictCommutativeRing) {\n    return {\n        Ring0: function () {\n            return Data_Ring.ringFn(dictCommutativeRing.Ring0());\n        }\n    };\n};\nmodule.exports = {\n    commutativeRingInt: commutativeRingInt,\n    commutativeRingNumber: commutativeRingNumber,\n    commutativeRingUnit: commutativeRingUnit,\n    commutativeRingFn: commutativeRingFn,\n    commutativeRingRecord: commutativeRingRecord,\n    commutativeRingProxy: commutativeRingProxy,\n    commutativeRingProxy2: commutativeRingProxy2,\n    commutativeRingProxy3: commutativeRingProxy3,\n    commutativeRingRecordNil: commutativeRingRecordNil,\n    commutativeRingRecordCons: commutativeRingRecordCons,\n    add: Data_Semiring.add,\n    mul: Data_Semiring.mul,\n    one: Data_Semiring.one,\n    zero: Data_Semiring.zero\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/CommutativeRing.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Eq.purs":
/*!************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Eq.purs ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.js */ \"./.spago/prelude/v5.0.1/src/Data/Eq.js\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Record_Unsafe = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Record/Unsafe.purs */ \"./.spago/prelude/v5.0.1/src/Record/Unsafe.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar eqVoid = {\n    eq: function (v) {\n        return function (v1) {\n            return true;\n        };\n    }\n};\nvar eqUnit = {\n    eq: function (v) {\n        return function (v1) {\n            return true;\n        };\n    }\n};\nvar eqString = {\n    eq: $foreign.eqStringImpl\n};\nvar eqRowNil = {\n    eqRecord: function (v) {\n        return function (v1) {\n            return function (v2) {\n                return true;\n            };\n        };\n    }\n};\nvar eqRecord = function (dict) {\n    return dict.eqRecord;\n};\nvar eqRec = function (dictRowToList) {\n    return function (dictEqRecord) {\n        return {\n            eq: eqRecord(dictEqRecord)(Type_Proxy[\"Proxy\"].value)\n        };\n    };\n};\nvar eqProxy3 = {\n    eq: function (v) {\n        return function (v1) {\n            return true;\n        };\n    }\n};\nvar eqProxy2 = {\n    eq: function (v) {\n        return function (v1) {\n            return true;\n        };\n    }\n};\nvar eqProxy = {\n    eq: function (v) {\n        return function (v1) {\n            return true;\n        };\n    }\n};\nvar eqNumber = {\n    eq: $foreign.eqNumberImpl\n};\nvar eqInt = {\n    eq: $foreign.eqIntImpl\n};\nvar eqChar = {\n    eq: $foreign.eqCharImpl\n};\nvar eqBoolean = {\n    eq: $foreign.eqBooleanImpl\n};\nvar eq1 = function (dict) {\n    return dict.eq1;\n};\nvar eq = function (dict) {\n    return dict.eq;\n};\nvar eqArray = function (dictEq) {\n    return {\n        eq: $foreign.eqArrayImpl(eq(dictEq))\n    };\n};\nvar eq1Array = {\n    eq1: function (dictEq) {\n        return eq(eqArray(dictEq));\n    }\n};\nvar eqRowCons = function (dictEqRecord) {\n    return function (dictCons) {\n        return function (dictIsSymbol) {\n            return function (dictEq) {\n                return {\n                    eqRecord: function (v) {\n                        return function (ra) {\n                            return function (rb) {\n                                var tail = eqRecord(dictEqRecord)(Type_Proxy[\"Proxy\"].value)(ra)(rb);\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var get = Record_Unsafe.unsafeGet(key);\n                                return eq(dictEq)(get(ra))(get(rb)) && tail;\n                            };\n                        };\n                    }\n                };\n            };\n        };\n    };\n};\nvar notEq = function (dictEq) {\n    return function (x) {\n        return function (y) {\n            return eq(eqBoolean)(eq(dictEq)(x)(y))(false);\n        };\n    };\n};\nvar notEq1 = function (dictEq1) {\n    return function (dictEq) {\n        return function (x) {\n            return function (y) {\n                return eq(eqBoolean)(eq1(dictEq1)(dictEq)(x)(y))(false);\n            };\n        };\n    };\n};\nmodule.exports = {\n    eq: eq,\n    notEq: notEq,\n    eq1: eq1,\n    notEq1: notEq1,\n    eqRecord: eqRecord,\n    eqBoolean: eqBoolean,\n    eqInt: eqInt,\n    eqNumber: eqNumber,\n    eqChar: eqChar,\n    eqString: eqString,\n    eqUnit: eqUnit,\n    eqVoid: eqVoid,\n    eqArray: eqArray,\n    eqRec: eqRec,\n    eqProxy: eqProxy,\n    eqProxy2: eqProxy2,\n    eqProxy3: eqProxy3,\n    eq1Array: eq1Array,\n    eqRowNil: eqRowNil,\n    eqRowCons: eqRowCons\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Eq.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs":
/*!***********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/EuclideanRing.js */ \"./.spago/prelude/v5.0.1/src/Data/EuclideanRing.js\");\nvar Data_CommutativeRing = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/CommutativeRing.purs */ \"./.spago/prelude/v5.0.1/src/Data/CommutativeRing.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Ring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ring.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar mod = function (dict) {\n    return dict.mod;\n};\nvar gcd = function ($copy_dictEq) {\n    return function ($copy_dictEuclideanRing) {\n        return function ($copy_a) {\n            return function ($copy_b) {\n                var $tco_var_dictEq = $copy_dictEq;\n                var $tco_var_dictEuclideanRing = $copy_dictEuclideanRing;\n                var $tco_var_a = $copy_a;\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(dictEq, dictEuclideanRing, a, b) {\n                    var $8 = Data_Eq.eq(dictEq)(b)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()));\n                    if ($8) {\n                        $tco_done = true;\n                        return a;\n                    };\n                    $tco_var_dictEq = dictEq;\n                    $tco_var_dictEuclideanRing = dictEuclideanRing;\n                    $tco_var_a = b;\n                    $copy_b = mod(dictEuclideanRing)(a)(b);\n                    return;\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($tco_var_dictEq, $tco_var_dictEuclideanRing, $tco_var_a, $copy_b);\n                };\n                return $tco_result;\n            };\n        };\n    };\n};\nvar euclideanRingNumber = {\n    degree: function (v) {\n        return 1;\n    },\n    div: $foreign.numDiv,\n    mod: function (v) {\n        return function (v1) {\n            return 0.0;\n        };\n    },\n    CommutativeRing0: function () {\n        return Data_CommutativeRing.commutativeRingNumber;\n    }\n};\nvar euclideanRingInt = {\n    degree: $foreign.intDegree,\n    div: $foreign.intDiv,\n    mod: $foreign.intMod,\n    CommutativeRing0: function () {\n        return Data_CommutativeRing.commutativeRingInt;\n    }\n};\nvar div = function (dict) {\n    return dict.div;\n};\nvar lcm = function (dictEq) {\n    return function (dictEuclideanRing) {\n        return function (a) {\n            return function (b) {\n                var $10 = Data_Eq.eq(dictEq)(a)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())) || Data_Eq.eq(dictEq)(b)(Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0()));\n                if ($10) {\n                    return Data_Semiring.zero(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0());\n                };\n                return div(dictEuclideanRing)(Data_Semiring.mul(((dictEuclideanRing.CommutativeRing0()).Ring0()).Semiring0())(a)(b))(gcd(dictEq)(dictEuclideanRing)(a)(b));\n            };\n        };\n    };\n};\nvar degree = function (dict) {\n    return dict.degree;\n};\nmodule.exports = {\n    degree: degree,\n    div: div,\n    mod: mod,\n    gcd: gcd,\n    lcm: lcm,\n    euclideanRingInt: euclideanRingInt,\n    euclideanRingNumber: euclideanRingNumber,\n    sub: Data_Ring.sub,\n    add: Data_Semiring.add,\n    mul: Data_Semiring.mul,\n    one: Data_Semiring.one,\n    zero: Data_Semiring.zero\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Function.purs":
/*!******************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Function.purs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar on = function (f) {\n    return function (g) {\n        return function (x) {\n            return function (y) {\n                return f(g(x))(g(y));\n            };\n        };\n    };\n};\nvar flip = function (f) {\n    return function (b) {\n        return function (a) {\n            return f(a)(b);\n        };\n    };\n};\nvar $$const = function (a) {\n    return function (v) {\n        return a;\n    };\n};\nvar applyN = function (f) {\n    var go = function ($copy_n) {\n        return function ($copy_acc) {\n            var $tco_var_n = $copy_n;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(n, acc) {\n                if (n <= 0) {\n                    $tco_done = true;\n                    return acc;\n                };\n                if (Data_Boolean.otherwise) {\n                    $tco_var_n = n - 1 | 0;\n                    $copy_acc = f(acc);\n                    return;\n                };\n                throw new Error(\"Failed pattern match at Data.Function (line 100, column 3 - line 102, column 37): \" + [ n.constructor.name, acc.constructor.name ]);\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_n, $copy_acc);\n            };\n            return $tco_result;\n        };\n    };\n    return go;\n};\nvar applyFlipped = function (x) {\n    return function (f) {\n        return f(x);\n    };\n};\nvar apply = function (f) {\n    return function (x) {\n        return f(x);\n    };\n};\nmodule.exports = {\n    flip: flip,\n    \"const\": $$const,\n    apply: apply,\n    applyFlipped: applyFlipped,\n    applyN: applyN,\n    on: on,\n    compose: Control_Category.compose,\n    identity: Control_Category.identity\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Function.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Functor.purs":
/*!*****************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Functor.purs ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.js */ \"./.spago/prelude/v5.0.1/src/Data/Functor.js\");\nvar Control_Semigroupoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs */ \"./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar map = function (dict) {\n    return dict.map;\n};\nvar mapFlipped = function (dictFunctor) {\n    return function (fa) {\n        return function (f) {\n            return map(dictFunctor)(f)(fa);\n        };\n    };\n};\nvar $$void = function (dictFunctor) {\n    return map(dictFunctor)(Data_Function[\"const\"](Data_Unit.unit));\n};\nvar voidLeft = function (dictFunctor) {\n    return function (f) {\n        return function (x) {\n            return map(dictFunctor)(Data_Function[\"const\"](x))(f);\n        };\n    };\n};\nvar voidRight = function (dictFunctor) {\n    return function (x) {\n        return map(dictFunctor)(Data_Function[\"const\"](x));\n    };\n};\nvar functorProxy = {\n    map: function (v) {\n        return function (v1) {\n            return Type_Proxy[\"Proxy\"].value;\n        };\n    }\n};\nvar functorFn = {\n    map: Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn)\n};\nvar functorArray = {\n    map: $foreign.arrayMap\n};\nvar flap = function (dictFunctor) {\n    return function (ff) {\n        return function (x) {\n            return map(dictFunctor)(function (f) {\n                return f(x);\n            })(ff);\n        };\n    };\n};\nmodule.exports = {\n    map: map,\n    mapFlipped: mapFlipped,\n    \"void\": $$void,\n    voidRight: voidRight,\n    voidLeft: voidLeft,\n    flap: flap,\n    functorFn: functorFn,\n    functorArray: functorArray,\n    functorProxy: functorProxy\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Functor.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs":
/*!*********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar Inl = (function () {\n    function Inl(value0) {\n        this.value0 = value0;\n    };\n    Inl.create = function (value0) {\n        return new Inl(value0);\n    };\n    return Inl;\n})();\nvar Inr = (function () {\n    function Inr(value0) {\n        this.value0 = value0;\n    };\n    Inr.create = function (value0) {\n        return new Inr(value0);\n    };\n    return Inr;\n})();\nvar Product = (function () {\n    function Product(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    Product.create = function (value0) {\n        return function (value1) {\n            return new Product(value0, value1);\n        };\n    };\n    return Product;\n})();\nvar NoArguments = (function () {\n    function NoArguments() {\n\n    };\n    NoArguments.value = new NoArguments();\n    return NoArguments;\n})();\nvar Constructor = function (x) {\n    return x;\n};\nvar Argument = function (x) {\n    return x;\n};\nvar to = function (dict) {\n    return dict.to;\n};\nvar showSum = function (dictShow) {\n    return function (dictShow1) {\n        return {\n            show: function (v) {\n                if (v instanceof Inl) {\n                    return \"(Inl \" + (Data_Show.show(dictShow)(v.value0) + \")\");\n                };\n                if (v instanceof Inr) {\n                    return \"(Inr \" + (Data_Show.show(dictShow1)(v.value0) + \")\");\n                };\n                throw new Error(\"Failed pattern match at Data.Generic.Rep (line 31, column 1 - line 33, column 42): \" + [ v.constructor.name ]);\n            }\n        };\n    };\n};\nvar showProduct = function (dictShow) {\n    return function (dictShow1) {\n        return {\n            show: function (v) {\n                return \"(Product \" + (Data_Show.show(dictShow)(v.value0) + (\" \" + (Data_Show.show(dictShow1)(v.value1) + \")\")));\n            }\n        };\n    };\n};\nvar showNoArguments = {\n    show: function (v) {\n        return \"NoArguments\";\n    }\n};\nvar showConstructor = function (dictIsSymbol) {\n    return function (dictShow) {\n        return {\n            show: function (v) {\n                return \"(Constructor @\" + (Data_Show.show(Data_Show.showString)(Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value)) + (\" \" + (Data_Show.show(dictShow)(v) + \")\")));\n            }\n        };\n    };\n};\nvar showArgument = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Argument \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar repOf = function (dictGeneric) {\n    return function (v) {\n        return Type_Proxy[\"Proxy\"].value;\n    };\n};\nvar from = function (dict) {\n    return dict.from;\n};\nmodule.exports = {\n    to: to,\n    from: from,\n    repOf: repOf,\n    NoArguments: NoArguments,\n    Inl: Inl,\n    Inr: Inr,\n    Product: Product,\n    Constructor: Constructor,\n    Argument: Argument,\n    showNoArguments: showNoArguments,\n    showSum: showSum,\n    showProduct: showProduct,\n    showConstructor: showConstructor,\n    showArgument: showArgument\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs":
/*!************************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.js */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.js\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Record_Unsafe = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Record/Unsafe.purs */ \"./.spago/prelude/v5.0.1/src/Record/Unsafe.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar ttRecord = function (dict) {\n    return dict.ttRecord;\n};\nvar tt = function (dict) {\n    return dict.tt;\n};\nvar notRecord = function (dict) {\n    return dict.notRecord;\n};\nvar not = function (dict) {\n    return dict.not;\n};\nvar impliesRecord = function (dict) {\n    return dict.impliesRecord;\n};\nvar implies = function (dict) {\n    return dict.implies;\n};\nvar heytingAlgebraUnit = {\n    ff: Data_Unit.unit,\n    tt: Data_Unit.unit,\n    implies: function (v) {\n        return function (v1) {\n            return Data_Unit.unit;\n        };\n    },\n    conj: function (v) {\n        return function (v1) {\n            return Data_Unit.unit;\n        };\n    },\n    disj: function (v) {\n        return function (v1) {\n            return Data_Unit.unit;\n        };\n    },\n    not: function (v) {\n        return Data_Unit.unit;\n    }\n};\nvar heytingAlgebraRecordNil = {\n    conjRecord: function (v) {\n        return function (v1) {\n            return function (v2) {\n                return {};\n            };\n        };\n    },\n    disjRecord: function (v) {\n        return function (v1) {\n            return function (v2) {\n                return {};\n            };\n        };\n    },\n    ffRecord: function (v) {\n        return function (v1) {\n            return {};\n        };\n    },\n    impliesRecord: function (v) {\n        return function (v1) {\n            return function (v2) {\n                return {};\n            };\n        };\n    },\n    notRecord: function (v) {\n        return function (v1) {\n            return {};\n        };\n    },\n    ttRecord: function (v) {\n        return function (v1) {\n            return {};\n        };\n    }\n};\nvar heytingAlgebraProxy3 = {\n    conj: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy3.value;\n        };\n    },\n    disj: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy3.value;\n        };\n    },\n    implies: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy3.value;\n        };\n    },\n    ff: Type_Proxy.Proxy3.value,\n    not: function (v) {\n        return Type_Proxy.Proxy3.value;\n    },\n    tt: Type_Proxy.Proxy3.value\n};\nvar heytingAlgebraProxy2 = {\n    conj: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy2.value;\n        };\n    },\n    disj: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy2.value;\n        };\n    },\n    implies: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy2.value;\n        };\n    },\n    ff: Type_Proxy.Proxy2.value,\n    not: function (v) {\n        return Type_Proxy.Proxy2.value;\n    },\n    tt: Type_Proxy.Proxy2.value\n};\nvar heytingAlgebraProxy = {\n    conj: function (v) {\n        return function (v1) {\n            return Type_Proxy[\"Proxy\"].value;\n        };\n    },\n    disj: function (v) {\n        return function (v1) {\n            return Type_Proxy[\"Proxy\"].value;\n        };\n    },\n    implies: function (v) {\n        return function (v1) {\n            return Type_Proxy[\"Proxy\"].value;\n        };\n    },\n    ff: Type_Proxy[\"Proxy\"].value,\n    not: function (v) {\n        return Type_Proxy[\"Proxy\"].value;\n    },\n    tt: Type_Proxy[\"Proxy\"].value\n};\nvar ffRecord = function (dict) {\n    return dict.ffRecord;\n};\nvar ff = function (dict) {\n    return dict.ff;\n};\nvar disjRecord = function (dict) {\n    return dict.disjRecord;\n};\nvar disj = function (dict) {\n    return dict.disj;\n};\nvar heytingAlgebraBoolean = {\n    ff: false,\n    tt: true,\n    implies: function (a) {\n        return function (b) {\n            return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);\n        };\n    },\n    conj: $foreign.boolConj,\n    disj: $foreign.boolDisj,\n    not: $foreign.boolNot\n};\nvar conjRecord = function (dict) {\n    return dict.conjRecord;\n};\nvar heytingAlgebraRecord = function (dictRowToList) {\n    return function (dictHeytingAlgebraRecord) {\n        return {\n            ff: ffRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value)(Type_Proxy[\"Proxy\"].value),\n            tt: ttRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value)(Type_Proxy[\"Proxy\"].value),\n            conj: conjRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value),\n            disj: disjRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value),\n            implies: impliesRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value),\n            not: notRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value)\n        };\n    };\n};\nvar conj = function (dict) {\n    return dict.conj;\n};\nvar heytingAlgebraFunction = function (dictHeytingAlgebra) {\n    return {\n        ff: function (v) {\n            return ff(dictHeytingAlgebra);\n        },\n        tt: function (v) {\n            return tt(dictHeytingAlgebra);\n        },\n        implies: function (f) {\n            return function (g) {\n                return function (a) {\n                    return implies(dictHeytingAlgebra)(f(a))(g(a));\n                };\n            };\n        },\n        conj: function (f) {\n            return function (g) {\n                return function (a) {\n                    return conj(dictHeytingAlgebra)(f(a))(g(a));\n                };\n            };\n        },\n        disj: function (f) {\n            return function (g) {\n                return function (a) {\n                    return disj(dictHeytingAlgebra)(f(a))(g(a));\n                };\n            };\n        },\n        not: function (f) {\n            return function (a) {\n                return not(dictHeytingAlgebra)(f(a));\n            };\n        }\n    };\n};\nvar heytingAlgebraRecordCons = function (dictIsSymbol) {\n    return function (dictCons) {\n        return function (dictHeytingAlgebraRecord) {\n            return function (dictHeytingAlgebra) {\n                return {\n                    conjRecord: function (v) {\n                        return function (ra) {\n                            return function (rb) {\n                                var tail = conjRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value)(ra)(rb);\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var insert = Record_Unsafe.unsafeSet(key);\n                                var get = Record_Unsafe.unsafeGet(key);\n                                return insert(conj(dictHeytingAlgebra)(get(ra))(get(rb)))(tail);\n                            };\n                        };\n                    },\n                    disjRecord: function (v) {\n                        return function (ra) {\n                            return function (rb) {\n                                var tail = disjRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value)(ra)(rb);\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var insert = Record_Unsafe.unsafeSet(key);\n                                var get = Record_Unsafe.unsafeGet(key);\n                                return insert(disj(dictHeytingAlgebra)(get(ra))(get(rb)))(tail);\n                            };\n                        };\n                    },\n                    impliesRecord: function (v) {\n                        return function (ra) {\n                            return function (rb) {\n                                var tail = impliesRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value)(ra)(rb);\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var insert = Record_Unsafe.unsafeSet(key);\n                                var get = Record_Unsafe.unsafeGet(key);\n                                return insert(implies(dictHeytingAlgebra)(get(ra))(get(rb)))(tail);\n                            };\n                        };\n                    },\n                    ffRecord: function (v) {\n                        return function (row) {\n                            var tail = ffRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value)(row);\n                            var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                            var insert = Record_Unsafe.unsafeSet(key);\n                            return insert(ff(dictHeytingAlgebra))(tail);\n                        };\n                    },\n                    notRecord: function (v) {\n                        return function (row) {\n                            var tail = notRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value)(row);\n                            var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                            var insert = Record_Unsafe.unsafeSet(key);\n                            var get = Record_Unsafe.unsafeGet(key);\n                            return insert(not(dictHeytingAlgebra)(get(row)))(tail);\n                        };\n                    },\n                    ttRecord: function (v) {\n                        return function (row) {\n                            var tail = ttRecord(dictHeytingAlgebraRecord)(Type_Proxy[\"Proxy\"].value)(row);\n                            var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                            var insert = Record_Unsafe.unsafeSet(key);\n                            return insert(tt(dictHeytingAlgebra))(tail);\n                        };\n                    }\n                };\n            };\n        };\n    };\n};\nmodule.exports = {\n    tt: tt,\n    ff: ff,\n    implies: implies,\n    conj: conj,\n    disj: disj,\n    not: not,\n    ffRecord: ffRecord,\n    ttRecord: ttRecord,\n    impliesRecord: impliesRecord,\n    conjRecord: conjRecord,\n    disjRecord: disjRecord,\n    notRecord: notRecord,\n    heytingAlgebraBoolean: heytingAlgebraBoolean,\n    heytingAlgebraUnit: heytingAlgebraUnit,\n    heytingAlgebraFunction: heytingAlgebraFunction,\n    heytingAlgebraProxy: heytingAlgebraProxy,\n    heytingAlgebraProxy2: heytingAlgebraProxy2,\n    heytingAlgebraProxy3: heytingAlgebraProxy3,\n    heytingAlgebraRecord: heytingAlgebraRecord,\n    heytingAlgebraRecordNil: heytingAlgebraRecordNil,\n    heytingAlgebraRecordCons: heytingAlgebraRecordCons\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Monoid.purs":
/*!****************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Monoid.purs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_EuclideanRing = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs */ \"./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Record_Unsafe = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Record/Unsafe.purs */ \"./.spago/prelude/v5.0.1/src/Record/Unsafe.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar monoidUnit = {\n    mempty: Data_Unit.unit,\n    Semigroup0: function () {\n        return Data_Semigroup.semigroupUnit;\n    }\n};\nvar monoidString = {\n    mempty: \"\",\n    Semigroup0: function () {\n        return Data_Semigroup.semigroupString;\n    }\n};\nvar monoidRecordNil = {\n    memptyRecord: function (v) {\n        return {};\n    },\n    SemigroupRecord0: function () {\n        return Data_Semigroup.semigroupRecordNil;\n    }\n};\nvar monoidOrdering = {\n    mempty: Data_Ordering.EQ.value,\n    Semigroup0: function () {\n        return Data_Ordering.semigroupOrdering;\n    }\n};\nvar monoidArray = {\n    mempty: [  ],\n    Semigroup0: function () {\n        return Data_Semigroup.semigroupArray;\n    }\n};\nvar memptyRecord = function (dict) {\n    return dict.memptyRecord;\n};\nvar monoidRecord = function (dictRowToList) {\n    return function (dictMonoidRecord) {\n        return {\n            mempty: memptyRecord(dictMonoidRecord)(Type_Proxy[\"Proxy\"].value),\n            Semigroup0: function () {\n                return Data_Semigroup.semigroupRecord()(dictMonoidRecord.SemigroupRecord0());\n            }\n        };\n    };\n};\nvar mempty = function (dict) {\n    return dict.mempty;\n};\nvar monoidFn = function (dictMonoid) {\n    return {\n        mempty: function (v) {\n            return mempty(dictMonoid);\n        },\n        Semigroup0: function () {\n            return Data_Semigroup.semigroupFn(dictMonoid.Semigroup0());\n        }\n    };\n};\nvar monoidRecordCons = function (dictIsSymbol) {\n    return function (dictMonoid) {\n        return function (dictCons) {\n            return function (dictMonoidRecord) {\n                return {\n                    memptyRecord: function (v) {\n                        var tail = memptyRecord(dictMonoidRecord)(Type_Proxy[\"Proxy\"].value);\n                        var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                        var insert = Record_Unsafe.unsafeSet(key);\n                        return insert(mempty(dictMonoid))(tail);\n                    },\n                    SemigroupRecord0: function () {\n                        return Data_Semigroup.semigroupRecordCons(dictIsSymbol)()(dictMonoidRecord.SemigroupRecord0())(dictMonoid.Semigroup0());\n                    }\n                };\n            };\n        };\n    };\n};\nvar power = function (dictMonoid) {\n    return function (x) {\n        var go = function (p) {\n            if (p <= 0) {\n                return mempty(dictMonoid);\n            };\n            if (p === 1) {\n                return x;\n            };\n            if (Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(p)(2) === 0) {\n                var x$prime = go(Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt)(p)(2));\n                return Data_Semigroup.append(dictMonoid.Semigroup0())(x$prime)(x$prime);\n            };\n            if (Data_Boolean.otherwise) {\n                var x$prime = go(Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt)(p)(2));\n                return Data_Semigroup.append(dictMonoid.Semigroup0())(x$prime)(Data_Semigroup.append(dictMonoid.Semigroup0())(x$prime)(x));\n            };\n            throw new Error(\"Failed pattern match at Data.Monoid (line 86, column 3 - line 86, column 17): \" + [ p.constructor.name ]);\n        };\n        return go;\n    };\n};\nvar guard = function (dictMonoid) {\n    return function (v) {\n        return function (v1) {\n            if (v) {\n                return v1;\n            };\n            if (!v) {\n                return mempty(dictMonoid);\n            };\n            throw new Error(\"Failed pattern match at Data.Monoid (line 94, column 1 - line 94, column 49): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    };\n};\nmodule.exports = {\n    mempty: mempty,\n    power: power,\n    guard: guard,\n    memptyRecord: memptyRecord,\n    monoidUnit: monoidUnit,\n    monoidOrdering: monoidOrdering,\n    monoidFn: monoidFn,\n    monoidString: monoidString,\n    monoidArray: monoidArray,\n    monoidRecord: monoidRecord,\n    monoidRecordNil: monoidRecordNil,\n    monoidRecordCons: monoidRecordCons\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Monoid.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Monoid/Additive.purs":
/*!*************************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Monoid/Additive.purs ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Additive = function (x) {\n    return x;\n};\nvar showAdditive = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Additive \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semigroupAdditive = function (dictSemiring) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                return Data_Semiring.add(dictSemiring)(v)(v1);\n            };\n        }\n    };\n};\nvar ordAdditive = function (dictOrd) {\n    return dictOrd;\n};\nvar monoidAdditive = function (dictSemiring) {\n    return {\n        mempty: Data_Semiring.zero(dictSemiring),\n        Semigroup0: function () {\n            return semigroupAdditive(dictSemiring);\n        }\n    };\n};\nvar functorAdditive = {\n    map: function (f) {\n        return function (m) {\n            return f(m);\n        };\n    }\n};\nvar eqAdditive = function (dictEq) {\n    return dictEq;\n};\nvar eq1Additive = {\n    eq1: function (dictEq) {\n        return Data_Eq.eq(eqAdditive(dictEq));\n    }\n};\nvar ord1Additive = {\n    compare1: function (dictOrd) {\n        return Data_Ord.compare(ordAdditive(dictOrd));\n    },\n    Eq10: function () {\n        return eq1Additive;\n    }\n};\nvar boundedAdditive = function (dictBounded) {\n    return dictBounded;\n};\nvar applyAdditive = {\n    apply: function (v) {\n        return function (v1) {\n            return v(v1);\n        };\n    },\n    Functor0: function () {\n        return functorAdditive;\n    }\n};\nvar bindAdditive = {\n    bind: function (v) {\n        return function (f) {\n            return f(v);\n        };\n    },\n    Apply0: function () {\n        return applyAdditive;\n    }\n};\nvar applicativeAdditive = {\n    pure: Additive,\n    Apply0: function () {\n        return applyAdditive;\n    }\n};\nvar monadAdditive = {\n    Applicative0: function () {\n        return applicativeAdditive;\n    },\n    Bind1: function () {\n        return bindAdditive;\n    }\n};\nmodule.exports = {\n    Additive: Additive,\n    eqAdditive: eqAdditive,\n    eq1Additive: eq1Additive,\n    ordAdditive: ordAdditive,\n    ord1Additive: ord1Additive,\n    boundedAdditive: boundedAdditive,\n    showAdditive: showAdditive,\n    functorAdditive: functorAdditive,\n    applyAdditive: applyAdditive,\n    applicativeAdditive: applicativeAdditive,\n    bindAdditive: bindAdditive,\n    monadAdditive: monadAdditive,\n    semigroupAdditive: semigroupAdditive,\n    monoidAdditive: monoidAdditive\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Monoid/Additive.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs":
/*!*********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Conj = function (x) {\n    return x;\n};\nvar showConj = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Conj \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semiringConj = function (dictHeytingAlgebra) {\n    return {\n        zero: Data_HeytingAlgebra.tt(dictHeytingAlgebra),\n        one: Data_HeytingAlgebra.ff(dictHeytingAlgebra),\n        add: function (v) {\n            return function (v1) {\n                return Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v)(v1);\n            };\n        },\n        mul: function (v) {\n            return function (v1) {\n                return Data_HeytingAlgebra.disj(dictHeytingAlgebra)(v)(v1);\n            };\n        }\n    };\n};\nvar semigroupConj = function (dictHeytingAlgebra) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                return Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v)(v1);\n            };\n        }\n    };\n};\nvar ordConj = function (dictOrd) {\n    return dictOrd;\n};\nvar monoidConj = function (dictHeytingAlgebra) {\n    return {\n        mempty: Data_HeytingAlgebra.tt(dictHeytingAlgebra),\n        Semigroup0: function () {\n            return semigroupConj(dictHeytingAlgebra);\n        }\n    };\n};\nvar functorConj = {\n    map: function (f) {\n        return function (m) {\n            return f(m);\n        };\n    }\n};\nvar eqConj = function (dictEq) {\n    return dictEq;\n};\nvar eq1Conj = {\n    eq1: function (dictEq) {\n        return Data_Eq.eq(eqConj(dictEq));\n    }\n};\nvar ord1Conj = {\n    compare1: function (dictOrd) {\n        return Data_Ord.compare(ordConj(dictOrd));\n    },\n    Eq10: function () {\n        return eq1Conj;\n    }\n};\nvar boundedConj = function (dictBounded) {\n    return dictBounded;\n};\nvar applyConj = {\n    apply: function (v) {\n        return function (v1) {\n            return v(v1);\n        };\n    },\n    Functor0: function () {\n        return functorConj;\n    }\n};\nvar bindConj = {\n    bind: function (v) {\n        return function (f) {\n            return f(v);\n        };\n    },\n    Apply0: function () {\n        return applyConj;\n    }\n};\nvar applicativeConj = {\n    pure: Conj,\n    Apply0: function () {\n        return applyConj;\n    }\n};\nvar monadConj = {\n    Applicative0: function () {\n        return applicativeConj;\n    },\n    Bind1: function () {\n        return bindConj;\n    }\n};\nmodule.exports = {\n    Conj: Conj,\n    eqConj: eqConj,\n    eq1Conj: eq1Conj,\n    ordConj: ordConj,\n    ord1Conj: ord1Conj,\n    boundedConj: boundedConj,\n    showConj: showConj,\n    functorConj: functorConj,\n    applyConj: applyConj,\n    applicativeConj: applicativeConj,\n    bindConj: bindConj,\n    monadConj: monadConj,\n    semigroupConj: semigroupConj,\n    monoidConj: monoidConj,\n    semiringConj: semiringConj\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Monoid/Conj.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs":
/*!*********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Disj = function (x) {\n    return x;\n};\nvar showDisj = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Disj \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semiringDisj = function (dictHeytingAlgebra) {\n    return {\n        zero: Data_HeytingAlgebra.ff(dictHeytingAlgebra),\n        one: Data_HeytingAlgebra.tt(dictHeytingAlgebra),\n        add: function (v) {\n            return function (v1) {\n                return Data_HeytingAlgebra.disj(dictHeytingAlgebra)(v)(v1);\n            };\n        },\n        mul: function (v) {\n            return function (v1) {\n                return Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v)(v1);\n            };\n        }\n    };\n};\nvar semigroupDisj = function (dictHeytingAlgebra) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                return Data_HeytingAlgebra.disj(dictHeytingAlgebra)(v)(v1);\n            };\n        }\n    };\n};\nvar ordDisj = function (dictOrd) {\n    return dictOrd;\n};\nvar monoidDisj = function (dictHeytingAlgebra) {\n    return {\n        mempty: Data_HeytingAlgebra.ff(dictHeytingAlgebra),\n        Semigroup0: function () {\n            return semigroupDisj(dictHeytingAlgebra);\n        }\n    };\n};\nvar functorDisj = {\n    map: function (f) {\n        return function (m) {\n            return f(m);\n        };\n    }\n};\nvar eqDisj = function (dictEq) {\n    return dictEq;\n};\nvar eq1Disj = {\n    eq1: function (dictEq) {\n        return Data_Eq.eq(eqDisj(dictEq));\n    }\n};\nvar ord1Disj = {\n    compare1: function (dictOrd) {\n        return Data_Ord.compare(ordDisj(dictOrd));\n    },\n    Eq10: function () {\n        return eq1Disj;\n    }\n};\nvar boundedDisj = function (dictBounded) {\n    return dictBounded;\n};\nvar applyDisj = {\n    apply: function (v) {\n        return function (v1) {\n            return v(v1);\n        };\n    },\n    Functor0: function () {\n        return functorDisj;\n    }\n};\nvar bindDisj = {\n    bind: function (v) {\n        return function (f) {\n            return f(v);\n        };\n    },\n    Apply0: function () {\n        return applyDisj;\n    }\n};\nvar applicativeDisj = {\n    pure: Disj,\n    Apply0: function () {\n        return applyDisj;\n    }\n};\nvar monadDisj = {\n    Applicative0: function () {\n        return applicativeDisj;\n    },\n    Bind1: function () {\n        return bindDisj;\n    }\n};\nmodule.exports = {\n    Disj: Disj,\n    eqDisj: eqDisj,\n    eq1Disj: eq1Disj,\n    ordDisj: ordDisj,\n    ord1Disj: ord1Disj,\n    boundedDisj: boundedDisj,\n    showDisj: showDisj,\n    functorDisj: functorDisj,\n    applyDisj: applyDisj,\n    applicativeDisj: applicativeDisj,\n    bindDisj: bindDisj,\n    monadDisj: monadDisj,\n    semigroupDisj: semigroupDisj,\n    monoidDisj: monoidDisj,\n    semiringDisj: semiringDisj\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Monoid/Disj.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs":
/*!*********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Dual = function (x) {\n    return x;\n};\nvar showDual = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Dual \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semigroupDual = function (dictSemigroup) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                return Data_Semigroup.append(dictSemigroup)(v1)(v);\n            };\n        }\n    };\n};\nvar ordDual = function (dictOrd) {\n    return dictOrd;\n};\nvar monoidDual = function (dictMonoid) {\n    return {\n        mempty: Data_Monoid.mempty(dictMonoid),\n        Semigroup0: function () {\n            return semigroupDual(dictMonoid.Semigroup0());\n        }\n    };\n};\nvar functorDual = {\n    map: function (f) {\n        return function (m) {\n            return f(m);\n        };\n    }\n};\nvar eqDual = function (dictEq) {\n    return dictEq;\n};\nvar eq1Dual = {\n    eq1: function (dictEq) {\n        return Data_Eq.eq(eqDual(dictEq));\n    }\n};\nvar ord1Dual = {\n    compare1: function (dictOrd) {\n        return Data_Ord.compare(ordDual(dictOrd));\n    },\n    Eq10: function () {\n        return eq1Dual;\n    }\n};\nvar boundedDual = function (dictBounded) {\n    return dictBounded;\n};\nvar applyDual = {\n    apply: function (v) {\n        return function (v1) {\n            return v(v1);\n        };\n    },\n    Functor0: function () {\n        return functorDual;\n    }\n};\nvar bindDual = {\n    bind: function (v) {\n        return function (f) {\n            return f(v);\n        };\n    },\n    Apply0: function () {\n        return applyDual;\n    }\n};\nvar applicativeDual = {\n    pure: Dual,\n    Apply0: function () {\n        return applyDual;\n    }\n};\nvar monadDual = {\n    Applicative0: function () {\n        return applicativeDual;\n    },\n    Bind1: function () {\n        return bindDual;\n    }\n};\nmodule.exports = {\n    Dual: Dual,\n    eqDual: eqDual,\n    eq1Dual: eq1Dual,\n    ordDual: ordDual,\n    ord1Dual: ord1Dual,\n    boundedDual: boundedDual,\n    showDual: showDual,\n    functorDual: functorDual,\n    applyDual: applyDual,\n    applicativeDual: applicativeDual,\n    bindDual: bindDual,\n    monadDual: monadDual,\n    semigroupDual: semigroupDual,\n    monoidDual: monoidDual\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Monoid/Dual.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs":
/*!*********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Semigroupoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs */ \"./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Endo = function (x) {\n    return x;\n};\nvar showEndo = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Endo \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semigroupEndo = function (dictSemigroupoid) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                return Control_Semigroupoid.compose(dictSemigroupoid)(v)(v1);\n            };\n        }\n    };\n};\nvar ordEndo = function (dictOrd) {\n    return dictOrd;\n};\nvar monoidEndo = function (dictCategory) {\n    return {\n        mempty: Control_Category.identity(dictCategory),\n        Semigroup0: function () {\n            return semigroupEndo(dictCategory.Semigroupoid0());\n        }\n    };\n};\nvar eqEndo = function (dictEq) {\n    return dictEq;\n};\nvar boundedEndo = function (dictBounded) {\n    return dictBounded;\n};\nmodule.exports = {\n    Endo: Endo,\n    eqEndo: eqEndo,\n    ordEndo: ordEndo,\n    boundedEndo: boundedEndo,\n    showEndo: showEndo,\n    semigroupEndo: semigroupEndo,\n    monoidEndo: monoidEndo\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Monoid/Multiplicative.purs":
/*!*******************************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Monoid/Multiplicative.purs ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Multiplicative = function (x) {\n    return x;\n};\nvar showMultiplicative = function (dictShow) {\n    return {\n        show: function (v) {\n            return \"(Multiplicative \" + (Data_Show.show(dictShow)(v) + \")\");\n        }\n    };\n};\nvar semigroupMultiplicative = function (dictSemiring) {\n    return {\n        append: function (v) {\n            return function (v1) {\n                return Data_Semiring.mul(dictSemiring)(v)(v1);\n            };\n        }\n    };\n};\nvar ordMultiplicative = function (dictOrd) {\n    return dictOrd;\n};\nvar monoidMultiplicative = function (dictSemiring) {\n    return {\n        mempty: Data_Semiring.one(dictSemiring),\n        Semigroup0: function () {\n            return semigroupMultiplicative(dictSemiring);\n        }\n    };\n};\nvar functorMultiplicative = {\n    map: function (f) {\n        return function (m) {\n            return f(m);\n        };\n    }\n};\nvar eqMultiplicative = function (dictEq) {\n    return dictEq;\n};\nvar eq1Multiplicative = {\n    eq1: function (dictEq) {\n        return Data_Eq.eq(eqMultiplicative(dictEq));\n    }\n};\nvar ord1Multiplicative = {\n    compare1: function (dictOrd) {\n        return Data_Ord.compare(ordMultiplicative(dictOrd));\n    },\n    Eq10: function () {\n        return eq1Multiplicative;\n    }\n};\nvar boundedMultiplicative = function (dictBounded) {\n    return dictBounded;\n};\nvar applyMultiplicative = {\n    apply: function (v) {\n        return function (v1) {\n            return v(v1);\n        };\n    },\n    Functor0: function () {\n        return functorMultiplicative;\n    }\n};\nvar bindMultiplicative = {\n    bind: function (v) {\n        return function (f) {\n            return f(v);\n        };\n    },\n    Apply0: function () {\n        return applyMultiplicative;\n    }\n};\nvar applicativeMultiplicative = {\n    pure: Multiplicative,\n    Apply0: function () {\n        return applyMultiplicative;\n    }\n};\nvar monadMultiplicative = {\n    Applicative0: function () {\n        return applicativeMultiplicative;\n    },\n    Bind1: function () {\n        return bindMultiplicative;\n    }\n};\nmodule.exports = {\n    Multiplicative: Multiplicative,\n    eqMultiplicative: eqMultiplicative,\n    eq1Multiplicative: eq1Multiplicative,\n    ordMultiplicative: ordMultiplicative,\n    ord1Multiplicative: ord1Multiplicative,\n    boundedMultiplicative: boundedMultiplicative,\n    showMultiplicative: showMultiplicative,\n    functorMultiplicative: functorMultiplicative,\n    applyMultiplicative: applyMultiplicative,\n    applicativeMultiplicative: applicativeMultiplicative,\n    bindMultiplicative: bindMultiplicative,\n    monadMultiplicative: monadMultiplicative,\n    semigroupMultiplicative: semigroupMultiplicative,\n    monoidMultiplicative: monoidMultiplicative\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Monoid/Multiplicative.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Ord.purs":
/*!*************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Ord.purs ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.js */ \"./.spago/prelude/v5.0.1/src/Data/Ord.js\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Ring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ring.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Record_Unsafe = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Record/Unsafe.purs */ \"./.spago/prelude/v5.0.1/src/Record/Unsafe.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar ordVoid = {\n    compare: function (v) {\n        return function (v1) {\n            return Data_Ordering.EQ.value;\n        };\n    },\n    Eq0: function () {\n        return Data_Eq.eqVoid;\n    }\n};\nvar ordUnit = {\n    compare: function (v) {\n        return function (v1) {\n            return Data_Ordering.EQ.value;\n        };\n    },\n    Eq0: function () {\n        return Data_Eq.eqUnit;\n    }\n};\nvar ordString = {\n    compare: $foreign.ordStringImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value),\n    Eq0: function () {\n        return Data_Eq.eqString;\n    }\n};\nvar ordRecordNil = {\n    compareRecord: function (v) {\n        return function (v1) {\n            return function (v2) {\n                return Data_Ordering.EQ.value;\n            };\n        };\n    },\n    EqRecord0: function () {\n        return Data_Eq.eqRowNil;\n    }\n};\nvar ordProxy3 = {\n    compare: function (v) {\n        return function (v1) {\n            return Data_Ordering.EQ.value;\n        };\n    },\n    Eq0: function () {\n        return Data_Eq.eqProxy3;\n    }\n};\nvar ordProxy2 = {\n    compare: function (v) {\n        return function (v1) {\n            return Data_Ordering.EQ.value;\n        };\n    },\n    Eq0: function () {\n        return Data_Eq.eqProxy2;\n    }\n};\nvar ordProxy = {\n    compare: function (v) {\n        return function (v1) {\n            return Data_Ordering.EQ.value;\n        };\n    },\n    Eq0: function () {\n        return Data_Eq.eqProxy;\n    }\n};\nvar ordOrdering = {\n    compare: function (v) {\n        return function (v1) {\n            if (v instanceof Data_Ordering.LT && v1 instanceof Data_Ordering.LT) {\n                return Data_Ordering.EQ.value;\n            };\n            if (v instanceof Data_Ordering.EQ && v1 instanceof Data_Ordering.EQ) {\n                return Data_Ordering.EQ.value;\n            };\n            if (v instanceof Data_Ordering.GT && v1 instanceof Data_Ordering.GT) {\n                return Data_Ordering.EQ.value;\n            };\n            if (v instanceof Data_Ordering.LT) {\n                return Data_Ordering.LT.value;\n            };\n            if (v instanceof Data_Ordering.EQ && v1 instanceof Data_Ordering.LT) {\n                return Data_Ordering.GT.value;\n            };\n            if (v instanceof Data_Ordering.EQ && v1 instanceof Data_Ordering.GT) {\n                return Data_Ordering.LT.value;\n            };\n            if (v instanceof Data_Ordering.GT) {\n                return Data_Ordering.GT.value;\n            };\n            throw new Error(\"Failed pattern match at Data.Ord (line 121, column 1 - line 128, column 21): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    },\n    Eq0: function () {\n        return Data_Ordering.eqOrdering;\n    }\n};\nvar ordNumber = {\n    compare: $foreign.ordNumberImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value),\n    Eq0: function () {\n        return Data_Eq.eqNumber;\n    }\n};\nvar ordInt = {\n    compare: $foreign.ordIntImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value),\n    Eq0: function () {\n        return Data_Eq.eqInt;\n    }\n};\nvar ordChar = {\n    compare: $foreign.ordCharImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value),\n    Eq0: function () {\n        return Data_Eq.eqChar;\n    }\n};\nvar ordBoolean = {\n    compare: $foreign.ordBooleanImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value),\n    Eq0: function () {\n        return Data_Eq.eqBoolean;\n    }\n};\nvar compareRecord = function (dict) {\n    return dict.compareRecord;\n};\nvar ordRecord = function (dictRowToList) {\n    return function (dictOrdRecord) {\n        return {\n            compare: compareRecord(dictOrdRecord)(Type_Proxy[\"Proxy\"].value),\n            Eq0: function () {\n                return Data_Eq.eqRec()(dictOrdRecord.EqRecord0());\n            }\n        };\n    };\n};\nvar compare1 = function (dict) {\n    return dict.compare1;\n};\nvar compare = function (dict) {\n    return dict.compare;\n};\nvar comparing = function (dictOrd) {\n    return function (f) {\n        return function (x) {\n            return function (y) {\n                return compare(dictOrd)(f(x))(f(y));\n            };\n        };\n    };\n};\nvar greaterThan = function (dictOrd) {\n    return function (a1) {\n        return function (a2) {\n            var v = compare(dictOrd)(a1)(a2);\n            if (v instanceof Data_Ordering.GT) {\n                return true;\n            };\n            return false;\n        };\n    };\n};\nvar greaterThanOrEq = function (dictOrd) {\n    return function (a1) {\n        return function (a2) {\n            var v = compare(dictOrd)(a1)(a2);\n            if (v instanceof Data_Ordering.LT) {\n                return false;\n            };\n            return true;\n        };\n    };\n};\nvar signum = function (dictOrd) {\n    return function (dictRing) {\n        return function (x) {\n            var $52 = greaterThanOrEq(dictOrd)(x)(Data_Semiring.zero(dictRing.Semiring0()));\n            if ($52) {\n                return Data_Semiring.one(dictRing.Semiring0());\n            };\n            return Data_Ring.negate(dictRing)(Data_Semiring.one(dictRing.Semiring0()));\n        };\n    };\n};\nvar lessThan = function (dictOrd) {\n    return function (a1) {\n        return function (a2) {\n            var v = compare(dictOrd)(a1)(a2);\n            if (v instanceof Data_Ordering.LT) {\n                return true;\n            };\n            return false;\n        };\n    };\n};\nvar lessThanOrEq = function (dictOrd) {\n    return function (a1) {\n        return function (a2) {\n            var v = compare(dictOrd)(a1)(a2);\n            if (v instanceof Data_Ordering.GT) {\n                return false;\n            };\n            return true;\n        };\n    };\n};\nvar max = function (dictOrd) {\n    return function (x) {\n        return function (y) {\n            var v = compare(dictOrd)(x)(y);\n            if (v instanceof Data_Ordering.LT) {\n                return y;\n            };\n            if (v instanceof Data_Ordering.EQ) {\n                return x;\n            };\n            if (v instanceof Data_Ordering.GT) {\n                return x;\n            };\n            throw new Error(\"Failed pattern match at Data.Ord (line 176, column 3 - line 179, column 12): \" + [ v.constructor.name ]);\n        };\n    };\n};\nvar min = function (dictOrd) {\n    return function (x) {\n        return function (y) {\n            var v = compare(dictOrd)(x)(y);\n            if (v instanceof Data_Ordering.LT) {\n                return x;\n            };\n            if (v instanceof Data_Ordering.EQ) {\n                return x;\n            };\n            if (v instanceof Data_Ordering.GT) {\n                return y;\n            };\n            throw new Error(\"Failed pattern match at Data.Ord (line 167, column 3 - line 170, column 12): \" + [ v.constructor.name ]);\n        };\n    };\n};\nvar ordArray = function (dictOrd) {\n    return {\n        compare: (function () {\n            var toDelta = function (x) {\n                return function (y) {\n                    var v = compare(dictOrd)(x)(y);\n                    if (v instanceof Data_Ordering.EQ) {\n                        return 0;\n                    };\n                    if (v instanceof Data_Ordering.LT) {\n                        return 1;\n                    };\n                    if (v instanceof Data_Ordering.GT) {\n                        return -1 | 0;\n                    };\n                    throw new Error(\"Failed pattern match at Data.Ord (line 74, column 7 - line 77, column 17): \" + [ v.constructor.name ]);\n                };\n            };\n            return function (xs) {\n                return function (ys) {\n                    return compare(ordInt)(0)($foreign.ordArrayImpl(toDelta)(xs)(ys));\n                };\n            };\n        })(),\n        Eq0: function () {\n            return Data_Eq.eqArray(dictOrd.Eq0());\n        }\n    };\n};\nvar ord1Array = {\n    compare1: function (dictOrd) {\n        return compare(ordArray(dictOrd));\n    },\n    Eq10: function () {\n        return Data_Eq.eq1Array;\n    }\n};\nvar ordRecordCons = function (dictOrdRecord) {\n    return function (dictCons) {\n        return function (dictIsSymbol) {\n            return function (dictOrd) {\n                return {\n                    compareRecord: function (v) {\n                        return function (ra) {\n                            return function (rb) {\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var left = compare(dictOrd)(Record_Unsafe.unsafeGet(key)(ra))(Record_Unsafe.unsafeGet(key)(rb));\n                                var $58 = Data_Eq.notEq(Data_Ordering.eqOrdering)(left)(Data_Ordering.EQ.value);\n                                if ($58) {\n                                    return left;\n                                };\n                                return compareRecord(dictOrdRecord)(Type_Proxy[\"Proxy\"].value)(ra)(rb);\n                            };\n                        };\n                    },\n                    EqRecord0: function () {\n                        return Data_Eq.eqRowCons(dictOrdRecord.EqRecord0())()(dictIsSymbol)(dictOrd.Eq0());\n                    }\n                };\n            };\n        };\n    };\n};\nvar clamp = function (dictOrd) {\n    return function (low) {\n        return function (hi) {\n            return function (x) {\n                return min(dictOrd)(hi)(max(dictOrd)(low)(x));\n            };\n        };\n    };\n};\nvar between = function (dictOrd) {\n    return function (low) {\n        return function (hi) {\n            return function (x) {\n                if (lessThan(dictOrd)(x)(low)) {\n                    return false;\n                };\n                if (greaterThan(dictOrd)(x)(hi)) {\n                    return false;\n                };\n                return true;\n            };\n        };\n    };\n};\nvar abs = function (dictOrd) {\n    return function (dictRing) {\n        return function (x) {\n            var $62 = greaterThanOrEq(dictOrd)(x)(Data_Semiring.zero(dictRing.Semiring0()));\n            if ($62) {\n                return x;\n            };\n            return Data_Ring.negate(dictRing)(x);\n        };\n    };\n};\nmodule.exports = {\n    compare: compare,\n    compare1: compare1,\n    lessThan: lessThan,\n    lessThanOrEq: lessThanOrEq,\n    greaterThan: greaterThan,\n    greaterThanOrEq: greaterThanOrEq,\n    comparing: comparing,\n    min: min,\n    max: max,\n    clamp: clamp,\n    between: between,\n    abs: abs,\n    signum: signum,\n    compareRecord: compareRecord,\n    ordBoolean: ordBoolean,\n    ordInt: ordInt,\n    ordNumber: ordNumber,\n    ordString: ordString,\n    ordChar: ordChar,\n    ordUnit: ordUnit,\n    ordVoid: ordVoid,\n    ordProxy: ordProxy,\n    ordProxy2: ordProxy2,\n    ordProxy3: ordProxy3,\n    ordArray: ordArray,\n    ordOrdering: ordOrdering,\n    ord1Array: ord1Array,\n    ordRecordNil: ordRecordNil,\n    ordRecordCons: ordRecordCons,\n    ordRecord: ordRecord,\n    EQ: Data_Ordering.EQ,\n    GT: Data_Ordering.GT,\n    LT: Data_Ordering.LT\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Ord.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Ordering.purs":
/*!******************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Ordering.purs ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar LT = (function () {\n    function LT() {\n\n    };\n    LT.value = new LT();\n    return LT;\n})();\nvar GT = (function () {\n    function GT() {\n\n    };\n    GT.value = new GT();\n    return GT;\n})();\nvar EQ = (function () {\n    function EQ() {\n\n    };\n    EQ.value = new EQ();\n    return EQ;\n})();\nvar showOrdering = {\n    show: function (v) {\n        if (v instanceof LT) {\n            return \"LT\";\n        };\n        if (v instanceof GT) {\n            return \"GT\";\n        };\n        if (v instanceof EQ) {\n            return \"EQ\";\n        };\n        throw new Error(\"Failed pattern match at Data.Ordering (line 26, column 1 - line 29, column 17): \" + [ v.constructor.name ]);\n    }\n};\nvar semigroupOrdering = {\n    append: function (v) {\n        return function (v1) {\n            if (v instanceof LT) {\n                return LT.value;\n            };\n            if (v instanceof GT) {\n                return GT.value;\n            };\n            if (v instanceof EQ) {\n                return v1;\n            };\n            throw new Error(\"Failed pattern match at Data.Ordering (line 21, column 1 - line 24, column 18): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    }\n};\nvar invert = function (v) {\n    if (v instanceof GT) {\n        return LT.value;\n    };\n    if (v instanceof EQ) {\n        return EQ.value;\n    };\n    if (v instanceof LT) {\n        return GT.value;\n    };\n    throw new Error(\"Failed pattern match at Data.Ordering (line 33, column 1 - line 33, column 31): \" + [ v.constructor.name ]);\n};\nvar eqOrdering = {\n    eq: function (v) {\n        return function (v1) {\n            if (v instanceof LT && v1 instanceof LT) {\n                return true;\n            };\n            if (v instanceof GT && v1 instanceof GT) {\n                return true;\n            };\n            if (v instanceof EQ && v1 instanceof EQ) {\n                return true;\n            };\n            return false;\n        };\n    }\n};\nmodule.exports = {\n    LT: LT,\n    GT: GT,\n    EQ: EQ,\n    invert: invert,\n    eqOrdering: eqOrdering,\n    semigroupOrdering: semigroupOrdering,\n    showOrdering: showOrdering\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Ordering.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Ring.purs":
/*!**************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Ring.purs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ring.js */ \"./.spago/prelude/v5.0.1/src/Data/Ring.js\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Record_Unsafe = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Record/Unsafe.purs */ \"./.spago/prelude/v5.0.1/src/Record/Unsafe.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar subRecord = function (dict) {\n    return dict.subRecord;\n};\nvar sub = function (dict) {\n    return dict.sub;\n};\nvar ringUnit = {\n    sub: function (v) {\n        return function (v1) {\n            return Data_Unit.unit;\n        };\n    },\n    Semiring0: function () {\n        return Data_Semiring.semiringUnit;\n    }\n};\nvar ringRecordNil = {\n    subRecord: function (v) {\n        return function (v1) {\n            return function (v2) {\n                return {};\n            };\n        };\n    },\n    SemiringRecord0: function () {\n        return Data_Semiring.semiringRecordNil;\n    }\n};\nvar ringRecordCons = function (dictIsSymbol) {\n    return function (dictCons) {\n        return function (dictRingRecord) {\n            return function (dictRing) {\n                return {\n                    subRecord: function (v) {\n                        return function (ra) {\n                            return function (rb) {\n                                var tail = subRecord(dictRingRecord)(Type_Proxy[\"Proxy\"].value)(ra)(rb);\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var insert = Record_Unsafe.unsafeSet(key);\n                                var get = Record_Unsafe.unsafeGet(key);\n                                return insert(sub(dictRing)(get(ra))(get(rb)))(tail);\n                            };\n                        };\n                    },\n                    SemiringRecord0: function () {\n                        return Data_Semiring.semiringRecordCons(dictIsSymbol)()(dictRingRecord.SemiringRecord0())(dictRing.Semiring0());\n                    }\n                };\n            };\n        };\n    };\n};\nvar ringRecord = function (dictRowToList) {\n    return function (dictRingRecord) {\n        return {\n            sub: subRecord(dictRingRecord)(Type_Proxy[\"Proxy\"].value),\n            Semiring0: function () {\n                return Data_Semiring.semiringRecord()(dictRingRecord.SemiringRecord0());\n            }\n        };\n    };\n};\nvar ringProxy3 = {\n    sub: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy3.value;\n        };\n    },\n    Semiring0: function () {\n        return Data_Semiring.semiringProxy3;\n    }\n};\nvar ringProxy2 = {\n    sub: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy2.value;\n        };\n    },\n    Semiring0: function () {\n        return Data_Semiring.semiringProxy2;\n    }\n};\nvar ringProxy = {\n    sub: function (v) {\n        return function (v1) {\n            return Type_Proxy[\"Proxy\"].value;\n        };\n    },\n    Semiring0: function () {\n        return Data_Semiring.semiringProxy;\n    }\n};\nvar ringNumber = {\n    sub: $foreign.numSub,\n    Semiring0: function () {\n        return Data_Semiring.semiringNumber;\n    }\n};\nvar ringInt = {\n    sub: $foreign.intSub,\n    Semiring0: function () {\n        return Data_Semiring.semiringInt;\n    }\n};\nvar ringFn = function (dictRing) {\n    return {\n        sub: function (f) {\n            return function (g) {\n                return function (x) {\n                    return sub(dictRing)(f(x))(g(x));\n                };\n            };\n        },\n        Semiring0: function () {\n            return Data_Semiring.semiringFn(dictRing.Semiring0());\n        }\n    };\n};\nvar negate = function (dictRing) {\n    return function (a) {\n        return sub(dictRing)(Data_Semiring.zero(dictRing.Semiring0()))(a);\n    };\n};\nmodule.exports = {\n    sub: sub,\n    negate: negate,\n    subRecord: subRecord,\n    ringInt: ringInt,\n    ringNumber: ringNumber,\n    ringUnit: ringUnit,\n    ringFn: ringFn,\n    ringProxy: ringProxy,\n    ringProxy2: ringProxy2,\n    ringProxy3: ringProxy3,\n    ringRecord: ringRecord,\n    ringRecordNil: ringRecordNil,\n    ringRecordCons: ringRecordCons,\n    add: Data_Semiring.add,\n    mul: Data_Semiring.mul,\n    one: Data_Semiring.one,\n    zero: Data_Semiring.zero\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Ring.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Semigroup.purs":
/*!*******************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.js */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.js\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Data_Void = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Void.purs */ \"./.spago/prelude/v5.0.1/src/Data/Void.purs\");\nvar Record_Unsafe = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Record/Unsafe.purs */ \"./.spago/prelude/v5.0.1/src/Record/Unsafe.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar semigroupVoid = {\n    append: function (v) {\n        return Data_Void.absurd;\n    }\n};\nvar semigroupUnit = {\n    append: function (v) {\n        return function (v1) {\n            return Data_Unit.unit;\n        };\n    }\n};\nvar semigroupString = {\n    append: $foreign.concatString\n};\nvar semigroupRecordNil = {\n    appendRecord: function (v) {\n        return function (v1) {\n            return function (v2) {\n                return {};\n            };\n        };\n    }\n};\nvar semigroupProxy3 = {\n    append: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy3.value;\n        };\n    }\n};\nvar semigroupProxy2 = {\n    append: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy2.value;\n        };\n    }\n};\nvar semigroupProxy = {\n    append: function (v) {\n        return function (v1) {\n            return Type_Proxy[\"Proxy\"].value;\n        };\n    }\n};\nvar semigroupArray = {\n    append: $foreign.concatArray\n};\nvar appendRecord = function (dict) {\n    return dict.appendRecord;\n};\nvar semigroupRecord = function (dictRowToList) {\n    return function (dictSemigroupRecord) {\n        return {\n            append: appendRecord(dictSemigroupRecord)(Type_Proxy[\"Proxy\"].value)\n        };\n    };\n};\nvar append = function (dict) {\n    return dict.append;\n};\nvar semigroupFn = function (dictSemigroup) {\n    return {\n        append: function (f) {\n            return function (g) {\n                return function (x) {\n                    return append(dictSemigroup)(f(x))(g(x));\n                };\n            };\n        }\n    };\n};\nvar semigroupRecordCons = function (dictIsSymbol) {\n    return function (dictCons) {\n        return function (dictSemigroupRecord) {\n            return function (dictSemigroup) {\n                return {\n                    appendRecord: function (v) {\n                        return function (ra) {\n                            return function (rb) {\n                                var tail = appendRecord(dictSemigroupRecord)(Type_Proxy[\"Proxy\"].value)(ra)(rb);\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var insert = Record_Unsafe.unsafeSet(key);\n                                var get = Record_Unsafe.unsafeGet(key);\n                                return insert(append(dictSemigroup)(get(ra))(get(rb)))(tail);\n                            };\n                        };\n                    }\n                };\n            };\n        };\n    };\n};\nmodule.exports = {\n    append: append,\n    appendRecord: appendRecord,\n    semigroupString: semigroupString,\n    semigroupUnit: semigroupUnit,\n    semigroupVoid: semigroupVoid,\n    semigroupFn: semigroupFn,\n    semigroupArray: semigroupArray,\n    semigroupProxy: semigroupProxy,\n    semigroupProxy2: semigroupProxy2,\n    semigroupProxy3: semigroupProxy3,\n    semigroupRecord: semigroupRecord,\n    semigroupRecordNil: semigroupRecordNil,\n    semigroupRecordCons: semigroupRecordCons\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Semigroup.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Semiring.purs":
/*!******************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Semiring.purs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.js */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.js\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Record_Unsafe = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Record/Unsafe.purs */ \"./.spago/prelude/v5.0.1/src/Record/Unsafe.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar zeroRecord = function (dict) {\n    return dict.zeroRecord;\n};\nvar zero = function (dict) {\n    return dict.zero;\n};\nvar semiringUnit = {\n    add: function (v) {\n        return function (v1) {\n            return Data_Unit.unit;\n        };\n    },\n    zero: Data_Unit.unit,\n    mul: function (v) {\n        return function (v1) {\n            return Data_Unit.unit;\n        };\n    },\n    one: Data_Unit.unit\n};\nvar semiringRecordNil = {\n    addRecord: function (v) {\n        return function (v1) {\n            return function (v2) {\n                return {};\n            };\n        };\n    },\n    mulRecord: function (v) {\n        return function (v1) {\n            return function (v2) {\n                return {};\n            };\n        };\n    },\n    oneRecord: function (v) {\n        return function (v1) {\n            return {};\n        };\n    },\n    zeroRecord: function (v) {\n        return function (v1) {\n            return {};\n        };\n    }\n};\nvar semiringProxy3 = {\n    add: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy3.value;\n        };\n    },\n    mul: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy3.value;\n        };\n    },\n    one: Type_Proxy.Proxy3.value,\n    zero: Type_Proxy.Proxy3.value\n};\nvar semiringProxy2 = {\n    add: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy2.value;\n        };\n    },\n    mul: function (v) {\n        return function (v1) {\n            return Type_Proxy.Proxy2.value;\n        };\n    },\n    one: Type_Proxy.Proxy2.value,\n    zero: Type_Proxy.Proxy2.value\n};\nvar semiringProxy = {\n    add: function (v) {\n        return function (v1) {\n            return Type_Proxy[\"Proxy\"].value;\n        };\n    },\n    mul: function (v) {\n        return function (v1) {\n            return Type_Proxy[\"Proxy\"].value;\n        };\n    },\n    one: Type_Proxy[\"Proxy\"].value,\n    zero: Type_Proxy[\"Proxy\"].value\n};\nvar semiringNumber = {\n    add: $foreign.numAdd,\n    zero: 0.0,\n    mul: $foreign.numMul,\n    one: 1.0\n};\nvar semiringInt = {\n    add: $foreign.intAdd,\n    zero: 0,\n    mul: $foreign.intMul,\n    one: 1\n};\nvar oneRecord = function (dict) {\n    return dict.oneRecord;\n};\nvar one = function (dict) {\n    return dict.one;\n};\nvar mulRecord = function (dict) {\n    return dict.mulRecord;\n};\nvar mul = function (dict) {\n    return dict.mul;\n};\nvar addRecord = function (dict) {\n    return dict.addRecord;\n};\nvar semiringRecord = function (dictRowToList) {\n    return function (dictSemiringRecord) {\n        return {\n            add: addRecord(dictSemiringRecord)(Type_Proxy[\"Proxy\"].value),\n            mul: mulRecord(dictSemiringRecord)(Type_Proxy[\"Proxy\"].value),\n            one: oneRecord(dictSemiringRecord)(Type_Proxy[\"Proxy\"].value)(Type_Proxy[\"Proxy\"].value),\n            zero: zeroRecord(dictSemiringRecord)(Type_Proxy[\"Proxy\"].value)(Type_Proxy[\"Proxy\"].value)\n        };\n    };\n};\nvar add = function (dict) {\n    return dict.add;\n};\nvar semiringFn = function (dictSemiring) {\n    return {\n        add: function (f) {\n            return function (g) {\n                return function (x) {\n                    return add(dictSemiring)(f(x))(g(x));\n                };\n            };\n        },\n        zero: function (v) {\n            return zero(dictSemiring);\n        },\n        mul: function (f) {\n            return function (g) {\n                return function (x) {\n                    return mul(dictSemiring)(f(x))(g(x));\n                };\n            };\n        },\n        one: function (v) {\n            return one(dictSemiring);\n        }\n    };\n};\nvar semiringRecordCons = function (dictIsSymbol) {\n    return function (dictCons) {\n        return function (dictSemiringRecord) {\n            return function (dictSemiring) {\n                return {\n                    addRecord: function (v) {\n                        return function (ra) {\n                            return function (rb) {\n                                var tail = addRecord(dictSemiringRecord)(Type_Proxy[\"Proxy\"].value)(ra)(rb);\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var insert = Record_Unsafe.unsafeSet(key);\n                                var get = Record_Unsafe.unsafeGet(key);\n                                return insert(add(dictSemiring)(get(ra))(get(rb)))(tail);\n                            };\n                        };\n                    },\n                    mulRecord: function (v) {\n                        return function (ra) {\n                            return function (rb) {\n                                var tail = mulRecord(dictSemiringRecord)(Type_Proxy[\"Proxy\"].value)(ra)(rb);\n                                var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                                var insert = Record_Unsafe.unsafeSet(key);\n                                var get = Record_Unsafe.unsafeGet(key);\n                                return insert(mul(dictSemiring)(get(ra))(get(rb)))(tail);\n                            };\n                        };\n                    },\n                    oneRecord: function (v) {\n                        return function (v1) {\n                            var tail = oneRecord(dictSemiringRecord)(Type_Proxy[\"Proxy\"].value)(Type_Proxy[\"Proxy\"].value);\n                            var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                            var insert = Record_Unsafe.unsafeSet(key);\n                            return insert(one(dictSemiring))(tail);\n                        };\n                    },\n                    zeroRecord: function (v) {\n                        return function (v1) {\n                            var tail = zeroRecord(dictSemiringRecord)(Type_Proxy[\"Proxy\"].value)(Type_Proxy[\"Proxy\"].value);\n                            var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                            var insert = Record_Unsafe.unsafeSet(key);\n                            return insert(zero(dictSemiring))(tail);\n                        };\n                    }\n                };\n            };\n        };\n    };\n};\nmodule.exports = {\n    add: add,\n    zero: zero,\n    mul: mul,\n    one: one,\n    addRecord: addRecord,\n    mulRecord: mulRecord,\n    oneRecord: oneRecord,\n    zeroRecord: zeroRecord,\n    semiringInt: semiringInt,\n    semiringNumber: semiringNumber,\n    semiringFn: semiringFn,\n    semiringUnit: semiringUnit,\n    semiringProxy: semiringProxy,\n    semiringProxy2: semiringProxy2,\n    semiringProxy3: semiringProxy3,\n    semiringRecord: semiringRecord,\n    semiringRecordNil: semiringRecordNil,\n    semiringRecordCons: semiringRecordCons\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Semiring.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Show.purs":
/*!**************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Show.purs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.js */ \"./.spago/prelude/v5.0.1/src/Data/Show.js\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Record_Unsafe = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Record/Unsafe.purs */ \"./.spago/prelude/v5.0.1/src/Record/Unsafe.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar showString = {\n    show: $foreign.showStringImpl\n};\nvar showRecordFieldsNil = {\n    showRecordFields: function (v) {\n        return function (v1) {\n            return [  ];\n        };\n    }\n};\nvar showRecordFields = function (dict) {\n    return dict.showRecordFields;\n};\nvar showRecord = function (dictRowToList) {\n    return function (dictShowRecordFields) {\n        return {\n            show: function (record) {\n                var v = showRecordFields(dictShowRecordFields)(Type_Proxy[\"Proxy\"].value)(record);\n                if (v.length === 0) {\n                    return \"{}\";\n                };\n                return $foreign.join(\" \")([ \"{\", $foreign.join(\", \")(v), \"}\" ]);\n            }\n        };\n    };\n};\nvar showProxy3 = {\n    show: function (v) {\n        return \"Proxy3\";\n    }\n};\nvar showProxy2 = {\n    show: function (v) {\n        return \"Proxy2\";\n    }\n};\nvar showProxy = {\n    show: function (v) {\n        return \"Proxy\";\n    }\n};\nvar showNumber = {\n    show: $foreign.showNumberImpl\n};\nvar showInt = {\n    show: $foreign.showIntImpl\n};\nvar showChar = {\n    show: $foreign.showCharImpl\n};\nvar showBoolean = {\n    show: function (v) {\n        if (v) {\n            return \"true\";\n        };\n        if (!v) {\n            return \"false\";\n        };\n        throw new Error(\"Failed pattern match at Data.Show (line 20, column 1 - line 22, column 23): \" + [ v.constructor.name ]);\n    }\n};\nvar show = function (dict) {\n    return dict.show;\n};\nvar showArray = function (dictShow) {\n    return {\n        show: $foreign.showArrayImpl(show(dictShow))\n    };\n};\nvar showRecordFieldsCons = function (dictIsSymbol) {\n    return function (dictShowRecordFields) {\n        return function (dictShow) {\n            return {\n                showRecordFields: function (v) {\n                    return function (record) {\n                        var tail = showRecordFields(dictShowRecordFields)(Type_Proxy[\"Proxy\"].value)(record);\n                        var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                        var focus = Record_Unsafe.unsafeGet(key)(record);\n                        return $foreign.cons($foreign.join(\": \")([ key, show(dictShow)(focus) ]))(tail);\n                    };\n                }\n            };\n        };\n    };\n};\nmodule.exports = {\n    show: show,\n    showRecordFields: showRecordFields,\n    showBoolean: showBoolean,\n    showInt: showInt,\n    showNumber: showNumber,\n    showChar: showChar,\n    showString: showString,\n    showArray: showArray,\n    showProxy: showProxy,\n    showProxy2: showProxy2,\n    showProxy3: showProxy3,\n    showRecord: showRecord,\n    showRecordFieldsNil: showRecordFieldsNil,\n    showRecordFieldsCons: showRecordFieldsCons\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Show.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Show/Generic.purs":
/*!**********************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Show/Generic.purs ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show/Generic.js */ \"./.spago/prelude/v5.0.1/src/Data/Show/Generic.js\");\nvar Data_Generic_Rep = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs */ \"./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Symbol = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.purs */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.purs\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar genericShowArgsNoArguments = {\n    genericShowArgs: function (v) {\n        return [  ];\n    }\n};\nvar genericShowArgsArgument = function (dictShow) {\n    return {\n        genericShowArgs: function (v) {\n            return [ Data_Show.show(dictShow)(v) ];\n        }\n    };\n};\nvar genericShowArgs = function (dict) {\n    return dict.genericShowArgs;\n};\nvar genericShowArgsProduct = function (dictGenericShowArgs) {\n    return function (dictGenericShowArgs1) {\n        return {\n            genericShowArgs: function (v) {\n                return Data_Semigroup.append(Data_Semigroup.semigroupArray)(genericShowArgs(dictGenericShowArgs)(v.value0))(genericShowArgs(dictGenericShowArgs1)(v.value1));\n            }\n        };\n    };\n};\nvar genericShowConstructor = function (dictGenericShowArgs) {\n    return function (dictIsSymbol) {\n        return {\n            \"genericShow'\": function (v) {\n                var ctor = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy[\"Proxy\"].value);\n                var v1 = genericShowArgs(dictGenericShowArgs)(v);\n                if (v1.length === 0) {\n                    return ctor;\n                };\n                return \"(\" + ($foreign.intercalate(\" \")(Data_Semigroup.append(Data_Semigroup.semigroupArray)([ ctor ])(v1)) + \")\");\n            }\n        };\n    };\n};\nvar genericShow$prime = function (dict) {\n    return dict[\"genericShow'\"];\n};\nvar genericShowNoConstructors = {\n    \"genericShow'\": function (a) {\n        return genericShow$prime(genericShowNoConstructors)(a);\n    }\n};\nvar genericShowSum = function (dictGenericShow) {\n    return function (dictGenericShow1) {\n        return {\n            \"genericShow'\": function (v) {\n                if (v instanceof Data_Generic_Rep.Inl) {\n                    return genericShow$prime(dictGenericShow)(v.value0);\n                };\n                if (v instanceof Data_Generic_Rep.Inr) {\n                    return genericShow$prime(dictGenericShow1)(v.value0);\n                };\n                throw new Error(\"Failed pattern match at Data.Show.Generic (line 26, column 1 - line 28, column 40): \" + [ v.constructor.name ]);\n            }\n        };\n    };\n};\nvar genericShow = function (dictGeneric) {\n    return function (dictGenericShow) {\n        return function (x) {\n            return genericShow$prime(dictGenericShow)(Data_Generic_Rep.from(dictGeneric)(x));\n        };\n    };\n};\nmodule.exports = {\n    \"genericShow'\": genericShow$prime,\n    genericShow: genericShow,\n    genericShowArgs: genericShowArgs,\n    genericShowNoConstructors: genericShowNoConstructors,\n    genericShowArgsNoArguments: genericShowArgsNoArguments,\n    genericShowSum: genericShowSum,\n    genericShowArgsProduct: genericShowArgsProduct,\n    genericShowConstructor: genericShowConstructor,\n    genericShowArgsArgument: genericShowArgsArgument\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Show/Generic.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Symbol.purs":
/*!****************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Symbol.purs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Symbol.js */ \"./.spago/prelude/v5.0.1/src/Data/Symbol.js\");\nvar Type_Proxy = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Type/Proxy.purs */ \"./.spago/prelude/v5.0.1/src/Type/Proxy.purs\");\nvar SProxy = (function () {\n    function SProxy() {\n\n    };\n    SProxy.value = new SProxy();\n    return SProxy;\n})();\nvar reifySymbol = function (s) {\n    return function (f) {\n        return $foreign.unsafeCoerce(function (dictIsSymbol) {\n            return f(dictIsSymbol);\n        })({\n            reflectSymbol: function (v) {\n                return s;\n            }\n        })(Type_Proxy[\"Proxy\"].value);\n    };\n};\nvar reflectSymbol = function (dict) {\n    return dict.reflectSymbol;\n};\nmodule.exports = {\n    reflectSymbol: reflectSymbol,\n    reifySymbol: reifySymbol,\n    SProxy: SProxy\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Symbol.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Unit.purs":
/*!**************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Unit.purs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.js */ \"./.spago/prelude/v5.0.1/src/Data/Unit.js\");\nvar showUnit = {\n    show: function (v) {\n        return \"unit\";\n    }\n};\nmodule.exports = {\n    showUnit: showUnit,\n    unit: $foreign.unit\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Unit.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Data/Void.purs":
/*!**************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Data/Void.purs ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Void = function (x) {\n    return x;\n};\nvar absurd = function (a) {\n    var spin = function ($copy_v) {\n        var $tco_result;\n        function $tco_loop(v) {\n            $copy_v = v;\n            return;\n        };\n        while (!false) {\n            $tco_result = $tco_loop($copy_v);\n        };\n        return $tco_result;\n    };\n    return spin(a);\n};\nvar showVoid = {\n    show: absurd\n};\nmodule.exports = {\n    absurd: absurd,\n    showVoid: showVoid\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Data/Void.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Record/Unsafe.purs":
/*!******************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Record/Unsafe.purs ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Record/Unsafe.js */ \"./.spago/prelude/v5.0.1/src/Record/Unsafe.js\");\nmodule.exports = {\n    unsafeHas: $foreign.unsafeHas,\n    unsafeGet: $foreign.unsafeGet,\n    unsafeSet: $foreign.unsafeSet,\n    unsafeDelete: $foreign.unsafeDelete\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Record/Unsafe.purs?");

/***/ }),

/***/ "./.spago/prelude/v5.0.1/src/Type/Proxy.purs":
/*!***************************************************!*\
  !*** ./.spago/prelude/v5.0.1/src/Type/Proxy.purs ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Proxy3 = (function () {\n    function Proxy3() {\n\n    };\n    Proxy3.value = new Proxy3();\n    return Proxy3;\n})();\nvar Proxy2 = (function () {\n    function Proxy2() {\n\n    };\n    Proxy2.value = new Proxy2();\n    return Proxy2;\n})();\nvar $$Proxy = (function () {\n    function $$Proxy() {\n\n    };\n    $$Proxy.value = new $$Proxy();\n    return $$Proxy;\n})();\nmodule.exports = {\n    \"Proxy\": $$Proxy,\n    Proxy2: Proxy2,\n    Proxy3: Proxy3\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/prelude/v5.0.1/src/Type/Proxy.purs?");

/***/ }),

/***/ "./.spago/profunctor/v5.0.0/src/Data/Profunctor.purs":
/*!***********************************************************!*\
  !*** ./.spago/profunctor/v5.0.0/src/Data/Profunctor.purs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar profunctorFn = {\n    dimap: function (a2b) {\n        return function (c2d) {\n            return function (b2c) {\n                return function ($10) {\n                    return c2d(b2c(a2b($10)));\n                };\n            };\n        };\n    }\n};\nvar dimap = function (dict) {\n    return dict.dimap;\n};\nvar lcmap = function (dictProfunctor) {\n    return function (a2b) {\n        return dimap(dictProfunctor)(a2b)(Control_Category.identity(Control_Category.categoryFn));\n    };\n};\nvar rmap = function (dictProfunctor) {\n    return function (b2c) {\n        return dimap(dictProfunctor)(Control_Category.identity(Control_Category.categoryFn))(b2c);\n    };\n};\nvar unwrapIso = function (dictProfunctor) {\n    return function (dictNewtype) {\n        return dimap(dictProfunctor)(Data_Newtype.wrap())(Data_Newtype.unwrap());\n    };\n};\nvar wrapIso = function (dictProfunctor) {\n    return function (dictNewtype) {\n        return function (v) {\n            return dimap(dictProfunctor)(Data_Newtype.unwrap())(Data_Newtype.wrap());\n        };\n    };\n};\nvar arr = function (dictCategory) {\n    return function (dictProfunctor) {\n        return function (f) {\n            return rmap(dictProfunctor)(f)(Control_Category.identity(dictCategory));\n        };\n    };\n};\nmodule.exports = {\n    dimap: dimap,\n    lcmap: lcmap,\n    rmap: rmap,\n    arr: arr,\n    unwrapIso: unwrapIso,\n    wrapIso: wrapIso,\n    profunctorFn: profunctorFn\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/profunctor/v5.0.0/src/Data/Profunctor.purs?");

/***/ }),

/***/ "./.spago/refs/v5.0.0/src/Effect/Ref.purs":
/*!************************************************!*\
  !*** ./.spago/refs/v5.0.0/src/Effect/Ref.purs ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/refs/v5.0.0/src/Effect/Ref.js */ \"./.spago/refs/v5.0.0/src/Effect/Ref.js\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Effect = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect.purs */ \"./.spago/effect/v3.0.0/src/Effect.purs\");\nvar modify$prime = $foreign.modifyImpl;\nvar modify = function (f) {\n    return modify$prime(function (s) {\n        var s$prime = f(s);\n        return {\n            state: s$prime,\n            value: s$prime\n        };\n    });\n};\nvar modify_ = function (f) {\n    return function (s) {\n        return Data_Functor[\"void\"](Effect.functorEffect)(modify(f)(s));\n    };\n};\nmodule.exports = {\n    \"modify'\": modify$prime,\n    modify: modify,\n    modify_: modify_,\n    \"new\": $foreign[\"new\"],\n    newWithSelf: $foreign.newWithSelf,\n    read: $foreign.read,\n    write: $foreign.write\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/refs/v5.0.0/src/Effect/Ref.purs?");

/***/ }),

/***/ "./.spago/safe-coerce/v1.0.0/src/Safe/Coerce.purs":
/*!********************************************************!*\
  !*** ./.spago/safe-coerce/v1.0.0/src/Safe/Coerce.purs ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Unsafe_Coerce = __webpack_require__(/*! ./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs */ \"./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs\");\nvar coerce = function (dictCoercible) {\n    return Unsafe_Coerce.unsafeCoerce;\n};\nmodule.exports = {\n    coerce: coerce\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/safe-coerce/v1.0.0/src/Safe/Coerce.purs?");

/***/ }),

/***/ "./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs":
/*!*************************************************************!*\
  !*** ./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.js */ \"./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.js\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar modify$prime = $foreign.modifyImpl;\nvar modify = function (f) {\n    return modify$prime(function (s) {\n        var s$prime = f(s);\n        return {\n            state: s$prime,\n            value: s$prime\n        };\n    });\n};\nvar functorST = {\n    map: $foreign.map_\n};\nvar monadST = {\n    Applicative0: function () {\n        return applicativeST;\n    },\n    Bind1: function () {\n        return bindST;\n    }\n};\nvar bindST = {\n    bind: $foreign.bind_,\n    Apply0: function () {\n        return applyST;\n    }\n};\nvar applyST = {\n    apply: Control_Monad.ap(monadST),\n    Functor0: function () {\n        return functorST;\n    }\n};\nvar applicativeST = {\n    pure: $foreign.pure_,\n    Apply0: function () {\n        return applyST;\n    }\n};\nvar monadRecST = {\n    tailRecM: function (f) {\n        return function (a) {\n            var isLooping = function (v) {\n                if (v instanceof Control_Monad_Rec_Class.Loop) {\n                    return true;\n                };\n                return false;\n            };\n            var fromDone = function (v) {\n                if (v instanceof Control_Monad_Rec_Class.Done) {\n                    return v.value0;\n                };\n                throw new Error(\"Failed pattern match at Control.Monad.ST.Internal (line 69, column 32 - line 69, column 46): \" + [ v.constructor.name ]);\n            };\n            return Control_Bind.bind(bindST)(Control_Bind.bindFlipped(bindST)($foreign[\"new\"])(f(a)))(function (r) {\n                return Control_Bind.discard(Control_Bind.discardUnit)(bindST)($foreign[\"while\"](Data_Functor.map(functorST)(isLooping)($foreign.read(r)))(Control_Bind.bind(bindST)($foreign.read(r))(function (v) {\n                    if (v instanceof Control_Monad_Rec_Class.Loop) {\n                        return Control_Bind.bind(bindST)(f(v.value0))(function (e) {\n                            return Data_Functor[\"void\"](functorST)($foreign.write(e)(r));\n                        });\n                    };\n                    if (v instanceof Control_Monad_Rec_Class.Done) {\n                        return Control_Applicative.pure(applicativeST)(Data_Unit.unit);\n                    };\n                    throw new Error(\"Failed pattern match at Control.Monad.ST.Internal (line 61, column 18 - line 65, column 28): \" + [ v.constructor.name ]);\n                })))(function () {\n                    return Data_Functor.map(functorST)(fromDone)($foreign.read(r));\n                });\n            });\n        };\n    },\n    Monad0: function () {\n        return monadST;\n    }\n};\nmodule.exports = {\n    \"modify'\": modify$prime,\n    modify: modify,\n    functorST: functorST,\n    applyST: applyST,\n    applicativeST: applicativeST,\n    bindST: bindST,\n    monadST: monadST,\n    monadRecST: monadRecST,\n    run: $foreign.run,\n    \"while\": $foreign[\"while\"],\n    \"for\": $foreign[\"for\"],\n    foreach: $foreign.foreach,\n    \"new\": $foreign[\"new\"],\n    read: $foreign.read,\n    write: $foreign.write\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/st/v5.0.1/src/Control/Monad/ST/Internal.purs?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/Char.purs":
/*!**************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/Char.purs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Enum = __webpack_require__(/*! ./.spago/enums/v5.0.0/src/Data/Enum.purs */ \"./.spago/enums/v5.0.0/src/Data/Enum.purs\");\nvar toCharCode = Data_Enum.fromEnum(Data_Enum.boundedEnumChar);\nvar fromCharCode = Data_Enum.toEnum(Data_Enum.boundedEnumChar);\nmodule.exports = {\n    toCharCode: toCharCode,\n    fromCharCode: fromCharCode\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/Char.purs?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs":
/*!***************************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodePoints.js */ \"./.spago/strings/v5.0.0/src/Data/String/CodePoints.js\");\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Bounded = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Bounded.purs */ \"./.spago/prelude/v5.0.1/src/Data/Bounded.purs\");\nvar Data_Enum = __webpack_require__(/*! ./.spago/enums/v5.0.0/src/Data/Enum.purs */ \"./.spago/enums/v5.0.0/src/Data/Enum.purs\");\nvar Data_EuclideanRing = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs */ \"./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Int = __webpack_require__(/*! ./.spago/integers/v5.0.0/src/Data/Int.purs */ \"./.spago/integers/v5.0.0/src/Data/Int.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_String_CodeUnits = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs\");\nvar Data_String_Common = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Common.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Common.purs\");\nvar Data_String_Unsafe = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Unsafe.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Unsafe.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar CodePoint = function (x) {\n    return x;\n};\nvar unsurrogate = function (lead) {\n    return function (trail) {\n        return (((lead - 55296 | 0) * 1024 | 0) + (trail - 56320 | 0) | 0) + 65536 | 0;\n    };\n};\nvar showCodePoint = {\n    show: function (v) {\n        return \"(CodePoint 0x\" + (Data_String_Common.toUpper(Data_Int.toStringAs(Data_Int.hexadecimal)(v)) + \")\");\n    }\n};\nvar isTrail = function (cu) {\n    return 56320 <= cu && cu <= 57343;\n};\nvar isLead = function (cu) {\n    return 55296 <= cu && cu <= 56319;\n};\nvar uncons = function (s) {\n    var v = Data_String_CodeUnits.length(s);\n    if (v === 0) {\n        return Data_Maybe.Nothing.value;\n    };\n    if (v === 1) {\n        return new Data_Maybe.Just({\n            head: Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(0)(s)),\n            tail: \"\"\n        });\n    };\n    var cu1 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(1)(s));\n    var cu0 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(0)(s));\n    var $21 = isLead(cu0) && isTrail(cu1);\n    if ($21) {\n        return new Data_Maybe.Just({\n            head: unsurrogate(cu0)(cu1),\n            tail: Data_String_CodeUnits.drop(2)(s)\n        });\n    };\n    return new Data_Maybe.Just({\n        head: cu0,\n        tail: Data_String_CodeUnits.drop(1)(s)\n    });\n};\nvar unconsButWithTuple = function (s) {\n    return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {\n        return new Data_Tuple.Tuple(v.head, v.tail);\n    })(uncons(s));\n};\nvar toCodePointArrayFallback = function (s) {\n    return Data_Unfoldable.unfoldr(Data_Unfoldable.unfoldableArray)(unconsButWithTuple)(s);\n};\nvar unsafeCodePointAt0Fallback = function (s) {\n    var cu0 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(0)(s));\n    var $25 = isLead(cu0) && Data_String_CodeUnits.length(s) > 1;\n    if ($25) {\n        var cu1 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar)(Data_String_Unsafe.charAt(1)(s));\n        var $26 = isTrail(cu1);\n        if ($26) {\n            return unsurrogate(cu0)(cu1);\n        };\n        return cu0;\n    };\n    return cu0;\n};\nvar unsafeCodePointAt0 = $foreign[\"_unsafeCodePointAt0\"](unsafeCodePointAt0Fallback);\nvar toCodePointArray = $foreign[\"_toCodePointArray\"](toCodePointArrayFallback)(unsafeCodePointAt0);\nvar length = function ($52) {\n    return Data_Array.length(toCodePointArray($52));\n};\nvar lastIndexOf = function (p) {\n    return function (s) {\n        return Data_Functor.map(Data_Maybe.functorMaybe)(function (i) {\n            return length(Data_String_CodeUnits.take(i)(s));\n        })(Data_String_CodeUnits.lastIndexOf(p)(s));\n    };\n};\nvar indexOf = function (p) {\n    return function (s) {\n        return Data_Functor.map(Data_Maybe.functorMaybe)(function (i) {\n            return length(Data_String_CodeUnits.take(i)(s));\n        })(Data_String_CodeUnits.indexOf(p)(s));\n    };\n};\nvar fromCharCode = (function () {\n    var $53 = Data_Enum.toEnumWithDefaults(Data_Enum.boundedEnumChar)(Data_Bounded.bottom(Data_Bounded.boundedChar))(Data_Bounded.top(Data_Bounded.boundedChar));\n    return function ($54) {\n        return Data_String_CodeUnits.singleton($53($54));\n    };\n})();\nvar singletonFallback = function (v) {\n    if (v <= 65535) {\n        return fromCharCode(v);\n    };\n    var lead = Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt)(v - 65536 | 0)(1024) + 55296 | 0;\n    var trail = Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(v - 65536 | 0)(1024) + 56320 | 0;\n    return fromCharCode(lead) + fromCharCode(trail);\n};\nvar fromCodePointArray = $foreign[\"_fromCodePointArray\"](singletonFallback);\nvar singleton = $foreign[\"_singleton\"](singletonFallback);\nvar takeFallback = function (n) {\n    return function (v) {\n        if (n < 1) {\n            return \"\";\n        };\n        var v1 = uncons(v);\n        if (v1 instanceof Data_Maybe.Just) {\n            return singleton(v1.value0.head) + takeFallback(n - 1 | 0)(v1.value0.tail);\n        };\n        return v;\n    };\n};\nvar take = $foreign[\"_take\"](takeFallback);\nvar lastIndexOf$prime = function (p) {\n    return function (i) {\n        return function (s) {\n            var i$prime = Data_String_CodeUnits.length(take(i)(s));\n            return Data_Functor.map(Data_Maybe.functorMaybe)(function (k) {\n                return length(Data_String_CodeUnits.take(k)(s));\n            })(Data_String_CodeUnits[\"lastIndexOf'\"](p)(i$prime)(s));\n        };\n    };\n};\nvar splitAt = function (i) {\n    return function (s) {\n        var before = take(i)(s);\n        return {\n            before: before,\n            after: Data_String_CodeUnits.drop(Data_String_CodeUnits.length(before))(s)\n        };\n    };\n};\nvar eqCodePoint = {\n    eq: function (x) {\n        return function (y) {\n            return x === y;\n        };\n    }\n};\nvar ordCodePoint = {\n    compare: function (x) {\n        return function (y) {\n            return Data_Ord.compare(Data_Ord.ordInt)(x)(y);\n        };\n    },\n    Eq0: function () {\n        return eqCodePoint;\n    }\n};\nvar drop = function (n) {\n    return function (s) {\n        return Data_String_CodeUnits.drop(Data_String_CodeUnits.length(take(n)(s)))(s);\n    };\n};\nvar indexOf$prime = function (p) {\n    return function (i) {\n        return function (s) {\n            var s$prime = drop(i)(s);\n            return Data_Functor.map(Data_Maybe.functorMaybe)(function (k) {\n                return i + length(Data_String_CodeUnits.take(k)(s$prime)) | 0;\n            })(Data_String_CodeUnits.indexOf(p)(s$prime));\n        };\n    };\n};\nvar countTail = function ($copy_p) {\n    return function ($copy_s) {\n        return function ($copy_accum) {\n            var $tco_var_p = $copy_p;\n            var $tco_var_s = $copy_s;\n            var $tco_done = false;\n            var $tco_result;\n            function $tco_loop(p, s, accum) {\n                var v = uncons(s);\n                if (v instanceof Data_Maybe.Just) {\n                    var $39 = p(v.value0.head);\n                    if ($39) {\n                        $tco_var_p = p;\n                        $tco_var_s = v.value0.tail;\n                        $copy_accum = accum + 1 | 0;\n                        return;\n                    };\n                    $tco_done = true;\n                    return accum;\n                };\n                $tco_done = true;\n                return accum;\n            };\n            while (!$tco_done) {\n                $tco_result = $tco_loop($tco_var_p, $tco_var_s, $copy_accum);\n            };\n            return $tco_result;\n        };\n    };\n};\nvar countFallback = function (p) {\n    return function (s) {\n        return countTail(p)(s)(0);\n    };\n};\nvar countPrefix = $foreign[\"_countPrefix\"](countFallback)(unsafeCodePointAt0);\nvar dropWhile = function (p) {\n    return function (s) {\n        return drop(countPrefix(p)(s))(s);\n    };\n};\nvar takeWhile = function (p) {\n    return function (s) {\n        return take(countPrefix(p)(s))(s);\n    };\n};\nvar codePointFromChar = (function () {\n    var $55 = Data_Enum.fromEnum(Data_Enum.boundedEnumChar);\n    return function ($56) {\n        return CodePoint($55($56));\n    };\n})();\nvar codePointAtFallback = function ($copy_n) {\n    return function ($copy_s) {\n        var $tco_var_n = $copy_n;\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(n, s) {\n            var v = uncons(s);\n            if (v instanceof Data_Maybe.Just) {\n                var $44 = n === 0;\n                if ($44) {\n                    $tco_done = true;\n                    return new Data_Maybe.Just(v.value0.head);\n                };\n                $tco_var_n = n - 1 | 0;\n                $copy_s = v.value0.tail;\n                return;\n            };\n            $tco_done = true;\n            return Data_Maybe.Nothing.value;\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($tco_var_n, $copy_s);\n        };\n        return $tco_result;\n    };\n};\nvar codePointAt = function (v) {\n    return function (v1) {\n        if (v < 0) {\n            return Data_Maybe.Nothing.value;\n        };\n        if (v === 0 && v1 === \"\") {\n            return Data_Maybe.Nothing.value;\n        };\n        if (v === 0) {\n            return new Data_Maybe.Just(unsafeCodePointAt0(v1));\n        };\n        return $foreign[\"_codePointAt\"](codePointAtFallback)(Data_Maybe.Just.create)(Data_Maybe.Nothing.value)(unsafeCodePointAt0)(v)(v1);\n    };\n};\nvar boundedCodePoint = {\n    bottom: 0,\n    top: 1114111,\n    Ord0: function () {\n        return ordCodePoint;\n    }\n};\nvar boundedEnumCodePoint = {\n    cardinality: 1114111 + 1 | 0,\n    fromEnum: function (v) {\n        return v;\n    },\n    toEnum: function (n) {\n        if (n >= 0 && n <= 1114111) {\n            return new Data_Maybe.Just(n);\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Maybe.Nothing.value;\n        };\n        throw new Error(\"Failed pattern match at Data.String.CodePoints (line 63, column 1 - line 68, column 26): \" + [ n.constructor.name ]);\n    },\n    Bounded0: function () {\n        return boundedCodePoint;\n    },\n    Enum1: function () {\n        return enumCodePoint;\n    }\n};\nvar enumCodePoint = {\n    succ: Data_Enum.defaultSucc(Data_Enum.toEnum(boundedEnumCodePoint))(Data_Enum.fromEnum(boundedEnumCodePoint)),\n    pred: Data_Enum.defaultPred(Data_Enum.toEnum(boundedEnumCodePoint))(Data_Enum.fromEnum(boundedEnumCodePoint)),\n    Ord0: function () {\n        return ordCodePoint;\n    }\n};\nmodule.exports = {\n    codePointFromChar: codePointFromChar,\n    singleton: singleton,\n    fromCodePointArray: fromCodePointArray,\n    toCodePointArray: toCodePointArray,\n    codePointAt: codePointAt,\n    uncons: uncons,\n    length: length,\n    countPrefix: countPrefix,\n    indexOf: indexOf,\n    \"indexOf'\": indexOf$prime,\n    lastIndexOf: lastIndexOf,\n    \"lastIndexOf'\": lastIndexOf$prime,\n    take: take,\n    takeWhile: takeWhile,\n    drop: drop,\n    dropWhile: dropWhile,\n    splitAt: splitAt,\n    eqCodePoint: eqCodePoint,\n    ordCodePoint: ordCodePoint,\n    showCodePoint: showCodePoint,\n    boundedCodePoint: boundedCodePoint,\n    enumCodePoint: enumCodePoint,\n    boundedEnumCodePoint: boundedEnumCodePoint,\n    contains: Data_String_CodeUnits.contains,\n    stripPrefix: Data_String_CodeUnits.stripPrefix,\n    stripSuffix: Data_String_CodeUnits.stripSuffix\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs":
/*!**************************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodeUnits.js */ \"./.spago/strings/v5.0.0/src/Data/String/CodeUnits.js\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_String_Unsafe = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Unsafe.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Unsafe.purs\");\nvar uncons = function (v) {\n    if (v === \"\") {\n        return Data_Maybe.Nothing.value;\n    };\n    return new Data_Maybe.Just({\n        head: Data_String_Unsafe.charAt(0)(v),\n        tail: $foreign.drop(1)(v)\n    });\n};\nvar toChar = $foreign[\"_toChar\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar takeWhile = function (p) {\n    return function (s) {\n        return $foreign.take($foreign.countPrefix(p)(s))(s);\n    };\n};\nvar takeRight = function (i) {\n    return function (s) {\n        return $foreign.drop($foreign.length(s) - i | 0)(s);\n    };\n};\nvar stripSuffix = function (v) {\n    return function (str) {\n        var v1 = $foreign.splitAt($foreign.length(str) - $foreign.length(v) | 0)(str);\n        var $9 = v1.after === v;\n        if ($9) {\n            return new Data_Maybe.Just(v1.before);\n        };\n        return Data_Maybe.Nothing.value;\n    };\n};\nvar stripPrefix = function (v) {\n    return function (str) {\n        var v1 = $foreign.splitAt($foreign.length(v))(str);\n        var $15 = v1.before === v;\n        if ($15) {\n            return new Data_Maybe.Just(v1.after);\n        };\n        return Data_Maybe.Nothing.value;\n    };\n};\nvar slice = function (b) {\n    return function (e) {\n        return function (s) {\n            var l = $foreign.length(s);\n            var norm = function (x) {\n                if (x < 0) {\n                    return l + x | 0;\n                };\n                if (Data_Boolean.otherwise) {\n                    return x;\n                };\n                throw new Error(\"Failed pattern match at Data.String.CodeUnits (line 319, column 5 - line 320, column 27): \" + [ x.constructor.name ]);\n            };\n            var e$prime = norm(e);\n            var b$prime = norm(b);\n            var $19 = b$prime < 0 || (b$prime >= l || (e$prime < 0 || (e$prime > l || b$prime > e$prime)));\n            if ($19) {\n                return Data_Maybe.Nothing.value;\n            };\n            return new Data_Maybe.Just($foreign[\"_slice\"](b)(e)(s));\n        };\n    };\n};\nvar lastIndexOf$prime = $foreign[\"_lastIndexOfStartingAt\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar lastIndexOf = $foreign[\"_lastIndexOf\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar indexOf$prime = $foreign[\"_indexOfStartingAt\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar indexOf = $foreign[\"_indexOf\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar dropWhile = function (p) {\n    return function (s) {\n        return $foreign.drop($foreign.countPrefix(p)(s))(s);\n    };\n};\nvar dropRight = function (i) {\n    return function (s) {\n        return $foreign.take($foreign.length(s) - i | 0)(s);\n    };\n};\nvar contains = function (pat) {\n    var $20 = indexOf(pat);\n    return function ($21) {\n        return Data_Maybe.isJust($20($21));\n    };\n};\nvar charAt = $foreign[\"_charAt\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nmodule.exports = {\n    stripPrefix: stripPrefix,\n    stripSuffix: stripSuffix,\n    contains: contains,\n    charAt: charAt,\n    toChar: toChar,\n    uncons: uncons,\n    indexOf: indexOf,\n    \"indexOf'\": indexOf$prime,\n    lastIndexOf: lastIndexOf,\n    \"lastIndexOf'\": lastIndexOf$prime,\n    takeRight: takeRight,\n    takeWhile: takeWhile,\n    dropRight: dropRight,\n    dropWhile: dropWhile,\n    slice: slice,\n    singleton: $foreign.singleton,\n    fromCharArray: $foreign.fromCharArray,\n    toCharArray: $foreign.toCharArray,\n    length: $foreign.length,\n    countPrefix: $foreign.countPrefix,\n    take: $foreign.take,\n    drop: $foreign.drop,\n    splitAt: $foreign.splitAt\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/Common.purs":
/*!***********************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/Common.purs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Common.js */ \"./.spago/strings/v5.0.0/src/Data/String/Common.js\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar $$null = function (s) {\n    return s === \"\";\n};\nvar localeCompare = $foreign[\"_localeCompare\"](Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value);\nmodule.exports = {\n    \"null\": $$null,\n    localeCompare: localeCompare,\n    replace: $foreign.replace,\n    replaceAll: $foreign.replaceAll,\n    split: $foreign.split,\n    toLower: $foreign.toLower,\n    toUpper: $foreign.toUpper,\n    trim: $foreign.trim,\n    joinWith: $foreign.joinWith\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/Common.purs?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/Regex.purs":
/*!**********************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/Regex.purs ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Regex.js */ \"./.spago/strings/v5.0.0/src/Data/String/Regex.js\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_String_CodeUnits = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs\");\nvar Data_String_Regex_Flags = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Regex/Flags.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Regex/Flags.purs\");\nvar showRegex = {\n    show: $foreign.showRegexImpl\n};\nvar search = $foreign[\"_search\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar replace$prime = $foreign[\"_replaceBy\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar renderFlags = function (v) {\n    return (function () {\n        if (v.value0.global) {\n            return \"g\";\n        };\n        return \"\";\n    })() + ((function () {\n        if (v.value0.ignoreCase) {\n            return \"i\";\n        };\n        return \"\";\n    })() + ((function () {\n        if (v.value0.multiline) {\n            return \"m\";\n        };\n        return \"\";\n    })() + ((function () {\n        if (v.value0.dotAll) {\n            return \"s\";\n        };\n        return \"\";\n    })() + ((function () {\n        if (v.value0.sticky) {\n            return \"y\";\n        };\n        return \"\";\n    })() + (function () {\n        if (v.value0.unicode) {\n            return \"u\";\n        };\n        return \"\";\n    })()))));\n};\nvar regex = function (s) {\n    return function (f) {\n        return $foreign.regexImpl(Data_Either.Left.create)(Data_Either.Right.create)(s)(renderFlags(f));\n    };\n};\nvar parseFlags = function (s) {\n    return new Data_String_Regex_Flags.RegexFlags({\n        global: Data_String_CodeUnits.contains(\"g\")(s),\n        ignoreCase: Data_String_CodeUnits.contains(\"i\")(s),\n        multiline: Data_String_CodeUnits.contains(\"m\")(s),\n        dotAll: Data_String_CodeUnits.contains(\"s\")(s),\n        sticky: Data_String_CodeUnits.contains(\"y\")(s),\n        unicode: Data_String_CodeUnits.contains(\"u\")(s)\n    });\n};\nvar match = $foreign[\"_match\"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);\nvar flags = function ($9) {\n    return Data_String_Regex_Flags.RegexFlags.create($foreign.flagsImpl($9));\n};\nmodule.exports = {\n    regex: regex,\n    flags: flags,\n    renderFlags: renderFlags,\n    parseFlags: parseFlags,\n    match: match,\n    \"replace'\": replace$prime,\n    search: search,\n    showRegex: showRegex,\n    source: $foreign.source,\n    test: $foreign.test,\n    replace: $foreign.replace,\n    split: $foreign.split\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/Regex.purs?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/Regex/Flags.purs":
/*!****************************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/Regex/Flags.purs ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alternative = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alternative.purs */ \"./.spago/control/v5.0.0/src/Control/Alternative.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_String_Common = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Common.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Common.purs\");\nvar RegexFlags = (function () {\n    function RegexFlags(value0) {\n        this.value0 = value0;\n    };\n    RegexFlags.create = function (value0) {\n        return new RegexFlags(value0);\n    };\n    return RegexFlags;\n})();\nvar unicode = new RegexFlags({\n    global: false,\n    ignoreCase: false,\n    multiline: false,\n    dotAll: false,\n    sticky: false,\n    unicode: true\n});\nvar sticky = new RegexFlags({\n    global: false,\n    ignoreCase: false,\n    multiline: false,\n    dotAll: false,\n    sticky: true,\n    unicode: false\n});\nvar showRegexFlags = {\n    show: function (v) {\n        var usedFlags = Data_Semigroup.append(Data_Semigroup.semigroupArray)([  ])(Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_Alternative.guard(Control_Alternative.alternativeArray)(v.value0.global))(\"global\"))(Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_Alternative.guard(Control_Alternative.alternativeArray)(v.value0.ignoreCase))(\"ignoreCase\"))(Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_Alternative.guard(Control_Alternative.alternativeArray)(v.value0.multiline))(\"multiline\"))(Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_Alternative.guard(Control_Alternative.alternativeArray)(v.value0.dotAll))(\"dotAll\"))(Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_Alternative.guard(Control_Alternative.alternativeArray)(v.value0.sticky))(\"sticky\"))(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_Alternative.guard(Control_Alternative.alternativeArray)(v.value0.unicode))(\"unicode\")))))));\n        var $6 = Data_Eq.eq(Data_Eq.eqArray(Data_Eq.eqString))(usedFlags)([  ]);\n        if ($6) {\n            return \"noFlags\";\n        };\n        return \"(\" + (Data_String_Common.joinWith(\" <> \")(usedFlags) + \")\");\n    }\n};\nvar semigroupRegexFlags = {\n    append: function (v) {\n        return function (v1) {\n            return new RegexFlags({\n                global: v.value0.global || v1.value0.global,\n                ignoreCase: v.value0.ignoreCase || v1.value0.ignoreCase,\n                multiline: v.value0.multiline || v1.value0.multiline,\n                dotAll: v.value0.dotAll || v1.value0.dotAll,\n                sticky: v.value0.sticky || v1.value0.sticky,\n                unicode: v.value0.unicode || v1.value0.unicode\n            });\n        };\n    }\n};\nvar noFlags = new RegexFlags({\n    global: false,\n    ignoreCase: false,\n    multiline: false,\n    dotAll: false,\n    sticky: false,\n    unicode: false\n});\nvar multiline = new RegexFlags({\n    global: false,\n    ignoreCase: false,\n    multiline: true,\n    dotAll: false,\n    sticky: false,\n    unicode: false\n});\nvar monoidRegexFlags = {\n    mempty: noFlags,\n    Semigroup0: function () {\n        return semigroupRegexFlags;\n    }\n};\nvar ignoreCase = new RegexFlags({\n    global: false,\n    ignoreCase: true,\n    multiline: false,\n    dotAll: false,\n    sticky: false,\n    unicode: false\n});\nvar global = new RegexFlags({\n    global: true,\n    ignoreCase: false,\n    multiline: false,\n    dotAll: false,\n    sticky: false,\n    unicode: false\n});\nvar eqRegexFlags = {\n    eq: function (v) {\n        return function (v1) {\n            return v.value0.global === v1.value0.global && (v.value0.ignoreCase === v1.value0.ignoreCase && (v.value0.multiline === v1.value0.multiline && (v.value0.dotAll === v1.value0.dotAll && (v.value0.sticky === v1.value0.sticky && v.value0.unicode === v1.value0.unicode))));\n        };\n    }\n};\nvar dotAll = new RegexFlags({\n    global: false,\n    ignoreCase: false,\n    multiline: false,\n    dotAll: true,\n    sticky: false,\n    unicode: false\n});\nmodule.exports = {\n    RegexFlags: RegexFlags,\n    noFlags: noFlags,\n    global: global,\n    ignoreCase: ignoreCase,\n    multiline: multiline,\n    sticky: sticky,\n    unicode: unicode,\n    dotAll: dotAll,\n    semigroupRegexFlags: semigroupRegexFlags,\n    monoidRegexFlags: monoidRegexFlags,\n    eqRegexFlags: eqRegexFlags,\n    showRegexFlags: showRegexFlags\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/Regex/Flags.purs?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/Regex/Unsafe.purs":
/*!*****************************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/Regex/Unsafe.purs ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_String_Regex = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Regex.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Regex.purs\");\nvar Partial_Unsafe = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.purs\");\nvar unsafeRegex = function (s) {\n    return function (f) {\n        return Data_Either.either(Partial_Unsafe.unsafeCrashWith)(Control_Category.identity(Control_Category.categoryFn))(Data_String_Regex.regex(s)(f));\n    };\n};\nmodule.exports = {\n    unsafeRegex: unsafeRegex\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/Regex/Unsafe.purs?");

/***/ }),

/***/ "./.spago/strings/v5.0.0/src/Data/String/Unsafe.purs":
/*!***********************************************************!*\
  !*** ./.spago/strings/v5.0.0/src/Data/String/Unsafe.purs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Unsafe.js */ \"./.spago/strings/v5.0.0/src/Data/String/Unsafe.js\");\nmodule.exports = {\n    \"char\": $foreign[\"char\"],\n    charAt: $foreign.charAt\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/strings/v5.0.0/src/Data/String/Unsafe.purs?");

/***/ }),

/***/ "./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs":
/*!****************************************************************!*\
  !*** ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Effect = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect.purs */ \"./.spago/effect/v3.0.0/src/Effect.purs\");\nvar Effect_Ref = __webpack_require__(/*! ./.spago/refs/v5.0.0/src/Effect/Ref.purs */ \"./.spago/refs/v5.0.0/src/Effect/Ref.purs\");\nvar Loop = (function () {\n    function Loop(value0) {\n        this.value0 = value0;\n    };\n    Loop.create = function (value0) {\n        return new Loop(value0);\n    };\n    return Loop;\n})();\nvar Done = (function () {\n    function Done(value0) {\n        this.value0 = value0;\n    };\n    Done.create = function (value0) {\n        return new Done(value0);\n    };\n    return Done;\n})();\nvar tailRecM = function (dict) {\n    return dict.tailRecM;\n};\nvar tailRecM2 = function (dictMonadRec) {\n    return function (f) {\n        return function (a) {\n            return function (b) {\n                return tailRecM(dictMonadRec)(function (o) {\n                    return f(o.a)(o.b);\n                })({\n                    a: a,\n                    b: b\n                });\n            };\n        };\n    };\n};\nvar tailRecM3 = function (dictMonadRec) {\n    return function (f) {\n        return function (a) {\n            return function (b) {\n                return function (c) {\n                    return tailRecM(dictMonadRec)(function (o) {\n                        return f(o.a)(o.b)(o.c);\n                    })({\n                        a: a,\n                        b: b,\n                        c: c\n                    });\n                };\n            };\n        };\n    };\n};\nvar untilJust = function (dictMonadRec) {\n    return function (m) {\n        return tailRecM(dictMonadRec)(function (v) {\n            return Data_Functor.mapFlipped((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0())(m)(function (v1) {\n                if (v1 instanceof Data_Maybe.Nothing) {\n                    return new Loop(Data_Unit.unit);\n                };\n                if (v1 instanceof Data_Maybe.Just) {\n                    return new Done(v1.value0);\n                };\n                throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 155, column 43 - line 157, column 19): \" + [ v1.constructor.name ]);\n            });\n        })(Data_Unit.unit);\n    };\n};\nvar whileJust = function (dictMonoid) {\n    return function (dictMonadRec) {\n        return function (m) {\n            return tailRecM(dictMonadRec)(function (v) {\n                return Data_Functor.mapFlipped((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0())(m)(function (v1) {\n                    if (v1 instanceof Data_Maybe.Nothing) {\n                        return new Done(v);\n                    };\n                    if (v1 instanceof Data_Maybe.Just) {\n                        return Loop.create(Data_Semigroup.append(dictMonoid.Semigroup0())(v)(v1.value0));\n                    };\n                    throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 148, column 45 - line 150, column 26): \" + [ v1.constructor.name ]);\n                });\n            })(Data_Monoid.mempty(dictMonoid));\n        };\n    };\n};\nvar tailRec = function (f) {\n    var go = function ($copy_v) {\n        var $tco_done = false;\n        var $tco_result;\n        function $tco_loop(v) {\n            if (v instanceof Loop) {\n                $copy_v = f(v.value0);\n                return;\n            };\n            if (v instanceof Done) {\n                $tco_done = true;\n                return v.value0;\n            };\n            throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 93, column 3 - line 93, column 25): \" + [ v.constructor.name ]);\n        };\n        while (!$tco_done) {\n            $tco_result = $tco_loop($copy_v);\n        };\n        return $tco_result;\n    };\n    return function ($59) {\n        return go(f($59));\n    };\n};\nvar monadRecMaybe = {\n    tailRecM: function (f) {\n        return function (a0) {\n            var g = function (v) {\n                if (v instanceof Data_Maybe.Nothing) {\n                    return new Done(Data_Maybe.Nothing.value);\n                };\n                if (v instanceof Data_Maybe.Just && v.value0 instanceof Loop) {\n                    return new Loop(f(v.value0.value0));\n                };\n                if (v instanceof Data_Maybe.Just && v.value0 instanceof Done) {\n                    return new Done(new Data_Maybe.Just(v.value0.value0));\n                };\n                throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 129, column 7 - line 129, column 31): \" + [ v.constructor.name ]);\n            };\n            return tailRec(g)(f(a0));\n        };\n    },\n    Monad0: function () {\n        return Data_Maybe.monadMaybe;\n    }\n};\nvar monadRecIdentity = {\n    tailRecM: function (f) {\n        var runIdentity = function (v) {\n            return v;\n        };\n        var $60 = tailRec(function ($62) {\n            return runIdentity(f($62));\n        });\n        return function ($61) {\n            return Data_Identity.Identity($60($61));\n        };\n    },\n    Monad0: function () {\n        return Data_Identity.monadIdentity;\n    }\n};\nvar monadRecFunction = {\n    tailRecM: function (f) {\n        return function (a0) {\n            return function (e) {\n                return tailRec(function (a) {\n                    return f(a)(e);\n                })(a0);\n            };\n        };\n    },\n    Monad0: function () {\n        return Control_Monad.monadFn;\n    }\n};\nvar monadRecEither = {\n    tailRecM: function (f) {\n        return function (a0) {\n            var g = function (v) {\n                if (v instanceof Data_Either.Left) {\n                    return new Done(new Data_Either.Left(v.value0));\n                };\n                if (v instanceof Data_Either.Right && v.value0 instanceof Loop) {\n                    return new Loop(f(v.value0.value0));\n                };\n                if (v instanceof Data_Either.Right && v.value0 instanceof Done) {\n                    return new Done(new Data_Either.Right(v.value0.value0));\n                };\n                throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 121, column 7 - line 121, column 33): \" + [ v.constructor.name ]);\n            };\n            return tailRec(g)(f(a0));\n        };\n    },\n    Monad0: function () {\n        return Data_Either.monadEither;\n    }\n};\nvar monadRecEffect = {\n    tailRecM: function (f) {\n        return function (a) {\n            var fromDone = function (v) {\n                if (v instanceof Done) {\n                    return v.value0;\n                };\n                throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 113, column 30 - line 113, column 44): \" + [ v.constructor.name ]);\n            };\n            return function __do() {\n                var r = Control_Bind.bindFlipped(Effect.bindEffect)(Effect_Ref[\"new\"])(f(a))();\n                (function () {\n                    while (!(function __do() {\n                        var v = Effect_Ref.read(r)();\n                        if (v instanceof Loop) {\n                            var e = f(v.value0)();\n                            Effect_Ref.write(e)(r)();\n                            return false;\n                        };\n                        if (v instanceof Done) {\n                            return true;\n                        };\n                        throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 104, column 22 - line 109, column 28): \" + [ v.constructor.name ]);\n                    })()) {\n\n                    };\n                    return {};\n                })();\n                return Data_Functor.map(Effect.functorEffect)(fromDone)(Effect_Ref.read(r))();\n            };\n        };\n    },\n    Monad0: function () {\n        return Effect.monadEffect;\n    }\n};\nvar functorStep = {\n    map: function (f) {\n        return function (m) {\n            if (m instanceof Loop) {\n                return new Loop(m.value0);\n            };\n            if (m instanceof Done) {\n                return new Done(f(m.value0));\n            };\n            throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 27, column 1 - line 27, column 48): \" + [ m.constructor.name ]);\n        };\n    }\n};\nvar forever = function (dictMonadRec) {\n    return function (ma) {\n        return tailRecM(dictMonadRec)(function (u) {\n            return Data_Functor.voidRight((((dictMonadRec.Monad0()).Bind1()).Apply0()).Functor0())(new Loop(u))(ma);\n        })(Data_Unit.unit);\n    };\n};\nvar bifunctorStep = {\n    bimap: function (v) {\n        return function (v1) {\n            return function (v2) {\n                if (v2 instanceof Loop) {\n                    return new Loop(v(v2.value0));\n                };\n                if (v2 instanceof Done) {\n                    return new Done(v1(v2.value0));\n                };\n                throw new Error(\"Failed pattern match at Control.Monad.Rec.Class (line 29, column 1 - line 31, column 34): \" + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);\n            };\n        };\n    }\n};\nmodule.exports = {\n    Loop: Loop,\n    Done: Done,\n    tailRec: tailRec,\n    tailRecM: tailRecM,\n    tailRecM2: tailRecM2,\n    tailRecM3: tailRecM3,\n    forever: forever,\n    whileJust: whileJust,\n    untilJust: untilJust,\n    functorStep: functorStep,\n    bifunctorStep: bifunctorStep,\n    monadRecIdentity: monadRecIdentity,\n    monadRecEffect: monadRecEffect,\n    monadRecFunction: monadRecFunction,\n    monadRecEither: monadRecEither,\n    monadRecMaybe: monadRecMaybe\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs":
/*!**********************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar callCC = function (dict) {\n    return dict.callCC;\n};\nmodule.exports = {\n    callCC: callCC\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs":
/*!***********************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Effect = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect.purs */ \"./.spago/effect/v3.0.0/src/Effect.purs\");\nvar Effect_Exception = __webpack_require__(/*! ./.spago/exceptions/v5.0.0/src/Effect/Exception.purs */ \"./.spago/exceptions/v5.0.0/src/Effect/Exception.purs\");\nvar throwError = function (dict) {\n    return dict.throwError;\n};\nvar monadThrowMaybe = {\n    throwError: Data_Function[\"const\"](Data_Maybe.Nothing.value),\n    Monad0: function () {\n        return Data_Maybe.monadMaybe;\n    }\n};\nvar monadThrowEither = {\n    throwError: Data_Either.Left.create,\n    Monad0: function () {\n        return Data_Either.monadEither;\n    }\n};\nvar monadThrowEffect = {\n    throwError: Effect_Exception.throwException,\n    Monad0: function () {\n        return Effect.monadEffect;\n    }\n};\nvar monadErrorMaybe = {\n    catchError: function (v) {\n        return function (v1) {\n            if (v instanceof Data_Maybe.Nothing) {\n                return v1(Data_Unit.unit);\n            };\n            if (v instanceof Data_Maybe.Just) {\n                return new Data_Maybe.Just(v.value0);\n            };\n            throw new Error(\"Failed pattern match at Control.Monad.Error.Class (line 79, column 1 - line 81, column 33): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    },\n    MonadThrow0: function () {\n        return monadThrowMaybe;\n    }\n};\nvar monadErrorEither = {\n    catchError: function (v) {\n        return function (v1) {\n            if (v instanceof Data_Either.Left) {\n                return v1(v.value0);\n            };\n            if (v instanceof Data_Either.Right) {\n                return new Data_Either.Right(v.value0);\n            };\n            throw new Error(\"Failed pattern match at Control.Monad.Error.Class (line 72, column 1 - line 74, column 35): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n    },\n    MonadThrow0: function () {\n        return monadThrowEither;\n    }\n};\nvar monadErrorEffect = {\n    catchError: Data_Function.flip(Effect_Exception.catchException),\n    MonadThrow0: function () {\n        return monadThrowEffect;\n    }\n};\nvar liftMaybe = function (dictMonadThrow) {\n    return function (error) {\n        return Data_Maybe.maybe(throwError(dictMonadThrow)(error))(Control_Applicative.pure((dictMonadThrow.Monad0()).Applicative0()));\n    };\n};\nvar liftEither = function (dictMonadThrow) {\n    return Data_Either.either(throwError(dictMonadThrow))(Control_Applicative.pure((dictMonadThrow.Monad0()).Applicative0()));\n};\nvar catchError = function (dict) {\n    return dict.catchError;\n};\nvar catchJust = function (dictMonadError) {\n    return function (p) {\n        return function (act) {\n            return function (handler) {\n                var handle = function (e) {\n                    var v = p(e);\n                    if (v instanceof Data_Maybe.Nothing) {\n                        return throwError(dictMonadError.MonadThrow0())(e);\n                    };\n                    if (v instanceof Data_Maybe.Just) {\n                        return handler(v.value0);\n                    };\n                    throw new Error(\"Failed pattern match at Control.Monad.Error.Class (line 57, column 5 - line 59, column 26): \" + [ v.constructor.name ]);\n                };\n                return catchError(dictMonadError)(act)(handle);\n            };\n        };\n    };\n};\nvar $$try = function (dictMonadError) {\n    return function (a) {\n        return catchError(dictMonadError)(Data_Functor.map(((((dictMonadError.MonadThrow0()).Monad0()).Bind1()).Apply0()).Functor0())(Data_Either.Right.create)(a))((function () {\n            var $21 = Control_Applicative.pure(((dictMonadError.MonadThrow0()).Monad0()).Applicative0());\n            return function ($22) {\n                return $21(Data_Either.Left.create($22));\n            };\n        })());\n    };\n};\nvar withResource = function (dictMonadError) {\n    return function (acquire) {\n        return function (release) {\n            return function (kleisli) {\n                return Control_Bind.bind(((dictMonadError.MonadThrow0()).Monad0()).Bind1())(acquire)(function (resource) {\n                    return Control_Bind.bind(((dictMonadError.MonadThrow0()).Monad0()).Bind1())($$try(dictMonadError)(kleisli(resource)))(function (result) {\n                        return Control_Bind.discard(Control_Bind.discardUnit)(((dictMonadError.MonadThrow0()).Monad0()).Bind1())(release(resource))(function () {\n                            return Data_Either.either(throwError(dictMonadError.MonadThrow0()))(Control_Applicative.pure(((dictMonadError.MonadThrow0()).Monad0()).Applicative0()))(result);\n                        });\n                    });\n                });\n            };\n        };\n    };\n};\nmodule.exports = {\n    catchError: catchError,\n    throwError: throwError,\n    catchJust: catchJust,\n    \"try\": $$try,\n    withResource: withResource,\n    liftMaybe: liftMaybe,\n    liftEither: liftEither,\n    monadThrowEither: monadThrowEither,\n    monadErrorEither: monadErrorEither,\n    monadThrowMaybe: monadThrowMaybe,\n    monadErrorMaybe: monadErrorMaybe,\n    monadThrowEffect: monadThrowEffect,\n    monadErrorEffect: monadErrorEffect\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Except.purs":
/*!******************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Except.purs ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Monad_Error_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs\");\nvar Control_Monad_Except_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar withExcept = Control_Monad_Except_Trans.withExceptT(Data_Identity.functorIdentity);\nvar runExcept = (function () {\n    var $0 = Data_Newtype.unwrap();\n    return function ($1) {\n        return $0(Control_Monad_Except_Trans.runExceptT($1));\n    };\n})();\nvar mapExcept = function (f) {\n    return Control_Monad_Except_Trans.mapExceptT((function () {\n        var $2 = Data_Newtype.unwrap();\n        return function ($3) {\n            return Data_Identity.Identity(f($2($3)));\n        };\n    })());\n};\nmodule.exports = {\n    runExcept: runExcept,\n    mapExcept: mapExcept,\n    withExcept: withExcept,\n    catchError: Control_Monad_Error_Class.catchError,\n    catchJust: Control_Monad_Error_Class.catchJust,\n    throwError: Control_Monad_Error_Class.throwError,\n    ExceptT: Control_Monad_Except_Trans.ExceptT,\n    except: Control_Monad_Except_Trans.except,\n    lift: Control_Monad_Except_Trans.lift,\n    mapExceptT: Control_Monad_Except_Trans.mapExceptT,\n    runExceptT: Control_Monad_Except_Trans.runExceptT,\n    withExceptT: Control_Monad_Except_Trans.withExceptT\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Except.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs":
/*!************************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Control_Monad_Cont_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs\");\nvar Control_Monad_Error_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs\");\nvar Control_Monad_Reader_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Control_Monad_State_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs\");\nvar Control_Monad_Trans_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs\");\nvar Control_Monad_Writer_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Effect_Class = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect/Class.purs */ \"./.spago/effect/v3.0.0/src/Effect/Class.purs\");\nvar ExceptT = function (x) {\n    return x;\n};\nvar withExceptT = function (dictFunctor) {\n    return function (f) {\n        return function (v) {\n            var mapLeft = function (v1) {\n                return function (v2) {\n                    if (v2 instanceof Data_Either.Right) {\n                        return new Data_Either.Right(v2.value0);\n                    };\n                    if (v2 instanceof Data_Either.Left) {\n                        return new Data_Either.Left(v1(v2.value0));\n                    };\n                    throw new Error(\"Failed pattern match at Control.Monad.Except.Trans (line 43, column 3 - line 43, column 32): \" + [ v1.constructor.name, v2.constructor.name ]);\n                };\n            };\n            return ExceptT(Data_Functor.map(dictFunctor)(mapLeft(f))(v));\n        };\n    };\n};\nvar runExceptT = function (v) {\n    return v;\n};\nvar newtypeExceptT = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monadTransExceptT = {\n    lift: function (dictMonad) {\n        return function (m) {\n            return Control_Bind.bind(dictMonad.Bind1())(m)(function (a) {\n                return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Either.Right(a));\n            });\n        };\n    }\n};\nvar mapExceptT = function (f) {\n    return function (v) {\n        return f(v);\n    };\n};\nvar functorExceptT = function (dictFunctor) {\n    return {\n        map: function (f) {\n            return mapExceptT(Data_Functor.map(dictFunctor)(Data_Functor.map(Data_Either.functorEither)(f)));\n        }\n    };\n};\nvar except = function (dictApplicative) {\n    var $89 = Control_Applicative.pure(dictApplicative);\n    return function ($90) {\n        return ExceptT($89($90));\n    };\n};\nvar monadExceptT = function (dictMonad) {\n    return {\n        Applicative0: function () {\n            return applicativeExceptT(dictMonad);\n        },\n        Bind1: function () {\n            return bindExceptT(dictMonad);\n        }\n    };\n};\nvar bindExceptT = function (dictMonad) {\n    return {\n        bind: function (v) {\n            return function (k) {\n                return Control_Bind.bind(dictMonad.Bind1())(v)(Data_Either.either((function () {\n                    var $91 = Control_Applicative.pure(dictMonad.Applicative0());\n                    return function ($92) {\n                        return $91(Data_Either.Left.create($92));\n                    };\n                })())(function (a) {\n                    var v1 = k(a);\n                    return v1;\n                }));\n            };\n        },\n        Apply0: function () {\n            return applyExceptT(dictMonad);\n        }\n    };\n};\nvar applyExceptT = function (dictMonad) {\n    return {\n        apply: Control_Monad.ap(monadExceptT(dictMonad)),\n        Functor0: function () {\n            return functorExceptT(((dictMonad.Bind1()).Apply0()).Functor0());\n        }\n    };\n};\nvar applicativeExceptT = function (dictMonad) {\n    return {\n        pure: (function () {\n            var $93 = Control_Applicative.pure(dictMonad.Applicative0());\n            return function ($94) {\n                return ExceptT($93(Data_Either.Right.create($94)));\n            };\n        })(),\n        Apply0: function () {\n            return applyExceptT(dictMonad);\n        }\n    };\n};\nvar semigroupExceptT = function (dictMonad) {\n    return function (dictSemigroup) {\n        return {\n            append: Control_Apply.lift2(applyExceptT(dictMonad))(Data_Semigroup.append(dictSemigroup))\n        };\n    };\n};\nvar monadAskExceptT = function (dictMonadAsk) {\n    return {\n        ask: Control_Monad_Trans_Class.lift(monadTransExceptT)(dictMonadAsk.Monad0())(Control_Monad_Reader_Class.ask(dictMonadAsk)),\n        Monad0: function () {\n            return monadExceptT(dictMonadAsk.Monad0());\n        }\n    };\n};\nvar monadReaderExceptT = function (dictMonadReader) {\n    return {\n        local: function (f) {\n            return mapExceptT(Control_Monad_Reader_Class.local(dictMonadReader)(f));\n        },\n        MonadAsk0: function () {\n            return monadAskExceptT(dictMonadReader.MonadAsk0());\n        }\n    };\n};\nvar monadContExceptT = function (dictMonadCont) {\n    return {\n        callCC: function (f) {\n            return ExceptT(Control_Monad_Cont_Class.callCC(dictMonadCont)(function (c) {\n                var v = f(function (a) {\n                    return ExceptT(c(new Data_Either.Right(a)));\n                });\n                return v;\n            }));\n        },\n        Monad0: function () {\n            return monadExceptT(dictMonadCont.Monad0());\n        }\n    };\n};\nvar monadEffectExceptT = function (dictMonadEffect) {\n    return {\n        liftEffect: (function () {\n            var $95 = Control_Monad_Trans_Class.lift(monadTransExceptT)(dictMonadEffect.Monad0());\n            var $96 = Effect_Class.liftEffect(dictMonadEffect);\n            return function ($97) {\n                return $95($96($97));\n            };\n        })(),\n        Monad0: function () {\n            return monadExceptT(dictMonadEffect.Monad0());\n        }\n    };\n};\nvar monadRecExceptT = function (dictMonadRec) {\n    return {\n        tailRecM: function (f) {\n            var $98 = Control_Monad_Rec_Class.tailRecM(dictMonadRec)(function (a) {\n                var v = f(a);\n                return Control_Bind.bind((dictMonadRec.Monad0()).Bind1())(v)(function (m$prime) {\n                    return Control_Applicative.pure((dictMonadRec.Monad0()).Applicative0())((function () {\n                        if (m$prime instanceof Data_Either.Left) {\n                            return new Control_Monad_Rec_Class.Done(new Data_Either.Left(m$prime.value0));\n                        };\n                        if (m$prime instanceof Data_Either.Right && m$prime.value0 instanceof Control_Monad_Rec_Class.Loop) {\n                            return new Control_Monad_Rec_Class.Loop(m$prime.value0.value0);\n                        };\n                        if (m$prime instanceof Data_Either.Right && m$prime.value0 instanceof Control_Monad_Rec_Class.Done) {\n                            return new Control_Monad_Rec_Class.Done(new Data_Either.Right(m$prime.value0.value0));\n                        };\n                        throw new Error(\"Failed pattern match at Control.Monad.Except.Trans (line 75, column 14 - line 78, column 43): \" + [ m$prime.constructor.name ]);\n                    })());\n                });\n            });\n            return function ($99) {\n                return ExceptT($98($99));\n            };\n        },\n        Monad0: function () {\n            return monadExceptT(dictMonadRec.Monad0());\n        }\n    };\n};\nvar monadStateExceptT = function (dictMonadState) {\n    return {\n        state: function (f) {\n            return Control_Monad_Trans_Class.lift(monadTransExceptT)(dictMonadState.Monad0())(Control_Monad_State_Class.state(dictMonadState)(f));\n        },\n        Monad0: function () {\n            return monadExceptT(dictMonadState.Monad0());\n        }\n    };\n};\nvar monadTellExceptT = function (dictMonadTell) {\n    return {\n        tell: (function () {\n            var $100 = Control_Monad_Trans_Class.lift(monadTransExceptT)(dictMonadTell.Monad1());\n            var $101 = Control_Monad_Writer_Class.tell(dictMonadTell);\n            return function ($102) {\n                return $100($101($102));\n            };\n        })(),\n        Semigroup0: dictMonadTell.Semigroup0,\n        Monad1: function () {\n            return monadExceptT(dictMonadTell.Monad1());\n        }\n    };\n};\nvar monadWriterExceptT = function (dictMonadWriter) {\n    return {\n        listen: mapExceptT(function (m) {\n            return Control_Bind.bind(((dictMonadWriter.MonadTell1()).Monad1()).Bind1())(Control_Monad_Writer_Class.listen(dictMonadWriter)(m))(function (v) {\n                return Control_Applicative.pure(((dictMonadWriter.MonadTell1()).Monad1()).Applicative0())(Data_Functor.map(Data_Either.functorEither)(function (r) {\n                    return new Data_Tuple.Tuple(r, v.value1);\n                })(v.value0));\n            });\n        }),\n        pass: mapExceptT(function (m) {\n            return Control_Monad_Writer_Class.pass(dictMonadWriter)(Control_Bind.bind(((dictMonadWriter.MonadTell1()).Monad1()).Bind1())(m)(function (a) {\n                return Control_Applicative.pure(((dictMonadWriter.MonadTell1()).Monad1()).Applicative0())((function () {\n                    if (a instanceof Data_Either.Left) {\n                        return new Data_Tuple.Tuple(new Data_Either.Left(a.value0), Control_Category.identity(Control_Category.categoryFn));\n                    };\n                    if (a instanceof Data_Either.Right) {\n                        return new Data_Tuple.Tuple(new Data_Either.Right(a.value0.value0), a.value0.value1);\n                    };\n                    throw new Error(\"Failed pattern match at Control.Monad.Except.Trans (line 137, column 10 - line 139, column 45): \" + [ a.constructor.name ]);\n                })());\n            }));\n        }),\n        Monoid0: dictMonadWriter.Monoid0,\n        MonadTell1: function () {\n            return monadTellExceptT(dictMonadWriter.MonadTell1());\n        }\n    };\n};\nvar monadThrowExceptT = function (dictMonad) {\n    return {\n        throwError: (function () {\n            var $103 = Control_Applicative.pure(dictMonad.Applicative0());\n            return function ($104) {\n                return ExceptT($103(Data_Either.Left.create($104)));\n            };\n        })(),\n        Monad0: function () {\n            return monadExceptT(dictMonad);\n        }\n    };\n};\nvar monadErrorExceptT = function (dictMonad) {\n    return {\n        catchError: function (v) {\n            return function (k) {\n                return Control_Bind.bind(dictMonad.Bind1())(v)(Data_Either.either(function (a) {\n                    var v1 = k(a);\n                    return v1;\n                })((function () {\n                    var $105 = Control_Applicative.pure(dictMonad.Applicative0());\n                    return function ($106) {\n                        return $105(Data_Either.Right.create($106));\n                    };\n                })()));\n            };\n        },\n        MonadThrow0: function () {\n            return monadThrowExceptT(dictMonad);\n        }\n    };\n};\nvar monoidExceptT = function (dictMonad) {\n    return function (dictMonoid) {\n        return {\n            mempty: Control_Applicative.pure(applicativeExceptT(dictMonad))(Data_Monoid.mempty(dictMonoid)),\n            Semigroup0: function () {\n                return semigroupExceptT(dictMonad)(dictMonoid.Semigroup0());\n            }\n        };\n    };\n};\nvar altExceptT = function (dictSemigroup) {\n    return function (dictMonad) {\n        return {\n            alt: function (v) {\n                return function (v1) {\n                    return Control_Bind.bind(dictMonad.Bind1())(v)(function (rm) {\n                        if (rm instanceof Data_Either.Right) {\n                            return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Either.Right(rm.value0));\n                        };\n                        if (rm instanceof Data_Either.Left) {\n                            return Control_Bind.bind(dictMonad.Bind1())(v1)(function (rn) {\n                                if (rn instanceof Data_Either.Right) {\n                                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Either.Right(rn.value0));\n                                };\n                                if (rn instanceof Data_Either.Left) {\n                                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Either.Left(Data_Semigroup.append(dictSemigroup)(rm.value0)(rn.value0)));\n                                };\n                                throw new Error(\"Failed pattern match at Control.Monad.Except.Trans (line 87, column 9 - line 89, column 49): \" + [ rn.constructor.name ]);\n                            });\n                        };\n                        throw new Error(\"Failed pattern match at Control.Monad.Except.Trans (line 83, column 5 - line 89, column 49): \" + [ rm.constructor.name ]);\n                    });\n                };\n            },\n            Functor0: function () {\n                return functorExceptT(((dictMonad.Bind1()).Apply0()).Functor0());\n            }\n        };\n    };\n};\nvar plusExceptT = function (dictMonoid) {\n    return function (dictMonad) {\n        return {\n            empty: Control_Monad_Error_Class.throwError(monadThrowExceptT(dictMonad))(Data_Monoid.mempty(dictMonoid)),\n            Alt0: function () {\n                return altExceptT(dictMonoid.Semigroup0())(dictMonad);\n            }\n        };\n    };\n};\nvar alternativeExceptT = function (dictMonoid) {\n    return function (dictMonad) {\n        return {\n            Applicative0: function () {\n                return applicativeExceptT(dictMonad);\n            },\n            Plus1: function () {\n                return plusExceptT(dictMonoid)(dictMonad);\n            }\n        };\n    };\n};\nvar monadPlusExceptT = function (dictMonoid) {\n    return function (dictMonad) {\n        return {\n            Monad0: function () {\n                return monadExceptT(dictMonad);\n            },\n            Alternative1: function () {\n                return alternativeExceptT(dictMonoid)(dictMonad);\n            }\n        };\n    };\n};\nvar monadZeroExceptT = function (dictMonoid) {\n    return function (dictMonad) {\n        return {\n            Monad0: function () {\n                return monadExceptT(dictMonad);\n            },\n            Alternative1: function () {\n                return alternativeExceptT(dictMonoid)(dictMonad);\n            },\n            MonadZeroIsDeprecated2: function () {\n                return undefined;\n            }\n        };\n    };\n};\nmodule.exports = {\n    ExceptT: ExceptT,\n    runExceptT: runExceptT,\n    withExceptT: withExceptT,\n    mapExceptT: mapExceptT,\n    except: except,\n    newtypeExceptT: newtypeExceptT,\n    functorExceptT: functorExceptT,\n    applyExceptT: applyExceptT,\n    applicativeExceptT: applicativeExceptT,\n    bindExceptT: bindExceptT,\n    monadExceptT: monadExceptT,\n    monadRecExceptT: monadRecExceptT,\n    altExceptT: altExceptT,\n    plusExceptT: plusExceptT,\n    alternativeExceptT: alternativeExceptT,\n    monadPlusExceptT: monadPlusExceptT,\n    monadZeroExceptT: monadZeroExceptT,\n    monadTransExceptT: monadTransExceptT,\n    monadEffectExceptT: monadEffectExceptT,\n    monadContExceptT: monadContExceptT,\n    monadThrowExceptT: monadThrowExceptT,\n    monadErrorExceptT: monadErrorExceptT,\n    monadAskExceptT: monadAskExceptT,\n    monadReaderExceptT: monadReaderExceptT,\n    monadStateExceptT: monadStateExceptT,\n    monadTellExceptT: monadTellExceptT,\n    monadWriterExceptT: monadWriterExceptT,\n    semigroupExceptT: semigroupExceptT,\n    monoidExceptT: monoidExceptT,\n    catchError: Control_Monad_Error_Class.catchError,\n    throwError: Control_Monad_Error_Class.throwError,\n    lift: Control_Monad_Trans_Class.lift\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Maybe/Trans.purs":
/*!***********************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Maybe/Trans.purs ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Control_Monad_Cont_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs\");\nvar Control_Monad_Error_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs\");\nvar Control_Monad_Reader_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Control_Monad_State_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs\");\nvar Control_Monad_Trans_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs\");\nvar Control_Monad_Writer_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Effect_Class = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect/Class.purs */ \"./.spago/effect/v3.0.0/src/Effect/Class.purs\");\nvar MaybeT = function (x) {\n    return x;\n};\nvar runMaybeT = function (v) {\n    return v;\n};\nvar newtypeMaybeT = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monadTransMaybeT = {\n    lift: function (dictMonad) {\n        var $72 = Control_Monad.liftM1(dictMonad)(Data_Maybe.Just.create);\n        return function ($73) {\n            return MaybeT($72($73));\n        };\n    }\n};\nvar mapMaybeT = function (f) {\n    return function (v) {\n        return f(v);\n    };\n};\nvar functorMaybeT = function (dictFunctor) {\n    return {\n        map: function (f) {\n            return function (v) {\n                return Data_Functor.map(dictFunctor)(Data_Functor.map(Data_Maybe.functorMaybe)(f))(v);\n            };\n        }\n    };\n};\nvar monadMaybeT = function (dictMonad) {\n    return {\n        Applicative0: function () {\n            return applicativeMaybeT(dictMonad);\n        },\n        Bind1: function () {\n            return bindMaybeT(dictMonad);\n        }\n    };\n};\nvar bindMaybeT = function (dictMonad) {\n    return {\n        bind: function (v) {\n            return function (f) {\n                return Control_Bind.bind(dictMonad.Bind1())(v)(function (v1) {\n                    if (v1 instanceof Data_Maybe.Nothing) {\n                        return Control_Applicative.pure(dictMonad.Applicative0())(Data_Maybe.Nothing.value);\n                    };\n                    if (v1 instanceof Data_Maybe.Just) {\n                        var v2 = f(v1.value0);\n                        return v2;\n                    };\n                    throw new Error(\"Failed pattern match at Control.Monad.Maybe.Trans (line 55, column 11 - line 57, column 42): \" + [ v1.constructor.name ]);\n                });\n            };\n        },\n        Apply0: function () {\n            return applyMaybeT(dictMonad);\n        }\n    };\n};\nvar applyMaybeT = function (dictMonad) {\n    return {\n        apply: Control_Monad.ap(monadMaybeT(dictMonad)),\n        Functor0: function () {\n            return functorMaybeT(((dictMonad.Bind1()).Apply0()).Functor0());\n        }\n    };\n};\nvar applicativeMaybeT = function (dictMonad) {\n    return {\n        pure: (function () {\n            var $74 = Control_Applicative.pure(dictMonad.Applicative0());\n            return function ($75) {\n                return MaybeT($74(Data_Maybe.Just.create($75)));\n            };\n        })(),\n        Apply0: function () {\n            return applyMaybeT(dictMonad);\n        }\n    };\n};\nvar semigroupMaybeT = function (dictMonad) {\n    return function (dictSemigroup) {\n        return {\n            append: Control_Apply.lift2(applyMaybeT(dictMonad))(Data_Semigroup.append(dictSemigroup))\n        };\n    };\n};\nvar monadAskMaybeT = function (dictMonadAsk) {\n    return {\n        ask: Control_Monad_Trans_Class.lift(monadTransMaybeT)(dictMonadAsk.Monad0())(Control_Monad_Reader_Class.ask(dictMonadAsk)),\n        Monad0: function () {\n            return monadMaybeT(dictMonadAsk.Monad0());\n        }\n    };\n};\nvar monadReaderMaybeT = function (dictMonadReader) {\n    return {\n        local: function (f) {\n            return mapMaybeT(Control_Monad_Reader_Class.local(dictMonadReader)(f));\n        },\n        MonadAsk0: function () {\n            return monadAskMaybeT(dictMonadReader.MonadAsk0());\n        }\n    };\n};\nvar monadContMaybeT = function (dictMonadCont) {\n    return {\n        callCC: function (f) {\n            return MaybeT(Control_Monad_Cont_Class.callCC(dictMonadCont)(function (c) {\n                var v = f(function (a) {\n                    return MaybeT(c(new Data_Maybe.Just(a)));\n                });\n                return v;\n            }));\n        },\n        Monad0: function () {\n            return monadMaybeT(dictMonadCont.Monad0());\n        }\n    };\n};\nvar monadEffectMaybe = function (dictMonadEffect) {\n    return {\n        liftEffect: (function () {\n            var $76 = Control_Monad_Trans_Class.lift(monadTransMaybeT)(dictMonadEffect.Monad0());\n            var $77 = Effect_Class.liftEffect(dictMonadEffect);\n            return function ($78) {\n                return $76($77($78));\n            };\n        })(),\n        Monad0: function () {\n            return monadMaybeT(dictMonadEffect.Monad0());\n        }\n    };\n};\nvar monadRecMaybeT = function (dictMonadRec) {\n    return {\n        tailRecM: function (f) {\n            var $79 = Control_Monad_Rec_Class.tailRecM(dictMonadRec)(function (a) {\n                var v = f(a);\n                return Control_Bind.bind((dictMonadRec.Monad0()).Bind1())(v)(function (m$prime) {\n                    return Control_Applicative.pure((dictMonadRec.Monad0()).Applicative0())((function () {\n                        if (m$prime instanceof Data_Maybe.Nothing) {\n                            return new Control_Monad_Rec_Class.Done(Data_Maybe.Nothing.value);\n                        };\n                        if (m$prime instanceof Data_Maybe.Just && m$prime.value0 instanceof Control_Monad_Rec_Class.Loop) {\n                            return new Control_Monad_Rec_Class.Loop(m$prime.value0.value0);\n                        };\n                        if (m$prime instanceof Data_Maybe.Just && m$prime.value0 instanceof Control_Monad_Rec_Class.Done) {\n                            return new Control_Monad_Rec_Class.Done(new Data_Maybe.Just(m$prime.value0.value0));\n                        };\n                        throw new Error(\"Failed pattern match at Control.Monad.Maybe.Trans (line 85, column 16 - line 88, column 43): \" + [ m$prime.constructor.name ]);\n                    })());\n                });\n            });\n            return function ($80) {\n                return MaybeT($79($80));\n            };\n        },\n        Monad0: function () {\n            return monadMaybeT(dictMonadRec.Monad0());\n        }\n    };\n};\nvar monadStateMaybeT = function (dictMonadState) {\n    return {\n        state: function (f) {\n            return Control_Monad_Trans_Class.lift(monadTransMaybeT)(dictMonadState.Monad0())(Control_Monad_State_Class.state(dictMonadState)(f));\n        },\n        Monad0: function () {\n            return monadMaybeT(dictMonadState.Monad0());\n        }\n    };\n};\nvar monadTellMaybeT = function (dictMonadTell) {\n    return {\n        tell: (function () {\n            var $81 = Control_Monad_Trans_Class.lift(monadTransMaybeT)(dictMonadTell.Monad1());\n            var $82 = Control_Monad_Writer_Class.tell(dictMonadTell);\n            return function ($83) {\n                return $81($82($83));\n            };\n        })(),\n        Semigroup0: dictMonadTell.Semigroup0,\n        Monad1: function () {\n            return monadMaybeT(dictMonadTell.Monad1());\n        }\n    };\n};\nvar monadWriterMaybeT = function (dictMonadWriter) {\n    return {\n        listen: mapMaybeT(function (m) {\n            return Control_Bind.bind(((dictMonadWriter.MonadTell1()).Monad1()).Bind1())(Control_Monad_Writer_Class.listen(dictMonadWriter)(m))(function (v) {\n                return Control_Applicative.pure(((dictMonadWriter.MonadTell1()).Monad1()).Applicative0())(Data_Functor.map(Data_Maybe.functorMaybe)(function (r) {\n                    return new Data_Tuple.Tuple(r, v.value1);\n                })(v.value0));\n            });\n        }),\n        pass: mapMaybeT(function (m) {\n            return Control_Monad_Writer_Class.pass(dictMonadWriter)(Control_Bind.bind(((dictMonadWriter.MonadTell1()).Monad1()).Bind1())(m)(function (a) {\n                return Control_Applicative.pure(((dictMonadWriter.MonadTell1()).Monad1()).Applicative0())((function () {\n                    if (a instanceof Data_Maybe.Nothing) {\n                        return new Data_Tuple.Tuple(Data_Maybe.Nothing.value, Control_Category.identity(Control_Category.categoryFn));\n                    };\n                    if (a instanceof Data_Maybe.Just) {\n                        return new Data_Tuple.Tuple(new Data_Maybe.Just(a.value0.value0), a.value0.value1);\n                    };\n                    throw new Error(\"Failed pattern match at Control.Monad.Maybe.Trans (line 122, column 10 - line 124, column 43): \" + [ a.constructor.name ]);\n                })());\n            }));\n        }),\n        Monoid0: dictMonadWriter.Monoid0,\n        MonadTell1: function () {\n            return monadTellMaybeT(dictMonadWriter.MonadTell1());\n        }\n    };\n};\nvar monadThrowMaybeT = function (dictMonadThrow) {\n    return {\n        throwError: function (e) {\n            return Control_Monad_Trans_Class.lift(monadTransMaybeT)(dictMonadThrow.Monad0())(Control_Monad_Error_Class.throwError(dictMonadThrow)(e));\n        },\n        Monad0: function () {\n            return monadMaybeT(dictMonadThrow.Monad0());\n        }\n    };\n};\nvar monadErrorMaybeT = function (dictMonadError) {\n    return {\n        catchError: function (v) {\n            return function (h) {\n                return MaybeT(Control_Monad_Error_Class.catchError(dictMonadError)(v)(function (a) {\n                    var v1 = h(a);\n                    return v1;\n                }));\n            };\n        },\n        MonadThrow0: function () {\n            return monadThrowMaybeT(dictMonadError.MonadThrow0());\n        }\n    };\n};\nvar monoidMaybeT = function (dictMonad) {\n    return function (dictMonoid) {\n        return {\n            mempty: Control_Applicative.pure(applicativeMaybeT(dictMonad))(Data_Monoid.mempty(dictMonoid)),\n            Semigroup0: function () {\n                return semigroupMaybeT(dictMonad)(dictMonoid.Semigroup0());\n            }\n        };\n    };\n};\nvar altMaybeT = function (dictMonad) {\n    return {\n        alt: function (v) {\n            return function (v1) {\n                return Control_Bind.bind(dictMonad.Bind1())(v)(function (m) {\n                    if (m instanceof Data_Maybe.Nothing) {\n                        return v1;\n                    };\n                    return Control_Applicative.pure(dictMonad.Applicative0())(m);\n                });\n            };\n        },\n        Functor0: function () {\n            return functorMaybeT(((dictMonad.Bind1()).Apply0()).Functor0());\n        }\n    };\n};\nvar plusMaybeT = function (dictMonad) {\n    return {\n        empty: Control_Applicative.pure(dictMonad.Applicative0())(Data_Maybe.Nothing.value),\n        Alt0: function () {\n            return altMaybeT(dictMonad);\n        }\n    };\n};\nvar alternativeMaybeT = function (dictMonad) {\n    return {\n        Applicative0: function () {\n            return applicativeMaybeT(dictMonad);\n        },\n        Plus1: function () {\n            return plusMaybeT(dictMonad);\n        }\n    };\n};\nvar monadPlusMaybeT = function (dictMonad) {\n    return {\n        Monad0: function () {\n            return monadMaybeT(dictMonad);\n        },\n        Alternative1: function () {\n            return alternativeMaybeT(dictMonad);\n        }\n    };\n};\nvar monadZeroMaybeT = function (dictMonad) {\n    return {\n        Monad0: function () {\n            return monadMaybeT(dictMonad);\n        },\n        Alternative1: function () {\n            return alternativeMaybeT(dictMonad);\n        },\n        MonadZeroIsDeprecated2: function () {\n            return undefined;\n        }\n    };\n};\nmodule.exports = {\n    MaybeT: MaybeT,\n    runMaybeT: runMaybeT,\n    mapMaybeT: mapMaybeT,\n    newtypeMaybeT: newtypeMaybeT,\n    functorMaybeT: functorMaybeT,\n    applyMaybeT: applyMaybeT,\n    applicativeMaybeT: applicativeMaybeT,\n    bindMaybeT: bindMaybeT,\n    monadMaybeT: monadMaybeT,\n    monadTransMaybeT: monadTransMaybeT,\n    altMaybeT: altMaybeT,\n    plusMaybeT: plusMaybeT,\n    alternativeMaybeT: alternativeMaybeT,\n    monadPlusMaybeT: monadPlusMaybeT,\n    monadZeroMaybeT: monadZeroMaybeT,\n    monadRecMaybeT: monadRecMaybeT,\n    monadEffectMaybe: monadEffectMaybe,\n    monadContMaybeT: monadContMaybeT,\n    monadThrowMaybeT: monadThrowMaybeT,\n    monadErrorMaybeT: monadErrorMaybeT,\n    monadAskMaybeT: monadAskMaybeT,\n    monadReaderMaybeT: monadReaderMaybeT,\n    monadStateMaybeT: monadStateMaybeT,\n    monadTellMaybeT: monadTellMaybeT,\n    monadWriterMaybeT: monadWriterMaybeT,\n    semigroupMaybeT: semigroupMaybeT,\n    monoidMaybeT: monoidMaybeT,\n    lift: Control_Monad_Trans_Class.lift\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Maybe/Trans.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Reader.purs":
/*!******************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Reader.purs ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Monad_Reader_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs\");\nvar Control_Monad_Reader_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar withReader = Control_Monad_Reader_Trans.withReaderT;\nvar runReader = function (v) {\n    var $2 = Data_Newtype.unwrap();\n    return function ($3) {\n        return $2(v($3));\n    };\n};\nvar mapReader = function (f) {\n    return Control_Monad_Reader_Trans.mapReaderT((function () {\n        var $4 = Data_Newtype.unwrap();\n        return function ($5) {\n            return Data_Identity.Identity(f($4($5)));\n        };\n    })());\n};\nmodule.exports = {\n    runReader: runReader,\n    mapReader: mapReader,\n    withReader: withReader,\n    ask: Control_Monad_Reader_Class.ask,\n    asks: Control_Monad_Reader_Class.asks,\n    local: Control_Monad_Reader_Class.local,\n    ReaderT: Control_Monad_Reader_Trans.ReaderT,\n    lift: Control_Monad_Reader_Trans.lift,\n    mapReaderT: Control_Monad_Reader_Trans.mapReaderT,\n    runReaderT: Control_Monad_Reader_Trans.runReaderT,\n    withReaderT: Control_Monad_Reader_Trans.withReaderT\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Reader.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs":
/*!************************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Control_Semigroupoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs */ \"./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar monadAskFun = {\n    ask: Control_Category.identity(Control_Category.categoryFn),\n    Monad0: function () {\n        return Control_Monad.monadFn;\n    }\n};\nvar monadReaderFun = {\n    local: Control_Semigroupoid.composeFlipped(Control_Semigroupoid.semigroupoidFn),\n    MonadAsk0: function () {\n        return monadAskFun;\n    }\n};\nvar local = function (dict) {\n    return dict.local;\n};\nvar ask = function (dict) {\n    return dict.ask;\n};\nvar asks = function (dictMonadAsk) {\n    return function (f) {\n        return Data_Functor.map((((dictMonadAsk.Monad0()).Bind1()).Apply0()).Functor0())(f)(ask(dictMonadAsk));\n    };\n};\nmodule.exports = {\n    ask: ask,\n    local: local,\n    asks: asks,\n    monadAskFun: monadAskFun,\n    monadReaderFun: monadReaderFun\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs":
/*!************************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_Cont_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs\");\nvar Control_Monad_Error_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs\");\nvar Control_Monad_Reader_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Control_Monad_State_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs\");\nvar Control_Monad_Trans_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs\");\nvar Control_Monad_Writer_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs\");\nvar Control_Plus = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Plus.purs */ \"./.spago/control/v5.0.0/src/Control/Plus.purs\");\nvar Data_Distributive = __webpack_require__(/*! ./.spago/distributive/v5.0.0/src/Data/Distributive.purs */ \"./.spago/distributive/v5.0.0/src/Data/Distributive.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Effect_Class = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect/Class.purs */ \"./.spago/effect/v3.0.0/src/Effect/Class.purs\");\nvar ReaderT = function (x) {\n    return x;\n};\nvar withReaderT = function (f) {\n    return function (v) {\n        return function ($63) {\n            return v(f($63));\n        };\n    };\n};\nvar runReaderT = function (v) {\n    return v;\n};\nvar newtypeReaderT = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monadTransReaderT = {\n    lift: function (dictMonad) {\n        return function ($64) {\n            return ReaderT(Data_Function[\"const\"]($64));\n        };\n    }\n};\nvar mapReaderT = function (f) {\n    return function (v) {\n        return function ($65) {\n            return f(v($65));\n        };\n    };\n};\nvar functorReaderT = function (dictFunctor) {\n    return {\n        map: (function () {\n            var $66 = Data_Functor.map(dictFunctor);\n            return function ($67) {\n                return mapReaderT($66($67));\n            };\n        })()\n    };\n};\nvar distributiveReaderT = function (dictDistributive) {\n    return {\n        distribute: function (dictFunctor) {\n            return function (a) {\n                return function (e) {\n                    return Data_Distributive.collect(dictDistributive)(dictFunctor)(function (r) {\n                        return r(e);\n                    })(a);\n                };\n            };\n        },\n        collect: function (dictFunctor) {\n            return function (f) {\n                var $68 = Data_Distributive.distribute(distributiveReaderT(dictDistributive))(dictFunctor);\n                var $69 = Data_Functor.map(dictFunctor)(f);\n                return function ($70) {\n                    return $68($69($70));\n                };\n            };\n        },\n        Functor0: function () {\n            return functorReaderT(dictDistributive.Functor0());\n        }\n    };\n};\nvar applyReaderT = function (dictApply) {\n    return {\n        apply: function (v) {\n            return function (v1) {\n                return function (r) {\n                    return Control_Apply.apply(dictApply)(v(r))(v1(r));\n                };\n            };\n        },\n        Functor0: function () {\n            return functorReaderT(dictApply.Functor0());\n        }\n    };\n};\nvar bindReaderT = function (dictBind) {\n    return {\n        bind: function (v) {\n            return function (k) {\n                return function (r) {\n                    return Control_Bind.bind(dictBind)(v(r))(function (a) {\n                        var v1 = k(a);\n                        return v1(r);\n                    });\n                };\n            };\n        },\n        Apply0: function () {\n            return applyReaderT(dictBind.Apply0());\n        }\n    };\n};\nvar semigroupReaderT = function (dictApply) {\n    return function (dictSemigroup) {\n        return {\n            append: Control_Apply.lift2(applyReaderT(dictApply))(Data_Semigroup.append(dictSemigroup))\n        };\n    };\n};\nvar applicativeReaderT = function (dictApplicative) {\n    return {\n        pure: (function () {\n            var $71 = Control_Applicative.pure(dictApplicative);\n            return function ($72) {\n                return ReaderT(Data_Function[\"const\"]($71($72)));\n            };\n        })(),\n        Apply0: function () {\n            return applyReaderT(dictApplicative.Apply0());\n        }\n    };\n};\nvar monadReaderT = function (dictMonad) {\n    return {\n        Applicative0: function () {\n            return applicativeReaderT(dictMonad.Applicative0());\n        },\n        Bind1: function () {\n            return bindReaderT(dictMonad.Bind1());\n        }\n    };\n};\nvar monadAskReaderT = function (dictMonad) {\n    return {\n        ask: Control_Applicative.pure(dictMonad.Applicative0()),\n        Monad0: function () {\n            return monadReaderT(dictMonad);\n        }\n    };\n};\nvar monadReaderReaderT = function (dictMonad) {\n    return {\n        local: withReaderT,\n        MonadAsk0: function () {\n            return monadAskReaderT(dictMonad);\n        }\n    };\n};\nvar monadContReaderT = function (dictMonadCont) {\n    return {\n        callCC: function (f) {\n            return function (r) {\n                return Control_Monad_Cont_Class.callCC(dictMonadCont)(function (c) {\n                    var v = f(function ($73) {\n                        return ReaderT(Data_Function[\"const\"](c($73)));\n                    });\n                    return v(r);\n                });\n            };\n        },\n        Monad0: function () {\n            return monadReaderT(dictMonadCont.Monad0());\n        }\n    };\n};\nvar monadEffectReader = function (dictMonadEffect) {\n    return {\n        liftEffect: (function () {\n            var $74 = Control_Monad_Trans_Class.lift(monadTransReaderT)(dictMonadEffect.Monad0());\n            var $75 = Effect_Class.liftEffect(dictMonadEffect);\n            return function ($76) {\n                return $74($75($76));\n            };\n        })(),\n        Monad0: function () {\n            return monadReaderT(dictMonadEffect.Monad0());\n        }\n    };\n};\nvar monadRecReaderT = function (dictMonadRec) {\n    return {\n        tailRecM: function (k) {\n            return function (a) {\n                var k$prime = function (r) {\n                    return function (a$prime) {\n                        var v = k(a$prime);\n                        return Control_Bind.bindFlipped((dictMonadRec.Monad0()).Bind1())(Control_Applicative.pure((dictMonadRec.Monad0()).Applicative0()))(v(r));\n                    };\n                };\n                return function (r) {\n                    return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(k$prime(r))(a);\n                };\n            };\n        },\n        Monad0: function () {\n            return monadReaderT(dictMonadRec.Monad0());\n        }\n    };\n};\nvar monadStateReaderT = function (dictMonadState) {\n    return {\n        state: (function () {\n            var $77 = Control_Monad_Trans_Class.lift(monadTransReaderT)(dictMonadState.Monad0());\n            var $78 = Control_Monad_State_Class.state(dictMonadState);\n            return function ($79) {\n                return $77($78($79));\n            };\n        })(),\n        Monad0: function () {\n            return monadReaderT(dictMonadState.Monad0());\n        }\n    };\n};\nvar monadTellReaderT = function (dictMonadTell) {\n    return {\n        tell: (function () {\n            var $80 = Control_Monad_Trans_Class.lift(monadTransReaderT)(dictMonadTell.Monad1());\n            var $81 = Control_Monad_Writer_Class.tell(dictMonadTell);\n            return function ($82) {\n                return $80($81($82));\n            };\n        })(),\n        Semigroup0: dictMonadTell.Semigroup0,\n        Monad1: function () {\n            return monadReaderT(dictMonadTell.Monad1());\n        }\n    };\n};\nvar monadWriterReaderT = function (dictMonadWriter) {\n    return {\n        listen: mapReaderT(Control_Monad_Writer_Class.listen(dictMonadWriter)),\n        pass: mapReaderT(Control_Monad_Writer_Class.pass(dictMonadWriter)),\n        Monoid0: dictMonadWriter.Monoid0,\n        MonadTell1: function () {\n            return monadTellReaderT(dictMonadWriter.MonadTell1());\n        }\n    };\n};\nvar monadThrowReaderT = function (dictMonadThrow) {\n    return {\n        throwError: (function () {\n            var $83 = Control_Monad_Trans_Class.lift(monadTransReaderT)(dictMonadThrow.Monad0());\n            var $84 = Control_Monad_Error_Class.throwError(dictMonadThrow);\n            return function ($85) {\n                return $83($84($85));\n            };\n        })(),\n        Monad0: function () {\n            return monadReaderT(dictMonadThrow.Monad0());\n        }\n    };\n};\nvar monadErrorReaderT = function (dictMonadError) {\n    return {\n        catchError: function (v) {\n            return function (h) {\n                return function (r) {\n                    return Control_Monad_Error_Class.catchError(dictMonadError)(v(r))(function (e) {\n                        var v1 = h(e);\n                        return v1(r);\n                    });\n                };\n            };\n        },\n        MonadThrow0: function () {\n            return monadThrowReaderT(dictMonadError.MonadThrow0());\n        }\n    };\n};\nvar monoidReaderT = function (dictApplicative) {\n    return function (dictMonoid) {\n        return {\n            mempty: Control_Applicative.pure(applicativeReaderT(dictApplicative))(Data_Monoid.mempty(dictMonoid)),\n            Semigroup0: function () {\n                return semigroupReaderT(dictApplicative.Apply0())(dictMonoid.Semigroup0());\n            }\n        };\n    };\n};\nvar altReaderT = function (dictAlt) {\n    return {\n        alt: function (v) {\n            return function (v1) {\n                return function (r) {\n                    return Control_Alt.alt(dictAlt)(v(r))(v1(r));\n                };\n            };\n        },\n        Functor0: function () {\n            return functorReaderT(dictAlt.Functor0());\n        }\n    };\n};\nvar plusReaderT = function (dictPlus) {\n    return {\n        empty: Data_Function[\"const\"](Control_Plus.empty(dictPlus)),\n        Alt0: function () {\n            return altReaderT(dictPlus.Alt0());\n        }\n    };\n};\nvar alternativeReaderT = function (dictAlternative) {\n    return {\n        Applicative0: function () {\n            return applicativeReaderT(dictAlternative.Applicative0());\n        },\n        Plus1: function () {\n            return plusReaderT(dictAlternative.Plus1());\n        }\n    };\n};\nvar monadPlusReaderT = function (dictMonadPlus) {\n    return {\n        Monad0: function () {\n            return monadReaderT(dictMonadPlus.Monad0());\n        },\n        Alternative1: function () {\n            return alternativeReaderT(dictMonadPlus.Alternative1());\n        }\n    };\n};\nvar monadZeroReaderT = function (dictMonadZero) {\n    return {\n        Monad0: function () {\n            return monadReaderT(dictMonadZero.Monad0());\n        },\n        Alternative1: function () {\n            return alternativeReaderT(dictMonadZero.Alternative1());\n        },\n        MonadZeroIsDeprecated2: function () {\n            return undefined;\n        }\n    };\n};\nmodule.exports = {\n    ReaderT: ReaderT,\n    runReaderT: runReaderT,\n    withReaderT: withReaderT,\n    mapReaderT: mapReaderT,\n    newtypeReaderT: newtypeReaderT,\n    functorReaderT: functorReaderT,\n    applyReaderT: applyReaderT,\n    applicativeReaderT: applicativeReaderT,\n    altReaderT: altReaderT,\n    plusReaderT: plusReaderT,\n    alternativeReaderT: alternativeReaderT,\n    bindReaderT: bindReaderT,\n    monadReaderT: monadReaderT,\n    monadZeroReaderT: monadZeroReaderT,\n    semigroupReaderT: semigroupReaderT,\n    monoidReaderT: monoidReaderT,\n    monadPlusReaderT: monadPlusReaderT,\n    monadTransReaderT: monadTransReaderT,\n    monadEffectReader: monadEffectReader,\n    monadContReaderT: monadContReaderT,\n    monadThrowReaderT: monadThrowReaderT,\n    monadErrorReaderT: monadErrorReaderT,\n    monadAskReaderT: monadAskReaderT,\n    monadReaderReaderT: monadReaderReaderT,\n    monadStateReaderT: monadStateReaderT,\n    monadTellReaderT: monadTellReaderT,\n    monadWriterReaderT: monadWriterReaderT,\n    distributiveReaderT: distributiveReaderT,\n    monadRecReaderT: monadRecReaderT,\n    ask: Control_Monad_Reader_Class.ask,\n    asks: Control_Monad_Reader_Class.asks,\n    local: Control_Monad_Reader_Class.local,\n    lift: Control_Monad_Trans_Class.lift\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs":
/*!***********************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar state = function (dict) {\n    return dict.state;\n};\nvar put = function (dictMonadState) {\n    return function (s) {\n        return state(dictMonadState)(function (v) {\n            return new Data_Tuple.Tuple(Data_Unit.unit, s);\n        });\n    };\n};\nvar modify_ = function (dictMonadState) {\n    return function (f) {\n        return state(dictMonadState)(function (s) {\n            return new Data_Tuple.Tuple(Data_Unit.unit, f(s));\n        });\n    };\n};\nvar modify = function (dictMonadState) {\n    return function (f) {\n        return state(dictMonadState)(function (s) {\n            var s$prime = f(s);\n            return new Data_Tuple.Tuple(s$prime, s$prime);\n        });\n    };\n};\nvar gets = function (dictMonadState) {\n    return function (f) {\n        return state(dictMonadState)(function (s) {\n            return new Data_Tuple.Tuple(f(s), s);\n        });\n    };\n};\nvar get = function (dictMonadState) {\n    return state(dictMonadState)(function (s) {\n        return new Data_Tuple.Tuple(s, s);\n    });\n};\nmodule.exports = {\n    state: state,\n    get: get,\n    gets: gets,\n    put: put,\n    modify: modify,\n    modify_: modify_\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/State/Trans.purs":
/*!***********************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/State/Trans.purs ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Monad.purs */ \"./.spago/prelude/v5.0.1/src/Control/Monad.purs\");\nvar Control_Monad_Cont_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs\");\nvar Control_Monad_Error_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs\");\nvar Control_Monad_Reader_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Control_Monad_State_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs\");\nvar Control_Monad_Trans_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs\");\nvar Control_Monad_Writer_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs\");\nvar Control_Plus = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Plus.purs */ \"./.spago/control/v5.0.0/src/Control/Plus.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Effect_Class = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect/Class.purs */ \"./.spago/effect/v3.0.0/src/Effect/Class.purs\");\nvar StateT = function (x) {\n    return x;\n};\nvar withStateT = function (f) {\n    return function (v) {\n        return function ($106) {\n            return v(f($106));\n        };\n    };\n};\nvar runStateT = function (v) {\n    return v;\n};\nvar newtypeStateT = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monadTransStateT = {\n    lift: function (dictMonad) {\n        return function (m) {\n            return function (s) {\n                return Control_Bind.bind(dictMonad.Bind1())(m)(function (x) {\n                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(x, s));\n                });\n            };\n        };\n    }\n};\nvar mapStateT = function (f) {\n    return function (v) {\n        return function ($107) {\n            return f(v($107));\n        };\n    };\n};\nvar lazyStateT = {\n    defer: function (f) {\n        return function (s) {\n            var v = f(Data_Unit.unit);\n            return v(s);\n        };\n    }\n};\nvar functorStateT = function (dictFunctor) {\n    return {\n        map: function (f) {\n            return function (v) {\n                return function (s) {\n                    return Data_Functor.map(dictFunctor)(function (v1) {\n                        return new Data_Tuple.Tuple(f(v1.value0), v1.value1);\n                    })(v(s));\n                };\n            };\n        }\n    };\n};\nvar execStateT = function (dictFunctor) {\n    return function (v) {\n        return function (s) {\n            return Data_Functor.map(dictFunctor)(Data_Tuple.snd)(v(s));\n        };\n    };\n};\nvar evalStateT = function (dictFunctor) {\n    return function (v) {\n        return function (s) {\n            return Data_Functor.map(dictFunctor)(Data_Tuple.fst)(v(s));\n        };\n    };\n};\nvar monadStateT = function (dictMonad) {\n    return {\n        Applicative0: function () {\n            return applicativeStateT(dictMonad);\n        },\n        Bind1: function () {\n            return bindStateT(dictMonad);\n        }\n    };\n};\nvar bindStateT = function (dictMonad) {\n    return {\n        bind: function (v) {\n            return function (f) {\n                return function (s) {\n                    return Control_Bind.bind(dictMonad.Bind1())(v(s))(function (v1) {\n                        var v3 = f(v1.value0);\n                        return v3(v1.value1);\n                    });\n                };\n            };\n        },\n        Apply0: function () {\n            return applyStateT(dictMonad);\n        }\n    };\n};\nvar applyStateT = function (dictMonad) {\n    return {\n        apply: Control_Monad.ap(monadStateT(dictMonad)),\n        Functor0: function () {\n            return functorStateT(((dictMonad.Bind1()).Apply0()).Functor0());\n        }\n    };\n};\nvar applicativeStateT = function (dictMonad) {\n    return {\n        pure: function (a) {\n            return function (s) {\n                return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(a, s));\n            };\n        },\n        Apply0: function () {\n            return applyStateT(dictMonad);\n        }\n    };\n};\nvar semigroupStateT = function (dictMonad) {\n    return function (dictSemigroup) {\n        return {\n            append: Control_Apply.lift2(applyStateT(dictMonad))(Data_Semigroup.append(dictSemigroup))\n        };\n    };\n};\nvar monadAskStateT = function (dictMonadAsk) {\n    return {\n        ask: Control_Monad_Trans_Class.lift(monadTransStateT)(dictMonadAsk.Monad0())(Control_Monad_Reader_Class.ask(dictMonadAsk)),\n        Monad0: function () {\n            return monadStateT(dictMonadAsk.Monad0());\n        }\n    };\n};\nvar monadReaderStateT = function (dictMonadReader) {\n    return {\n        local: (function () {\n            var $108 = Control_Monad_Reader_Class.local(dictMonadReader);\n            return function ($109) {\n                return mapStateT($108($109));\n            };\n        })(),\n        MonadAsk0: function () {\n            return monadAskStateT(dictMonadReader.MonadAsk0());\n        }\n    };\n};\nvar monadContStateT = function (dictMonadCont) {\n    return {\n        callCC: function (f) {\n            return function (s) {\n                return Control_Monad_Cont_Class.callCC(dictMonadCont)(function (c) {\n                    var v = f(function (a) {\n                        return function (s$prime) {\n                            return c(new Data_Tuple.Tuple(a, s$prime));\n                        };\n                    });\n                    return v(s);\n                });\n            };\n        },\n        Monad0: function () {\n            return monadStateT(dictMonadCont.Monad0());\n        }\n    };\n};\nvar monadEffectState = function (dictMonadEffect) {\n    return {\n        liftEffect: (function () {\n            var $110 = Control_Monad_Trans_Class.lift(monadTransStateT)(dictMonadEffect.Monad0());\n            var $111 = Effect_Class.liftEffect(dictMonadEffect);\n            return function ($112) {\n                return $110($111($112));\n            };\n        })(),\n        Monad0: function () {\n            return monadStateT(dictMonadEffect.Monad0());\n        }\n    };\n};\nvar monadRecStateT = function (dictMonadRec) {\n    return {\n        tailRecM: function (f) {\n            return function (a) {\n                var f$prime = function (v) {\n                    var v1 = f(v.value0);\n                    return Control_Bind.bind((dictMonadRec.Monad0()).Bind1())(v1(v.value1))(function (v2) {\n                        return Control_Applicative.pure((dictMonadRec.Monad0()).Applicative0())((function () {\n                            if (v2.value0 instanceof Control_Monad_Rec_Class.Loop) {\n                                return new Control_Monad_Rec_Class.Loop(new Data_Tuple.Tuple(v2.value0.value0, v2.value1));\n                            };\n                            if (v2.value0 instanceof Control_Monad_Rec_Class.Done) {\n                                return new Control_Monad_Rec_Class.Done(new Data_Tuple.Tuple(v2.value0.value0, v2.value1));\n                            };\n                            throw new Error(\"Failed pattern match at Control.Monad.State.Trans (line 88, column 16 - line 90, column 40): \" + [ v2.value0.constructor.name ]);\n                        })());\n                    });\n                };\n                return function (s) {\n                    return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(f$prime)(new Data_Tuple.Tuple(a, s));\n                };\n            };\n        },\n        Monad0: function () {\n            return monadStateT(dictMonadRec.Monad0());\n        }\n    };\n};\nvar monadStateStateT = function (dictMonad) {\n    return {\n        state: function (f) {\n            return StateT((function () {\n                var $113 = Control_Applicative.pure(dictMonad.Applicative0());\n                return function ($114) {\n                    return $113(f($114));\n                };\n            })());\n        },\n        Monad0: function () {\n            return monadStateT(dictMonad);\n        }\n    };\n};\nvar monadTellStateT = function (dictMonadTell) {\n    return {\n        tell: (function () {\n            var $115 = Control_Monad_Trans_Class.lift(monadTransStateT)(dictMonadTell.Monad1());\n            var $116 = Control_Monad_Writer_Class.tell(dictMonadTell);\n            return function ($117) {\n                return $115($116($117));\n            };\n        })(),\n        Semigroup0: dictMonadTell.Semigroup0,\n        Monad1: function () {\n            return monadStateT(dictMonadTell.Monad1());\n        }\n    };\n};\nvar monadWriterStateT = function (dictMonadWriter) {\n    return {\n        listen: function (m) {\n            return function (s) {\n                return Control_Bind.bind(((dictMonadWriter.MonadTell1()).Monad1()).Bind1())(Control_Monad_Writer_Class.listen(dictMonadWriter)(m(s)))(function (v) {\n                    return Control_Applicative.pure(((dictMonadWriter.MonadTell1()).Monad1()).Applicative0())(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value0, v.value1), v.value0.value1));\n                });\n            };\n        },\n        pass: function (m) {\n            return function (s) {\n                return Control_Monad_Writer_Class.pass(dictMonadWriter)(Control_Bind.bind(((dictMonadWriter.MonadTell1()).Monad1()).Bind1())(m(s))(function (v) {\n                    return Control_Applicative.pure(((dictMonadWriter.MonadTell1()).Monad1()).Applicative0())(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value0, v.value1), v.value0.value1));\n                }));\n            };\n        },\n        Monoid0: dictMonadWriter.Monoid0,\n        MonadTell1: function () {\n            return monadTellStateT(dictMonadWriter.MonadTell1());\n        }\n    };\n};\nvar monadThrowStateT = function (dictMonadThrow) {\n    return {\n        throwError: function (e) {\n            return Control_Monad_Trans_Class.lift(monadTransStateT)(dictMonadThrow.Monad0())(Control_Monad_Error_Class.throwError(dictMonadThrow)(e));\n        },\n        Monad0: function () {\n            return monadStateT(dictMonadThrow.Monad0());\n        }\n    };\n};\nvar monadErrorStateT = function (dictMonadError) {\n    return {\n        catchError: function (v) {\n            return function (h) {\n                return function (s) {\n                    return Control_Monad_Error_Class.catchError(dictMonadError)(v(s))(function (e) {\n                        var v1 = h(e);\n                        return v1(s);\n                    });\n                };\n            };\n        },\n        MonadThrow0: function () {\n            return monadThrowStateT(dictMonadError.MonadThrow0());\n        }\n    };\n};\nvar monoidStateT = function (dictMonad) {\n    return function (dictMonoid) {\n        return {\n            mempty: Control_Applicative.pure(applicativeStateT(dictMonad))(Data_Monoid.mempty(dictMonoid)),\n            Semigroup0: function () {\n                return semigroupStateT(dictMonad)(dictMonoid.Semigroup0());\n            }\n        };\n    };\n};\nvar altStateT = function (dictMonad) {\n    return function (dictAlt) {\n        return {\n            alt: function (v) {\n                return function (v1) {\n                    return function (s) {\n                        return Control_Alt.alt(dictAlt)(v(s))(v1(s));\n                    };\n                };\n            },\n            Functor0: function () {\n                return functorStateT(dictAlt.Functor0());\n            }\n        };\n    };\n};\nvar plusStateT = function (dictMonad) {\n    return function (dictPlus) {\n        return {\n            empty: function (v) {\n                return Control_Plus.empty(dictPlus);\n            },\n            Alt0: function () {\n                return altStateT(dictMonad)(dictPlus.Alt0());\n            }\n        };\n    };\n};\nvar alternativeStateT = function (dictMonad) {\n    return function (dictAlternative) {\n        return {\n            Applicative0: function () {\n                return applicativeStateT(dictMonad);\n            },\n            Plus1: function () {\n                return plusStateT(dictMonad)(dictAlternative.Plus1());\n            }\n        };\n    };\n};\nvar monadPlusStateT = function (dictMonadPlus) {\n    return {\n        Monad0: function () {\n            return monadStateT(dictMonadPlus.Monad0());\n        },\n        Alternative1: function () {\n            return alternativeStateT(dictMonadPlus.Monad0())(dictMonadPlus.Alternative1());\n        }\n    };\n};\nvar monadZeroStateT = function (dictMonadZero) {\n    return {\n        Monad0: function () {\n            return monadStateT(dictMonadZero.Monad0());\n        },\n        Alternative1: function () {\n            return alternativeStateT(dictMonadZero.Monad0())(dictMonadZero.Alternative1());\n        },\n        MonadZeroIsDeprecated2: function () {\n            return undefined;\n        }\n    };\n};\nmodule.exports = {\n    StateT: StateT,\n    runStateT: runStateT,\n    evalStateT: evalStateT,\n    execStateT: execStateT,\n    mapStateT: mapStateT,\n    withStateT: withStateT,\n    newtypeStateT: newtypeStateT,\n    functorStateT: functorStateT,\n    applyStateT: applyStateT,\n    applicativeStateT: applicativeStateT,\n    altStateT: altStateT,\n    plusStateT: plusStateT,\n    alternativeStateT: alternativeStateT,\n    bindStateT: bindStateT,\n    monadStateT: monadStateT,\n    monadRecStateT: monadRecStateT,\n    monadZeroStateT: monadZeroStateT,\n    monadPlusStateT: monadPlusStateT,\n    monadTransStateT: monadTransStateT,\n    lazyStateT: lazyStateT,\n    monadEffectState: monadEffectState,\n    monadContStateT: monadContStateT,\n    monadThrowStateT: monadThrowStateT,\n    monadErrorStateT: monadErrorStateT,\n    monadAskStateT: monadAskStateT,\n    monadReaderStateT: monadReaderStateT,\n    monadStateStateT: monadStateStateT,\n    monadTellStateT: monadTellStateT,\n    monadWriterStateT: monadWriterStateT,\n    semigroupStateT: semigroupStateT,\n    monoidStateT: monoidStateT,\n    get: Control_Monad_State_Class.get,\n    gets: Control_Monad_State_Class.gets,\n    modify: Control_Monad_State_Class.modify,\n    modify_: Control_Monad_State_Class.modify_,\n    put: Control_Monad_State_Class.put,\n    state: Control_Monad_State_Class.state,\n    lift: Control_Monad_Trans_Class.lift\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/State/Trans.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs":
/*!***********************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar lift = function (dict) {\n    return dict.lift;\n};\nmodule.exports = {\n    lift: lift\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Writer.purs":
/*!******************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Writer.purs ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Monad_Writer_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs\");\nvar Control_Monad_Writer_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Trans.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar writer = (function () {\n    var $0 = Control_Applicative.pure(Data_Identity.applicativeIdentity);\n    return function ($1) {\n        return Control_Monad_Writer_Trans.WriterT($0($1));\n    };\n})();\nvar runWriter = (function () {\n    var $2 = Data_Newtype.unwrap();\n    return function ($3) {\n        return $2(Control_Monad_Writer_Trans.runWriterT($3));\n    };\n})();\nvar mapWriter = function (f) {\n    return Control_Monad_Writer_Trans.mapWriterT((function () {\n        var $4 = Data_Newtype.unwrap();\n        return function ($5) {\n            return Data_Identity.Identity(f($4($5)));\n        };\n    })());\n};\nvar execWriter = function (m) {\n    return Data_Tuple.snd(runWriter(m));\n};\nmodule.exports = {\n    writer: writer,\n    runWriter: runWriter,\n    execWriter: execWriter,\n    mapWriter: mapWriter,\n    censor: Control_Monad_Writer_Class.censor,\n    listen: Control_Monad_Writer_Class.listen,\n    listens: Control_Monad_Writer_Class.listens,\n    pass: Control_Monad_Writer_Class.pass,\n    tell: Control_Monad_Writer_Class.tell,\n    WriterT: Control_Monad_Writer_Trans.WriterT,\n    execWriterT: Control_Monad_Writer_Trans.execWriterT,\n    lift: Control_Monad_Writer_Trans.lift,\n    mapWriterT: Control_Monad_Writer_Trans.mapWriterT,\n    runWriterT: Control_Monad_Writer_Trans.runWriterT\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Writer.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs":
/*!************************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar tell = function (dict) {\n    return dict.tell;\n};\nvar pass = function (dict) {\n    return dict.pass;\n};\nvar listen = function (dict) {\n    return dict.listen;\n};\nvar listens = function (dictMonadWriter) {\n    return function (f) {\n        return function (m) {\n            return Control_Bind.bind(((dictMonadWriter.MonadTell1()).Monad1()).Bind1())(listen(dictMonadWriter)(m))(function (v) {\n                return Control_Applicative.pure(((dictMonadWriter.MonadTell1()).Monad1()).Applicative0())(new Data_Tuple.Tuple(v.value0, f(v.value1)));\n            });\n        };\n    };\n};\nvar censor = function (dictMonadWriter) {\n    return function (f) {\n        return function (m) {\n            return pass(dictMonadWriter)(Control_Bind.bind(((dictMonadWriter.MonadTell1()).Monad1()).Bind1())(m)(function (a) {\n                return Control_Applicative.pure(((dictMonadWriter.MonadTell1()).Monad1()).Applicative0())(new Data_Tuple.Tuple(a, f));\n            }));\n        };\n    };\n};\nmodule.exports = {\n    listen: listen,\n    pass: pass,\n    tell: tell,\n    listens: listens,\n    censor: censor\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs?");

/***/ }),

/***/ "./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Trans.purs":
/*!************************************************************************!*\
  !*** ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Trans.purs ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_Cont_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Cont/Class.purs\");\nvar Control_Monad_Error_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs\");\nvar Control_Monad_Reader_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs\");\nvar Control_Monad_Rec_Class = __webpack_require__(/*! ./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs */ \"./.spago/tailrec/v5.0.1/src/Control/Monad/Rec/Class.purs\");\nvar Control_Monad_State_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs\");\nvar Control_Monad_Trans_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs\");\nvar Control_Monad_Writer_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs\");\nvar Control_Plus = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Plus.purs */ \"./.spago/control/v5.0.0/src/Control/Plus.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Effect_Class = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect/Class.purs */ \"./.spago/effect/v3.0.0/src/Effect/Class.purs\");\nvar WriterT = function (x) {\n    return x;\n};\nvar runWriterT = function (v) {\n    return v;\n};\nvar newtypeWriterT = {\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar monadTransWriterT = function (dictMonoid) {\n    return {\n        lift: function (dictMonad) {\n            return function (m) {\n                return Control_Bind.bind(dictMonad.Bind1())(m)(function (a) {\n                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(a, Data_Monoid.mempty(dictMonoid)));\n                });\n            };\n        }\n    };\n};\nvar mapWriterT = function (f) {\n    return function (v) {\n        return f(v);\n    };\n};\nvar functorWriterT = function (dictFunctor) {\n    return {\n        map: function (f) {\n            return mapWriterT(Data_Functor.map(dictFunctor)(function (v) {\n                return new Data_Tuple.Tuple(f(v.value0), v.value1);\n            }));\n        }\n    };\n};\nvar execWriterT = function (dictFunctor) {\n    return function (v) {\n        return Data_Functor.map(dictFunctor)(Data_Tuple.snd)(v);\n    };\n};\nvar applyWriterT = function (dictSemigroup) {\n    return function (dictApply) {\n        return {\n            apply: function (v) {\n                return function (v1) {\n                    var k = function (v3) {\n                        return function (v4) {\n                            return new Data_Tuple.Tuple(v3.value0(v4.value0), Data_Semigroup.append(dictSemigroup)(v3.value1)(v4.value1));\n                        };\n                    };\n                    return Control_Apply.apply(dictApply)(Data_Functor.map(dictApply.Functor0())(k)(v))(v1);\n                };\n            },\n            Functor0: function () {\n                return functorWriterT(dictApply.Functor0());\n            }\n        };\n    };\n};\nvar bindWriterT = function (dictSemigroup) {\n    return function (dictBind) {\n        return {\n            bind: function (v) {\n                return function (k) {\n                    return WriterT(Control_Bind.bind(dictBind)(v)(function (v1) {\n                        var v2 = k(v1.value0);\n                        return Data_Functor.map((dictBind.Apply0()).Functor0())(function (v3) {\n                            return new Data_Tuple.Tuple(v3.value0, Data_Semigroup.append(dictSemigroup)(v1.value1)(v3.value1));\n                        })(v2);\n                    }));\n                };\n            },\n            Apply0: function () {\n                return applyWriterT(dictSemigroup)(dictBind.Apply0());\n            }\n        };\n    };\n};\nvar semigroupWriterT = function (dictApply) {\n    return function (dictSemigroup) {\n        return function (dictSemigroup1) {\n            return {\n                append: Control_Apply.lift2(applyWriterT(dictSemigroup)(dictApply))(Data_Semigroup.append(dictSemigroup1))\n            };\n        };\n    };\n};\nvar applicativeWriterT = function (dictMonoid) {\n    return function (dictApplicative) {\n        return {\n            pure: function (a) {\n                return WriterT(Control_Applicative.pure(dictApplicative)(new Data_Tuple.Tuple(a, Data_Monoid.mempty(dictMonoid))));\n            },\n            Apply0: function () {\n                return applyWriterT(dictMonoid.Semigroup0())(dictApplicative.Apply0());\n            }\n        };\n    };\n};\nvar monadWriterT = function (dictMonoid) {\n    return function (dictMonad) {\n        return {\n            Applicative0: function () {\n                return applicativeWriterT(dictMonoid)(dictMonad.Applicative0());\n            },\n            Bind1: function () {\n                return bindWriterT(dictMonoid.Semigroup0())(dictMonad.Bind1());\n            }\n        };\n    };\n};\nvar monadAskWriterT = function (dictMonoid) {\n    return function (dictMonadAsk) {\n        return {\n            ask: Control_Monad_Trans_Class.lift(monadTransWriterT(dictMonoid))(dictMonadAsk.Monad0())(Control_Monad_Reader_Class.ask(dictMonadAsk)),\n            Monad0: function () {\n                return monadWriterT(dictMonoid)(dictMonadAsk.Monad0());\n            }\n        };\n    };\n};\nvar monadReaderWriterT = function (dictMonoid) {\n    return function (dictMonadReader) {\n        return {\n            local: function (f) {\n                return mapWriterT(Control_Monad_Reader_Class.local(dictMonadReader)(f));\n            },\n            MonadAsk0: function () {\n                return monadAskWriterT(dictMonoid)(dictMonadReader.MonadAsk0());\n            }\n        };\n    };\n};\nvar monadContWriterT = function (dictMonoid) {\n    return function (dictMonadCont) {\n        return {\n            callCC: function (f) {\n                return WriterT(Control_Monad_Cont_Class.callCC(dictMonadCont)(function (c) {\n                    var v = f(function (a) {\n                        return WriterT(c(new Data_Tuple.Tuple(a, Data_Monoid.mempty(dictMonoid))));\n                    });\n                    return v;\n                }));\n            },\n            Monad0: function () {\n                return monadWriterT(dictMonoid)(dictMonadCont.Monad0());\n            }\n        };\n    };\n};\nvar monadEffectWriter = function (dictMonoid) {\n    return function (dictMonadEffect) {\n        return {\n            liftEffect: (function () {\n                var $124 = Control_Monad_Trans_Class.lift(monadTransWriterT(dictMonoid))(dictMonadEffect.Monad0());\n                var $125 = Effect_Class.liftEffect(dictMonadEffect);\n                return function ($126) {\n                    return $124($125($126));\n                };\n            })(),\n            Monad0: function () {\n                return monadWriterT(dictMonoid)(dictMonadEffect.Monad0());\n            }\n        };\n    };\n};\nvar monadRecWriterT = function (dictMonoid) {\n    return function (dictMonadRec) {\n        return {\n            tailRecM: function (f) {\n                return function (a) {\n                    var f$prime = function (v) {\n                        var v1 = f(v.value0);\n                        return Control_Bind.bind((dictMonadRec.Monad0()).Bind1())(v1)(function (v2) {\n                            return Control_Applicative.pure((dictMonadRec.Monad0()).Applicative0())((function () {\n                                if (v2.value0 instanceof Control_Monad_Rec_Class.Loop) {\n                                    return new Control_Monad_Rec_Class.Loop(new Data_Tuple.Tuple(v2.value0.value0, Data_Semigroup.append(dictMonoid.Semigroup0())(v.value1)(v2.value1)));\n                                };\n                                if (v2.value0 instanceof Control_Monad_Rec_Class.Done) {\n                                    return new Control_Monad_Rec_Class.Done(new Data_Tuple.Tuple(v2.value0.value0, Data_Semigroup.append(dictMonoid.Semigroup0())(v.value1)(v2.value1)));\n                                };\n                                throw new Error(\"Failed pattern match at Control.Monad.Writer.Trans (line 84, column 16 - line 86, column 47): \" + [ v2.value0.constructor.name ]);\n                            })());\n                        });\n                    };\n                    return WriterT(Control_Monad_Rec_Class.tailRecM(dictMonadRec)(f$prime)(new Data_Tuple.Tuple(a, Data_Monoid.mempty(dictMonoid))));\n                };\n            },\n            Monad0: function () {\n                return monadWriterT(dictMonoid)(dictMonadRec.Monad0());\n            }\n        };\n    };\n};\nvar monadStateWriterT = function (dictMonoid) {\n    return function (dictMonadState) {\n        return {\n            state: function (f) {\n                return Control_Monad_Trans_Class.lift(monadTransWriterT(dictMonoid))(dictMonadState.Monad0())(Control_Monad_State_Class.state(dictMonadState)(f));\n            },\n            Monad0: function () {\n                return monadWriterT(dictMonoid)(dictMonadState.Monad0());\n            }\n        };\n    };\n};\nvar monadTellWriterT = function (dictMonoid) {\n    return function (dictMonad) {\n        return {\n            tell: (function () {\n                var $127 = Control_Applicative.pure(dictMonad.Applicative0());\n                var $128 = Data_Tuple.Tuple.create(Data_Unit.unit);\n                return function ($129) {\n                    return WriterT($127($128($129)));\n                };\n            })(),\n            Semigroup0: dictMonoid.Semigroup0,\n            Monad1: function () {\n                return monadWriterT(dictMonoid)(dictMonad);\n            }\n        };\n    };\n};\nvar monadWriterWriterT = function (dictMonoid) {\n    return function (dictMonad) {\n        return {\n            listen: function (v) {\n                return Control_Bind.bind(dictMonad.Bind1())(v)(function (v1) {\n                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v1.value0, v1.value1), v1.value1));\n                });\n            },\n            pass: function (v) {\n                return Control_Bind.bind(dictMonad.Bind1())(v)(function (v1) {\n                    return Control_Applicative.pure(dictMonad.Applicative0())(new Data_Tuple.Tuple(v1.value0.value0, v1.value0.value1(v1.value1)));\n                });\n            },\n            Monoid0: function () {\n                return dictMonoid;\n            },\n            MonadTell1: function () {\n                return monadTellWriterT(dictMonoid)(dictMonad);\n            }\n        };\n    };\n};\nvar monadThrowWriterT = function (dictMonoid) {\n    return function (dictMonadThrow) {\n        return {\n            throwError: function (e) {\n                return Control_Monad_Trans_Class.lift(monadTransWriterT(dictMonoid))(dictMonadThrow.Monad0())(Control_Monad_Error_Class.throwError(dictMonadThrow)(e));\n            },\n            Monad0: function () {\n                return monadWriterT(dictMonoid)(dictMonadThrow.Monad0());\n            }\n        };\n    };\n};\nvar monadErrorWriterT = function (dictMonoid) {\n    return function (dictMonadError) {\n        return {\n            catchError: function (v) {\n                return function (h) {\n                    return WriterT(Control_Monad_Error_Class.catchError(dictMonadError)(v)(function (e) {\n                        var v1 = h(e);\n                        return v1;\n                    }));\n                };\n            },\n            MonadThrow0: function () {\n                return monadThrowWriterT(dictMonoid)(dictMonadError.MonadThrow0());\n            }\n        };\n    };\n};\nvar monoidWriterT = function (dictApplicative) {\n    return function (dictMonoid) {\n        return function (dictMonoid1) {\n            return {\n                mempty: Control_Applicative.pure(applicativeWriterT(dictMonoid)(dictApplicative))(Data_Monoid.mempty(dictMonoid1)),\n                Semigroup0: function () {\n                    return semigroupWriterT(dictApplicative.Apply0())(dictMonoid.Semigroup0())(dictMonoid1.Semigroup0());\n                }\n            };\n        };\n    };\n};\nvar altWriterT = function (dictAlt) {\n    return {\n        alt: function (v) {\n            return function (v1) {\n                return Control_Alt.alt(dictAlt)(v)(v1);\n            };\n        },\n        Functor0: function () {\n            return functorWriterT(dictAlt.Functor0());\n        }\n    };\n};\nvar plusWriterT = function (dictPlus) {\n    return {\n        empty: Control_Plus.empty(dictPlus),\n        Alt0: function () {\n            return altWriterT(dictPlus.Alt0());\n        }\n    };\n};\nvar alternativeWriterT = function (dictMonoid) {\n    return function (dictAlternative) {\n        return {\n            Applicative0: function () {\n                return applicativeWriterT(dictMonoid)(dictAlternative.Applicative0());\n            },\n            Plus1: function () {\n                return plusWriterT(dictAlternative.Plus1());\n            }\n        };\n    };\n};\nvar monadPlusWriterT = function (dictMonoid) {\n    return function (dictMonadPlus) {\n        return {\n            Monad0: function () {\n                return monadWriterT(dictMonoid)(dictMonadPlus.Monad0());\n            },\n            Alternative1: function () {\n                return alternativeWriterT(dictMonoid)(dictMonadPlus.Alternative1());\n            }\n        };\n    };\n};\nvar monadZeroWriterT = function (dictMonoid) {\n    return function (dictMonadZero) {\n        return {\n            Monad0: function () {\n                return monadWriterT(dictMonoid)(dictMonadZero.Monad0());\n            },\n            Alternative1: function () {\n                return alternativeWriterT(dictMonoid)(dictMonadZero.Alternative1());\n            },\n            MonadZeroIsDeprecated2: function () {\n                return undefined;\n            }\n        };\n    };\n};\nmodule.exports = {\n    WriterT: WriterT,\n    runWriterT: runWriterT,\n    execWriterT: execWriterT,\n    mapWriterT: mapWriterT,\n    newtypeWriterT: newtypeWriterT,\n    functorWriterT: functorWriterT,\n    applyWriterT: applyWriterT,\n    applicativeWriterT: applicativeWriterT,\n    altWriterT: altWriterT,\n    plusWriterT: plusWriterT,\n    alternativeWriterT: alternativeWriterT,\n    bindWriterT: bindWriterT,\n    monadWriterT: monadWriterT,\n    monadRecWriterT: monadRecWriterT,\n    monadZeroWriterT: monadZeroWriterT,\n    monadPlusWriterT: monadPlusWriterT,\n    monadTransWriterT: monadTransWriterT,\n    monadEffectWriter: monadEffectWriter,\n    monadContWriterT: monadContWriterT,\n    monadThrowWriterT: monadThrowWriterT,\n    monadErrorWriterT: monadErrorWriterT,\n    monadAskWriterT: monadAskWriterT,\n    monadReaderWriterT: monadReaderWriterT,\n    monadStateWriterT: monadStateWriterT,\n    monadTellWriterT: monadTellWriterT,\n    monadWriterWriterT: monadWriterWriterT,\n    semigroupWriterT: semigroupWriterT,\n    monoidWriterT: monoidWriterT,\n    lift: Control_Monad_Trans_Class.lift,\n    censor: Control_Monad_Writer_Class.censor,\n    listen: Control_Monad_Writer_Class.listen,\n    listens: Control_Monad_Writer_Class.listens,\n    pass: Control_Monad_Writer_Class.pass,\n    tell: Control_Monad_Writer_Class.tell\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Trans.purs?");

/***/ }),

/***/ "./.spago/tuples/v6.0.1/src/Data/Tuple.purs":
/*!**************************************************!*\
  !*** ./.spago/tuples/v6.0.1/src/Data/Tuple.purs ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Lazy = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Lazy.purs */ \"./.spago/control/v5.0.0/src/Control/Lazy.purs\");\nvar Data_Bounded = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Bounded.purs */ \"./.spago/prelude/v5.0.1/src/Data/Bounded.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Functor_Invariant = __webpack_require__(/*! ./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs */ \"./.spago/invariant/v5.0.0/src/Data/Functor/Invariant.purs\");\nvar Data_Generic_Rep = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs */ \"./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Ring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ring.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Semiring = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semiring.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semiring.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Tuple = (function () {\n    function Tuple(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    Tuple.create = function (value0) {\n        return function (value1) {\n            return new Tuple(value0, value1);\n        };\n    };\n    return Tuple;\n})();\nvar uncurry = function (f) {\n    return function (v) {\n        return f(v.value0)(v.value1);\n    };\n};\nvar swap = function (v) {\n    return new Tuple(v.value1, v.value0);\n};\nvar snd = function (v) {\n    return v.value1;\n};\nvar showTuple = function (dictShow) {\n    return function (dictShow1) {\n        return {\n            show: function (v) {\n                return \"(Tuple \" + (Data_Show.show(dictShow)(v.value0) + (\" \" + (Data_Show.show(dictShow1)(v.value1) + \")\")));\n            }\n        };\n    };\n};\nvar semiringTuple = function (dictSemiring) {\n    return function (dictSemiring1) {\n        return {\n            add: function (v) {\n                return function (v1) {\n                    return new Tuple(Data_Semiring.add(dictSemiring)(v.value0)(v1.value0), Data_Semiring.add(dictSemiring1)(v.value1)(v1.value1));\n                };\n            },\n            one: new Tuple(Data_Semiring.one(dictSemiring), Data_Semiring.one(dictSemiring1)),\n            mul: function (v) {\n                return function (v1) {\n                    return new Tuple(Data_Semiring.mul(dictSemiring)(v.value0)(v1.value0), Data_Semiring.mul(dictSemiring1)(v.value1)(v1.value1));\n                };\n            },\n            zero: new Tuple(Data_Semiring.zero(dictSemiring), Data_Semiring.zero(dictSemiring1))\n        };\n    };\n};\nvar semigroupoidTuple = {\n    compose: function (v) {\n        return function (v1) {\n            return new Tuple(v1.value0, v.value1);\n        };\n    }\n};\nvar semigroupTuple = function (dictSemigroup) {\n    return function (dictSemigroup1) {\n        return {\n            append: function (v) {\n                return function (v1) {\n                    return new Tuple(Data_Semigroup.append(dictSemigroup)(v.value0)(v1.value0), Data_Semigroup.append(dictSemigroup1)(v.value1)(v1.value1));\n                };\n            }\n        };\n    };\n};\nvar ringTuple = function (dictRing) {\n    return function (dictRing1) {\n        return {\n            sub: function (v) {\n                return function (v1) {\n                    return new Tuple(Data_Ring.sub(dictRing)(v.value0)(v1.value0), Data_Ring.sub(dictRing1)(v.value1)(v1.value1));\n                };\n            },\n            Semiring0: function () {\n                return semiringTuple(dictRing.Semiring0())(dictRing1.Semiring0());\n            }\n        };\n    };\n};\nvar monoidTuple = function (dictMonoid) {\n    return function (dictMonoid1) {\n        return {\n            mempty: new Tuple(Data_Monoid.mempty(dictMonoid), Data_Monoid.mempty(dictMonoid1)),\n            Semigroup0: function () {\n                return semigroupTuple(dictMonoid.Semigroup0())(dictMonoid1.Semigroup0());\n            }\n        };\n    };\n};\nvar heytingAlgebraTuple = function (dictHeytingAlgebra) {\n    return function (dictHeytingAlgebra1) {\n        return {\n            tt: new Tuple(Data_HeytingAlgebra.tt(dictHeytingAlgebra), Data_HeytingAlgebra.tt(dictHeytingAlgebra1)),\n            ff: new Tuple(Data_HeytingAlgebra.ff(dictHeytingAlgebra), Data_HeytingAlgebra.ff(dictHeytingAlgebra1)),\n            implies: function (v) {\n                return function (v1) {\n                    return new Tuple(Data_HeytingAlgebra.implies(dictHeytingAlgebra)(v.value0)(v1.value0), Data_HeytingAlgebra.implies(dictHeytingAlgebra1)(v.value1)(v1.value1));\n                };\n            },\n            conj: function (v) {\n                return function (v1) {\n                    return new Tuple(Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v.value0)(v1.value0), Data_HeytingAlgebra.conj(dictHeytingAlgebra1)(v.value1)(v1.value1));\n                };\n            },\n            disj: function (v) {\n                return function (v1) {\n                    return new Tuple(Data_HeytingAlgebra.disj(dictHeytingAlgebra)(v.value0)(v1.value0), Data_HeytingAlgebra.disj(dictHeytingAlgebra1)(v.value1)(v1.value1));\n                };\n            },\n            not: function (v) {\n                return new Tuple(Data_HeytingAlgebra.not(dictHeytingAlgebra)(v.value0), Data_HeytingAlgebra.not(dictHeytingAlgebra1)(v.value1));\n            }\n        };\n    };\n};\nvar genericTuple = {\n    to: function (x) {\n        return new Tuple(x.value0, x.value1);\n    },\n    from: function (x) {\n        return new Data_Generic_Rep.Product(x.value0, x.value1);\n    }\n};\nvar functorTuple = {\n    map: function (f) {\n        return function (m) {\n            return new Tuple(m.value0, f(m.value1));\n        };\n    }\n};\nvar invariantTuple = {\n    imap: Data_Functor_Invariant.imapF(functorTuple)\n};\nvar fst = function (v) {\n    return v.value0;\n};\nvar lazyTuple = function (dictLazy) {\n    return function (dictLazy1) {\n        return {\n            defer: function (f) {\n                return new Tuple(Control_Lazy.defer(dictLazy)(function (v) {\n                    return fst(f(Data_Unit.unit));\n                }), Control_Lazy.defer(dictLazy1)(function (v) {\n                    return snd(f(Data_Unit.unit));\n                }));\n            }\n        };\n    };\n};\nvar extendTuple = {\n    extend: function (f) {\n        return function (v) {\n            return new Tuple(v.value0, f(v));\n        };\n    },\n    Functor0: function () {\n        return functorTuple;\n    }\n};\nvar eqTuple = function (dictEq) {\n    return function (dictEq1) {\n        return {\n            eq: function (x) {\n                return function (y) {\n                    return Data_Eq.eq(dictEq)(x.value0)(y.value0) && Data_Eq.eq(dictEq1)(x.value1)(y.value1);\n                };\n            }\n        };\n    };\n};\nvar ordTuple = function (dictOrd) {\n    return function (dictOrd1) {\n        return {\n            compare: function (x) {\n                return function (y) {\n                    var v = Data_Ord.compare(dictOrd)(x.value0)(y.value0);\n                    if (v instanceof Data_Ordering.LT) {\n                        return Data_Ordering.LT.value;\n                    };\n                    if (v instanceof Data_Ordering.GT) {\n                        return Data_Ordering.GT.value;\n                    };\n                    return Data_Ord.compare(dictOrd1)(x.value1)(y.value1);\n                };\n            },\n            Eq0: function () {\n                return eqTuple(dictOrd.Eq0())(dictOrd1.Eq0());\n            }\n        };\n    };\n};\nvar eq1Tuple = function (dictEq) {\n    return {\n        eq1: function (dictEq1) {\n            return Data_Eq.eq(eqTuple(dictEq)(dictEq1));\n        }\n    };\n};\nvar ord1Tuple = function (dictOrd) {\n    return {\n        compare1: function (dictOrd1) {\n            return Data_Ord.compare(ordTuple(dictOrd)(dictOrd1));\n        },\n        Eq10: function () {\n            return eq1Tuple(dictOrd.Eq0());\n        }\n    };\n};\nvar curry = function (f) {\n    return function (a) {\n        return function (b) {\n            return f(new Tuple(a, b));\n        };\n    };\n};\nvar comonadTuple = {\n    extract: snd,\n    Extend0: function () {\n        return extendTuple;\n    }\n};\nvar commutativeRingTuple = function (dictCommutativeRing) {\n    return function (dictCommutativeRing1) {\n        return {\n            Ring0: function () {\n                return ringTuple(dictCommutativeRing.Ring0())(dictCommutativeRing1.Ring0());\n            }\n        };\n    };\n};\nvar boundedTuple = function (dictBounded) {\n    return function (dictBounded1) {\n        return {\n            top: new Tuple(Data_Bounded.top(dictBounded), Data_Bounded.top(dictBounded1)),\n            bottom: new Tuple(Data_Bounded.bottom(dictBounded), Data_Bounded.bottom(dictBounded1)),\n            Ord0: function () {\n                return ordTuple(dictBounded.Ord0())(dictBounded1.Ord0());\n            }\n        };\n    };\n};\nvar booleanAlgebraTuple = function (dictBooleanAlgebra) {\n    return function (dictBooleanAlgebra1) {\n        return {\n            HeytingAlgebra0: function () {\n                return heytingAlgebraTuple(dictBooleanAlgebra.HeytingAlgebra0())(dictBooleanAlgebra1.HeytingAlgebra0());\n            }\n        };\n    };\n};\nvar applyTuple = function (dictSemigroup) {\n    return {\n        apply: function (v) {\n            return function (v1) {\n                return new Tuple(Data_Semigroup.append(dictSemigroup)(v.value0)(v1.value0), v.value1(v1.value1));\n            };\n        },\n        Functor0: function () {\n            return functorTuple;\n        }\n    };\n};\nvar bindTuple = function (dictSemigroup) {\n    return {\n        bind: function (v) {\n            return function (f) {\n                var v1 = f(v.value1);\n                return new Tuple(Data_Semigroup.append(dictSemigroup)(v.value0)(v1.value0), v1.value1);\n            };\n        },\n        Apply0: function () {\n            return applyTuple(dictSemigroup);\n        }\n    };\n};\nvar applicativeTuple = function (dictMonoid) {\n    return {\n        pure: Tuple.create(Data_Monoid.mempty(dictMonoid)),\n        Apply0: function () {\n            return applyTuple(dictMonoid.Semigroup0());\n        }\n    };\n};\nvar monadTuple = function (dictMonoid) {\n    return {\n        Applicative0: function () {\n            return applicativeTuple(dictMonoid);\n        },\n        Bind1: function () {\n            return bindTuple(dictMonoid.Semigroup0());\n        }\n    };\n};\nmodule.exports = {\n    Tuple: Tuple,\n    fst: fst,\n    snd: snd,\n    curry: curry,\n    uncurry: uncurry,\n    swap: swap,\n    showTuple: showTuple,\n    eqTuple: eqTuple,\n    eq1Tuple: eq1Tuple,\n    ordTuple: ordTuple,\n    ord1Tuple: ord1Tuple,\n    boundedTuple: boundedTuple,\n    semigroupoidTuple: semigroupoidTuple,\n    semigroupTuple: semigroupTuple,\n    monoidTuple: monoidTuple,\n    semiringTuple: semiringTuple,\n    ringTuple: ringTuple,\n    commutativeRingTuple: commutativeRingTuple,\n    heytingAlgebraTuple: heytingAlgebraTuple,\n    booleanAlgebraTuple: booleanAlgebraTuple,\n    functorTuple: functorTuple,\n    genericTuple: genericTuple,\n    invariantTuple: invariantTuple,\n    applyTuple: applyTuple,\n    applicativeTuple: applicativeTuple,\n    bindTuple: bindTuple,\n    monadTuple: monadTuple,\n    extendTuple: extendTuple,\n    comonadTuple: comonadTuple,\n    lazyTuple: lazyTuple\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/tuples/v6.0.1/src/Data/Tuple.purs?");

/***/ }),

/***/ "./.spago/type-equality/v4.0.0/src/Type/Equality.purs":
/*!************************************************************!*\
  !*** ./.spago/type-equality/v4.0.0/src/Type/Equality.purs ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar To = function (x) {\n    return x;\n};\nvar From = function (x) {\n    return x;\n};\nvar refl = {\n    proof: function (a) {\n        return a;\n    },\n    Coercible0: function () {\n        return undefined;\n    }\n};\nvar proof = function (dict) {\n    return dict.proof;\n};\nvar to = function (dictTypeEquals) {\n    var v = proof(dictTypeEquals)(function (a) {\n        return a;\n    });\n    return v;\n};\nvar from = function (dictTypeEquals) {\n    var v = proof(dictTypeEquals)(function (a) {\n        return a;\n    });\n    return v;\n};\nmodule.exports = {\n    proof: proof,\n    to: to,\n    from: from,\n    refl: refl\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/type-equality/v4.0.0/src/Type/Equality.purs?");

/***/ }),

/***/ "./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs":
/*!***********************************************************!*\
  !*** ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.js */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.js\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable1 = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar unfoldr = function (dict) {\n    return dict.unfoldr;\n};\nvar unfoldableMaybe = {\n    unfoldr: function (f) {\n        return function (b) {\n            return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Tuple.fst)(f(b));\n        };\n    },\n    Unfoldable10: function () {\n        return Data_Unfoldable1.unfoldable1Maybe;\n    }\n};\nvar unfoldableArray = {\n    unfoldr: $foreign.unfoldrArrayImpl(Data_Maybe.isNothing)(Data_Maybe.fromJust())(Data_Tuple.fst)(Data_Tuple.snd),\n    Unfoldable10: function () {\n        return Data_Unfoldable1.unfoldable1Array;\n    }\n};\nvar replicate = function (dictUnfoldable) {\n    return function (n) {\n        return function (v) {\n            var step = function (i) {\n                var $8 = i <= 0;\n                if ($8) {\n                    return Data_Maybe.Nothing.value;\n                };\n                return new Data_Maybe.Just(new Data_Tuple.Tuple(v, i - 1 | 0));\n            };\n            return unfoldr(dictUnfoldable)(step)(n);\n        };\n    };\n};\nvar replicateA = function (dictApplicative) {\n    return function (dictUnfoldable) {\n        return function (dictTraversable) {\n            return function (n) {\n                return function (m) {\n                    return Data_Traversable.sequence(dictTraversable)(dictApplicative)(replicate(dictUnfoldable)(n)(m));\n                };\n            };\n        };\n    };\n};\nvar none = function (dictUnfoldable) {\n    return unfoldr(dictUnfoldable)(Data_Function[\"const\"](Data_Maybe.Nothing.value))(Data_Unit.unit);\n};\nvar fromMaybe = function (dictUnfoldable) {\n    return unfoldr(dictUnfoldable)(function (b) {\n        return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Function.flip(Data_Tuple.Tuple.create)(Data_Maybe.Nothing.value))(b);\n    });\n};\nmodule.exports = {\n    unfoldr: unfoldr,\n    replicate: replicate,\n    replicateA: replicateA,\n    none: none,\n    fromMaybe: fromMaybe,\n    unfoldableArray: unfoldableArray,\n    unfoldableMaybe: unfoldableMaybe,\n    range: Data_Unfoldable1.range,\n    replicate1: Data_Unfoldable1.replicate1,\n    replicate1A: Data_Unfoldable1.replicate1A,\n    singleton: Data_Unfoldable1.singleton,\n    unfoldr1: Data_Unfoldable1.unfoldr1\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs?");

/***/ }),

/***/ "./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs":
/*!************************************************************!*\
  !*** ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.js */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.js\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Semigroup_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Semigroup/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar unfoldr1 = function (dict) {\n    return dict.unfoldr1;\n};\nvar unfoldable1Maybe = {\n    unfoldr1: function (f) {\n        return function (b) {\n            return new Data_Maybe.Just(Data_Tuple.fst(f(b)));\n        };\n    }\n};\nvar unfoldable1Array = {\n    unfoldr1: $foreign.unfoldr1ArrayImpl(Data_Maybe.isNothing)(Data_Maybe.fromJust())(Data_Tuple.fst)(Data_Tuple.snd)\n};\nvar replicate1 = function (dictUnfoldable1) {\n    return function (n) {\n        return function (v) {\n            var step = function (i) {\n                if (i <= 0) {\n                    return new Data_Tuple.Tuple(v, Data_Maybe.Nothing.value);\n                };\n                if (Data_Boolean.otherwise) {\n                    return new Data_Tuple.Tuple(v, new Data_Maybe.Just(i - 1 | 0));\n                };\n                throw new Error(\"Failed pattern match at Data.Unfoldable1 (line 67, column 5 - line 67, column 39): \" + [ i.constructor.name ]);\n            };\n            return unfoldr1(dictUnfoldable1)(step)(n - 1 | 0);\n        };\n    };\n};\nvar replicate1A = function (dictApply) {\n    return function (dictUnfoldable1) {\n        return function (dictTraversable1) {\n            return function (n) {\n                return function (m) {\n                    return Data_Semigroup_Traversable.sequence1(dictTraversable1)(dictApply)(replicate1(dictUnfoldable1)(n)(m));\n                };\n            };\n        };\n    };\n};\nvar singleton = function (dictUnfoldable1) {\n    return replicate1(dictUnfoldable1)(1);\n};\nvar range = function (dictUnfoldable1) {\n    return function (start) {\n        return function (end) {\n            var go = function (delta) {\n                return function (i) {\n                    var i$prime = i + delta | 0;\n                    return new Data_Tuple.Tuple(i, (function () {\n                        var $9 = i === end;\n                        if ($9) {\n                            return Data_Maybe.Nothing.value;\n                        };\n                        return new Data_Maybe.Just(i$prime);\n                    })());\n                };\n            };\n            var delta = (function () {\n                var $10 = end >= start;\n                if ($10) {\n                    return 1;\n                };\n                return -1 | 0;\n            })();\n            return unfoldr1(dictUnfoldable1)(go(delta))(start);\n        };\n    };\n};\nmodule.exports = {\n    unfoldr1: unfoldr1,\n    replicate1: replicate1,\n    replicate1A: replicate1A,\n    singleton: singleton,\n    range: range,\n    unfoldable1Array: unfoldable1Array,\n    unfoldable1Maybe: unfoldable1Maybe\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/unfoldable/v5.0.0/src/Data/Unfoldable1.purs?");

/***/ }),

/***/ "./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs":
/*!***************************************************************!*\
  !*** ./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Char = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/Char.purs */ \"./.spago/strings/v5.0.0/src/Data/Char.purs\");\nvar Data_CodePoint_Unicode_Internal = __webpack_require__(/*! ./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal.purs */ \"./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal.purs\");\nvar Data_CodePoint_Unicode_Internal_Casing = __webpack_require__(/*! ./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal/Casing.purs */ \"./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal/Casing.purs\");\nvar Data_Enum = __webpack_require__(/*! ./.spago/enums/v5.0.0/src/Data/Enum.purs */ \"./.spago/enums/v5.0.0/src/Data/Enum.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_String_CodePoints = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs\");\nvar Unsafe_Coerce = __webpack_require__(/*! ./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs */ \"./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs\");\nvar UppercaseLetter = (function () {\n    function UppercaseLetter() {\n\n    };\n    UppercaseLetter.value = new UppercaseLetter();\n    return UppercaseLetter;\n})();\nvar LowercaseLetter = (function () {\n    function LowercaseLetter() {\n\n    };\n    LowercaseLetter.value = new LowercaseLetter();\n    return LowercaseLetter;\n})();\nvar TitlecaseLetter = (function () {\n    function TitlecaseLetter() {\n\n    };\n    TitlecaseLetter.value = new TitlecaseLetter();\n    return TitlecaseLetter;\n})();\nvar ModifierLetter = (function () {\n    function ModifierLetter() {\n\n    };\n    ModifierLetter.value = new ModifierLetter();\n    return ModifierLetter;\n})();\nvar OtherLetter = (function () {\n    function OtherLetter() {\n\n    };\n    OtherLetter.value = new OtherLetter();\n    return OtherLetter;\n})();\nvar NonSpacingMark = (function () {\n    function NonSpacingMark() {\n\n    };\n    NonSpacingMark.value = new NonSpacingMark();\n    return NonSpacingMark;\n})();\nvar SpacingCombiningMark = (function () {\n    function SpacingCombiningMark() {\n\n    };\n    SpacingCombiningMark.value = new SpacingCombiningMark();\n    return SpacingCombiningMark;\n})();\nvar EnclosingMark = (function () {\n    function EnclosingMark() {\n\n    };\n    EnclosingMark.value = new EnclosingMark();\n    return EnclosingMark;\n})();\nvar DecimalNumber = (function () {\n    function DecimalNumber() {\n\n    };\n    DecimalNumber.value = new DecimalNumber();\n    return DecimalNumber;\n})();\nvar LetterNumber = (function () {\n    function LetterNumber() {\n\n    };\n    LetterNumber.value = new LetterNumber();\n    return LetterNumber;\n})();\nvar OtherNumber = (function () {\n    function OtherNumber() {\n\n    };\n    OtherNumber.value = new OtherNumber();\n    return OtherNumber;\n})();\nvar ConnectorPunctuation = (function () {\n    function ConnectorPunctuation() {\n\n    };\n    ConnectorPunctuation.value = new ConnectorPunctuation();\n    return ConnectorPunctuation;\n})();\nvar DashPunctuation = (function () {\n    function DashPunctuation() {\n\n    };\n    DashPunctuation.value = new DashPunctuation();\n    return DashPunctuation;\n})();\nvar OpenPunctuation = (function () {\n    function OpenPunctuation() {\n\n    };\n    OpenPunctuation.value = new OpenPunctuation();\n    return OpenPunctuation;\n})();\nvar ClosePunctuation = (function () {\n    function ClosePunctuation() {\n\n    };\n    ClosePunctuation.value = new ClosePunctuation();\n    return ClosePunctuation;\n})();\nvar InitialQuote = (function () {\n    function InitialQuote() {\n\n    };\n    InitialQuote.value = new InitialQuote();\n    return InitialQuote;\n})();\nvar FinalQuote = (function () {\n    function FinalQuote() {\n\n    };\n    FinalQuote.value = new FinalQuote();\n    return FinalQuote;\n})();\nvar OtherPunctuation = (function () {\n    function OtherPunctuation() {\n\n    };\n    OtherPunctuation.value = new OtherPunctuation();\n    return OtherPunctuation;\n})();\nvar MathSymbol = (function () {\n    function MathSymbol() {\n\n    };\n    MathSymbol.value = new MathSymbol();\n    return MathSymbol;\n})();\nvar CurrencySymbol = (function () {\n    function CurrencySymbol() {\n\n    };\n    CurrencySymbol.value = new CurrencySymbol();\n    return CurrencySymbol;\n})();\nvar ModifierSymbol = (function () {\n    function ModifierSymbol() {\n\n    };\n    ModifierSymbol.value = new ModifierSymbol();\n    return ModifierSymbol;\n})();\nvar OtherSymbol = (function () {\n    function OtherSymbol() {\n\n    };\n    OtherSymbol.value = new OtherSymbol();\n    return OtherSymbol;\n})();\nvar Space = (function () {\n    function Space() {\n\n    };\n    Space.value = new Space();\n    return Space;\n})();\nvar LineSeparator = (function () {\n    function LineSeparator() {\n\n    };\n    LineSeparator.value = new LineSeparator();\n    return LineSeparator;\n})();\nvar ParagraphSeparator = (function () {\n    function ParagraphSeparator() {\n\n    };\n    ParagraphSeparator.value = new ParagraphSeparator();\n    return ParagraphSeparator;\n})();\nvar Control = (function () {\n    function Control() {\n\n    };\n    Control.value = new Control();\n    return Control;\n})();\nvar Format = (function () {\n    function Format() {\n\n    };\n    Format.value = new Format();\n    return Format;\n})();\nvar Surrogate = (function () {\n    function Surrogate() {\n\n    };\n    Surrogate.value = new Surrogate();\n    return Surrogate;\n})();\nvar PrivateUse = (function () {\n    function PrivateUse() {\n\n    };\n    PrivateUse.value = new PrivateUse();\n    return PrivateUse;\n})();\nvar NotAssigned = (function () {\n    function NotAssigned() {\n\n    };\n    NotAssigned.value = new NotAssigned();\n    return NotAssigned;\n})();\nvar unicodeCatToGeneralCat = function (v) {\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_LU) {\n        return UppercaseLetter.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_LL) {\n        return LowercaseLetter.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_LT) {\n        return TitlecaseLetter.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_LM) {\n        return ModifierLetter.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_LO) {\n        return OtherLetter.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_MN) {\n        return NonSpacingMark.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_MC) {\n        return SpacingCombiningMark.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_ME) {\n        return EnclosingMark.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_ND) {\n        return DecimalNumber.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_NL) {\n        return LetterNumber.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_NO) {\n        return OtherNumber.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_PC) {\n        return ConnectorPunctuation.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_PD) {\n        return DashPunctuation.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_PS) {\n        return OpenPunctuation.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_PE) {\n        return ClosePunctuation.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_PI) {\n        return InitialQuote.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_PF) {\n        return FinalQuote.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_PO) {\n        return OtherPunctuation.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_SM) {\n        return MathSymbol.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_SC) {\n        return CurrencySymbol.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_SK) {\n        return ModifierSymbol.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_SO) {\n        return OtherSymbol.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_ZS) {\n        return Space.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_ZL) {\n        return LineSeparator.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_ZP) {\n        return ParagraphSeparator.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_CC) {\n        return Control.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_CF) {\n        return Format.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_CS) {\n        return Surrogate.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_CO) {\n        return PrivateUse.value;\n    };\n    if (v instanceof Data_CodePoint_Unicode_Internal.NUMCAT_CN) {\n        return NotAssigned.value;\n    };\n    throw new Error(\"Failed pattern match at Data.CodePoint.Unicode (line 206, column 1 - line 206, column 61): \" + [ v.constructor.name ]);\n};\nvar showGeneralCategory = {\n    show: function (v) {\n        if (v instanceof UppercaseLetter) {\n            return \"UppercaseLetter\";\n        };\n        if (v instanceof LowercaseLetter) {\n            return \"LowercaseLetter\";\n        };\n        if (v instanceof TitlecaseLetter) {\n            return \"TitlecaseLetter\";\n        };\n        if (v instanceof ModifierLetter) {\n            return \"ModifierLetter\";\n        };\n        if (v instanceof OtherLetter) {\n            return \"OtherLetter\";\n        };\n        if (v instanceof NonSpacingMark) {\n            return \"NonSpacingMark\";\n        };\n        if (v instanceof SpacingCombiningMark) {\n            return \"SpacingCombiningMark\";\n        };\n        if (v instanceof EnclosingMark) {\n            return \"EnclosingMark\";\n        };\n        if (v instanceof DecimalNumber) {\n            return \"DecimalNumber\";\n        };\n        if (v instanceof LetterNumber) {\n            return \"LetterNumber\";\n        };\n        if (v instanceof OtherNumber) {\n            return \"OtherNumber\";\n        };\n        if (v instanceof ConnectorPunctuation) {\n            return \"ConnectorPunctuation\";\n        };\n        if (v instanceof DashPunctuation) {\n            return \"DashPunctuation\";\n        };\n        if (v instanceof OpenPunctuation) {\n            return \"OpenPunctuation\";\n        };\n        if (v instanceof ClosePunctuation) {\n            return \"ClosePunctuation\";\n        };\n        if (v instanceof InitialQuote) {\n            return \"InitialQuote\";\n        };\n        if (v instanceof FinalQuote) {\n            return \"FinalQuote\";\n        };\n        if (v instanceof OtherPunctuation) {\n            return \"OtherPunctuation\";\n        };\n        if (v instanceof MathSymbol) {\n            return \"MathSymbol\";\n        };\n        if (v instanceof CurrencySymbol) {\n            return \"CurrencySymbol\";\n        };\n        if (v instanceof ModifierSymbol) {\n            return \"ModifierSymbol\";\n        };\n        if (v instanceof OtherSymbol) {\n            return \"OtherSymbol\";\n        };\n        if (v instanceof Space) {\n            return \"Space\";\n        };\n        if (v instanceof LineSeparator) {\n            return \"LineSeparator\";\n        };\n        if (v instanceof ParagraphSeparator) {\n            return \"ParagraphSeparator\";\n        };\n        if (v instanceof Control) {\n            return \"Control\";\n        };\n        if (v instanceof Format) {\n            return \"Format\";\n        };\n        if (v instanceof Surrogate) {\n            return \"Surrogate\";\n        };\n        if (v instanceof PrivateUse) {\n            return \"PrivateUse\";\n        };\n        if (v instanceof NotAssigned) {\n            return \"NotAssigned\";\n        };\n        throw new Error(\"Failed pattern match at Data.CodePoint.Unicode (line 238, column 1 - line 268, column 37): \" + [ v.constructor.name ]);\n    }\n};\nvar modifyFull = Unsafe_Coerce.unsafeCoerce;\nvar toLower = modifyFull(Data_CodePoint_Unicode_Internal_Casing.lower);\nvar toTitle = modifyFull(Data_CodePoint_Unicode_Internal_Casing.title);\nvar toUpper = modifyFull(Data_CodePoint_Unicode_Internal_Casing.upper);\nvar modify = Unsafe_Coerce.unsafeCoerce;\nvar toLowerSimple = modify(Data_CodePoint_Unicode_Internal.uTowlower);\nvar toTitleSimple = modify(Data_CodePoint_Unicode_Internal.uTowtitle);\nvar toUpperSimple = modify(Data_CodePoint_Unicode_Internal.uTowupper);\nvar isUpper = (function () {\n    var $54 = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint);\n    return function ($55) {\n        return Data_CodePoint_Unicode_Internal.uIswupper($54($55));\n    };\n})();\nvar isSpace = function (c) {\n    var uc = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint)(c);\n    var $16 = uc <= 823;\n    if ($16) {\n        return uc === 32 || (uc >= 9 && uc <= 13 || uc === 160);\n    };\n    return Data_CodePoint_Unicode_Internal.uIswspace(uc);\n};\nvar isPrint = (function () {\n    var $56 = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint);\n    return function ($57) {\n        return Data_CodePoint_Unicode_Internal.uIswprint($56($57));\n    };\n})();\nvar isOctDigit = function (c) {\n    var diff = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint)(c) - Data_Char.toCharCode(\"0\") | 0;\n    return diff <= 7 && diff >= 0;\n};\nvar octDigitToInt = function (c) {\n    if (isOctDigit(c)) {\n        return Data_Maybe.Just.create(Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint)(c) - Data_Char.toCharCode(\"0\") | 0);\n    };\n    if (Data_Boolean.otherwise) {\n        return Data_Maybe.Nothing.value;\n    };\n    throw new Error(\"Failed pattern match at Data.CodePoint.Unicode (line 630, column 1 - line 630, column 40): \" + [ c.constructor.name ]);\n};\nvar isLower = (function () {\n    var $58 = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint);\n    return function ($59) {\n        return Data_CodePoint_Unicode_Internal.uIswlower($58($59));\n    };\n})();\nvar isLatin1 = function (c) {\n    return Data_Ord.lessThanOrEq(Data_String_CodePoints.ordCodePoint)(c)(Data_String_CodePoints.codePointFromChar(\"\\xff\"));\n};\nvar isDecDigit = function (c) {\n    var diff = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint)(c) - Data_Char.toCharCode(\"0\") | 0;\n    return diff <= 9 && diff >= 0;\n};\nvar isDigit = function (dictWarn) {\n    return isDecDigit;\n};\nvar isHexDigit = function (c) {\n    return isDecDigit(c) || ((function () {\n        var diff = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint)(c) - Data_Char.toCharCode(\"A\") | 0;\n        return diff <= 5 && diff >= 0;\n    })() || (function () {\n        var diff = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint)(c) - Data_Char.toCharCode(\"a\") | 0;\n        return diff <= 5 && diff >= 0;\n    })());\n};\nvar isControl = (function () {\n    var $60 = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint);\n    return function ($61) {\n        return Data_CodePoint_Unicode_Internal.uIswcntrl($60($61));\n    };\n})();\nvar isAsciiUpper = function (c) {\n    return Data_Ord.greaterThanOrEq(Data_String_CodePoints.ordCodePoint)(c)(Data_String_CodePoints.codePointFromChar(\"A\")) && Data_Ord.lessThanOrEq(Data_String_CodePoints.ordCodePoint)(c)(Data_String_CodePoints.codePointFromChar(\"Z\"));\n};\nvar isAsciiLower = function (c) {\n    return Data_Ord.greaterThanOrEq(Data_String_CodePoints.ordCodePoint)(c)(Data_String_CodePoints.codePointFromChar(\"a\")) && Data_Ord.lessThanOrEq(Data_String_CodePoints.ordCodePoint)(c)(Data_String_CodePoints.codePointFromChar(\"z\"));\n};\nvar isAscii = function (c) {\n    return Data_Ord.lessThan(Data_String_CodePoints.ordCodePoint)(c)(Data_String_CodePoints.codePointFromChar(\"\\x80\"));\n};\nvar isAlphaNum = (function () {\n    var $62 = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint);\n    return function ($63) {\n        return Data_CodePoint_Unicode_Internal.uIswalnum($62($63));\n    };\n})();\nvar isAlpha = (function () {\n    var $64 = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint);\n    return function ($65) {\n        return Data_CodePoint_Unicode_Internal.uIswalpha($64($65));\n    };\n})();\nvar hexDigitToInt = function (c) {\n    var hexUpper = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint)(c) - Data_Char.toCharCode(\"A\") | 0;\n    var hexLower = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint)(c) - Data_Char.toCharCode(\"a\") | 0;\n    var dec = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint)(c) - Data_Char.toCharCode(\"0\") | 0;\n    var result = (function () {\n        if (dec <= 9 && dec >= 0) {\n            return new Data_Maybe.Just(dec);\n        };\n        if (hexLower <= 5 && hexLower >= 0) {\n            return Data_Maybe.Just.create(hexLower + 10 | 0);\n        };\n        if (hexUpper <= 5 && hexUpper >= 0) {\n            return Data_Maybe.Just.create(hexUpper + 10 | 0);\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Maybe.Nothing.value;\n        };\n        throw new Error(\"Failed pattern match at Data.CodePoint.Unicode (line 585, column 5 - line 585, column 24): \" + [  ]);\n    })();\n    return result;\n};\nvar generalCategory = (function () {\n    var $66 = Data_Functor.map(Data_Maybe.functorMaybe)(unicodeCatToGeneralCat);\n    var $67 = Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint);\n    return function ($68) {\n        return $66(Data_CodePoint_Unicode_Internal.uGencat($67($68)));\n    };\n})();\nvar isLetter = function (c) {\n    var v = generalCategory(c);\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof UppercaseLetter) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof LowercaseLetter) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof TitlecaseLetter) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof ModifierLetter) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof OtherLetter) {\n        return true;\n    };\n    return false;\n};\nvar isMark = function (c) {\n    var v = generalCategory(c);\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof NonSpacingMark) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof SpacingCombiningMark) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof EnclosingMark) {\n        return true;\n    };\n    return false;\n};\nvar isNumber = function (c) {\n    var v = generalCategory(c);\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof DecimalNumber) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof LetterNumber) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof OtherNumber) {\n        return true;\n    };\n    return false;\n};\nvar isPunctuation = function (c) {\n    var v = generalCategory(c);\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof ConnectorPunctuation) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof DashPunctuation) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof OpenPunctuation) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof ClosePunctuation) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof InitialQuote) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof FinalQuote) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof OtherPunctuation) {\n        return true;\n    };\n    return false;\n};\nvar isSeparator = function (c) {\n    var v = generalCategory(c);\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof Space) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof LineSeparator) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof ParagraphSeparator) {\n        return true;\n    };\n    return false;\n};\nvar isSymbol = function (c) {\n    var v = generalCategory(c);\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof MathSymbol) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof CurrencySymbol) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof ModifierSymbol) {\n        return true;\n    };\n    if (v instanceof Data_Maybe.Just && v.value0 instanceof OtherSymbol) {\n        return true;\n    };\n    return false;\n};\nvar generalCatToUnicodeCat = function (v) {\n    if (v instanceof UppercaseLetter) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_LU.value;\n    };\n    if (v instanceof LowercaseLetter) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_LL.value;\n    };\n    if (v instanceof TitlecaseLetter) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_LT.value;\n    };\n    if (v instanceof ModifierLetter) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_LM.value;\n    };\n    if (v instanceof OtherLetter) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_LO.value;\n    };\n    if (v instanceof NonSpacingMark) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_MN.value;\n    };\n    if (v instanceof SpacingCombiningMark) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_MC.value;\n    };\n    if (v instanceof EnclosingMark) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_ME.value;\n    };\n    if (v instanceof DecimalNumber) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_ND.value;\n    };\n    if (v instanceof LetterNumber) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_NL.value;\n    };\n    if (v instanceof OtherNumber) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_NO.value;\n    };\n    if (v instanceof ConnectorPunctuation) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_PC.value;\n    };\n    if (v instanceof DashPunctuation) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_PD.value;\n    };\n    if (v instanceof OpenPunctuation) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_PS.value;\n    };\n    if (v instanceof ClosePunctuation) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_PE.value;\n    };\n    if (v instanceof InitialQuote) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_PI.value;\n    };\n    if (v instanceof FinalQuote) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_PF.value;\n    };\n    if (v instanceof OtherPunctuation) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_PO.value;\n    };\n    if (v instanceof MathSymbol) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_SM.value;\n    };\n    if (v instanceof CurrencySymbol) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_SC.value;\n    };\n    if (v instanceof ModifierSymbol) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_SK.value;\n    };\n    if (v instanceof OtherSymbol) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_SO.value;\n    };\n    if (v instanceof Space) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_ZS.value;\n    };\n    if (v instanceof LineSeparator) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_ZL.value;\n    };\n    if (v instanceof ParagraphSeparator) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_ZP.value;\n    };\n    if (v instanceof Control) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_CC.value;\n    };\n    if (v instanceof Format) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_CF.value;\n    };\n    if (v instanceof Surrogate) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_CS.value;\n    };\n    if (v instanceof PrivateUse) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_CO.value;\n    };\n    if (v instanceof NotAssigned) {\n        return Data_CodePoint_Unicode_Internal.NUMCAT_CN.value;\n    };\n    throw new Error(\"Failed pattern match at Data.CodePoint.Unicode (line 174, column 1 - line 174, column 61): \" + [ v.constructor.name ]);\n};\nvar generalCatToInt = function (v) {\n    if (v instanceof UppercaseLetter) {\n        return 1;\n    };\n    if (v instanceof LowercaseLetter) {\n        return 2;\n    };\n    if (v instanceof TitlecaseLetter) {\n        return 3;\n    };\n    if (v instanceof ModifierLetter) {\n        return 4;\n    };\n    if (v instanceof OtherLetter) {\n        return 5;\n    };\n    if (v instanceof NonSpacingMark) {\n        return 6;\n    };\n    if (v instanceof SpacingCombiningMark) {\n        return 7;\n    };\n    if (v instanceof EnclosingMark) {\n        return 8;\n    };\n    if (v instanceof DecimalNumber) {\n        return 9;\n    };\n    if (v instanceof LetterNumber) {\n        return 10;\n    };\n    if (v instanceof OtherNumber) {\n        return 11;\n    };\n    if (v instanceof ConnectorPunctuation) {\n        return 12;\n    };\n    if (v instanceof DashPunctuation) {\n        return 13;\n    };\n    if (v instanceof OpenPunctuation) {\n        return 14;\n    };\n    if (v instanceof ClosePunctuation) {\n        return 15;\n    };\n    if (v instanceof InitialQuote) {\n        return 16;\n    };\n    if (v instanceof FinalQuote) {\n        return 17;\n    };\n    if (v instanceof OtherPunctuation) {\n        return 18;\n    };\n    if (v instanceof MathSymbol) {\n        return 19;\n    };\n    if (v instanceof CurrencySymbol) {\n        return 20;\n    };\n    if (v instanceof ModifierSymbol) {\n        return 21;\n    };\n    if (v instanceof OtherSymbol) {\n        return 22;\n    };\n    if (v instanceof Space) {\n        return 23;\n    };\n    if (v instanceof LineSeparator) {\n        return 24;\n    };\n    if (v instanceof ParagraphSeparator) {\n        return 25;\n    };\n    if (v instanceof Control) {\n        return 26;\n    };\n    if (v instanceof Format) {\n        return 27;\n    };\n    if (v instanceof Surrogate) {\n        return 28;\n    };\n    if (v instanceof PrivateUse) {\n        return 29;\n    };\n    if (v instanceof NotAssigned) {\n        return 30;\n    };\n    throw new Error(\"Failed pattern match at Data.CodePoint.Unicode (line 142, column 1 - line 142, column 42): \" + [ v.constructor.name ]);\n};\nvar eqGeneralCategory = {\n    eq: function (v) {\n        return function (v1) {\n            if (v instanceof UppercaseLetter && v1 instanceof UppercaseLetter) {\n                return true;\n            };\n            if (v instanceof LowercaseLetter && v1 instanceof LowercaseLetter) {\n                return true;\n            };\n            if (v instanceof TitlecaseLetter && v1 instanceof TitlecaseLetter) {\n                return true;\n            };\n            if (v instanceof ModifierLetter && v1 instanceof ModifierLetter) {\n                return true;\n            };\n            if (v instanceof OtherLetter && v1 instanceof OtherLetter) {\n                return true;\n            };\n            if (v instanceof NonSpacingMark && v1 instanceof NonSpacingMark) {\n                return true;\n            };\n            if (v instanceof SpacingCombiningMark && v1 instanceof SpacingCombiningMark) {\n                return true;\n            };\n            if (v instanceof EnclosingMark && v1 instanceof EnclosingMark) {\n                return true;\n            };\n            if (v instanceof DecimalNumber && v1 instanceof DecimalNumber) {\n                return true;\n            };\n            if (v instanceof LetterNumber && v1 instanceof LetterNumber) {\n                return true;\n            };\n            if (v instanceof OtherNumber && v1 instanceof OtherNumber) {\n                return true;\n            };\n            if (v instanceof ConnectorPunctuation && v1 instanceof ConnectorPunctuation) {\n                return true;\n            };\n            if (v instanceof DashPunctuation && v1 instanceof DashPunctuation) {\n                return true;\n            };\n            if (v instanceof OpenPunctuation && v1 instanceof OpenPunctuation) {\n                return true;\n            };\n            if (v instanceof ClosePunctuation && v1 instanceof ClosePunctuation) {\n                return true;\n            };\n            if (v instanceof InitialQuote && v1 instanceof InitialQuote) {\n                return true;\n            };\n            if (v instanceof FinalQuote && v1 instanceof FinalQuote) {\n                return true;\n            };\n            if (v instanceof OtherPunctuation && v1 instanceof OtherPunctuation) {\n                return true;\n            };\n            if (v instanceof MathSymbol && v1 instanceof MathSymbol) {\n                return true;\n            };\n            if (v instanceof CurrencySymbol && v1 instanceof CurrencySymbol) {\n                return true;\n            };\n            if (v instanceof ModifierSymbol && v1 instanceof ModifierSymbol) {\n                return true;\n            };\n            if (v instanceof OtherSymbol && v1 instanceof OtherSymbol) {\n                return true;\n            };\n            if (v instanceof Space && v1 instanceof Space) {\n                return true;\n            };\n            if (v instanceof LineSeparator && v1 instanceof LineSeparator) {\n                return true;\n            };\n            if (v instanceof ParagraphSeparator && v1 instanceof ParagraphSeparator) {\n                return true;\n            };\n            if (v instanceof Control && v1 instanceof Control) {\n                return true;\n            };\n            if (v instanceof Format && v1 instanceof Format) {\n                return true;\n            };\n            if (v instanceof Surrogate && v1 instanceof Surrogate) {\n                return true;\n            };\n            if (v instanceof PrivateUse && v1 instanceof PrivateUse) {\n                return true;\n            };\n            if (v instanceof NotAssigned && v1 instanceof NotAssigned) {\n                return true;\n            };\n            return false;\n        };\n    }\n};\nvar ordGeneralCategory = {\n    compare: function (catA) {\n        return function (catB) {\n            return Data_Ord.compare(Data_Ord.ordInt)(generalCatToInt(catA))(generalCatToInt(catB));\n        };\n    },\n    Eq0: function () {\n        return eqGeneralCategory;\n    }\n};\nvar digitToInt = function (dictWarn) {\n    return hexDigitToInt;\n};\nvar decDigitToInt = function (c) {\n    if (isDecDigit(c)) {\n        return Data_Maybe.Just.create(Data_Enum.fromEnum(Data_String_CodePoints.boundedEnumCodePoint)(c) - Data_Char.toCharCode(\"0\") | 0);\n    };\n    if (Data_Boolean.otherwise) {\n        return Data_Maybe.Nothing.value;\n    };\n    throw new Error(\"Failed pattern match at Data.CodePoint.Unicode (line 613, column 1 - line 613, column 40): \" + [ c.constructor.name ]);\n};\nvar caseFoldSimple = modify(Data_CodePoint_Unicode_Internal_Casing.fold);\nvar caseFold = modifyFull(Data_CodePoint_Unicode_Internal_Casing.foldFull);\nvar boundedGeneralCategory = {\n    bottom: UppercaseLetter.value,\n    top: NotAssigned.value,\n    Ord0: function () {\n        return ordGeneralCategory;\n    }\n};\nmodule.exports = {\n    isAscii: isAscii,\n    isAsciiLower: isAsciiLower,\n    isAsciiUpper: isAsciiUpper,\n    isLatin1: isLatin1,\n    isLower: isLower,\n    isUpper: isUpper,\n    isAlpha: isAlpha,\n    isAlphaNum: isAlphaNum,\n    isLetter: isLetter,\n    isDigit: isDigit,\n    isDecDigit: isDecDigit,\n    isOctDigit: isOctDigit,\n    isHexDigit: isHexDigit,\n    isControl: isControl,\n    isPrint: isPrint,\n    isSpace: isSpace,\n    isSymbol: isSymbol,\n    isSeparator: isSeparator,\n    isPunctuation: isPunctuation,\n    isMark: isMark,\n    isNumber: isNumber,\n    digitToInt: digitToInt,\n    hexDigitToInt: hexDigitToInt,\n    decDigitToInt: decDigitToInt,\n    octDigitToInt: octDigitToInt,\n    toLower: toLower,\n    toUpper: toUpper,\n    toTitle: toTitle,\n    caseFold: caseFold,\n    toLowerSimple: toLowerSimple,\n    toUpperSimple: toUpperSimple,\n    toTitleSimple: toTitleSimple,\n    caseFoldSimple: caseFoldSimple,\n    UppercaseLetter: UppercaseLetter,\n    LowercaseLetter: LowercaseLetter,\n    TitlecaseLetter: TitlecaseLetter,\n    ModifierLetter: ModifierLetter,\n    OtherLetter: OtherLetter,\n    NonSpacingMark: NonSpacingMark,\n    SpacingCombiningMark: SpacingCombiningMark,\n    EnclosingMark: EnclosingMark,\n    DecimalNumber: DecimalNumber,\n    LetterNumber: LetterNumber,\n    OtherNumber: OtherNumber,\n    ConnectorPunctuation: ConnectorPunctuation,\n    DashPunctuation: DashPunctuation,\n    OpenPunctuation: OpenPunctuation,\n    ClosePunctuation: ClosePunctuation,\n    InitialQuote: InitialQuote,\n    FinalQuote: FinalQuote,\n    OtherPunctuation: OtherPunctuation,\n    MathSymbol: MathSymbol,\n    CurrencySymbol: CurrencySymbol,\n    ModifierSymbol: ModifierSymbol,\n    OtherSymbol: OtherSymbol,\n    Space: Space,\n    LineSeparator: LineSeparator,\n    ParagraphSeparator: ParagraphSeparator,\n    Control: Control,\n    Format: Format,\n    Surrogate: Surrogate,\n    PrivateUse: PrivateUse,\n    NotAssigned: NotAssigned,\n    unicodeCatToGeneralCat: unicodeCatToGeneralCat,\n    generalCatToInt: generalCatToInt,\n    generalCatToUnicodeCat: generalCatToUnicodeCat,\n    generalCategory: generalCategory,\n    showGeneralCategory: showGeneralCategory,\n    eqGeneralCategory: eqGeneralCategory,\n    ordGeneralCategory: ordGeneralCategory,\n    boundedGeneralCategory: boundedGeneralCategory\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs?");

/***/ }),

/***/ "./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal.purs":
/*!************************************************************************!*\
  !*** ./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal.purs ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Int = __webpack_require__(/*! ./.spago/integers/v5.0.0/src/Data/Int.purs */ \"./.spago/integers/v5.0.0/src/Data/Int.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ordering = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ordering.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ordering.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar NUMCAT_LU = (function () {\n    function NUMCAT_LU() {\n\n    };\n    NUMCAT_LU.value = new NUMCAT_LU();\n    return NUMCAT_LU;\n})();\nvar NUMCAT_LL = (function () {\n    function NUMCAT_LL() {\n\n    };\n    NUMCAT_LL.value = new NUMCAT_LL();\n    return NUMCAT_LL;\n})();\nvar NUMCAT_LT = (function () {\n    function NUMCAT_LT() {\n\n    };\n    NUMCAT_LT.value = new NUMCAT_LT();\n    return NUMCAT_LT;\n})();\nvar NUMCAT_LM = (function () {\n    function NUMCAT_LM() {\n\n    };\n    NUMCAT_LM.value = new NUMCAT_LM();\n    return NUMCAT_LM;\n})();\nvar NUMCAT_LO = (function () {\n    function NUMCAT_LO() {\n\n    };\n    NUMCAT_LO.value = new NUMCAT_LO();\n    return NUMCAT_LO;\n})();\nvar NUMCAT_MN = (function () {\n    function NUMCAT_MN() {\n\n    };\n    NUMCAT_MN.value = new NUMCAT_MN();\n    return NUMCAT_MN;\n})();\nvar NUMCAT_MC = (function () {\n    function NUMCAT_MC() {\n\n    };\n    NUMCAT_MC.value = new NUMCAT_MC();\n    return NUMCAT_MC;\n})();\nvar NUMCAT_ME = (function () {\n    function NUMCAT_ME() {\n\n    };\n    NUMCAT_ME.value = new NUMCAT_ME();\n    return NUMCAT_ME;\n})();\nvar NUMCAT_ND = (function () {\n    function NUMCAT_ND() {\n\n    };\n    NUMCAT_ND.value = new NUMCAT_ND();\n    return NUMCAT_ND;\n})();\nvar NUMCAT_NL = (function () {\n    function NUMCAT_NL() {\n\n    };\n    NUMCAT_NL.value = new NUMCAT_NL();\n    return NUMCAT_NL;\n})();\nvar NUMCAT_NO = (function () {\n    function NUMCAT_NO() {\n\n    };\n    NUMCAT_NO.value = new NUMCAT_NO();\n    return NUMCAT_NO;\n})();\nvar NUMCAT_PC = (function () {\n    function NUMCAT_PC() {\n\n    };\n    NUMCAT_PC.value = new NUMCAT_PC();\n    return NUMCAT_PC;\n})();\nvar NUMCAT_PD = (function () {\n    function NUMCAT_PD() {\n\n    };\n    NUMCAT_PD.value = new NUMCAT_PD();\n    return NUMCAT_PD;\n})();\nvar NUMCAT_PS = (function () {\n    function NUMCAT_PS() {\n\n    };\n    NUMCAT_PS.value = new NUMCAT_PS();\n    return NUMCAT_PS;\n})();\nvar NUMCAT_PE = (function () {\n    function NUMCAT_PE() {\n\n    };\n    NUMCAT_PE.value = new NUMCAT_PE();\n    return NUMCAT_PE;\n})();\nvar NUMCAT_PI = (function () {\n    function NUMCAT_PI() {\n\n    };\n    NUMCAT_PI.value = new NUMCAT_PI();\n    return NUMCAT_PI;\n})();\nvar NUMCAT_PF = (function () {\n    function NUMCAT_PF() {\n\n    };\n    NUMCAT_PF.value = new NUMCAT_PF();\n    return NUMCAT_PF;\n})();\nvar NUMCAT_PO = (function () {\n    function NUMCAT_PO() {\n\n    };\n    NUMCAT_PO.value = new NUMCAT_PO();\n    return NUMCAT_PO;\n})();\nvar NUMCAT_SM = (function () {\n    function NUMCAT_SM() {\n\n    };\n    NUMCAT_SM.value = new NUMCAT_SM();\n    return NUMCAT_SM;\n})();\nvar NUMCAT_SC = (function () {\n    function NUMCAT_SC() {\n\n    };\n    NUMCAT_SC.value = new NUMCAT_SC();\n    return NUMCAT_SC;\n})();\nvar NUMCAT_SK = (function () {\n    function NUMCAT_SK() {\n\n    };\n    NUMCAT_SK.value = new NUMCAT_SK();\n    return NUMCAT_SK;\n})();\nvar NUMCAT_SO = (function () {\n    function NUMCAT_SO() {\n\n    };\n    NUMCAT_SO.value = new NUMCAT_SO();\n    return NUMCAT_SO;\n})();\nvar NUMCAT_ZS = (function () {\n    function NUMCAT_ZS() {\n\n    };\n    NUMCAT_ZS.value = new NUMCAT_ZS();\n    return NUMCAT_ZS;\n})();\nvar NUMCAT_ZL = (function () {\n    function NUMCAT_ZL() {\n\n    };\n    NUMCAT_ZL.value = new NUMCAT_ZL();\n    return NUMCAT_ZL;\n})();\nvar NUMCAT_ZP = (function () {\n    function NUMCAT_ZP() {\n\n    };\n    NUMCAT_ZP.value = new NUMCAT_ZP();\n    return NUMCAT_ZP;\n})();\nvar NUMCAT_CC = (function () {\n    function NUMCAT_CC() {\n\n    };\n    NUMCAT_CC.value = new NUMCAT_CC();\n    return NUMCAT_CC;\n})();\nvar NUMCAT_CF = (function () {\n    function NUMCAT_CF() {\n\n    };\n    NUMCAT_CF.value = new NUMCAT_CF();\n    return NUMCAT_CF;\n})();\nvar NUMCAT_CS = (function () {\n    function NUMCAT_CS() {\n\n    };\n    NUMCAT_CS.value = new NUMCAT_CS();\n    return NUMCAT_CS;\n})();\nvar NUMCAT_CO = (function () {\n    function NUMCAT_CO() {\n\n    };\n    NUMCAT_CO.value = new NUMCAT_CO();\n    return NUMCAT_CO;\n})();\nvar NUMCAT_CN = (function () {\n    function NUMCAT_CN() {\n\n    };\n    NUMCAT_CN.value = new NUMCAT_CN();\n    return NUMCAT_CN;\n})();\nvar ConversionRule = function (x) {\n    return x;\n};\nvar CharBlock = function (x) {\n    return x;\n};\nvar showUnicodeCategory = {\n    show: function (v) {\n        if (v instanceof NUMCAT_LU) {\n            return \"NUMCAT_LU\";\n        };\n        if (v instanceof NUMCAT_LL) {\n            return \"NUMCAT_LL\";\n        };\n        if (v instanceof NUMCAT_LT) {\n            return \"NUMCAT_LT\";\n        };\n        if (v instanceof NUMCAT_LM) {\n            return \"NUMCAT_LM\";\n        };\n        if (v instanceof NUMCAT_LO) {\n            return \"NUMCAT_LO\";\n        };\n        if (v instanceof NUMCAT_MN) {\n            return \"NUMCAT_MN\";\n        };\n        if (v instanceof NUMCAT_MC) {\n            return \"NUMCAT_MC\";\n        };\n        if (v instanceof NUMCAT_ME) {\n            return \"NUMCAT_ME\";\n        };\n        if (v instanceof NUMCAT_ND) {\n            return \"NUMCAT_ND\";\n        };\n        if (v instanceof NUMCAT_NL) {\n            return \"NUMCAT_NL\";\n        };\n        if (v instanceof NUMCAT_NO) {\n            return \"NUMCAT_NO\";\n        };\n        if (v instanceof NUMCAT_PC) {\n            return \"NUMCAT_PC\";\n        };\n        if (v instanceof NUMCAT_PD) {\n            return \"NUMCAT_PD\";\n        };\n        if (v instanceof NUMCAT_PS) {\n            return \"NUMCAT_PS\";\n        };\n        if (v instanceof NUMCAT_PE) {\n            return \"NUMCAT_PE\";\n        };\n        if (v instanceof NUMCAT_PI) {\n            return \"NUMCAT_PI\";\n        };\n        if (v instanceof NUMCAT_PF) {\n            return \"NUMCAT_PF\";\n        };\n        if (v instanceof NUMCAT_PO) {\n            return \"NUMCAT_PO\";\n        };\n        if (v instanceof NUMCAT_SM) {\n            return \"NUMCAT_SM\";\n        };\n        if (v instanceof NUMCAT_SC) {\n            return \"NUMCAT_SC\";\n        };\n        if (v instanceof NUMCAT_SK) {\n            return \"NUMCAT_SK\";\n        };\n        if (v instanceof NUMCAT_SO) {\n            return \"NUMCAT_SO\";\n        };\n        if (v instanceof NUMCAT_ZS) {\n            return \"NUMCAT_ZS\";\n        };\n        if (v instanceof NUMCAT_ZL) {\n            return \"NUMCAT_ZL\";\n        };\n        if (v instanceof NUMCAT_ZP) {\n            return \"NUMCAT_ZP\";\n        };\n        if (v instanceof NUMCAT_CC) {\n            return \"NUMCAT_CC\";\n        };\n        if (v instanceof NUMCAT_CF) {\n            return \"NUMCAT_CF\";\n        };\n        if (v instanceof NUMCAT_CS) {\n            return \"NUMCAT_CS\";\n        };\n        if (v instanceof NUMCAT_CO) {\n            return \"NUMCAT_CO\";\n        };\n        if (v instanceof NUMCAT_CN) {\n            return \"NUMCAT_CN\";\n        };\n        throw new Error(\"Failed pattern match at Data.CodePoint.Unicode.Internal (line 49, column 1 - line 79, column 33): \" + [ v.constructor.name ]);\n    }\n};\nvar showConversionRule = {\n    show: function (v) {\n        return \"ConversionRule { category: \" + (Data_Show.show(Data_Show.showInt)(v.category) + (\", unicodeCat: \" + (Data_Show.show(showUnicodeCategory)(v.unicodeCat) + (\", possible: \" + (Data_Show.show(Data_Show.showInt)(v.possible) + (\", updist: \" + (Data_Show.show(Data_Show.showInt)(v.updist) + (\", lowdist: \" + (Data_Show.show(Data_Show.showInt)(v.lowdist) + (\", titledist: \" + (Data_Show.show(Data_Show.showInt)(v.titledist) + \" }\")))))))))));\n    }\n};\nvar showCharBlock = {\n    show: function (v) {\n        return \"CharBlock { start: \" + (Data_Show.show(Data_Show.showInt)(v.start) + (\", length: \" + (Data_Show.show(Data_Show.showInt)(v.length) + (\", convRule: \" + (Data_Show.show(showConversionRule)(v.convRule) + \" }\")))));\n    }\n};\nvar numSpaceBlocks = 7;\nvar numRules = 205;\nvar numLat1Blocks = 63;\nvar numConvBlocks = 1332;\nvar numBlocks = 3396;\nvar maxUniChar = 1114109;\nvar gencatZS = 2;\nvar rule1 = {\n    category: gencatZS,\n    unicodeCat: NUMCAT_ZS.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar spacechars = [ {\n    start: 32,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 160,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 5760,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 8192,\n    length: 11,\n    convRule: rule1\n}, {\n    start: 8239,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 8287,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 12288,\n    length: 1,\n    convRule: rule1\n} ];\nvar gencatZP = 67108864;\nvar rule162 = {\n    category: gencatZP,\n    unicodeCat: NUMCAT_ZP.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatZL = 33554432;\nvar rule161 = {\n    category: gencatZL,\n    unicodeCat: NUMCAT_ZL.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatSO = 8192;\nvar rule13 = {\n    category: gencatSO,\n    unicodeCat: NUMCAT_SO.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar rule170 = {\n    category: gencatSO,\n    unicodeCat: NUMCAT_SO.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 26,\n    titledist: 0\n};\nvar rule171 = {\n    category: gencatSO,\n    unicodeCat: NUMCAT_SO.value,\n    possible: 1,\n    updist: -26 | 0,\n    lowdist: 0,\n    titledist: -26 | 0\n};\nvar gencatSM = 64;\nvar rule6 = {\n    category: gencatSM,\n    unicodeCat: NUMCAT_SM.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatSK = 1024;\nvar rule10 = {\n    category: gencatSK,\n    unicodeCat: NUMCAT_SK.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatSC = 8;\nvar rule3 = {\n    category: gencatSC,\n    unicodeCat: NUMCAT_SC.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatPS = 16;\nvar rule4 = {\n    category: gencatPS,\n    unicodeCat: NUMCAT_PS.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatPO = 4;\nvar rule2 = {\n    category: gencatPO,\n    unicodeCat: NUMCAT_PO.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatPI = 32768;\nvar rule15 = {\n    category: gencatPI,\n    unicodeCat: NUMCAT_PI.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatPF = 262144;\nvar rule19 = {\n    category: gencatPF,\n    unicodeCat: NUMCAT_PF.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatPE = 32;\nvar rule5 = {\n    category: gencatPE,\n    unicodeCat: NUMCAT_PE.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatPD = 128;\nvar rule7 = {\n    category: gencatPD,\n    unicodeCat: NUMCAT_PD.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatPC = 2048;\nvar rule11 = {\n    category: gencatPC,\n    unicodeCat: NUMCAT_PC.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatNO = 131072;\nvar rule17 = {\n    category: gencatNO,\n    unicodeCat: NUMCAT_NO.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatNL = 16777216;\nvar rule128 = {\n    category: gencatNL,\n    unicodeCat: NUMCAT_NL.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar rule168 = {\n    category: gencatNL,\n    unicodeCat: NUMCAT_NL.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 16,\n    titledist: 0\n};\nvar rule169 = {\n    category: gencatNL,\n    unicodeCat: NUMCAT_NL.value,\n    possible: 1,\n    updist: -16 | 0,\n    lowdist: 0,\n    titledist: -16 | 0\n};\nvar gencatND = 256;\nvar rule8 = {\n    category: gencatND,\n    unicodeCat: NUMCAT_ND.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatMN = 2097152;\nvar rule92 = {\n    category: gencatMN,\n    unicodeCat: NUMCAT_MN.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar rule93 = {\n    category: gencatMN,\n    unicodeCat: NUMCAT_MN.value,\n    possible: 1,\n    updist: 84,\n    lowdist: 0,\n    titledist: 84\n};\nvar gencatME = 4194304;\nvar rule119 = {\n    category: gencatME,\n    unicodeCat: NUMCAT_ME.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatMC = 8388608;\nvar rule124 = {\n    category: gencatMC,\n    unicodeCat: NUMCAT_MC.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatLU = 512;\nvar nullrule = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_CN.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar rule104 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 8,\n    titledist: 0\n};\nvar rule107 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar rule115 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -60 | 0,\n    titledist: 0\n};\nvar rule117 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -7 | 0,\n    titledist: 0\n};\nvar rule118 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 80,\n    titledist: 0\n};\nvar rule120 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 15,\n    titledist: 0\n};\nvar rule122 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 48,\n    titledist: 0\n};\nvar rule125 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 7264,\n    titledist: 0\n};\nvar rule127 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 38864,\n    titledist: 0\n};\nvar rule137 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -3008 | 0,\n    titledist: 0\n};\nvar rule142 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -7615 | 0,\n    titledist: 0\n};\nvar rule144 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -8 | 0,\n    titledist: 0\n};\nvar rule153 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -74 | 0,\n    titledist: 0\n};\nvar rule156 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -86 | 0,\n    titledist: 0\n};\nvar rule157 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -100 | 0,\n    titledist: 0\n};\nvar rule158 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -112 | 0,\n    titledist: 0\n};\nvar rule159 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -128 | 0,\n    titledist: 0\n};\nvar rule160 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -126 | 0,\n    titledist: 0\n};\nvar rule163 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -7517 | 0,\n    titledist: 0\n};\nvar rule164 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -8383 | 0,\n    titledist: 0\n};\nvar rule165 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -8262 | 0,\n    titledist: 0\n};\nvar rule166 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 28,\n    titledist: 0\n};\nvar rule172 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -10743 | 0,\n    titledist: 0\n};\nvar rule173 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -3814 | 0,\n    titledist: 0\n};\nvar rule174 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -10727 | 0,\n    titledist: 0\n};\nvar rule177 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -10780 | 0,\n    titledist: 0\n};\nvar rule178 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -10749 | 0,\n    titledist: 0\n};\nvar rule179 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -10783 | 0,\n    titledist: 0\n};\nvar rule180 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -10782 | 0,\n    titledist: 0\n};\nvar rule181 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -10815 | 0,\n    titledist: 0\n};\nvar rule183 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -35332 | 0,\n    titledist: 0\n};\nvar rule184 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -42280 | 0,\n    titledist: 0\n};\nvar rule186 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -42308 | 0,\n    titledist: 0\n};\nvar rule187 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -42319 | 0,\n    titledist: 0\n};\nvar rule188 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -42315 | 0,\n    titledist: 0\n};\nvar rule189 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -42305 | 0,\n    titledist: 0\n};\nvar rule190 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -42258 | 0,\n    titledist: 0\n};\nvar rule191 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -42282 | 0,\n    titledist: 0\n};\nvar rule192 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -42261 | 0,\n    titledist: 0\n};\nvar rule193 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 928,\n    titledist: 0\n};\nvar rule194 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -48 | 0,\n    titledist: 0\n};\nvar rule195 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -42307 | 0,\n    titledist: 0\n};\nvar rule196 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -35384 | 0,\n    titledist: 0\n};\nvar rule201 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 40,\n    titledist: 0\n};\nvar rule203 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 34,\n    titledist: 0\n};\nvar rule22 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 1,\n    titledist: 0\n};\nvar rule24 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -199 | 0,\n    titledist: 0\n};\nvar rule26 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -121 | 0,\n    titledist: 0\n};\nvar rule29 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 210,\n    titledist: 0\n};\nvar rule30 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 206,\n    titledist: 0\n};\nvar rule31 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 205,\n    titledist: 0\n};\nvar rule32 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 79,\n    titledist: 0\n};\nvar rule33 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 202,\n    titledist: 0\n};\nvar rule34 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 203,\n    titledist: 0\n};\nvar rule35 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 207,\n    titledist: 0\n};\nvar rule37 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 211,\n    titledist: 0\n};\nvar rule38 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 209,\n    titledist: 0\n};\nvar rule40 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 213,\n    titledist: 0\n};\nvar rule42 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 214,\n    titledist: 0\n};\nvar rule43 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 218,\n    titledist: 0\n};\nvar rule44 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 217,\n    titledist: 0\n};\nvar rule45 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 219,\n    titledist: 0\n};\nvar rule47 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 2,\n    titledist: 1\n};\nvar rule51 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -97 | 0,\n    titledist: 0\n};\nvar rule52 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -56 | 0,\n    titledist: 0\n};\nvar rule53 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -130 | 0,\n    titledist: 0\n};\nvar rule54 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 10795,\n    titledist: 0\n};\nvar rule55 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -163 | 0,\n    titledist: 0\n};\nvar rule56 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 10792,\n    titledist: 0\n};\nvar rule58 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -195 | 0,\n    titledist: 0\n};\nvar rule59 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 69,\n    titledist: 0\n};\nvar rule60 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 71,\n    titledist: 0\n};\nvar rule9 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 32,\n    titledist: 0\n};\nvar rule94 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 116,\n    titledist: 0\n};\nvar rule95 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 38,\n    titledist: 0\n};\nvar rule96 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 37,\n    titledist: 0\n};\nvar rule97 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 64,\n    titledist: 0\n};\nvar rule98 = {\n    category: gencatLU,\n    unicodeCat: NUMCAT_LU.value,\n    possible: 1,\n    updist: 0,\n    lowdist: 63,\n    titledist: 0\n};\nvar gencatLT = 524288;\nvar rule151 = {\n    category: gencatLT,\n    unicodeCat: NUMCAT_LT.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -8 | 0,\n    titledist: 0\n};\nvar rule154 = {\n    category: gencatLT,\n    unicodeCat: NUMCAT_LT.value,\n    possible: 1,\n    updist: 0,\n    lowdist: -9 | 0,\n    titledist: 0\n};\nvar rule48 = {\n    category: gencatLT,\n    unicodeCat: NUMCAT_LT.value,\n    possible: 1,\n    updist: -1 | 0,\n    lowdist: 1,\n    titledist: 0\n};\nvar gencatLO = 16384;\nvar rule14 = {\n    category: gencatLO,\n    unicodeCat: NUMCAT_LO.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatLM = 1048576;\nvar rule91 = {\n    category: gencatLM,\n    unicodeCat: NUMCAT_LM.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatLL = 4096;\nvar rule100 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -37 | 0,\n    lowdist: 0,\n    titledist: -37 | 0\n};\nvar rule101 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -31 | 0,\n    lowdist: 0,\n    titledist: -31 | 0\n};\nvar rule102 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -64 | 0,\n    lowdist: 0,\n    titledist: -64 | 0\n};\nvar rule103 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -63 | 0,\n    lowdist: 0,\n    titledist: -63 | 0\n};\nvar rule105 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -62 | 0,\n    lowdist: 0,\n    titledist: -62 | 0\n};\nvar rule106 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -57 | 0,\n    lowdist: 0,\n    titledist: -57 | 0\n};\nvar rule108 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -47 | 0,\n    lowdist: 0,\n    titledist: -47 | 0\n};\nvar rule109 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -54 | 0,\n    lowdist: 0,\n    titledist: -54 | 0\n};\nvar rule110 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -8 | 0,\n    lowdist: 0,\n    titledist: -8 | 0\n};\nvar rule111 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -86 | 0,\n    lowdist: 0,\n    titledist: -86 | 0\n};\nvar rule112 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -80 | 0,\n    lowdist: 0,\n    titledist: -80 | 0\n};\nvar rule113 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 7,\n    lowdist: 0,\n    titledist: 7\n};\nvar rule114 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -116 | 0,\n    lowdist: 0,\n    titledist: -116 | 0\n};\nvar rule116 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -96 | 0,\n    lowdist: 0,\n    titledist: -96 | 0\n};\nvar rule12 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -32 | 0,\n    lowdist: 0,\n    titledist: -32 | 0\n};\nvar rule121 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -15 | 0,\n    lowdist: 0,\n    titledist: -15 | 0\n};\nvar rule123 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -48 | 0,\n    lowdist: 0,\n    titledist: -48 | 0\n};\nvar rule126 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 3008,\n    lowdist: 0,\n    titledist: 0\n};\nvar rule129 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -6254 | 0,\n    lowdist: 0,\n    titledist: -6254 | 0\n};\nvar rule130 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -6253 | 0,\n    lowdist: 0,\n    titledist: -6253 | 0\n};\nvar rule131 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -6244 | 0,\n    lowdist: 0,\n    titledist: -6244 | 0\n};\nvar rule132 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -6242 | 0,\n    lowdist: 0,\n    titledist: -6242 | 0\n};\nvar rule133 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -6243 | 0,\n    lowdist: 0,\n    titledist: -6243 | 0\n};\nvar rule134 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -6236 | 0,\n    lowdist: 0,\n    titledist: -6236 | 0\n};\nvar rule135 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -6181 | 0,\n    lowdist: 0,\n    titledist: -6181 | 0\n};\nvar rule136 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 35266,\n    lowdist: 0,\n    titledist: 35266\n};\nvar rule138 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 35332,\n    lowdist: 0,\n    titledist: 35332\n};\nvar rule139 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 3814,\n    lowdist: 0,\n    titledist: 3814\n};\nvar rule140 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 35384,\n    lowdist: 0,\n    titledist: 35384\n};\nvar rule141 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -59 | 0,\n    lowdist: 0,\n    titledist: -59 | 0\n};\nvar rule143 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 8,\n    lowdist: 0,\n    titledist: 8\n};\nvar rule145 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 74,\n    lowdist: 0,\n    titledist: 74\n};\nvar rule146 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 86,\n    lowdist: 0,\n    titledist: 86\n};\nvar rule147 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 100,\n    lowdist: 0,\n    titledist: 100\n};\nvar rule148 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 128,\n    lowdist: 0,\n    titledist: 128\n};\nvar rule149 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 112,\n    lowdist: 0,\n    titledist: 112\n};\nvar rule150 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 126,\n    lowdist: 0,\n    titledist: 126\n};\nvar rule152 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 9,\n    lowdist: 0,\n    titledist: 9\n};\nvar rule155 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -7205 | 0,\n    lowdist: 0,\n    titledist: -7205 | 0\n};\nvar rule167 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -28 | 0,\n    lowdist: 0,\n    titledist: -28 | 0\n};\nvar rule175 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -10795 | 0,\n    lowdist: 0,\n    titledist: -10795 | 0\n};\nvar rule176 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -10792 | 0,\n    lowdist: 0,\n    titledist: -10792 | 0\n};\nvar rule18 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 743,\n    lowdist: 0,\n    titledist: 743\n};\nvar rule182 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -7264 | 0,\n    lowdist: 0,\n    titledist: -7264 | 0\n};\nvar rule185 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 48,\n    lowdist: 0,\n    titledist: 48\n};\nvar rule197 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -928 | 0,\n    lowdist: 0,\n    titledist: -928 | 0\n};\nvar rule198 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -38864 | 0,\n    lowdist: 0,\n    titledist: -38864 | 0\n};\nvar rule20 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar rule202 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -40 | 0,\n    lowdist: 0,\n    titledist: -40 | 0\n};\nvar rule204 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -34 | 0,\n    lowdist: 0,\n    titledist: -34 | 0\n};\nvar rule21 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 121,\n    lowdist: 0,\n    titledist: 121\n};\nvar rule23 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -1 | 0,\n    lowdist: 0,\n    titledist: -1 | 0\n};\nvar rule25 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -232 | 0,\n    lowdist: 0,\n    titledist: -232 | 0\n};\nvar rule27 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -300 | 0,\n    lowdist: 0,\n    titledist: -300 | 0\n};\nvar rule28 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 195,\n    lowdist: 0,\n    titledist: 195\n};\nvar rule36 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 97,\n    lowdist: 0,\n    titledist: 97\n};\nvar rule39 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 163,\n    lowdist: 0,\n    titledist: 163\n};\nvar rule41 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 130,\n    lowdist: 0,\n    titledist: 130\n};\nvar rule46 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 56,\n    lowdist: 0,\n    titledist: 56\n};\nvar rule49 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -2 | 0,\n    lowdist: 0,\n    titledist: -1 | 0\n};\nvar rule50 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -79 | 0,\n    lowdist: 0,\n    titledist: -79 | 0\n};\nvar rule57 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 10815,\n    lowdist: 0,\n    titledist: 10815\n};\nvar rule61 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 10783,\n    lowdist: 0,\n    titledist: 10783\n};\nvar rule62 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 10780,\n    lowdist: 0,\n    titledist: 10780\n};\nvar rule63 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 10782,\n    lowdist: 0,\n    titledist: 10782\n};\nvar rule64 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -210 | 0,\n    lowdist: 0,\n    titledist: -210 | 0\n};\nvar rule65 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -206 | 0,\n    lowdist: 0,\n    titledist: -206 | 0\n};\nvar rule66 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -205 | 0,\n    lowdist: 0,\n    titledist: -205 | 0\n};\nvar rule67 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -202 | 0,\n    lowdist: 0,\n    titledist: -202 | 0\n};\nvar rule68 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -203 | 0,\n    lowdist: 0,\n    titledist: -203 | 0\n};\nvar rule69 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 42319,\n    lowdist: 0,\n    titledist: 42319\n};\nvar rule70 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 42315,\n    lowdist: 0,\n    titledist: 42315\n};\nvar rule71 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -207 | 0,\n    lowdist: 0,\n    titledist: -207 | 0\n};\nvar rule72 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 42280,\n    lowdist: 0,\n    titledist: 42280\n};\nvar rule73 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 42308,\n    lowdist: 0,\n    titledist: 42308\n};\nvar rule74 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -209 | 0,\n    lowdist: 0,\n    titledist: -209 | 0\n};\nvar rule75 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -211 | 0,\n    lowdist: 0,\n    titledist: -211 | 0\n};\nvar rule76 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 10743,\n    lowdist: 0,\n    titledist: 10743\n};\nvar rule77 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 42305,\n    lowdist: 0,\n    titledist: 42305\n};\nvar rule78 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 10749,\n    lowdist: 0,\n    titledist: 10749\n};\nvar rule79 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -213 | 0,\n    lowdist: 0,\n    titledist: -213 | 0\n};\nvar rule80 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -214 | 0,\n    lowdist: 0,\n    titledist: -214 | 0\n};\nvar rule81 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 10727,\n    lowdist: 0,\n    titledist: 10727\n};\nvar rule82 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -218 | 0,\n    lowdist: 0,\n    titledist: -218 | 0\n};\nvar rule83 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 42307,\n    lowdist: 0,\n    titledist: 42307\n};\nvar rule84 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 42282,\n    lowdist: 0,\n    titledist: 42282\n};\nvar rule85 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -69 | 0,\n    lowdist: 0,\n    titledist: -69 | 0\n};\nvar rule86 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -217 | 0,\n    lowdist: 0,\n    titledist: -217 | 0\n};\nvar rule87 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -71 | 0,\n    lowdist: 0,\n    titledist: -71 | 0\n};\nvar rule88 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -219 | 0,\n    lowdist: 0,\n    titledist: -219 | 0\n};\nvar rule89 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 42261,\n    lowdist: 0,\n    titledist: 42261\n};\nvar rule90 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: 42258,\n    lowdist: 0,\n    titledist: 42258\n};\nvar rule99 = {\n    category: gencatLL,\n    unicodeCat: NUMCAT_LL.value,\n    possible: 1,\n    updist: -38 | 0,\n    lowdist: 0,\n    titledist: -38 | 0\n};\nvar gencatCS = 134217728;\nvar rule199 = {\n    category: gencatCS,\n    unicodeCat: NUMCAT_CS.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatCO = 268435456;\nvar rule200 = {\n    category: gencatCO,\n    unicodeCat: NUMCAT_CO.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatCF = 65536;\nvar rule16 = {\n    category: gencatCF,\n    unicodeCat: NUMCAT_CF.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar gencatCC = 1;\nvar rule0 = {\n    category: gencatCC,\n    unicodeCat: NUMCAT_CC.value,\n    possible: 0,\n    updist: 0,\n    lowdist: 0,\n    titledist: 0\n};\nvar convchars = [ {\n    start: 65,\n    length: 26,\n    convRule: rule9\n}, {\n    start: 97,\n    length: 26,\n    convRule: rule12\n}, {\n    start: 181,\n    length: 1,\n    convRule: rule18\n}, {\n    start: 192,\n    length: 23,\n    convRule: rule9\n}, {\n    start: 216,\n    length: 7,\n    convRule: rule9\n}, {\n    start: 224,\n    length: 23,\n    convRule: rule12\n}, {\n    start: 248,\n    length: 7,\n    convRule: rule12\n}, {\n    start: 255,\n    length: 1,\n    convRule: rule21\n}, {\n    start: 256,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 257,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 258,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 259,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 260,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 261,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 262,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 263,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 264,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 265,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 266,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 267,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 268,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 269,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 270,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 271,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 272,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 273,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 274,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 275,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 276,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 277,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 278,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 279,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 280,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 281,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 282,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 283,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 284,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 285,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 286,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 287,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 288,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 289,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 290,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 291,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 292,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 293,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 294,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 295,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 296,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 297,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 298,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 299,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 300,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 301,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 302,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 303,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 304,\n    length: 1,\n    convRule: rule24\n}, {\n    start: 305,\n    length: 1,\n    convRule: rule25\n}, {\n    start: 306,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 307,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 308,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 309,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 310,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 311,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 313,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 314,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 315,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 316,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 317,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 318,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 319,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 320,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 321,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 322,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 323,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 324,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 325,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 326,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 327,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 328,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 330,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 331,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 332,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 333,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 334,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 335,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 336,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 337,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 338,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 339,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 340,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 341,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 342,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 343,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 344,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 345,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 346,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 347,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 348,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 349,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 350,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 351,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 352,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 353,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 354,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 355,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 356,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 357,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 358,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 359,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 360,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 361,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 362,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 363,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 364,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 365,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 366,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 367,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 368,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 369,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 370,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 371,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 372,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 373,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 374,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 375,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 376,\n    length: 1,\n    convRule: rule26\n}, {\n    start: 377,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 378,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 379,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 380,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 381,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 382,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 383,\n    length: 1,\n    convRule: rule27\n}, {\n    start: 384,\n    length: 1,\n    convRule: rule28\n}, {\n    start: 385,\n    length: 1,\n    convRule: rule29\n}, {\n    start: 386,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 387,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 388,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 389,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 390,\n    length: 1,\n    convRule: rule30\n}, {\n    start: 391,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 392,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 393,\n    length: 2,\n    convRule: rule31\n}, {\n    start: 395,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 396,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 398,\n    length: 1,\n    convRule: rule32\n}, {\n    start: 399,\n    length: 1,\n    convRule: rule33\n}, {\n    start: 400,\n    length: 1,\n    convRule: rule34\n}, {\n    start: 401,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 402,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 403,\n    length: 1,\n    convRule: rule31\n}, {\n    start: 404,\n    length: 1,\n    convRule: rule35\n}, {\n    start: 405,\n    length: 1,\n    convRule: rule36\n}, {\n    start: 406,\n    length: 1,\n    convRule: rule37\n}, {\n    start: 407,\n    length: 1,\n    convRule: rule38\n}, {\n    start: 408,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 409,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 410,\n    length: 1,\n    convRule: rule39\n}, {\n    start: 412,\n    length: 1,\n    convRule: rule37\n}, {\n    start: 413,\n    length: 1,\n    convRule: rule40\n}, {\n    start: 414,\n    length: 1,\n    convRule: rule41\n}, {\n    start: 415,\n    length: 1,\n    convRule: rule42\n}, {\n    start: 416,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 417,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 418,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 419,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 420,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 421,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 422,\n    length: 1,\n    convRule: rule43\n}, {\n    start: 423,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 424,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 425,\n    length: 1,\n    convRule: rule43\n}, {\n    start: 428,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 429,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 430,\n    length: 1,\n    convRule: rule43\n}, {\n    start: 431,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 432,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 433,\n    length: 2,\n    convRule: rule44\n}, {\n    start: 435,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 436,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 437,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 438,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 439,\n    length: 1,\n    convRule: rule45\n}, {\n    start: 440,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 441,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 444,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 445,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 447,\n    length: 1,\n    convRule: rule46\n}, {\n    start: 452,\n    length: 1,\n    convRule: rule47\n}, {\n    start: 453,\n    length: 1,\n    convRule: rule48\n}, {\n    start: 454,\n    length: 1,\n    convRule: rule49\n}, {\n    start: 455,\n    length: 1,\n    convRule: rule47\n}, {\n    start: 456,\n    length: 1,\n    convRule: rule48\n}, {\n    start: 457,\n    length: 1,\n    convRule: rule49\n}, {\n    start: 458,\n    length: 1,\n    convRule: rule47\n}, {\n    start: 459,\n    length: 1,\n    convRule: rule48\n}, {\n    start: 460,\n    length: 1,\n    convRule: rule49\n}, {\n    start: 461,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 462,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 463,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 464,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 465,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 466,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 467,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 468,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 469,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 470,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 471,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 472,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 473,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 474,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 475,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 476,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 477,\n    length: 1,\n    convRule: rule50\n}, {\n    start: 478,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 479,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 480,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 481,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 482,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 483,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 484,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 485,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 486,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 487,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 488,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 489,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 490,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 491,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 492,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 493,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 494,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 495,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 497,\n    length: 1,\n    convRule: rule47\n}, {\n    start: 498,\n    length: 1,\n    convRule: rule48\n}, {\n    start: 499,\n    length: 1,\n    convRule: rule49\n}, {\n    start: 500,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 501,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 502,\n    length: 1,\n    convRule: rule51\n}, {\n    start: 503,\n    length: 1,\n    convRule: rule52\n}, {\n    start: 504,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 505,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 506,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 507,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 508,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 509,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 510,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 511,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 512,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 513,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 514,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 515,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 516,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 517,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 518,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 519,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 520,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 521,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 522,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 523,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 524,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 525,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 526,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 527,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 528,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 529,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 530,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 531,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 532,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 533,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 534,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 535,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 536,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 537,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 538,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 539,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 540,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 541,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 542,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 543,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 544,\n    length: 1,\n    convRule: rule53\n}, {\n    start: 546,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 547,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 548,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 549,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 550,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 551,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 552,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 553,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 554,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 555,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 556,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 557,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 558,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 559,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 560,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 561,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 562,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 563,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 570,\n    length: 1,\n    convRule: rule54\n}, {\n    start: 571,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 572,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 573,\n    length: 1,\n    convRule: rule55\n}, {\n    start: 574,\n    length: 1,\n    convRule: rule56\n}, {\n    start: 575,\n    length: 2,\n    convRule: rule57\n}, {\n    start: 577,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 578,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 579,\n    length: 1,\n    convRule: rule58\n}, {\n    start: 580,\n    length: 1,\n    convRule: rule59\n}, {\n    start: 581,\n    length: 1,\n    convRule: rule60\n}, {\n    start: 582,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 583,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 584,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 585,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 586,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 587,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 588,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 589,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 590,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 591,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 592,\n    length: 1,\n    convRule: rule61\n}, {\n    start: 593,\n    length: 1,\n    convRule: rule62\n}, {\n    start: 594,\n    length: 1,\n    convRule: rule63\n}, {\n    start: 595,\n    length: 1,\n    convRule: rule64\n}, {\n    start: 596,\n    length: 1,\n    convRule: rule65\n}, {\n    start: 598,\n    length: 2,\n    convRule: rule66\n}, {\n    start: 601,\n    length: 1,\n    convRule: rule67\n}, {\n    start: 603,\n    length: 1,\n    convRule: rule68\n}, {\n    start: 604,\n    length: 1,\n    convRule: rule69\n}, {\n    start: 608,\n    length: 1,\n    convRule: rule66\n}, {\n    start: 609,\n    length: 1,\n    convRule: rule70\n}, {\n    start: 611,\n    length: 1,\n    convRule: rule71\n}, {\n    start: 613,\n    length: 1,\n    convRule: rule72\n}, {\n    start: 614,\n    length: 1,\n    convRule: rule73\n}, {\n    start: 616,\n    length: 1,\n    convRule: rule74\n}, {\n    start: 617,\n    length: 1,\n    convRule: rule75\n}, {\n    start: 618,\n    length: 1,\n    convRule: rule73\n}, {\n    start: 619,\n    length: 1,\n    convRule: rule76\n}, {\n    start: 620,\n    length: 1,\n    convRule: rule77\n}, {\n    start: 623,\n    length: 1,\n    convRule: rule75\n}, {\n    start: 625,\n    length: 1,\n    convRule: rule78\n}, {\n    start: 626,\n    length: 1,\n    convRule: rule79\n}, {\n    start: 629,\n    length: 1,\n    convRule: rule80\n}, {\n    start: 637,\n    length: 1,\n    convRule: rule81\n}, {\n    start: 640,\n    length: 1,\n    convRule: rule82\n}, {\n    start: 642,\n    length: 1,\n    convRule: rule83\n}, {\n    start: 643,\n    length: 1,\n    convRule: rule82\n}, {\n    start: 647,\n    length: 1,\n    convRule: rule84\n}, {\n    start: 648,\n    length: 1,\n    convRule: rule82\n}, {\n    start: 649,\n    length: 1,\n    convRule: rule85\n}, {\n    start: 650,\n    length: 2,\n    convRule: rule86\n}, {\n    start: 652,\n    length: 1,\n    convRule: rule87\n}, {\n    start: 658,\n    length: 1,\n    convRule: rule88\n}, {\n    start: 669,\n    length: 1,\n    convRule: rule89\n}, {\n    start: 670,\n    length: 1,\n    convRule: rule90\n}, {\n    start: 837,\n    length: 1,\n    convRule: rule93\n}, {\n    start: 880,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 881,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 882,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 883,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 886,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 887,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 891,\n    length: 3,\n    convRule: rule41\n}, {\n    start: 895,\n    length: 1,\n    convRule: rule94\n}, {\n    start: 902,\n    length: 1,\n    convRule: rule95\n}, {\n    start: 904,\n    length: 3,\n    convRule: rule96\n}, {\n    start: 908,\n    length: 1,\n    convRule: rule97\n}, {\n    start: 910,\n    length: 2,\n    convRule: rule98\n}, {\n    start: 913,\n    length: 17,\n    convRule: rule9\n}, {\n    start: 931,\n    length: 9,\n    convRule: rule9\n}, {\n    start: 940,\n    length: 1,\n    convRule: rule99\n}, {\n    start: 941,\n    length: 3,\n    convRule: rule100\n}, {\n    start: 945,\n    length: 17,\n    convRule: rule12\n}, {\n    start: 962,\n    length: 1,\n    convRule: rule101\n}, {\n    start: 963,\n    length: 9,\n    convRule: rule12\n}, {\n    start: 972,\n    length: 1,\n    convRule: rule102\n}, {\n    start: 973,\n    length: 2,\n    convRule: rule103\n}, {\n    start: 975,\n    length: 1,\n    convRule: rule104\n}, {\n    start: 976,\n    length: 1,\n    convRule: rule105\n}, {\n    start: 977,\n    length: 1,\n    convRule: rule106\n}, {\n    start: 981,\n    length: 1,\n    convRule: rule108\n}, {\n    start: 982,\n    length: 1,\n    convRule: rule109\n}, {\n    start: 983,\n    length: 1,\n    convRule: rule110\n}, {\n    start: 984,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 985,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 986,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 987,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 988,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 989,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 990,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 991,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 992,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 993,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 994,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 995,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 996,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 997,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 998,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 999,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1000,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1001,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1002,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1003,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1004,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1005,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1006,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1007,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1008,\n    length: 1,\n    convRule: rule111\n}, {\n    start: 1009,\n    length: 1,\n    convRule: rule112\n}, {\n    start: 1010,\n    length: 1,\n    convRule: rule113\n}, {\n    start: 1011,\n    length: 1,\n    convRule: rule114\n}, {\n    start: 1012,\n    length: 1,\n    convRule: rule115\n}, {\n    start: 1013,\n    length: 1,\n    convRule: rule116\n}, {\n    start: 1015,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1016,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1017,\n    length: 1,\n    convRule: rule117\n}, {\n    start: 1018,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1019,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1021,\n    length: 3,\n    convRule: rule53\n}, {\n    start: 1024,\n    length: 16,\n    convRule: rule118\n}, {\n    start: 1040,\n    length: 32,\n    convRule: rule9\n}, {\n    start: 1072,\n    length: 32,\n    convRule: rule12\n}, {\n    start: 1104,\n    length: 16,\n    convRule: rule112\n}, {\n    start: 1120,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1121,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1122,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1123,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1124,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1125,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1126,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1127,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1128,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1129,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1130,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1131,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1132,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1133,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1134,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1135,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1136,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1137,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1138,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1139,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1140,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1141,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1142,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1143,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1144,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1145,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1146,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1147,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1148,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1149,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1150,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1151,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1152,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1153,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1162,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1163,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1164,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1165,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1166,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1167,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1168,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1169,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1170,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1171,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1172,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1173,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1174,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1175,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1176,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1177,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1178,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1179,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1180,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1181,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1182,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1183,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1184,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1185,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1186,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1187,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1188,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1189,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1190,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1191,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1192,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1193,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1194,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1195,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1196,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1197,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1198,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1199,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1200,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1201,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1202,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1203,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1204,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1205,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1206,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1207,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1208,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1209,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1210,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1211,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1212,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1213,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1214,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1215,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1216,\n    length: 1,\n    convRule: rule120\n}, {\n    start: 1217,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1218,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1219,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1220,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1221,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1222,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1223,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1224,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1225,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1226,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1227,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1228,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1229,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1230,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1231,\n    length: 1,\n    convRule: rule121\n}, {\n    start: 1232,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1233,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1234,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1235,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1236,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1237,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1238,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1239,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1240,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1241,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1242,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1243,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1244,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1245,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1246,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1247,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1248,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1249,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1250,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1251,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1252,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1253,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1254,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1255,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1256,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1257,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1258,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1259,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1260,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1261,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1262,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1263,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1264,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1265,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1266,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1267,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1268,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1269,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1270,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1271,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1272,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1273,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1274,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1275,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1276,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1277,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1278,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1279,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1280,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1281,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1282,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1283,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1284,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1285,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1286,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1287,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1288,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1289,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1290,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1291,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1292,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1293,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1294,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1295,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1296,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1297,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1298,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1299,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1300,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1301,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1302,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1303,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1304,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1305,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1306,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1307,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1308,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1309,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1310,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1311,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1312,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1313,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1314,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1315,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1316,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1317,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1318,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1319,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1320,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1321,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1322,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1323,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1324,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1325,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1326,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1327,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1329,\n    length: 38,\n    convRule: rule122\n}, {\n    start: 1377,\n    length: 38,\n    convRule: rule123\n}, {\n    start: 4256,\n    length: 38,\n    convRule: rule125\n}, {\n    start: 4295,\n    length: 1,\n    convRule: rule125\n}, {\n    start: 4301,\n    length: 1,\n    convRule: rule125\n}, {\n    start: 4304,\n    length: 43,\n    convRule: rule126\n}, {\n    start: 4349,\n    length: 3,\n    convRule: rule126\n}, {\n    start: 5024,\n    length: 80,\n    convRule: rule127\n}, {\n    start: 5104,\n    length: 6,\n    convRule: rule104\n}, {\n    start: 5112,\n    length: 6,\n    convRule: rule110\n}, {\n    start: 7296,\n    length: 1,\n    convRule: rule129\n}, {\n    start: 7297,\n    length: 1,\n    convRule: rule130\n}, {\n    start: 7298,\n    length: 1,\n    convRule: rule131\n}, {\n    start: 7299,\n    length: 2,\n    convRule: rule132\n}, {\n    start: 7301,\n    length: 1,\n    convRule: rule133\n}, {\n    start: 7302,\n    length: 1,\n    convRule: rule134\n}, {\n    start: 7303,\n    length: 1,\n    convRule: rule135\n}, {\n    start: 7304,\n    length: 1,\n    convRule: rule136\n}, {\n    start: 7312,\n    length: 43,\n    convRule: rule137\n}, {\n    start: 7357,\n    length: 3,\n    convRule: rule137\n}, {\n    start: 7545,\n    length: 1,\n    convRule: rule138\n}, {\n    start: 7549,\n    length: 1,\n    convRule: rule139\n}, {\n    start: 7566,\n    length: 1,\n    convRule: rule140\n}, {\n    start: 7680,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7681,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7682,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7683,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7684,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7685,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7686,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7687,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7688,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7689,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7690,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7691,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7692,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7693,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7694,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7695,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7696,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7697,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7698,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7699,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7700,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7701,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7702,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7703,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7704,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7705,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7706,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7707,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7708,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7709,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7710,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7711,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7712,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7713,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7714,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7715,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7716,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7717,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7718,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7719,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7720,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7721,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7722,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7723,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7724,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7725,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7726,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7727,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7728,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7729,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7730,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7731,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7732,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7733,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7734,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7735,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7736,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7737,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7738,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7739,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7740,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7741,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7742,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7743,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7744,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7745,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7746,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7747,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7748,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7749,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7750,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7751,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7752,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7753,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7754,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7755,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7756,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7757,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7758,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7759,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7760,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7761,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7762,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7763,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7764,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7765,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7766,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7767,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7768,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7769,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7770,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7771,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7772,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7773,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7774,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7775,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7776,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7777,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7778,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7779,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7780,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7781,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7782,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7783,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7784,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7785,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7786,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7787,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7788,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7789,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7790,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7791,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7792,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7793,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7794,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7795,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7796,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7797,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7798,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7799,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7800,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7801,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7802,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7803,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7804,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7805,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7806,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7807,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7808,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7809,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7810,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7811,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7812,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7813,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7814,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7815,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7816,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7817,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7818,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7819,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7820,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7821,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7822,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7823,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7824,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7825,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7826,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7827,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7828,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7829,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7835,\n    length: 1,\n    convRule: rule141\n}, {\n    start: 7838,\n    length: 1,\n    convRule: rule142\n}, {\n    start: 7840,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7841,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7842,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7843,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7844,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7845,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7846,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7847,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7848,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7849,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7850,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7851,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7852,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7853,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7854,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7855,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7856,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7857,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7858,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7859,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7860,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7861,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7862,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7863,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7864,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7865,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7866,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7867,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7868,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7869,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7870,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7871,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7872,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7873,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7874,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7875,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7876,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7877,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7878,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7879,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7880,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7881,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7882,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7883,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7884,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7885,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7886,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7887,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7888,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7889,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7890,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7891,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7892,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7893,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7894,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7895,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7896,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7897,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7898,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7899,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7900,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7901,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7902,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7903,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7904,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7905,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7906,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7907,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7908,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7909,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7910,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7911,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7912,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7913,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7914,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7915,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7916,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7917,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7918,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7919,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7920,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7921,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7922,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7923,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7924,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7925,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7926,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7927,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7928,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7929,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7930,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7931,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7932,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7933,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7934,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7935,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7936,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 7944,\n    length: 8,\n    convRule: rule144\n}, {\n    start: 7952,\n    length: 6,\n    convRule: rule143\n}, {\n    start: 7960,\n    length: 6,\n    convRule: rule144\n}, {\n    start: 7968,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 7976,\n    length: 8,\n    convRule: rule144\n}, {\n    start: 7984,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 7992,\n    length: 8,\n    convRule: rule144\n}, {\n    start: 8000,\n    length: 6,\n    convRule: rule143\n}, {\n    start: 8008,\n    length: 6,\n    convRule: rule144\n}, {\n    start: 8017,\n    length: 1,\n    convRule: rule143\n}, {\n    start: 8019,\n    length: 1,\n    convRule: rule143\n}, {\n    start: 8021,\n    length: 1,\n    convRule: rule143\n}, {\n    start: 8023,\n    length: 1,\n    convRule: rule143\n}, {\n    start: 8025,\n    length: 1,\n    convRule: rule144\n}, {\n    start: 8027,\n    length: 1,\n    convRule: rule144\n}, {\n    start: 8029,\n    length: 1,\n    convRule: rule144\n}, {\n    start: 8031,\n    length: 1,\n    convRule: rule144\n}, {\n    start: 8032,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 8040,\n    length: 8,\n    convRule: rule144\n}, {\n    start: 8048,\n    length: 2,\n    convRule: rule145\n}, {\n    start: 8050,\n    length: 4,\n    convRule: rule146\n}, {\n    start: 8054,\n    length: 2,\n    convRule: rule147\n}, {\n    start: 8056,\n    length: 2,\n    convRule: rule148\n}, {\n    start: 8058,\n    length: 2,\n    convRule: rule149\n}, {\n    start: 8060,\n    length: 2,\n    convRule: rule150\n}, {\n    start: 8064,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 8072,\n    length: 8,\n    convRule: rule151\n}, {\n    start: 8080,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 8088,\n    length: 8,\n    convRule: rule151\n}, {\n    start: 8096,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 8104,\n    length: 8,\n    convRule: rule151\n}, {\n    start: 8112,\n    length: 2,\n    convRule: rule143\n}, {\n    start: 8115,\n    length: 1,\n    convRule: rule152\n}, {\n    start: 8120,\n    length: 2,\n    convRule: rule144\n}, {\n    start: 8122,\n    length: 2,\n    convRule: rule153\n}, {\n    start: 8124,\n    length: 1,\n    convRule: rule154\n}, {\n    start: 8126,\n    length: 1,\n    convRule: rule155\n}, {\n    start: 8131,\n    length: 1,\n    convRule: rule152\n}, {\n    start: 8136,\n    length: 4,\n    convRule: rule156\n}, {\n    start: 8140,\n    length: 1,\n    convRule: rule154\n}, {\n    start: 8144,\n    length: 2,\n    convRule: rule143\n}, {\n    start: 8152,\n    length: 2,\n    convRule: rule144\n}, {\n    start: 8154,\n    length: 2,\n    convRule: rule157\n}, {\n    start: 8160,\n    length: 2,\n    convRule: rule143\n}, {\n    start: 8165,\n    length: 1,\n    convRule: rule113\n}, {\n    start: 8168,\n    length: 2,\n    convRule: rule144\n}, {\n    start: 8170,\n    length: 2,\n    convRule: rule158\n}, {\n    start: 8172,\n    length: 1,\n    convRule: rule117\n}, {\n    start: 8179,\n    length: 1,\n    convRule: rule152\n}, {\n    start: 8184,\n    length: 2,\n    convRule: rule159\n}, {\n    start: 8186,\n    length: 2,\n    convRule: rule160\n}, {\n    start: 8188,\n    length: 1,\n    convRule: rule154\n}, {\n    start: 8486,\n    length: 1,\n    convRule: rule163\n}, {\n    start: 8490,\n    length: 1,\n    convRule: rule164\n}, {\n    start: 8491,\n    length: 1,\n    convRule: rule165\n}, {\n    start: 8498,\n    length: 1,\n    convRule: rule166\n}, {\n    start: 8526,\n    length: 1,\n    convRule: rule167\n}, {\n    start: 8544,\n    length: 16,\n    convRule: rule168\n}, {\n    start: 8560,\n    length: 16,\n    convRule: rule169\n}, {\n    start: 8579,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 8580,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 9398,\n    length: 26,\n    convRule: rule170\n}, {\n    start: 9424,\n    length: 26,\n    convRule: rule171\n}, {\n    start: 11264,\n    length: 47,\n    convRule: rule122\n}, {\n    start: 11312,\n    length: 47,\n    convRule: rule123\n}, {\n    start: 11360,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11361,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11362,\n    length: 1,\n    convRule: rule172\n}, {\n    start: 11363,\n    length: 1,\n    convRule: rule173\n}, {\n    start: 11364,\n    length: 1,\n    convRule: rule174\n}, {\n    start: 11365,\n    length: 1,\n    convRule: rule175\n}, {\n    start: 11366,\n    length: 1,\n    convRule: rule176\n}, {\n    start: 11367,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11368,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11369,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11370,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11371,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11372,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11373,\n    length: 1,\n    convRule: rule177\n}, {\n    start: 11374,\n    length: 1,\n    convRule: rule178\n}, {\n    start: 11375,\n    length: 1,\n    convRule: rule179\n}, {\n    start: 11376,\n    length: 1,\n    convRule: rule180\n}, {\n    start: 11378,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11379,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11381,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11382,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11390,\n    length: 2,\n    convRule: rule181\n}, {\n    start: 11392,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11393,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11394,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11395,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11396,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11397,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11398,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11399,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11400,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11401,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11402,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11403,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11404,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11405,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11406,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11407,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11408,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11409,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11410,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11411,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11412,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11413,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11414,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11415,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11416,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11417,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11418,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11419,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11420,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11421,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11422,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11423,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11424,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11425,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11426,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11427,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11428,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11429,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11430,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11431,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11432,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11433,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11434,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11435,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11436,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11437,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11438,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11439,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11440,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11441,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11442,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11443,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11444,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11445,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11446,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11447,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11448,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11449,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11450,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11451,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11452,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11453,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11454,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11455,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11456,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11457,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11458,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11459,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11460,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11461,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11462,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11463,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11464,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11465,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11466,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11467,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11468,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11469,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11470,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11471,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11472,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11473,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11474,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11475,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11476,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11477,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11478,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11479,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11480,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11481,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11482,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11483,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11484,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11485,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11486,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11487,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11488,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11489,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11490,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11491,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11499,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11500,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11501,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11502,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11506,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11507,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11520,\n    length: 38,\n    convRule: rule182\n}, {\n    start: 11559,\n    length: 1,\n    convRule: rule182\n}, {\n    start: 11565,\n    length: 1,\n    convRule: rule182\n}, {\n    start: 42560,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42561,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42562,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42563,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42564,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42565,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42566,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42567,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42568,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42569,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42570,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42571,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42572,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42573,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42574,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42575,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42576,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42577,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42578,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42579,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42580,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42581,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42582,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42583,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42584,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42585,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42586,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42587,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42588,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42589,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42590,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42591,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42592,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42593,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42594,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42595,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42596,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42597,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42598,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42599,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42600,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42601,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42602,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42603,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42604,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42605,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42624,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42625,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42626,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42627,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42628,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42629,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42630,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42631,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42632,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42633,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42634,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42635,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42636,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42637,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42638,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42639,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42640,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42641,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42642,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42643,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42644,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42645,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42646,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42647,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42648,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42649,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42650,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42651,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42786,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42787,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42788,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42789,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42790,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42791,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42792,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42793,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42794,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42795,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42796,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42797,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42798,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42799,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42802,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42803,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42804,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42805,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42806,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42807,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42808,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42809,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42810,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42811,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42812,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42813,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42814,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42815,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42816,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42817,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42818,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42819,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42820,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42821,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42822,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42823,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42824,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42825,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42826,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42827,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42828,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42829,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42830,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42831,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42832,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42833,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42834,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42835,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42836,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42837,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42838,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42839,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42840,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42841,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42842,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42843,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42844,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42845,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42846,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42847,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42848,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42849,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42850,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42851,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42852,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42853,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42854,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42855,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42856,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42857,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42858,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42859,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42860,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42861,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42862,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42863,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42873,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42874,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42875,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42876,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42877,\n    length: 1,\n    convRule: rule183\n}, {\n    start: 42878,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42879,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42880,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42881,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42882,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42883,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42884,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42885,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42886,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42887,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42891,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42892,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42893,\n    length: 1,\n    convRule: rule184\n}, {\n    start: 42896,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42897,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42898,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42899,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42900,\n    length: 1,\n    convRule: rule185\n}, {\n    start: 42902,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42903,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42904,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42905,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42906,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42907,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42908,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42909,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42910,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42911,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42912,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42913,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42914,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42915,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42916,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42917,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42918,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42919,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42920,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42921,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42922,\n    length: 1,\n    convRule: rule186\n}, {\n    start: 42923,\n    length: 1,\n    convRule: rule187\n}, {\n    start: 42924,\n    length: 1,\n    convRule: rule188\n}, {\n    start: 42925,\n    length: 1,\n    convRule: rule189\n}, {\n    start: 42926,\n    length: 1,\n    convRule: rule186\n}, {\n    start: 42928,\n    length: 1,\n    convRule: rule190\n}, {\n    start: 42929,\n    length: 1,\n    convRule: rule191\n}, {\n    start: 42930,\n    length: 1,\n    convRule: rule192\n}, {\n    start: 42931,\n    length: 1,\n    convRule: rule193\n}, {\n    start: 42932,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42933,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42934,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42935,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42936,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42937,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42938,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42939,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42940,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42941,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42942,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42943,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42946,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42947,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42948,\n    length: 1,\n    convRule: rule194\n}, {\n    start: 42949,\n    length: 1,\n    convRule: rule195\n}, {\n    start: 42950,\n    length: 1,\n    convRule: rule196\n}, {\n    start: 42951,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42952,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42953,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42954,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42997,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42998,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 43859,\n    length: 1,\n    convRule: rule197\n}, {\n    start: 43888,\n    length: 80,\n    convRule: rule198\n}, {\n    start: 65313,\n    length: 26,\n    convRule: rule9\n}, {\n    start: 65345,\n    length: 26,\n    convRule: rule12\n}, {\n    start: 66560,\n    length: 40,\n    convRule: rule201\n}, {\n    start: 66600,\n    length: 40,\n    convRule: rule202\n}, {\n    start: 66736,\n    length: 36,\n    convRule: rule201\n}, {\n    start: 66776,\n    length: 36,\n    convRule: rule202\n}, {\n    start: 68736,\n    length: 51,\n    convRule: rule97\n}, {\n    start: 68800,\n    length: 51,\n    convRule: rule102\n}, {\n    start: 71840,\n    length: 32,\n    convRule: rule9\n}, {\n    start: 71872,\n    length: 32,\n    convRule: rule12\n}, {\n    start: 93760,\n    length: 32,\n    convRule: rule9\n}, {\n    start: 93792,\n    length: 32,\n    convRule: rule12\n}, {\n    start: 125184,\n    length: 34,\n    convRule: rule203\n}, {\n    start: 125218,\n    length: 34,\n    convRule: rule204\n} ];\nvar bsearch = function (a) {\n    return function (array) {\n        return function (size) {\n            return function (compare) {\n                var go = function ($copy_i) {\n                    return function ($copy_k) {\n                        var $tco_var_i = $copy_i;\n                        var $tco_done = false;\n                        var $tco_result;\n                        function $tco_loop(i, k) {\n                            if (i > k || i >= Data_Array.length(array)) {\n                                $tco_done = true;\n                                return Data_Maybe.Nothing.value;\n                            };\n                            if (Data_Boolean.otherwise) {\n                                var j = Data_Int.floor(Data_Int.toNumber(i + k | 0) / 2.0);\n                                var v = compare(a)(array[j]);\n                                if (v instanceof Data_Ordering.EQ) {\n                                    $tco_done = true;\n                                    return new Data_Maybe.Just(array[j]);\n                                };\n                                if (v instanceof Data_Ordering.GT) {\n                                    $tco_var_i = j + 1 | 0;\n                                    $copy_k = k;\n                                    return;\n                                };\n                                $tco_var_i = i;\n                                $copy_k = j - 1 | 0;\n                                return;\n                            };\n                            throw new Error(\"Failed pattern match at Data.CodePoint.Unicode.Internal (line 5611, column 5 - line 5617, column 49): \" + [ i.constructor.name, k.constructor.name ]);\n                        };\n                        while (!$tco_done) {\n                            $tco_result = $tco_loop($tco_var_i, $copy_k);\n                        };\n                        return $tco_result;\n                    };\n                };\n                return go(0)(size);\n            };\n        };\n    };\n};\nvar blkCmp = function (v) {\n    return function (v1) {\n        if (v.start >= v1.start && v.start < (v1.start + v1.length | 0)) {\n            return Data_Ordering.EQ.value;\n        };\n        if (v.start > v1.start) {\n            return Data_Ordering.GT.value;\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Ordering.LT.value;\n        };\n        throw new Error(\"Failed pattern match at Data.CodePoint.Unicode.Internal (line 5588, column 1 - line 5588, column 45): \" + [ v.constructor.name, v1.constructor.name ]);\n    };\n};\nvar getRule = function (blocks) {\n    return function (unichar) {\n        return function (size) {\n            var key = {\n                start: unichar,\n                length: 1,\n                convRule: nullrule\n            };\n            var maybeCharBlock = bsearch(key)(blocks)(size)(blkCmp);\n            if (maybeCharBlock instanceof Data_Maybe.Nothing) {\n                return Data_Maybe.Nothing.value;\n            };\n            if (maybeCharBlock instanceof Data_Maybe.Just) {\n                return new Data_Maybe.Just(maybeCharBlock.value0.convRule);\n            };\n            throw new Error(\"Failed pattern match at Data.CodePoint.Unicode.Internal (line 5601, column 8 - line 5603, column 62): \" + [ maybeCharBlock.constructor.name ]);\n        };\n    };\n};\nvar caseConv = function (f) {\n    return function ($$char) {\n        var maybeConversionRule = getRule(convchars)($$char)(numConvBlocks);\n        if (maybeConversionRule instanceof Data_Maybe.Nothing) {\n            return $$char;\n        };\n        if (maybeConversionRule instanceof Data_Maybe.Just) {\n            return $$char + f(maybeConversionRule.value0) | 0;\n        };\n        throw new Error(\"Failed pattern match at Data.CodePoint.Unicode.Internal (line 5678, column 8 - line 5680, column 55): \" + [ maybeConversionRule.constructor.name ]);\n    };\n};\nvar uTowlower = caseConv(function (v) {\n    return v.lowdist;\n});\nvar uTowtitle = caseConv(function (v) {\n    return v.titledist;\n});\nvar uTowupper = caseConv(function (v) {\n    return v.updist;\n});\nvar checkAttrS = function (categories) {\n    return function ($$char) {\n        var maybeConversionRule = getRule(spacechars)($$char)(numSpaceBlocks);\n        if (maybeConversionRule instanceof Data_Maybe.Nothing) {\n            return false;\n        };\n        if (maybeConversionRule instanceof Data_Maybe.Just) {\n            return Data_Maybe.isJust(Data_Array.elemIndex(Data_Eq.eqInt)(maybeConversionRule.value0.category)(categories));\n        };\n        throw new Error(\"Failed pattern match at Data.CodePoint.Unicode.Internal (line 5635, column 8 - line 5637, column 92): \" + [ maybeConversionRule.constructor.name ]);\n    };\n};\nvar uIswspace = checkAttrS([ gencatZS ]);\nvar allchars = [ {\n    start: 0,\n    length: 32,\n    convRule: rule0\n}, {\n    start: 32,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 33,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 36,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 37,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 40,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 41,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 42,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 43,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 44,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 45,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 46,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 48,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 58,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 60,\n    length: 3,\n    convRule: rule6\n}, {\n    start: 63,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 65,\n    length: 26,\n    convRule: rule9\n}, {\n    start: 91,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 92,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 93,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 94,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 95,\n    length: 1,\n    convRule: rule11\n}, {\n    start: 96,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 97,\n    length: 26,\n    convRule: rule12\n}, {\n    start: 123,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 124,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 125,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 126,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 127,\n    length: 33,\n    convRule: rule0\n}, {\n    start: 160,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 161,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 162,\n    length: 4,\n    convRule: rule3\n}, {\n    start: 166,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 167,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 168,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 169,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 170,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 171,\n    length: 1,\n    convRule: rule15\n}, {\n    start: 172,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 173,\n    length: 1,\n    convRule: rule16\n}, {\n    start: 174,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 175,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 176,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 177,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 178,\n    length: 2,\n    convRule: rule17\n}, {\n    start: 180,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 181,\n    length: 1,\n    convRule: rule18\n}, {\n    start: 182,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 184,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 185,\n    length: 1,\n    convRule: rule17\n}, {\n    start: 186,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 187,\n    length: 1,\n    convRule: rule19\n}, {\n    start: 188,\n    length: 3,\n    convRule: rule17\n}, {\n    start: 191,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 192,\n    length: 23,\n    convRule: rule9\n}, {\n    start: 215,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 216,\n    length: 7,\n    convRule: rule9\n}, {\n    start: 223,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 224,\n    length: 23,\n    convRule: rule12\n}, {\n    start: 247,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 248,\n    length: 7,\n    convRule: rule12\n}, {\n    start: 255,\n    length: 1,\n    convRule: rule21\n}, {\n    start: 256,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 257,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 258,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 259,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 260,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 261,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 262,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 263,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 264,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 265,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 266,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 267,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 268,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 269,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 270,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 271,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 272,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 273,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 274,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 275,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 276,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 277,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 278,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 279,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 280,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 281,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 282,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 283,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 284,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 285,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 286,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 287,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 288,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 289,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 290,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 291,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 292,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 293,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 294,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 295,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 296,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 297,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 298,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 299,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 300,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 301,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 302,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 303,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 304,\n    length: 1,\n    convRule: rule24\n}, {\n    start: 305,\n    length: 1,\n    convRule: rule25\n}, {\n    start: 306,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 307,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 308,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 309,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 310,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 311,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 312,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 313,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 314,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 315,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 316,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 317,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 318,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 319,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 320,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 321,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 322,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 323,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 324,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 325,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 326,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 327,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 328,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 329,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 330,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 331,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 332,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 333,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 334,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 335,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 336,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 337,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 338,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 339,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 340,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 341,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 342,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 343,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 344,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 345,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 346,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 347,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 348,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 349,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 350,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 351,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 352,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 353,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 354,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 355,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 356,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 357,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 358,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 359,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 360,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 361,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 362,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 363,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 364,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 365,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 366,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 367,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 368,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 369,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 370,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 371,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 372,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 373,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 374,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 375,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 376,\n    length: 1,\n    convRule: rule26\n}, {\n    start: 377,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 378,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 379,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 380,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 381,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 382,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 383,\n    length: 1,\n    convRule: rule27\n}, {\n    start: 384,\n    length: 1,\n    convRule: rule28\n}, {\n    start: 385,\n    length: 1,\n    convRule: rule29\n}, {\n    start: 386,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 387,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 388,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 389,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 390,\n    length: 1,\n    convRule: rule30\n}, {\n    start: 391,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 392,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 393,\n    length: 2,\n    convRule: rule31\n}, {\n    start: 395,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 396,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 397,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 398,\n    length: 1,\n    convRule: rule32\n}, {\n    start: 399,\n    length: 1,\n    convRule: rule33\n}, {\n    start: 400,\n    length: 1,\n    convRule: rule34\n}, {\n    start: 401,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 402,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 403,\n    length: 1,\n    convRule: rule31\n}, {\n    start: 404,\n    length: 1,\n    convRule: rule35\n}, {\n    start: 405,\n    length: 1,\n    convRule: rule36\n}, {\n    start: 406,\n    length: 1,\n    convRule: rule37\n}, {\n    start: 407,\n    length: 1,\n    convRule: rule38\n}, {\n    start: 408,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 409,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 410,\n    length: 1,\n    convRule: rule39\n}, {\n    start: 411,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 412,\n    length: 1,\n    convRule: rule37\n}, {\n    start: 413,\n    length: 1,\n    convRule: rule40\n}, {\n    start: 414,\n    length: 1,\n    convRule: rule41\n}, {\n    start: 415,\n    length: 1,\n    convRule: rule42\n}, {\n    start: 416,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 417,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 418,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 419,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 420,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 421,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 422,\n    length: 1,\n    convRule: rule43\n}, {\n    start: 423,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 424,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 425,\n    length: 1,\n    convRule: rule43\n}, {\n    start: 426,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 428,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 429,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 430,\n    length: 1,\n    convRule: rule43\n}, {\n    start: 431,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 432,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 433,\n    length: 2,\n    convRule: rule44\n}, {\n    start: 435,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 436,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 437,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 438,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 439,\n    length: 1,\n    convRule: rule45\n}, {\n    start: 440,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 441,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 442,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 443,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 444,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 445,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 446,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 447,\n    length: 1,\n    convRule: rule46\n}, {\n    start: 448,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 452,\n    length: 1,\n    convRule: rule47\n}, {\n    start: 453,\n    length: 1,\n    convRule: rule48\n}, {\n    start: 454,\n    length: 1,\n    convRule: rule49\n}, {\n    start: 455,\n    length: 1,\n    convRule: rule47\n}, {\n    start: 456,\n    length: 1,\n    convRule: rule48\n}, {\n    start: 457,\n    length: 1,\n    convRule: rule49\n}, {\n    start: 458,\n    length: 1,\n    convRule: rule47\n}, {\n    start: 459,\n    length: 1,\n    convRule: rule48\n}, {\n    start: 460,\n    length: 1,\n    convRule: rule49\n}, {\n    start: 461,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 462,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 463,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 464,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 465,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 466,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 467,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 468,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 469,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 470,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 471,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 472,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 473,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 474,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 475,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 476,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 477,\n    length: 1,\n    convRule: rule50\n}, {\n    start: 478,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 479,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 480,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 481,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 482,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 483,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 484,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 485,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 486,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 487,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 488,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 489,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 490,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 491,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 492,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 493,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 494,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 495,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 496,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 497,\n    length: 1,\n    convRule: rule47\n}, {\n    start: 498,\n    length: 1,\n    convRule: rule48\n}, {\n    start: 499,\n    length: 1,\n    convRule: rule49\n}, {\n    start: 500,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 501,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 502,\n    length: 1,\n    convRule: rule51\n}, {\n    start: 503,\n    length: 1,\n    convRule: rule52\n}, {\n    start: 504,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 505,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 506,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 507,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 508,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 509,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 510,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 511,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 512,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 513,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 514,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 515,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 516,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 517,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 518,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 519,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 520,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 521,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 522,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 523,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 524,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 525,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 526,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 527,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 528,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 529,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 530,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 531,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 532,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 533,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 534,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 535,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 536,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 537,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 538,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 539,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 540,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 541,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 542,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 543,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 544,\n    length: 1,\n    convRule: rule53\n}, {\n    start: 545,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 546,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 547,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 548,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 549,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 550,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 551,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 552,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 553,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 554,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 555,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 556,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 557,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 558,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 559,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 560,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 561,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 562,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 563,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 564,\n    length: 6,\n    convRule: rule20\n}, {\n    start: 570,\n    length: 1,\n    convRule: rule54\n}, {\n    start: 571,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 572,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 573,\n    length: 1,\n    convRule: rule55\n}, {\n    start: 574,\n    length: 1,\n    convRule: rule56\n}, {\n    start: 575,\n    length: 2,\n    convRule: rule57\n}, {\n    start: 577,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 578,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 579,\n    length: 1,\n    convRule: rule58\n}, {\n    start: 580,\n    length: 1,\n    convRule: rule59\n}, {\n    start: 581,\n    length: 1,\n    convRule: rule60\n}, {\n    start: 582,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 583,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 584,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 585,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 586,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 587,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 588,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 589,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 590,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 591,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 592,\n    length: 1,\n    convRule: rule61\n}, {\n    start: 593,\n    length: 1,\n    convRule: rule62\n}, {\n    start: 594,\n    length: 1,\n    convRule: rule63\n}, {\n    start: 595,\n    length: 1,\n    convRule: rule64\n}, {\n    start: 596,\n    length: 1,\n    convRule: rule65\n}, {\n    start: 597,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 598,\n    length: 2,\n    convRule: rule66\n}, {\n    start: 600,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 601,\n    length: 1,\n    convRule: rule67\n}, {\n    start: 602,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 603,\n    length: 1,\n    convRule: rule68\n}, {\n    start: 604,\n    length: 1,\n    convRule: rule69\n}, {\n    start: 605,\n    length: 3,\n    convRule: rule20\n}, {\n    start: 608,\n    length: 1,\n    convRule: rule66\n}, {\n    start: 609,\n    length: 1,\n    convRule: rule70\n}, {\n    start: 610,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 611,\n    length: 1,\n    convRule: rule71\n}, {\n    start: 612,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 613,\n    length: 1,\n    convRule: rule72\n}, {\n    start: 614,\n    length: 1,\n    convRule: rule73\n}, {\n    start: 615,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 616,\n    length: 1,\n    convRule: rule74\n}, {\n    start: 617,\n    length: 1,\n    convRule: rule75\n}, {\n    start: 618,\n    length: 1,\n    convRule: rule73\n}, {\n    start: 619,\n    length: 1,\n    convRule: rule76\n}, {\n    start: 620,\n    length: 1,\n    convRule: rule77\n}, {\n    start: 621,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 623,\n    length: 1,\n    convRule: rule75\n}, {\n    start: 624,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 625,\n    length: 1,\n    convRule: rule78\n}, {\n    start: 626,\n    length: 1,\n    convRule: rule79\n}, {\n    start: 627,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 629,\n    length: 1,\n    convRule: rule80\n}, {\n    start: 630,\n    length: 7,\n    convRule: rule20\n}, {\n    start: 637,\n    length: 1,\n    convRule: rule81\n}, {\n    start: 638,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 640,\n    length: 1,\n    convRule: rule82\n}, {\n    start: 641,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 642,\n    length: 1,\n    convRule: rule83\n}, {\n    start: 643,\n    length: 1,\n    convRule: rule82\n}, {\n    start: 644,\n    length: 3,\n    convRule: rule20\n}, {\n    start: 647,\n    length: 1,\n    convRule: rule84\n}, {\n    start: 648,\n    length: 1,\n    convRule: rule82\n}, {\n    start: 649,\n    length: 1,\n    convRule: rule85\n}, {\n    start: 650,\n    length: 2,\n    convRule: rule86\n}, {\n    start: 652,\n    length: 1,\n    convRule: rule87\n}, {\n    start: 653,\n    length: 5,\n    convRule: rule20\n}, {\n    start: 658,\n    length: 1,\n    convRule: rule88\n}, {\n    start: 659,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 660,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 661,\n    length: 8,\n    convRule: rule20\n}, {\n    start: 669,\n    length: 1,\n    convRule: rule89\n}, {\n    start: 670,\n    length: 1,\n    convRule: rule90\n}, {\n    start: 671,\n    length: 17,\n    convRule: rule20\n}, {\n    start: 688,\n    length: 18,\n    convRule: rule91\n}, {\n    start: 706,\n    length: 4,\n    convRule: rule10\n}, {\n    start: 710,\n    length: 12,\n    convRule: rule91\n}, {\n    start: 722,\n    length: 14,\n    convRule: rule10\n}, {\n    start: 736,\n    length: 5,\n    convRule: rule91\n}, {\n    start: 741,\n    length: 7,\n    convRule: rule10\n}, {\n    start: 748,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 749,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 750,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 751,\n    length: 17,\n    convRule: rule10\n}, {\n    start: 768,\n    length: 69,\n    convRule: rule92\n}, {\n    start: 837,\n    length: 1,\n    convRule: rule93\n}, {\n    start: 838,\n    length: 42,\n    convRule: rule92\n}, {\n    start: 880,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 881,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 882,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 883,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 884,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 885,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 886,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 887,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 890,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 891,\n    length: 3,\n    convRule: rule41\n}, {\n    start: 894,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 895,\n    length: 1,\n    convRule: rule94\n}, {\n    start: 900,\n    length: 2,\n    convRule: rule10\n}, {\n    start: 902,\n    length: 1,\n    convRule: rule95\n}, {\n    start: 903,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 904,\n    length: 3,\n    convRule: rule96\n}, {\n    start: 908,\n    length: 1,\n    convRule: rule97\n}, {\n    start: 910,\n    length: 2,\n    convRule: rule98\n}, {\n    start: 912,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 913,\n    length: 17,\n    convRule: rule9\n}, {\n    start: 931,\n    length: 9,\n    convRule: rule9\n}, {\n    start: 940,\n    length: 1,\n    convRule: rule99\n}, {\n    start: 941,\n    length: 3,\n    convRule: rule100\n}, {\n    start: 944,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 945,\n    length: 17,\n    convRule: rule12\n}, {\n    start: 962,\n    length: 1,\n    convRule: rule101\n}, {\n    start: 963,\n    length: 9,\n    convRule: rule12\n}, {\n    start: 972,\n    length: 1,\n    convRule: rule102\n}, {\n    start: 973,\n    length: 2,\n    convRule: rule103\n}, {\n    start: 975,\n    length: 1,\n    convRule: rule104\n}, {\n    start: 976,\n    length: 1,\n    convRule: rule105\n}, {\n    start: 977,\n    length: 1,\n    convRule: rule106\n}, {\n    start: 978,\n    length: 3,\n    convRule: rule107\n}, {\n    start: 981,\n    length: 1,\n    convRule: rule108\n}, {\n    start: 982,\n    length: 1,\n    convRule: rule109\n}, {\n    start: 983,\n    length: 1,\n    convRule: rule110\n}, {\n    start: 984,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 985,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 986,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 987,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 988,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 989,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 990,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 991,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 992,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 993,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 994,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 995,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 996,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 997,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 998,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 999,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1000,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1001,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1002,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1003,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1004,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1005,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1006,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1007,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1008,\n    length: 1,\n    convRule: rule111\n}, {\n    start: 1009,\n    length: 1,\n    convRule: rule112\n}, {\n    start: 1010,\n    length: 1,\n    convRule: rule113\n}, {\n    start: 1011,\n    length: 1,\n    convRule: rule114\n}, {\n    start: 1012,\n    length: 1,\n    convRule: rule115\n}, {\n    start: 1013,\n    length: 1,\n    convRule: rule116\n}, {\n    start: 1014,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 1015,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1016,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1017,\n    length: 1,\n    convRule: rule117\n}, {\n    start: 1018,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1019,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1020,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 1021,\n    length: 3,\n    convRule: rule53\n}, {\n    start: 1024,\n    length: 16,\n    convRule: rule118\n}, {\n    start: 1040,\n    length: 32,\n    convRule: rule9\n}, {\n    start: 1072,\n    length: 32,\n    convRule: rule12\n}, {\n    start: 1104,\n    length: 16,\n    convRule: rule112\n}, {\n    start: 1120,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1121,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1122,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1123,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1124,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1125,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1126,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1127,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1128,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1129,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1130,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1131,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1132,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1133,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1134,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1135,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1136,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1137,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1138,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1139,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1140,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1141,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1142,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1143,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1144,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1145,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1146,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1147,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1148,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1149,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1150,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1151,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1152,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1153,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1154,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 1155,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 1160,\n    length: 2,\n    convRule: rule119\n}, {\n    start: 1162,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1163,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1164,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1165,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1166,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1167,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1168,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1169,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1170,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1171,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1172,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1173,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1174,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1175,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1176,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1177,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1178,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1179,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1180,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1181,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1182,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1183,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1184,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1185,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1186,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1187,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1188,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1189,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1190,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1191,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1192,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1193,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1194,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1195,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1196,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1197,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1198,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1199,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1200,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1201,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1202,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1203,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1204,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1205,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1206,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1207,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1208,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1209,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1210,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1211,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1212,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1213,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1214,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1215,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1216,\n    length: 1,\n    convRule: rule120\n}, {\n    start: 1217,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1218,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1219,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1220,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1221,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1222,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1223,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1224,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1225,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1226,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1227,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1228,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1229,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1230,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1231,\n    length: 1,\n    convRule: rule121\n}, {\n    start: 1232,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1233,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1234,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1235,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1236,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1237,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1238,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1239,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1240,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1241,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1242,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1243,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1244,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1245,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1246,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1247,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1248,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1249,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1250,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1251,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1252,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1253,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1254,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1255,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1256,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1257,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1258,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1259,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1260,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1261,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1262,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1263,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1264,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1265,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1266,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1267,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1268,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1269,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1270,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1271,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1272,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1273,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1274,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1275,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1276,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1277,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1278,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1279,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1280,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1281,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1282,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1283,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1284,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1285,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1286,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1287,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1288,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1289,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1290,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1291,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1292,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1293,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1294,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1295,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1296,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1297,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1298,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1299,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1300,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1301,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1302,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1303,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1304,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1305,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1306,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1307,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1308,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1309,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1310,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1311,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1312,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1313,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1314,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1315,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1316,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1317,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1318,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1319,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1320,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1321,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1322,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1323,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1324,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1325,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1326,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 1327,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 1329,\n    length: 38,\n    convRule: rule122\n}, {\n    start: 1369,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 1370,\n    length: 6,\n    convRule: rule2\n}, {\n    start: 1376,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 1377,\n    length: 38,\n    convRule: rule123\n}, {\n    start: 1415,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 1417,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 1418,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 1421,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 1423,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 1425,\n    length: 45,\n    convRule: rule92\n}, {\n    start: 1470,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 1471,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 1472,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 1473,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 1475,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 1476,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 1478,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 1479,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 1488,\n    length: 27,\n    convRule: rule14\n}, {\n    start: 1519,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 1523,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 1536,\n    length: 6,\n    convRule: rule16\n}, {\n    start: 1542,\n    length: 3,\n    convRule: rule6\n}, {\n    start: 1545,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 1547,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 1548,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 1550,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 1552,\n    length: 11,\n    convRule: rule92\n}, {\n    start: 1563,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 1564,\n    length: 1,\n    convRule: rule16\n}, {\n    start: 1566,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 1568,\n    length: 32,\n    convRule: rule14\n}, {\n    start: 1600,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 1601,\n    length: 10,\n    convRule: rule14\n}, {\n    start: 1611,\n    length: 21,\n    convRule: rule92\n}, {\n    start: 1632,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 1642,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 1646,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 1648,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 1649,\n    length: 99,\n    convRule: rule14\n}, {\n    start: 1748,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 1749,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 1750,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 1757,\n    length: 1,\n    convRule: rule16\n}, {\n    start: 1758,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 1759,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 1765,\n    length: 2,\n    convRule: rule91\n}, {\n    start: 1767,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 1769,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 1770,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 1774,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 1776,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 1786,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 1789,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 1791,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 1792,\n    length: 14,\n    convRule: rule2\n}, {\n    start: 1807,\n    length: 1,\n    convRule: rule16\n}, {\n    start: 1808,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 1809,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 1810,\n    length: 30,\n    convRule: rule14\n}, {\n    start: 1840,\n    length: 27,\n    convRule: rule92\n}, {\n    start: 1869,\n    length: 89,\n    convRule: rule14\n}, {\n    start: 1958,\n    length: 11,\n    convRule: rule92\n}, {\n    start: 1969,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 1984,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 1994,\n    length: 33,\n    convRule: rule14\n}, {\n    start: 2027,\n    length: 9,\n    convRule: rule92\n}, {\n    start: 2036,\n    length: 2,\n    convRule: rule91\n}, {\n    start: 2038,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 2039,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 2042,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 2045,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2046,\n    length: 2,\n    convRule: rule3\n}, {\n    start: 2048,\n    length: 22,\n    convRule: rule14\n}, {\n    start: 2070,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 2074,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 2075,\n    length: 9,\n    convRule: rule92\n}, {\n    start: 2084,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 2085,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 2088,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 2089,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 2096,\n    length: 15,\n    convRule: rule2\n}, {\n    start: 2112,\n    length: 25,\n    convRule: rule14\n}, {\n    start: 2137,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 2142,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 2144,\n    length: 11,\n    convRule: rule14\n}, {\n    start: 2208,\n    length: 21,\n    convRule: rule14\n}, {\n    start: 2230,\n    length: 18,\n    convRule: rule14\n}, {\n    start: 2259,\n    length: 15,\n    convRule: rule92\n}, {\n    start: 2274,\n    length: 1,\n    convRule: rule16\n}, {\n    start: 2275,\n    length: 32,\n    convRule: rule92\n}, {\n    start: 2307,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 2308,\n    length: 54,\n    convRule: rule14\n}, {\n    start: 2362,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2363,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 2364,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2365,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2366,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 2369,\n    length: 8,\n    convRule: rule92\n}, {\n    start: 2377,\n    length: 4,\n    convRule: rule124\n}, {\n    start: 2381,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2382,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 2384,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2385,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 2392,\n    length: 10,\n    convRule: rule14\n}, {\n    start: 2402,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2404,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 2406,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 2416,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 2417,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 2418,\n    length: 15,\n    convRule: rule14\n}, {\n    start: 2433,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2434,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 2437,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 2447,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2451,\n    length: 22,\n    convRule: rule14\n}, {\n    start: 2474,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 2482,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2486,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 2492,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2493,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2494,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 2497,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 2503,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 2507,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 2509,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2510,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2519,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 2524,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2527,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 2530,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2534,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 2544,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2546,\n    length: 2,\n    convRule: rule3\n}, {\n    start: 2548,\n    length: 6,\n    convRule: rule17\n}, {\n    start: 2554,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 2555,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 2556,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2557,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 2558,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2561,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2563,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 2565,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 2575,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2579,\n    length: 22,\n    convRule: rule14\n}, {\n    start: 2602,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 2610,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2613,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2616,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2620,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2622,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 2625,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2631,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2635,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 2641,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2649,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 2654,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2662,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 2672,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2674,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 2677,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2678,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 2689,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2691,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 2693,\n    length: 9,\n    convRule: rule14\n}, {\n    start: 2703,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 2707,\n    length: 22,\n    convRule: rule14\n}, {\n    start: 2730,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 2738,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2741,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 2748,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2749,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2750,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 2753,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 2759,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2761,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 2763,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 2765,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2768,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2784,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2786,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2790,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 2800,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 2801,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 2809,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2810,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 2817,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2818,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 2821,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 2831,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2835,\n    length: 22,\n    convRule: rule14\n}, {\n    start: 2858,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 2866,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2869,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 2876,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2877,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2878,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 2879,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2880,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 2881,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 2887,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 2891,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 2893,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2901,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2903,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 2908,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2911,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 2914,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 2918,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 2928,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 2929,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2930,\n    length: 6,\n    convRule: rule17\n}, {\n    start: 2946,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 2947,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2949,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 2958,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 2962,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 2969,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2972,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 2974,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2979,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 2984,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 2990,\n    length: 12,\n    convRule: rule14\n}, {\n    start: 3006,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 3008,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3009,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 3014,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 3018,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 3021,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3024,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3031,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 3046,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 3056,\n    length: 3,\n    convRule: rule17\n}, {\n    start: 3059,\n    length: 6,\n    convRule: rule13\n}, {\n    start: 3065,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 3066,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 3072,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3073,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 3076,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3077,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 3086,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 3090,\n    length: 23,\n    convRule: rule14\n}, {\n    start: 3114,\n    length: 16,\n    convRule: rule14\n}, {\n    start: 3133,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3134,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 3137,\n    length: 4,\n    convRule: rule124\n}, {\n    start: 3142,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 3146,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 3157,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 3160,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 3168,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 3170,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 3174,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 3191,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 3192,\n    length: 7,\n    convRule: rule17\n}, {\n    start: 3199,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 3200,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3201,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3202,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 3204,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 3205,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 3214,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 3218,\n    length: 23,\n    convRule: rule14\n}, {\n    start: 3242,\n    length: 10,\n    convRule: rule14\n}, {\n    start: 3253,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 3260,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3261,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3262,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 3263,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3264,\n    length: 5,\n    convRule: rule124\n}, {\n    start: 3270,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3271,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 3274,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 3276,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 3285,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 3294,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3296,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 3298,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 3302,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 3313,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 3328,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 3330,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 3332,\n    length: 9,\n    convRule: rule14\n}, {\n    start: 3342,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 3346,\n    length: 41,\n    convRule: rule14\n}, {\n    start: 3387,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 3389,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3390,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 3393,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 3398,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 3402,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 3405,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3406,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3407,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 3412,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 3415,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 3416,\n    length: 7,\n    convRule: rule17\n}, {\n    start: 3423,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 3426,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 3430,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 3440,\n    length: 9,\n    convRule: rule17\n}, {\n    start: 3449,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 3450,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 3457,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3458,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 3461,\n    length: 18,\n    convRule: rule14\n}, {\n    start: 3482,\n    length: 24,\n    convRule: rule14\n}, {\n    start: 3507,\n    length: 9,\n    convRule: rule14\n}, {\n    start: 3517,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3520,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 3530,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3535,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 3538,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 3542,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3544,\n    length: 8,\n    convRule: rule124\n}, {\n    start: 3558,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 3570,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 3572,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 3585,\n    length: 48,\n    convRule: rule14\n}, {\n    start: 3633,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3634,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 3636,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 3647,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 3648,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 3654,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 3655,\n    length: 8,\n    convRule: rule92\n}, {\n    start: 3663,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 3664,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 3674,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 3713,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 3716,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3718,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 3724,\n    length: 24,\n    convRule: rule14\n}, {\n    start: 3749,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3751,\n    length: 10,\n    convRule: rule14\n}, {\n    start: 3761,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3762,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 3764,\n    length: 9,\n    convRule: rule92\n}, {\n    start: 3773,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3776,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 3782,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 3784,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 3792,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 3804,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 3840,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 3841,\n    length: 3,\n    convRule: rule13\n}, {\n    start: 3844,\n    length: 15,\n    convRule: rule2\n}, {\n    start: 3859,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 3860,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 3861,\n    length: 3,\n    convRule: rule13\n}, {\n    start: 3864,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 3866,\n    length: 6,\n    convRule: rule13\n}, {\n    start: 3872,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 3882,\n    length: 10,\n    convRule: rule17\n}, {\n    start: 3892,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 3893,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3894,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 3895,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3896,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 3897,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 3898,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 3899,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 3900,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 3901,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 3902,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 3904,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 3913,\n    length: 36,\n    convRule: rule14\n}, {\n    start: 3953,\n    length: 14,\n    convRule: rule92\n}, {\n    start: 3967,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 3968,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 3973,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 3974,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 3976,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 3981,\n    length: 11,\n    convRule: rule92\n}, {\n    start: 3993,\n    length: 36,\n    convRule: rule92\n}, {\n    start: 4030,\n    length: 8,\n    convRule: rule13\n}, {\n    start: 4038,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 4039,\n    length: 6,\n    convRule: rule13\n}, {\n    start: 4046,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 4048,\n    length: 5,\n    convRule: rule2\n}, {\n    start: 4053,\n    length: 4,\n    convRule: rule13\n}, {\n    start: 4057,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 4096,\n    length: 43,\n    convRule: rule14\n}, {\n    start: 4139,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 4141,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 4145,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 4146,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 4152,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 4153,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 4155,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 4157,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 4159,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 4160,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 4170,\n    length: 6,\n    convRule: rule2\n}, {\n    start: 4176,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 4182,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 4184,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 4186,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 4190,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 4193,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 4194,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 4197,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 4199,\n    length: 7,\n    convRule: rule124\n}, {\n    start: 4206,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 4209,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 4213,\n    length: 13,\n    convRule: rule14\n}, {\n    start: 4226,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 4227,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 4229,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 4231,\n    length: 6,\n    convRule: rule124\n}, {\n    start: 4237,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 4238,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 4239,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 4240,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 4250,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 4253,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 4254,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 4256,\n    length: 38,\n    convRule: rule125\n}, {\n    start: 4295,\n    length: 1,\n    convRule: rule125\n}, {\n    start: 4301,\n    length: 1,\n    convRule: rule125\n}, {\n    start: 4304,\n    length: 43,\n    convRule: rule126\n}, {\n    start: 4347,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 4348,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 4349,\n    length: 3,\n    convRule: rule126\n}, {\n    start: 4352,\n    length: 329,\n    convRule: rule14\n}, {\n    start: 4682,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 4688,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 4696,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 4698,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 4704,\n    length: 41,\n    convRule: rule14\n}, {\n    start: 4746,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 4752,\n    length: 33,\n    convRule: rule14\n}, {\n    start: 4786,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 4792,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 4800,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 4802,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 4808,\n    length: 15,\n    convRule: rule14\n}, {\n    start: 4824,\n    length: 57,\n    convRule: rule14\n}, {\n    start: 4882,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 4888,\n    length: 67,\n    convRule: rule14\n}, {\n    start: 4957,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 4960,\n    length: 9,\n    convRule: rule2\n}, {\n    start: 4969,\n    length: 20,\n    convRule: rule17\n}, {\n    start: 4992,\n    length: 16,\n    convRule: rule14\n}, {\n    start: 5008,\n    length: 10,\n    convRule: rule13\n}, {\n    start: 5024,\n    length: 80,\n    convRule: rule127\n}, {\n    start: 5104,\n    length: 6,\n    convRule: rule104\n}, {\n    start: 5112,\n    length: 6,\n    convRule: rule110\n}, {\n    start: 5120,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 5121,\n    length: 620,\n    convRule: rule14\n}, {\n    start: 5741,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 5742,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 5743,\n    length: 17,\n    convRule: rule14\n}, {\n    start: 5760,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 5761,\n    length: 26,\n    convRule: rule14\n}, {\n    start: 5787,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 5788,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 5792,\n    length: 75,\n    convRule: rule14\n}, {\n    start: 5867,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 5870,\n    length: 3,\n    convRule: rule128\n}, {\n    start: 5873,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 5888,\n    length: 13,\n    convRule: rule14\n}, {\n    start: 5902,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 5906,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 5920,\n    length: 18,\n    convRule: rule14\n}, {\n    start: 5938,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 5941,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 5952,\n    length: 18,\n    convRule: rule14\n}, {\n    start: 5970,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 5984,\n    length: 13,\n    convRule: rule14\n}, {\n    start: 5998,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 6002,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 6016,\n    length: 52,\n    convRule: rule14\n}, {\n    start: 6068,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 6070,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 6071,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 6078,\n    length: 8,\n    convRule: rule124\n}, {\n    start: 6086,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6087,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 6089,\n    length: 11,\n    convRule: rule92\n}, {\n    start: 6100,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 6103,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 6104,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 6107,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 6108,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 6109,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6112,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 6128,\n    length: 10,\n    convRule: rule17\n}, {\n    start: 6144,\n    length: 6,\n    convRule: rule2\n}, {\n    start: 6150,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 6151,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 6155,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 6158,\n    length: 1,\n    convRule: rule16\n}, {\n    start: 6160,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 6176,\n    length: 35,\n    convRule: rule14\n}, {\n    start: 6211,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 6212,\n    length: 53,\n    convRule: rule14\n}, {\n    start: 6272,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 6277,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 6279,\n    length: 34,\n    convRule: rule14\n}, {\n    start: 6313,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6314,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 6320,\n    length: 70,\n    convRule: rule14\n}, {\n    start: 6400,\n    length: 31,\n    convRule: rule14\n}, {\n    start: 6432,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 6435,\n    length: 4,\n    convRule: rule124\n}, {\n    start: 6439,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 6441,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 6448,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 6450,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6451,\n    length: 6,\n    convRule: rule124\n}, {\n    start: 6457,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 6464,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 6468,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 6470,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 6480,\n    length: 30,\n    convRule: rule14\n}, {\n    start: 6512,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 6528,\n    length: 44,\n    convRule: rule14\n}, {\n    start: 6576,\n    length: 26,\n    convRule: rule14\n}, {\n    start: 6608,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 6618,\n    length: 1,\n    convRule: rule17\n}, {\n    start: 6622,\n    length: 34,\n    convRule: rule13\n}, {\n    start: 6656,\n    length: 23,\n    convRule: rule14\n}, {\n    start: 6679,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 6681,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 6683,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6686,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 6688,\n    length: 53,\n    convRule: rule14\n}, {\n    start: 6741,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 6742,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6743,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 6744,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 6752,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6753,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 6754,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6755,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 6757,\n    length: 8,\n    convRule: rule92\n}, {\n    start: 6765,\n    length: 6,\n    convRule: rule124\n}, {\n    start: 6771,\n    length: 10,\n    convRule: rule92\n}, {\n    start: 6783,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6784,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 6800,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 6816,\n    length: 7,\n    convRule: rule2\n}, {\n    start: 6823,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 6824,\n    length: 6,\n    convRule: rule2\n}, {\n    start: 6832,\n    length: 14,\n    convRule: rule92\n}, {\n    start: 6846,\n    length: 1,\n    convRule: rule119\n}, {\n    start: 6847,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 6912,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 6916,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 6917,\n    length: 47,\n    convRule: rule14\n}, {\n    start: 6964,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6965,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 6966,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 6971,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 6972,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6973,\n    length: 5,\n    convRule: rule124\n}, {\n    start: 6978,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 6979,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 6981,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 6992,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 7002,\n    length: 7,\n    convRule: rule2\n}, {\n    start: 7009,\n    length: 10,\n    convRule: rule13\n}, {\n    start: 7019,\n    length: 9,\n    convRule: rule92\n}, {\n    start: 7028,\n    length: 9,\n    convRule: rule13\n}, {\n    start: 7040,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 7042,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 7043,\n    length: 30,\n    convRule: rule14\n}, {\n    start: 7073,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 7074,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 7078,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 7080,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 7082,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 7083,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 7086,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 7088,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 7098,\n    length: 44,\n    convRule: rule14\n}, {\n    start: 7142,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 7143,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 7144,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 7146,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 7149,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 7150,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 7151,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 7154,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 7164,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 7168,\n    length: 36,\n    convRule: rule14\n}, {\n    start: 7204,\n    length: 8,\n    convRule: rule124\n}, {\n    start: 7212,\n    length: 8,\n    convRule: rule92\n}, {\n    start: 7220,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 7222,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 7227,\n    length: 5,\n    convRule: rule2\n}, {\n    start: 7232,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 7245,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 7248,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 7258,\n    length: 30,\n    convRule: rule14\n}, {\n    start: 7288,\n    length: 6,\n    convRule: rule91\n}, {\n    start: 7294,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 7296,\n    length: 1,\n    convRule: rule129\n}, {\n    start: 7297,\n    length: 1,\n    convRule: rule130\n}, {\n    start: 7298,\n    length: 1,\n    convRule: rule131\n}, {\n    start: 7299,\n    length: 2,\n    convRule: rule132\n}, {\n    start: 7301,\n    length: 1,\n    convRule: rule133\n}, {\n    start: 7302,\n    length: 1,\n    convRule: rule134\n}, {\n    start: 7303,\n    length: 1,\n    convRule: rule135\n}, {\n    start: 7304,\n    length: 1,\n    convRule: rule136\n}, {\n    start: 7312,\n    length: 43,\n    convRule: rule137\n}, {\n    start: 7357,\n    length: 3,\n    convRule: rule137\n}, {\n    start: 7360,\n    length: 8,\n    convRule: rule2\n}, {\n    start: 7376,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 7379,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 7380,\n    length: 13,\n    convRule: rule92\n}, {\n    start: 7393,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 7394,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 7401,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 7405,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 7406,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 7412,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 7413,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 7415,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 7416,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 7418,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 7424,\n    length: 44,\n    convRule: rule20\n}, {\n    start: 7468,\n    length: 63,\n    convRule: rule91\n}, {\n    start: 7531,\n    length: 13,\n    convRule: rule20\n}, {\n    start: 7544,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 7545,\n    length: 1,\n    convRule: rule138\n}, {\n    start: 7546,\n    length: 3,\n    convRule: rule20\n}, {\n    start: 7549,\n    length: 1,\n    convRule: rule139\n}, {\n    start: 7550,\n    length: 16,\n    convRule: rule20\n}, {\n    start: 7566,\n    length: 1,\n    convRule: rule140\n}, {\n    start: 7567,\n    length: 12,\n    convRule: rule20\n}, {\n    start: 7579,\n    length: 37,\n    convRule: rule91\n}, {\n    start: 7616,\n    length: 58,\n    convRule: rule92\n}, {\n    start: 7675,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 7680,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7681,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7682,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7683,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7684,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7685,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7686,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7687,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7688,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7689,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7690,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7691,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7692,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7693,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7694,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7695,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7696,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7697,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7698,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7699,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7700,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7701,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7702,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7703,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7704,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7705,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7706,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7707,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7708,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7709,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7710,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7711,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7712,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7713,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7714,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7715,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7716,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7717,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7718,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7719,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7720,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7721,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7722,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7723,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7724,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7725,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7726,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7727,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7728,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7729,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7730,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7731,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7732,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7733,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7734,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7735,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7736,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7737,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7738,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7739,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7740,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7741,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7742,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7743,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7744,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7745,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7746,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7747,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7748,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7749,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7750,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7751,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7752,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7753,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7754,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7755,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7756,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7757,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7758,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7759,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7760,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7761,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7762,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7763,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7764,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7765,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7766,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7767,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7768,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7769,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7770,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7771,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7772,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7773,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7774,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7775,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7776,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7777,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7778,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7779,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7780,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7781,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7782,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7783,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7784,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7785,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7786,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7787,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7788,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7789,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7790,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7791,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7792,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7793,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7794,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7795,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7796,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7797,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7798,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7799,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7800,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7801,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7802,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7803,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7804,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7805,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7806,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7807,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7808,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7809,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7810,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7811,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7812,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7813,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7814,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7815,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7816,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7817,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7818,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7819,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7820,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7821,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7822,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7823,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7824,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7825,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7826,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7827,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7828,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7829,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7830,\n    length: 5,\n    convRule: rule20\n}, {\n    start: 7835,\n    length: 1,\n    convRule: rule141\n}, {\n    start: 7836,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 7838,\n    length: 1,\n    convRule: rule142\n}, {\n    start: 7839,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 7840,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7841,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7842,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7843,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7844,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7845,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7846,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7847,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7848,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7849,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7850,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7851,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7852,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7853,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7854,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7855,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7856,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7857,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7858,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7859,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7860,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7861,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7862,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7863,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7864,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7865,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7866,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7867,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7868,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7869,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7870,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7871,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7872,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7873,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7874,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7875,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7876,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7877,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7878,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7879,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7880,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7881,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7882,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7883,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7884,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7885,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7886,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7887,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7888,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7889,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7890,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7891,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7892,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7893,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7894,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7895,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7896,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7897,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7898,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7899,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7900,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7901,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7902,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7903,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7904,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7905,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7906,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7907,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7908,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7909,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7910,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7911,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7912,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7913,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7914,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7915,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7916,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7917,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7918,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7919,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7920,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7921,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7922,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7923,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7924,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7925,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7926,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7927,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7928,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7929,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7930,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7931,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7932,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7933,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7934,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 7935,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 7936,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 7944,\n    length: 8,\n    convRule: rule144\n}, {\n    start: 7952,\n    length: 6,\n    convRule: rule143\n}, {\n    start: 7960,\n    length: 6,\n    convRule: rule144\n}, {\n    start: 7968,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 7976,\n    length: 8,\n    convRule: rule144\n}, {\n    start: 7984,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 7992,\n    length: 8,\n    convRule: rule144\n}, {\n    start: 8000,\n    length: 6,\n    convRule: rule143\n}, {\n    start: 8008,\n    length: 6,\n    convRule: rule144\n}, {\n    start: 8016,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8017,\n    length: 1,\n    convRule: rule143\n}, {\n    start: 8018,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8019,\n    length: 1,\n    convRule: rule143\n}, {\n    start: 8020,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8021,\n    length: 1,\n    convRule: rule143\n}, {\n    start: 8022,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8023,\n    length: 1,\n    convRule: rule143\n}, {\n    start: 8025,\n    length: 1,\n    convRule: rule144\n}, {\n    start: 8027,\n    length: 1,\n    convRule: rule144\n}, {\n    start: 8029,\n    length: 1,\n    convRule: rule144\n}, {\n    start: 8031,\n    length: 1,\n    convRule: rule144\n}, {\n    start: 8032,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 8040,\n    length: 8,\n    convRule: rule144\n}, {\n    start: 8048,\n    length: 2,\n    convRule: rule145\n}, {\n    start: 8050,\n    length: 4,\n    convRule: rule146\n}, {\n    start: 8054,\n    length: 2,\n    convRule: rule147\n}, {\n    start: 8056,\n    length: 2,\n    convRule: rule148\n}, {\n    start: 8058,\n    length: 2,\n    convRule: rule149\n}, {\n    start: 8060,\n    length: 2,\n    convRule: rule150\n}, {\n    start: 8064,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 8072,\n    length: 8,\n    convRule: rule151\n}, {\n    start: 8080,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 8088,\n    length: 8,\n    convRule: rule151\n}, {\n    start: 8096,\n    length: 8,\n    convRule: rule143\n}, {\n    start: 8104,\n    length: 8,\n    convRule: rule151\n}, {\n    start: 8112,\n    length: 2,\n    convRule: rule143\n}, {\n    start: 8114,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8115,\n    length: 1,\n    convRule: rule152\n}, {\n    start: 8116,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8118,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 8120,\n    length: 2,\n    convRule: rule144\n}, {\n    start: 8122,\n    length: 2,\n    convRule: rule153\n}, {\n    start: 8124,\n    length: 1,\n    convRule: rule154\n}, {\n    start: 8125,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 8126,\n    length: 1,\n    convRule: rule155\n}, {\n    start: 8127,\n    length: 3,\n    convRule: rule10\n}, {\n    start: 8130,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8131,\n    length: 1,\n    convRule: rule152\n}, {\n    start: 8132,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8134,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 8136,\n    length: 4,\n    convRule: rule156\n}, {\n    start: 8140,\n    length: 1,\n    convRule: rule154\n}, {\n    start: 8141,\n    length: 3,\n    convRule: rule10\n}, {\n    start: 8144,\n    length: 2,\n    convRule: rule143\n}, {\n    start: 8146,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 8150,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 8152,\n    length: 2,\n    convRule: rule144\n}, {\n    start: 8154,\n    length: 2,\n    convRule: rule157\n}, {\n    start: 8157,\n    length: 3,\n    convRule: rule10\n}, {\n    start: 8160,\n    length: 2,\n    convRule: rule143\n}, {\n    start: 8162,\n    length: 3,\n    convRule: rule20\n}, {\n    start: 8165,\n    length: 1,\n    convRule: rule113\n}, {\n    start: 8166,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 8168,\n    length: 2,\n    convRule: rule144\n}, {\n    start: 8170,\n    length: 2,\n    convRule: rule158\n}, {\n    start: 8172,\n    length: 1,\n    convRule: rule117\n}, {\n    start: 8173,\n    length: 3,\n    convRule: rule10\n}, {\n    start: 8178,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8179,\n    length: 1,\n    convRule: rule152\n}, {\n    start: 8180,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8182,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 8184,\n    length: 2,\n    convRule: rule159\n}, {\n    start: 8186,\n    length: 2,\n    convRule: rule160\n}, {\n    start: 8188,\n    length: 1,\n    convRule: rule154\n}, {\n    start: 8189,\n    length: 2,\n    convRule: rule10\n}, {\n    start: 8192,\n    length: 11,\n    convRule: rule1\n}, {\n    start: 8203,\n    length: 5,\n    convRule: rule16\n}, {\n    start: 8208,\n    length: 6,\n    convRule: rule7\n}, {\n    start: 8214,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 8216,\n    length: 1,\n    convRule: rule15\n}, {\n    start: 8217,\n    length: 1,\n    convRule: rule19\n}, {\n    start: 8218,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 8219,\n    length: 2,\n    convRule: rule15\n}, {\n    start: 8221,\n    length: 1,\n    convRule: rule19\n}, {\n    start: 8222,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 8223,\n    length: 1,\n    convRule: rule15\n}, {\n    start: 8224,\n    length: 8,\n    convRule: rule2\n}, {\n    start: 8232,\n    length: 1,\n    convRule: rule161\n}, {\n    start: 8233,\n    length: 1,\n    convRule: rule162\n}, {\n    start: 8234,\n    length: 5,\n    convRule: rule16\n}, {\n    start: 8239,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 8240,\n    length: 9,\n    convRule: rule2\n}, {\n    start: 8249,\n    length: 1,\n    convRule: rule15\n}, {\n    start: 8250,\n    length: 1,\n    convRule: rule19\n}, {\n    start: 8251,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 8255,\n    length: 2,\n    convRule: rule11\n}, {\n    start: 8257,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 8260,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 8261,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 8262,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 8263,\n    length: 11,\n    convRule: rule2\n}, {\n    start: 8274,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 8275,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 8276,\n    length: 1,\n    convRule: rule11\n}, {\n    start: 8277,\n    length: 10,\n    convRule: rule2\n}, {\n    start: 8287,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 8288,\n    length: 5,\n    convRule: rule16\n}, {\n    start: 8294,\n    length: 10,\n    convRule: rule16\n}, {\n    start: 8304,\n    length: 1,\n    convRule: rule17\n}, {\n    start: 8305,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 8308,\n    length: 6,\n    convRule: rule17\n}, {\n    start: 8314,\n    length: 3,\n    convRule: rule6\n}, {\n    start: 8317,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 8318,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 8319,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 8320,\n    length: 10,\n    convRule: rule17\n}, {\n    start: 8330,\n    length: 3,\n    convRule: rule6\n}, {\n    start: 8333,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 8334,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 8336,\n    length: 13,\n    convRule: rule91\n}, {\n    start: 8352,\n    length: 32,\n    convRule: rule3\n}, {\n    start: 8400,\n    length: 13,\n    convRule: rule92\n}, {\n    start: 8413,\n    length: 4,\n    convRule: rule119\n}, {\n    start: 8417,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 8418,\n    length: 3,\n    convRule: rule119\n}, {\n    start: 8421,\n    length: 12,\n    convRule: rule92\n}, {\n    start: 8448,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 8450,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 8451,\n    length: 4,\n    convRule: rule13\n}, {\n    start: 8455,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 8456,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 8458,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8459,\n    length: 3,\n    convRule: rule107\n}, {\n    start: 8462,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 8464,\n    length: 3,\n    convRule: rule107\n}, {\n    start: 8467,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8468,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 8469,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 8470,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 8472,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 8473,\n    length: 5,\n    convRule: rule107\n}, {\n    start: 8478,\n    length: 6,\n    convRule: rule13\n}, {\n    start: 8484,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 8485,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 8486,\n    length: 1,\n    convRule: rule163\n}, {\n    start: 8487,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 8488,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 8489,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 8490,\n    length: 1,\n    convRule: rule164\n}, {\n    start: 8491,\n    length: 1,\n    convRule: rule165\n}, {\n    start: 8492,\n    length: 2,\n    convRule: rule107\n}, {\n    start: 8494,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 8495,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8496,\n    length: 2,\n    convRule: rule107\n}, {\n    start: 8498,\n    length: 1,\n    convRule: rule166\n}, {\n    start: 8499,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 8500,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8501,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 8505,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 8506,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 8508,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 8510,\n    length: 2,\n    convRule: rule107\n}, {\n    start: 8512,\n    length: 5,\n    convRule: rule6\n}, {\n    start: 8517,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 8518,\n    length: 4,\n    convRule: rule20\n}, {\n    start: 8522,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 8523,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 8524,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 8526,\n    length: 1,\n    convRule: rule167\n}, {\n    start: 8527,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 8528,\n    length: 16,\n    convRule: rule17\n}, {\n    start: 8544,\n    length: 16,\n    convRule: rule168\n}, {\n    start: 8560,\n    length: 16,\n    convRule: rule169\n}, {\n    start: 8576,\n    length: 3,\n    convRule: rule128\n}, {\n    start: 8579,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 8580,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 8581,\n    length: 4,\n    convRule: rule128\n}, {\n    start: 8585,\n    length: 1,\n    convRule: rule17\n}, {\n    start: 8586,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 8592,\n    length: 5,\n    convRule: rule6\n}, {\n    start: 8597,\n    length: 5,\n    convRule: rule13\n}, {\n    start: 8602,\n    length: 2,\n    convRule: rule6\n}, {\n    start: 8604,\n    length: 4,\n    convRule: rule13\n}, {\n    start: 8608,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 8609,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 8611,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 8612,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 8614,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 8615,\n    length: 7,\n    convRule: rule13\n}, {\n    start: 8622,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 8623,\n    length: 31,\n    convRule: rule13\n}, {\n    start: 8654,\n    length: 2,\n    convRule: rule6\n}, {\n    start: 8656,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 8658,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 8659,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 8660,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 8661,\n    length: 31,\n    convRule: rule13\n}, {\n    start: 8692,\n    length: 268,\n    convRule: rule6\n}, {\n    start: 8960,\n    length: 8,\n    convRule: rule13\n}, {\n    start: 8968,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 8969,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 8970,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 8971,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 8972,\n    length: 20,\n    convRule: rule13\n}, {\n    start: 8992,\n    length: 2,\n    convRule: rule6\n}, {\n    start: 8994,\n    length: 7,\n    convRule: rule13\n}, {\n    start: 9001,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 9002,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 9003,\n    length: 81,\n    convRule: rule13\n}, {\n    start: 9084,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 9085,\n    length: 30,\n    convRule: rule13\n}, {\n    start: 9115,\n    length: 25,\n    convRule: rule6\n}, {\n    start: 9140,\n    length: 40,\n    convRule: rule13\n}, {\n    start: 9180,\n    length: 6,\n    convRule: rule6\n}, {\n    start: 9186,\n    length: 69,\n    convRule: rule13\n}, {\n    start: 9280,\n    length: 11,\n    convRule: rule13\n}, {\n    start: 9312,\n    length: 60,\n    convRule: rule17\n}, {\n    start: 9372,\n    length: 26,\n    convRule: rule13\n}, {\n    start: 9398,\n    length: 26,\n    convRule: rule170\n}, {\n    start: 9424,\n    length: 26,\n    convRule: rule171\n}, {\n    start: 9450,\n    length: 22,\n    convRule: rule17\n}, {\n    start: 9472,\n    length: 183,\n    convRule: rule13\n}, {\n    start: 9655,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 9656,\n    length: 9,\n    convRule: rule13\n}, {\n    start: 9665,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 9666,\n    length: 54,\n    convRule: rule13\n}, {\n    start: 9720,\n    length: 8,\n    convRule: rule6\n}, {\n    start: 9728,\n    length: 111,\n    convRule: rule13\n}, {\n    start: 9839,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 9840,\n    length: 248,\n    convRule: rule13\n}, {\n    start: 10088,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10089,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10090,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10091,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10092,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10093,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10094,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10095,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10096,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10097,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10098,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10099,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10100,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10101,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10102,\n    length: 30,\n    convRule: rule17\n}, {\n    start: 10132,\n    length: 44,\n    convRule: rule13\n}, {\n    start: 10176,\n    length: 5,\n    convRule: rule6\n}, {\n    start: 10181,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10182,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10183,\n    length: 31,\n    convRule: rule6\n}, {\n    start: 10214,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10215,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10216,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10217,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10218,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10219,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10220,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10221,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10222,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10223,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10224,\n    length: 16,\n    convRule: rule6\n}, {\n    start: 10240,\n    length: 256,\n    convRule: rule13\n}, {\n    start: 10496,\n    length: 131,\n    convRule: rule6\n}, {\n    start: 10627,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10628,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10629,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10630,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10631,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10632,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10633,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10634,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10635,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10636,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10637,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10638,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10639,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10640,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10641,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10642,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10643,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10644,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10645,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10646,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10647,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10648,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10649,\n    length: 63,\n    convRule: rule6\n}, {\n    start: 10712,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10713,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10714,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10715,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10716,\n    length: 32,\n    convRule: rule6\n}, {\n    start: 10748,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 10749,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 10750,\n    length: 258,\n    convRule: rule6\n}, {\n    start: 11008,\n    length: 48,\n    convRule: rule13\n}, {\n    start: 11056,\n    length: 21,\n    convRule: rule6\n}, {\n    start: 11077,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 11079,\n    length: 6,\n    convRule: rule6\n}, {\n    start: 11085,\n    length: 39,\n    convRule: rule13\n}, {\n    start: 11126,\n    length: 32,\n    convRule: rule13\n}, {\n    start: 11159,\n    length: 105,\n    convRule: rule13\n}, {\n    start: 11264,\n    length: 47,\n    convRule: rule122\n}, {\n    start: 11312,\n    length: 47,\n    convRule: rule123\n}, {\n    start: 11360,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11361,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11362,\n    length: 1,\n    convRule: rule172\n}, {\n    start: 11363,\n    length: 1,\n    convRule: rule173\n}, {\n    start: 11364,\n    length: 1,\n    convRule: rule174\n}, {\n    start: 11365,\n    length: 1,\n    convRule: rule175\n}, {\n    start: 11366,\n    length: 1,\n    convRule: rule176\n}, {\n    start: 11367,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11368,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11369,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11370,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11371,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11372,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11373,\n    length: 1,\n    convRule: rule177\n}, {\n    start: 11374,\n    length: 1,\n    convRule: rule178\n}, {\n    start: 11375,\n    length: 1,\n    convRule: rule179\n}, {\n    start: 11376,\n    length: 1,\n    convRule: rule180\n}, {\n    start: 11377,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 11378,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11379,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11380,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 11381,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11382,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11383,\n    length: 5,\n    convRule: rule20\n}, {\n    start: 11388,\n    length: 2,\n    convRule: rule91\n}, {\n    start: 11390,\n    length: 2,\n    convRule: rule181\n}, {\n    start: 11392,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11393,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11394,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11395,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11396,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11397,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11398,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11399,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11400,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11401,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11402,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11403,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11404,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11405,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11406,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11407,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11408,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11409,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11410,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11411,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11412,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11413,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11414,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11415,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11416,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11417,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11418,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11419,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11420,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11421,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11422,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11423,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11424,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11425,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11426,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11427,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11428,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11429,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11430,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11431,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11432,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11433,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11434,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11435,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11436,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11437,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11438,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11439,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11440,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11441,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11442,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11443,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11444,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11445,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11446,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11447,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11448,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11449,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11450,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11451,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11452,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11453,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11454,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11455,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11456,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11457,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11458,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11459,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11460,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11461,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11462,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11463,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11464,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11465,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11466,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11467,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11468,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11469,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11470,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11471,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11472,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11473,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11474,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11475,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11476,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11477,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11478,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11479,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11480,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11481,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11482,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11483,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11484,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11485,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11486,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11487,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11488,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11489,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11490,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11491,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11492,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 11493,\n    length: 6,\n    convRule: rule13\n}, {\n    start: 11499,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11500,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11501,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11502,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11503,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 11506,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 11507,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 11513,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 11517,\n    length: 1,\n    convRule: rule17\n}, {\n    start: 11518,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 11520,\n    length: 38,\n    convRule: rule182\n}, {\n    start: 11559,\n    length: 1,\n    convRule: rule182\n}, {\n    start: 11565,\n    length: 1,\n    convRule: rule182\n}, {\n    start: 11568,\n    length: 56,\n    convRule: rule14\n}, {\n    start: 11631,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 11632,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 11647,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 11648,\n    length: 23,\n    convRule: rule14\n}, {\n    start: 11680,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 11688,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 11696,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 11704,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 11712,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 11720,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 11728,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 11736,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 11744,\n    length: 32,\n    convRule: rule92\n}, {\n    start: 11776,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 11778,\n    length: 1,\n    convRule: rule15\n}, {\n    start: 11779,\n    length: 1,\n    convRule: rule19\n}, {\n    start: 11780,\n    length: 1,\n    convRule: rule15\n}, {\n    start: 11781,\n    length: 1,\n    convRule: rule19\n}, {\n    start: 11782,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 11785,\n    length: 1,\n    convRule: rule15\n}, {\n    start: 11786,\n    length: 1,\n    convRule: rule19\n}, {\n    start: 11787,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 11788,\n    length: 1,\n    convRule: rule15\n}, {\n    start: 11789,\n    length: 1,\n    convRule: rule19\n}, {\n    start: 11790,\n    length: 9,\n    convRule: rule2\n}, {\n    start: 11799,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 11800,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 11802,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 11803,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 11804,\n    length: 1,\n    convRule: rule15\n}, {\n    start: 11805,\n    length: 1,\n    convRule: rule19\n}, {\n    start: 11806,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 11808,\n    length: 1,\n    convRule: rule15\n}, {\n    start: 11809,\n    length: 1,\n    convRule: rule19\n}, {\n    start: 11810,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 11811,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 11812,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 11813,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 11814,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 11815,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 11816,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 11817,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 11818,\n    length: 5,\n    convRule: rule2\n}, {\n    start: 11823,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 11824,\n    length: 10,\n    convRule: rule2\n}, {\n    start: 11834,\n    length: 2,\n    convRule: rule7\n}, {\n    start: 11836,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 11840,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 11841,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 11842,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 11843,\n    length: 13,\n    convRule: rule2\n}, {\n    start: 11856,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 11858,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 11904,\n    length: 26,\n    convRule: rule13\n}, {\n    start: 11931,\n    length: 89,\n    convRule: rule13\n}, {\n    start: 12032,\n    length: 214,\n    convRule: rule13\n}, {\n    start: 12272,\n    length: 12,\n    convRule: rule13\n}, {\n    start: 12288,\n    length: 1,\n    convRule: rule1\n}, {\n    start: 12289,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 12292,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 12293,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 12294,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 12295,\n    length: 1,\n    convRule: rule128\n}, {\n    start: 12296,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 12297,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 12298,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 12299,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 12300,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 12301,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 12302,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 12303,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 12304,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 12305,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 12306,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 12308,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 12309,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 12310,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 12311,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 12312,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 12313,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 12314,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 12315,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 12316,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 12317,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 12318,\n    length: 2,\n    convRule: rule5\n}, {\n    start: 12320,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 12321,\n    length: 9,\n    convRule: rule128\n}, {\n    start: 12330,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 12334,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 12336,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 12337,\n    length: 5,\n    convRule: rule91\n}, {\n    start: 12342,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 12344,\n    length: 3,\n    convRule: rule128\n}, {\n    start: 12347,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 12348,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 12349,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 12350,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 12353,\n    length: 86,\n    convRule: rule14\n}, {\n    start: 12441,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 12443,\n    length: 2,\n    convRule: rule10\n}, {\n    start: 12445,\n    length: 2,\n    convRule: rule91\n}, {\n    start: 12447,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 12448,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 12449,\n    length: 90,\n    convRule: rule14\n}, {\n    start: 12539,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 12540,\n    length: 3,\n    convRule: rule91\n}, {\n    start: 12543,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 12549,\n    length: 43,\n    convRule: rule14\n}, {\n    start: 12593,\n    length: 94,\n    convRule: rule14\n}, {\n    start: 12688,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 12690,\n    length: 4,\n    convRule: rule17\n}, {\n    start: 12694,\n    length: 10,\n    convRule: rule13\n}, {\n    start: 12704,\n    length: 32,\n    convRule: rule14\n}, {\n    start: 12736,\n    length: 36,\n    convRule: rule13\n}, {\n    start: 12784,\n    length: 16,\n    convRule: rule14\n}, {\n    start: 12800,\n    length: 31,\n    convRule: rule13\n}, {\n    start: 12832,\n    length: 10,\n    convRule: rule17\n}, {\n    start: 12842,\n    length: 30,\n    convRule: rule13\n}, {\n    start: 12872,\n    length: 8,\n    convRule: rule17\n}, {\n    start: 12880,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 12881,\n    length: 15,\n    convRule: rule17\n}, {\n    start: 12896,\n    length: 32,\n    convRule: rule13\n}, {\n    start: 12928,\n    length: 10,\n    convRule: rule17\n}, {\n    start: 12938,\n    length: 39,\n    convRule: rule13\n}, {\n    start: 12977,\n    length: 15,\n    convRule: rule17\n}, {\n    start: 12992,\n    length: 320,\n    convRule: rule13\n}, {\n    start: 13312,\n    length: 6592,\n    convRule: rule14\n}, {\n    start: 19904,\n    length: 64,\n    convRule: rule13\n}, {\n    start: 19968,\n    length: 20989,\n    convRule: rule14\n}, {\n    start: 40960,\n    length: 21,\n    convRule: rule14\n}, {\n    start: 40981,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 40982,\n    length: 1143,\n    convRule: rule14\n}, {\n    start: 42128,\n    length: 55,\n    convRule: rule13\n}, {\n    start: 42192,\n    length: 40,\n    convRule: rule14\n}, {\n    start: 42232,\n    length: 6,\n    convRule: rule91\n}, {\n    start: 42238,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 42240,\n    length: 268,\n    convRule: rule14\n}, {\n    start: 42508,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 42509,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 42512,\n    length: 16,\n    convRule: rule14\n}, {\n    start: 42528,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 42538,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 42560,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42561,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42562,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42563,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42564,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42565,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42566,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42567,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42568,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42569,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42570,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42571,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42572,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42573,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42574,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42575,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42576,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42577,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42578,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42579,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42580,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42581,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42582,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42583,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42584,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42585,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42586,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42587,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42588,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42589,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42590,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42591,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42592,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42593,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42594,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42595,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42596,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42597,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42598,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42599,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42600,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42601,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42602,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42603,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42604,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42605,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42606,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 42607,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 42608,\n    length: 3,\n    convRule: rule119\n}, {\n    start: 42611,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 42612,\n    length: 10,\n    convRule: rule92\n}, {\n    start: 42622,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 42623,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 42624,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42625,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42626,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42627,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42628,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42629,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42630,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42631,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42632,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42633,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42634,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42635,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42636,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42637,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42638,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42639,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42640,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42641,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42642,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42643,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42644,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42645,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42646,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42647,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42648,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42649,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42650,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42651,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42652,\n    length: 2,\n    convRule: rule91\n}, {\n    start: 42654,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 42656,\n    length: 70,\n    convRule: rule14\n}, {\n    start: 42726,\n    length: 10,\n    convRule: rule128\n}, {\n    start: 42736,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 42738,\n    length: 6,\n    convRule: rule2\n}, {\n    start: 42752,\n    length: 23,\n    convRule: rule10\n}, {\n    start: 42775,\n    length: 9,\n    convRule: rule91\n}, {\n    start: 42784,\n    length: 2,\n    convRule: rule10\n}, {\n    start: 42786,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42787,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42788,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42789,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42790,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42791,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42792,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42793,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42794,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42795,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42796,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42797,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42798,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42799,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42800,\n    length: 2,\n    convRule: rule20\n}, {\n    start: 42802,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42803,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42804,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42805,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42806,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42807,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42808,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42809,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42810,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42811,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42812,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42813,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42814,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42815,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42816,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42817,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42818,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42819,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42820,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42821,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42822,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42823,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42824,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42825,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42826,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42827,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42828,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42829,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42830,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42831,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42832,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42833,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42834,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42835,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42836,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42837,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42838,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42839,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42840,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42841,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42842,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42843,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42844,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42845,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42846,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42847,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42848,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42849,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42850,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42851,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42852,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42853,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42854,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42855,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42856,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42857,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42858,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42859,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42860,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42861,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42862,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42863,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42864,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 42865,\n    length: 8,\n    convRule: rule20\n}, {\n    start: 42873,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42874,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42875,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42876,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42877,\n    length: 1,\n    convRule: rule183\n}, {\n    start: 42878,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42879,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42880,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42881,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42882,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42883,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42884,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42885,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42886,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42887,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42888,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 42889,\n    length: 2,\n    convRule: rule10\n}, {\n    start: 42891,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42892,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42893,\n    length: 1,\n    convRule: rule184\n}, {\n    start: 42894,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 42895,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 42896,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42897,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42898,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42899,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42900,\n    length: 1,\n    convRule: rule185\n}, {\n    start: 42901,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 42902,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42903,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42904,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42905,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42906,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42907,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42908,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42909,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42910,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42911,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42912,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42913,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42914,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42915,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42916,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42917,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42918,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42919,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42920,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42921,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42922,\n    length: 1,\n    convRule: rule186\n}, {\n    start: 42923,\n    length: 1,\n    convRule: rule187\n}, {\n    start: 42924,\n    length: 1,\n    convRule: rule188\n}, {\n    start: 42925,\n    length: 1,\n    convRule: rule189\n}, {\n    start: 42926,\n    length: 1,\n    convRule: rule186\n}, {\n    start: 42927,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 42928,\n    length: 1,\n    convRule: rule190\n}, {\n    start: 42929,\n    length: 1,\n    convRule: rule191\n}, {\n    start: 42930,\n    length: 1,\n    convRule: rule192\n}, {\n    start: 42931,\n    length: 1,\n    convRule: rule193\n}, {\n    start: 42932,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42933,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42934,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42935,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42936,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42937,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42938,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42939,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42940,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42941,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42942,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42943,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42946,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42947,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42948,\n    length: 1,\n    convRule: rule194\n}, {\n    start: 42949,\n    length: 1,\n    convRule: rule195\n}, {\n    start: 42950,\n    length: 1,\n    convRule: rule196\n}, {\n    start: 42951,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42952,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42953,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42954,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42997,\n    length: 1,\n    convRule: rule22\n}, {\n    start: 42998,\n    length: 1,\n    convRule: rule23\n}, {\n    start: 42999,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 43000,\n    length: 2,\n    convRule: rule91\n}, {\n    start: 43002,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 43003,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 43010,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43011,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 43014,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43015,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 43019,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43020,\n    length: 23,\n    convRule: rule14\n}, {\n    start: 43043,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 43045,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 43047,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 43048,\n    length: 4,\n    convRule: rule13\n}, {\n    start: 43052,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43056,\n    length: 6,\n    convRule: rule17\n}, {\n    start: 43062,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 43064,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 43065,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 43072,\n    length: 52,\n    convRule: rule14\n}, {\n    start: 43124,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 43136,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 43138,\n    length: 50,\n    convRule: rule14\n}, {\n    start: 43188,\n    length: 16,\n    convRule: rule124\n}, {\n    start: 43204,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 43214,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 43216,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 43232,\n    length: 18,\n    convRule: rule92\n}, {\n    start: 43250,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 43256,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 43259,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 43260,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 43261,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 43263,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43264,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 43274,\n    length: 28,\n    convRule: rule14\n}, {\n    start: 43302,\n    length: 8,\n    convRule: rule92\n}, {\n    start: 43310,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 43312,\n    length: 23,\n    convRule: rule14\n}, {\n    start: 43335,\n    length: 11,\n    convRule: rule92\n}, {\n    start: 43346,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 43359,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 43360,\n    length: 29,\n    convRule: rule14\n}, {\n    start: 43392,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 43395,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 43396,\n    length: 47,\n    convRule: rule14\n}, {\n    start: 43443,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43444,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 43446,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 43450,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 43452,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 43454,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 43457,\n    length: 13,\n    convRule: rule2\n}, {\n    start: 43471,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 43472,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 43486,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 43488,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 43493,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43494,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 43495,\n    length: 9,\n    convRule: rule14\n}, {\n    start: 43504,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 43514,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 43520,\n    length: 41,\n    convRule: rule14\n}, {\n    start: 43561,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 43567,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 43569,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 43571,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 43573,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 43584,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 43587,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43588,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 43596,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43597,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 43600,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 43612,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 43616,\n    length: 16,\n    convRule: rule14\n}, {\n    start: 43632,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 43633,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 43639,\n    length: 3,\n    convRule: rule13\n}, {\n    start: 43642,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 43643,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 43644,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43645,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 43646,\n    length: 50,\n    convRule: rule14\n}, {\n    start: 43696,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43697,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 43698,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 43701,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 43703,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 43705,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 43710,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 43712,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 43713,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43714,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 43739,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 43741,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 43742,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 43744,\n    length: 11,\n    convRule: rule14\n}, {\n    start: 43755,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 43756,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 43758,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 43760,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 43762,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 43763,\n    length: 2,\n    convRule: rule91\n}, {\n    start: 43765,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 43766,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 43777,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 43785,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 43793,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 43808,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 43816,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 43824,\n    length: 35,\n    convRule: rule20\n}, {\n    start: 43859,\n    length: 1,\n    convRule: rule197\n}, {\n    start: 43860,\n    length: 7,\n    convRule: rule20\n}, {\n    start: 43867,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 43868,\n    length: 4,\n    convRule: rule91\n}, {\n    start: 43872,\n    length: 9,\n    convRule: rule20\n}, {\n    start: 43881,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 43882,\n    length: 2,\n    convRule: rule10\n}, {\n    start: 43888,\n    length: 80,\n    convRule: rule198\n}, {\n    start: 43968,\n    length: 35,\n    convRule: rule14\n}, {\n    start: 44003,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 44005,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 44006,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 44008,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 44009,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 44011,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 44012,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 44013,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 44016,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 44032,\n    length: 11172,\n    convRule: rule14\n}, {\n    start: 55216,\n    length: 23,\n    convRule: rule14\n}, {\n    start: 55243,\n    length: 49,\n    convRule: rule14\n}, {\n    start: 55296,\n    length: 896,\n    convRule: rule199\n}, {\n    start: 56192,\n    length: 128,\n    convRule: rule199\n}, {\n    start: 56320,\n    length: 1024,\n    convRule: rule199\n}, {\n    start: 57344,\n    length: 6400,\n    convRule: rule200\n}, {\n    start: 63744,\n    length: 366,\n    convRule: rule14\n}, {\n    start: 64112,\n    length: 106,\n    convRule: rule14\n}, {\n    start: 64256,\n    length: 7,\n    convRule: rule20\n}, {\n    start: 64275,\n    length: 5,\n    convRule: rule20\n}, {\n    start: 64285,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 64286,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 64287,\n    length: 10,\n    convRule: rule14\n}, {\n    start: 64297,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 64298,\n    length: 13,\n    convRule: rule14\n}, {\n    start: 64312,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 64318,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 64320,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 64323,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 64326,\n    length: 108,\n    convRule: rule14\n}, {\n    start: 64434,\n    length: 16,\n    convRule: rule10\n}, {\n    start: 64467,\n    length: 363,\n    convRule: rule14\n}, {\n    start: 64830,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 64831,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 64848,\n    length: 64,\n    convRule: rule14\n}, {\n    start: 64914,\n    length: 54,\n    convRule: rule14\n}, {\n    start: 65008,\n    length: 12,\n    convRule: rule14\n}, {\n    start: 65020,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 65021,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 65024,\n    length: 16,\n    convRule: rule92\n}, {\n    start: 65040,\n    length: 7,\n    convRule: rule2\n}, {\n    start: 65047,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65048,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65049,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 65056,\n    length: 16,\n    convRule: rule92\n}, {\n    start: 65072,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 65073,\n    length: 2,\n    convRule: rule7\n}, {\n    start: 65075,\n    length: 2,\n    convRule: rule11\n}, {\n    start: 65077,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65078,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65079,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65080,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65081,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65082,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65083,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65084,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65085,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65086,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65087,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65088,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65089,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65090,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65091,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65092,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65093,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 65095,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65096,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65097,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 65101,\n    length: 3,\n    convRule: rule11\n}, {\n    start: 65104,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 65108,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 65112,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 65113,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65114,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65115,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65116,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65117,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65118,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65119,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 65122,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 65123,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 65124,\n    length: 3,\n    convRule: rule6\n}, {\n    start: 65128,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 65129,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 65130,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 65136,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 65142,\n    length: 135,\n    convRule: rule14\n}, {\n    start: 65279,\n    length: 1,\n    convRule: rule16\n}, {\n    start: 65281,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 65284,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 65285,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 65288,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65289,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65290,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 65291,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 65292,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 65293,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 65294,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 65296,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 65306,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 65308,\n    length: 3,\n    convRule: rule6\n}, {\n    start: 65311,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 65313,\n    length: 26,\n    convRule: rule9\n}, {\n    start: 65339,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65340,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 65341,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65342,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 65343,\n    length: 1,\n    convRule: rule11\n}, {\n    start: 65344,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 65345,\n    length: 26,\n    convRule: rule12\n}, {\n    start: 65371,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65372,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 65373,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65374,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 65375,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65376,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65377,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 65378,\n    length: 1,\n    convRule: rule4\n}, {\n    start: 65379,\n    length: 1,\n    convRule: rule5\n}, {\n    start: 65380,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 65382,\n    length: 10,\n    convRule: rule14\n}, {\n    start: 65392,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 65393,\n    length: 45,\n    convRule: rule14\n}, {\n    start: 65438,\n    length: 2,\n    convRule: rule91\n}, {\n    start: 65440,\n    length: 31,\n    convRule: rule14\n}, {\n    start: 65474,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 65482,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 65490,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 65498,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 65504,\n    length: 2,\n    convRule: rule3\n}, {\n    start: 65506,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 65507,\n    length: 1,\n    convRule: rule10\n}, {\n    start: 65508,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 65509,\n    length: 2,\n    convRule: rule3\n}, {\n    start: 65512,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 65513,\n    length: 4,\n    convRule: rule6\n}, {\n    start: 65517,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 65529,\n    length: 3,\n    convRule: rule16\n}, {\n    start: 65532,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 65536,\n    length: 12,\n    convRule: rule14\n}, {\n    start: 65549,\n    length: 26,\n    convRule: rule14\n}, {\n    start: 65576,\n    length: 19,\n    convRule: rule14\n}, {\n    start: 65596,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 65599,\n    length: 15,\n    convRule: rule14\n}, {\n    start: 65616,\n    length: 14,\n    convRule: rule14\n}, {\n    start: 65664,\n    length: 123,\n    convRule: rule14\n}, {\n    start: 65792,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 65799,\n    length: 45,\n    convRule: rule17\n}, {\n    start: 65847,\n    length: 9,\n    convRule: rule13\n}, {\n    start: 65856,\n    length: 53,\n    convRule: rule128\n}, {\n    start: 65909,\n    length: 4,\n    convRule: rule17\n}, {\n    start: 65913,\n    length: 17,\n    convRule: rule13\n}, {\n    start: 65930,\n    length: 2,\n    convRule: rule17\n}, {\n    start: 65932,\n    length: 3,\n    convRule: rule13\n}, {\n    start: 65936,\n    length: 13,\n    convRule: rule13\n}, {\n    start: 65952,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 66000,\n    length: 45,\n    convRule: rule13\n}, {\n    start: 66045,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 66176,\n    length: 29,\n    convRule: rule14\n}, {\n    start: 66208,\n    length: 49,\n    convRule: rule14\n}, {\n    start: 66272,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 66273,\n    length: 27,\n    convRule: rule17\n}, {\n    start: 66304,\n    length: 32,\n    convRule: rule14\n}, {\n    start: 66336,\n    length: 4,\n    convRule: rule17\n}, {\n    start: 66349,\n    length: 20,\n    convRule: rule14\n}, {\n    start: 66369,\n    length: 1,\n    convRule: rule128\n}, {\n    start: 66370,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 66378,\n    length: 1,\n    convRule: rule128\n}, {\n    start: 66384,\n    length: 38,\n    convRule: rule14\n}, {\n    start: 66422,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 66432,\n    length: 30,\n    convRule: rule14\n}, {\n    start: 66463,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 66464,\n    length: 36,\n    convRule: rule14\n}, {\n    start: 66504,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 66512,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 66513,\n    length: 5,\n    convRule: rule128\n}, {\n    start: 66560,\n    length: 40,\n    convRule: rule201\n}, {\n    start: 66600,\n    length: 40,\n    convRule: rule202\n}, {\n    start: 66640,\n    length: 78,\n    convRule: rule14\n}, {\n    start: 66720,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 66736,\n    length: 36,\n    convRule: rule201\n}, {\n    start: 66776,\n    length: 36,\n    convRule: rule202\n}, {\n    start: 66816,\n    length: 40,\n    convRule: rule14\n}, {\n    start: 66864,\n    length: 52,\n    convRule: rule14\n}, {\n    start: 66927,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 67072,\n    length: 311,\n    convRule: rule14\n}, {\n    start: 67392,\n    length: 22,\n    convRule: rule14\n}, {\n    start: 67424,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 67584,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 67592,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 67594,\n    length: 44,\n    convRule: rule14\n}, {\n    start: 67639,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 67644,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 67647,\n    length: 23,\n    convRule: rule14\n}, {\n    start: 67671,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 67672,\n    length: 8,\n    convRule: rule17\n}, {\n    start: 67680,\n    length: 23,\n    convRule: rule14\n}, {\n    start: 67703,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 67705,\n    length: 7,\n    convRule: rule17\n}, {\n    start: 67712,\n    length: 31,\n    convRule: rule14\n}, {\n    start: 67751,\n    length: 9,\n    convRule: rule17\n}, {\n    start: 67808,\n    length: 19,\n    convRule: rule14\n}, {\n    start: 67828,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 67835,\n    length: 5,\n    convRule: rule17\n}, {\n    start: 67840,\n    length: 22,\n    convRule: rule14\n}, {\n    start: 67862,\n    length: 6,\n    convRule: rule17\n}, {\n    start: 67871,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 67872,\n    length: 26,\n    convRule: rule14\n}, {\n    start: 67903,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 67968,\n    length: 56,\n    convRule: rule14\n}, {\n    start: 68028,\n    length: 2,\n    convRule: rule17\n}, {\n    start: 68030,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 68032,\n    length: 16,\n    convRule: rule17\n}, {\n    start: 68050,\n    length: 46,\n    convRule: rule17\n}, {\n    start: 68096,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 68097,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 68101,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 68108,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 68112,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 68117,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 68121,\n    length: 29,\n    convRule: rule14\n}, {\n    start: 68152,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 68159,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 68160,\n    length: 9,\n    convRule: rule17\n}, {\n    start: 68176,\n    length: 9,\n    convRule: rule2\n}, {\n    start: 68192,\n    length: 29,\n    convRule: rule14\n}, {\n    start: 68221,\n    length: 2,\n    convRule: rule17\n}, {\n    start: 68223,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 68224,\n    length: 29,\n    convRule: rule14\n}, {\n    start: 68253,\n    length: 3,\n    convRule: rule17\n}, {\n    start: 68288,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 68296,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 68297,\n    length: 28,\n    convRule: rule14\n}, {\n    start: 68325,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 68331,\n    length: 5,\n    convRule: rule17\n}, {\n    start: 68336,\n    length: 7,\n    convRule: rule2\n}, {\n    start: 68352,\n    length: 54,\n    convRule: rule14\n}, {\n    start: 68409,\n    length: 7,\n    convRule: rule2\n}, {\n    start: 68416,\n    length: 22,\n    convRule: rule14\n}, {\n    start: 68440,\n    length: 8,\n    convRule: rule17\n}, {\n    start: 68448,\n    length: 19,\n    convRule: rule14\n}, {\n    start: 68472,\n    length: 8,\n    convRule: rule17\n}, {\n    start: 68480,\n    length: 18,\n    convRule: rule14\n}, {\n    start: 68505,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 68521,\n    length: 7,\n    convRule: rule17\n}, {\n    start: 68608,\n    length: 73,\n    convRule: rule14\n}, {\n    start: 68736,\n    length: 51,\n    convRule: rule97\n}, {\n    start: 68800,\n    length: 51,\n    convRule: rule102\n}, {\n    start: 68858,\n    length: 6,\n    convRule: rule17\n}, {\n    start: 68864,\n    length: 36,\n    convRule: rule14\n}, {\n    start: 68900,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 68912,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 69216,\n    length: 31,\n    convRule: rule17\n}, {\n    start: 69248,\n    length: 42,\n    convRule: rule14\n}, {\n    start: 69291,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 69293,\n    length: 1,\n    convRule: rule7\n}, {\n    start: 69296,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 69376,\n    length: 29,\n    convRule: rule14\n}, {\n    start: 69405,\n    length: 10,\n    convRule: rule17\n}, {\n    start: 69415,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 69424,\n    length: 22,\n    convRule: rule14\n}, {\n    start: 69446,\n    length: 11,\n    convRule: rule92\n}, {\n    start: 69457,\n    length: 4,\n    convRule: rule17\n}, {\n    start: 69461,\n    length: 5,\n    convRule: rule2\n}, {\n    start: 69552,\n    length: 21,\n    convRule: rule14\n}, {\n    start: 69573,\n    length: 7,\n    convRule: rule17\n}, {\n    start: 69600,\n    length: 23,\n    convRule: rule14\n}, {\n    start: 69632,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 69633,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 69634,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 69635,\n    length: 53,\n    convRule: rule14\n}, {\n    start: 69688,\n    length: 15,\n    convRule: rule92\n}, {\n    start: 69703,\n    length: 7,\n    convRule: rule2\n}, {\n    start: 69714,\n    length: 20,\n    convRule: rule17\n}, {\n    start: 69734,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 69759,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 69762,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 69763,\n    length: 45,\n    convRule: rule14\n}, {\n    start: 69808,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 69811,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 69815,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 69817,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 69819,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 69821,\n    length: 1,\n    convRule: rule16\n}, {\n    start: 69822,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 69837,\n    length: 1,\n    convRule: rule16\n}, {\n    start: 69840,\n    length: 25,\n    convRule: rule14\n}, {\n    start: 69872,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 69888,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 69891,\n    length: 36,\n    convRule: rule14\n}, {\n    start: 69927,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 69932,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 69933,\n    length: 8,\n    convRule: rule92\n}, {\n    start: 69942,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 69952,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 69956,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 69957,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 69959,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 69968,\n    length: 35,\n    convRule: rule14\n}, {\n    start: 70003,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 70004,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 70006,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 70016,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 70018,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 70019,\n    length: 48,\n    convRule: rule14\n}, {\n    start: 70067,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 70070,\n    length: 9,\n    convRule: rule92\n}, {\n    start: 70079,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 70081,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 70085,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 70089,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 70093,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 70094,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 70095,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 70096,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 70106,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 70107,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 70108,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 70109,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 70113,\n    length: 20,\n    convRule: rule17\n}, {\n    start: 70144,\n    length: 18,\n    convRule: rule14\n}, {\n    start: 70163,\n    length: 25,\n    convRule: rule14\n}, {\n    start: 70188,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 70191,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 70194,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 70196,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 70197,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 70198,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 70200,\n    length: 6,\n    convRule: rule2\n}, {\n    start: 70206,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 70272,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 70280,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 70282,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 70287,\n    length: 15,\n    convRule: rule14\n}, {\n    start: 70303,\n    length: 10,\n    convRule: rule14\n}, {\n    start: 70313,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 70320,\n    length: 47,\n    convRule: rule14\n}, {\n    start: 70367,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 70368,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 70371,\n    length: 8,\n    convRule: rule92\n}, {\n    start: 70384,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 70400,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 70402,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 70405,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 70415,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 70419,\n    length: 22,\n    convRule: rule14\n}, {\n    start: 70442,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 70450,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 70453,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 70459,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 70461,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 70462,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 70464,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 70465,\n    length: 4,\n    convRule: rule124\n}, {\n    start: 70471,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 70475,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 70480,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 70487,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 70493,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 70498,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 70502,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 70512,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 70656,\n    length: 53,\n    convRule: rule14\n}, {\n    start: 70709,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 70712,\n    length: 8,\n    convRule: rule92\n}, {\n    start: 70720,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 70722,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 70725,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 70726,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 70727,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 70731,\n    length: 5,\n    convRule: rule2\n}, {\n    start: 70736,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 70746,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 70749,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 70750,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 70751,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 70784,\n    length: 48,\n    convRule: rule14\n}, {\n    start: 70832,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 70835,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 70841,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 70842,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 70843,\n    length: 4,\n    convRule: rule124\n}, {\n    start: 70847,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 70849,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 70850,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 70852,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 70854,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 70855,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 70864,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 71040,\n    length: 47,\n    convRule: rule14\n}, {\n    start: 71087,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 71090,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 71096,\n    length: 4,\n    convRule: rule124\n}, {\n    start: 71100,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 71102,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 71103,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 71105,\n    length: 23,\n    convRule: rule2\n}, {\n    start: 71128,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 71132,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 71168,\n    length: 48,\n    convRule: rule14\n}, {\n    start: 71216,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 71219,\n    length: 8,\n    convRule: rule92\n}, {\n    start: 71227,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 71229,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 71230,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 71231,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 71233,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 71236,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 71248,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 71264,\n    length: 13,\n    convRule: rule2\n}, {\n    start: 71296,\n    length: 43,\n    convRule: rule14\n}, {\n    start: 71339,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 71340,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 71341,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 71342,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 71344,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 71350,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 71351,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 71352,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 71360,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 71424,\n    length: 27,\n    convRule: rule14\n}, {\n    start: 71453,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 71456,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 71458,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 71462,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 71463,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 71472,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 71482,\n    length: 2,\n    convRule: rule17\n}, {\n    start: 71484,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 71487,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 71680,\n    length: 44,\n    convRule: rule14\n}, {\n    start: 71724,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 71727,\n    length: 9,\n    convRule: rule92\n}, {\n    start: 71736,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 71737,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 71739,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 71840,\n    length: 32,\n    convRule: rule9\n}, {\n    start: 71872,\n    length: 32,\n    convRule: rule12\n}, {\n    start: 71904,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 71914,\n    length: 9,\n    convRule: rule17\n}, {\n    start: 71935,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 71945,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 71948,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 71957,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 71960,\n    length: 24,\n    convRule: rule14\n}, {\n    start: 71984,\n    length: 6,\n    convRule: rule124\n}, {\n    start: 71991,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 71995,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 71997,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 71998,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 71999,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 72000,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 72001,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 72002,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 72003,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 72004,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 72016,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 72096,\n    length: 8,\n    convRule: rule14\n}, {\n    start: 72106,\n    length: 39,\n    convRule: rule14\n}, {\n    start: 72145,\n    length: 3,\n    convRule: rule124\n}, {\n    start: 72148,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 72154,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 72156,\n    length: 4,\n    convRule: rule124\n}, {\n    start: 72160,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 72161,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 72162,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 72163,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 72164,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 72192,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 72193,\n    length: 10,\n    convRule: rule92\n}, {\n    start: 72203,\n    length: 40,\n    convRule: rule14\n}, {\n    start: 72243,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 72249,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 72250,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 72251,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 72255,\n    length: 8,\n    convRule: rule2\n}, {\n    start: 72263,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 72272,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 72273,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 72279,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 72281,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 72284,\n    length: 46,\n    convRule: rule14\n}, {\n    start: 72330,\n    length: 13,\n    convRule: rule92\n}, {\n    start: 72343,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 72344,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 72346,\n    length: 3,\n    convRule: rule2\n}, {\n    start: 72349,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 72350,\n    length: 5,\n    convRule: rule2\n}, {\n    start: 72384,\n    length: 57,\n    convRule: rule14\n}, {\n    start: 72704,\n    length: 9,\n    convRule: rule14\n}, {\n    start: 72714,\n    length: 37,\n    convRule: rule14\n}, {\n    start: 72751,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 72752,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 72760,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 72766,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 72767,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 72768,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 72769,\n    length: 5,\n    convRule: rule2\n}, {\n    start: 72784,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 72794,\n    length: 19,\n    convRule: rule17\n}, {\n    start: 72816,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 72818,\n    length: 30,\n    convRule: rule14\n}, {\n    start: 72850,\n    length: 22,\n    convRule: rule92\n}, {\n    start: 72873,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 72874,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 72881,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 72882,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 72884,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 72885,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 72960,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 72968,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 72971,\n    length: 38,\n    convRule: rule14\n}, {\n    start: 73009,\n    length: 6,\n    convRule: rule92\n}, {\n    start: 73018,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 73020,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 73023,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 73030,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 73031,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 73040,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 73056,\n    length: 6,\n    convRule: rule14\n}, {\n    start: 73063,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 73066,\n    length: 32,\n    convRule: rule14\n}, {\n    start: 73098,\n    length: 5,\n    convRule: rule124\n}, {\n    start: 73104,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 73107,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 73109,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 73110,\n    length: 1,\n    convRule: rule124\n}, {\n    start: 73111,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 73112,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 73120,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 73440,\n    length: 19,\n    convRule: rule14\n}, {\n    start: 73459,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 73461,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 73463,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 73648,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 73664,\n    length: 21,\n    convRule: rule17\n}, {\n    start: 73685,\n    length: 8,\n    convRule: rule13\n}, {\n    start: 73693,\n    length: 4,\n    convRule: rule3\n}, {\n    start: 73697,\n    length: 17,\n    convRule: rule13\n}, {\n    start: 73727,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 73728,\n    length: 922,\n    convRule: rule14\n}, {\n    start: 74752,\n    length: 111,\n    convRule: rule128\n}, {\n    start: 74864,\n    length: 5,\n    convRule: rule2\n}, {\n    start: 74880,\n    length: 196,\n    convRule: rule14\n}, {\n    start: 77824,\n    length: 1071,\n    convRule: rule14\n}, {\n    start: 78896,\n    length: 9,\n    convRule: rule16\n}, {\n    start: 82944,\n    length: 583,\n    convRule: rule14\n}, {\n    start: 92160,\n    length: 569,\n    convRule: rule14\n}, {\n    start: 92736,\n    length: 31,\n    convRule: rule14\n}, {\n    start: 92768,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 92782,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 92880,\n    length: 30,\n    convRule: rule14\n}, {\n    start: 92912,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 92917,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 92928,\n    length: 48,\n    convRule: rule14\n}, {\n    start: 92976,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 92983,\n    length: 5,\n    convRule: rule2\n}, {\n    start: 92988,\n    length: 4,\n    convRule: rule13\n}, {\n    start: 92992,\n    length: 4,\n    convRule: rule91\n}, {\n    start: 92996,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 92997,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 93008,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 93019,\n    length: 7,\n    convRule: rule17\n}, {\n    start: 93027,\n    length: 21,\n    convRule: rule14\n}, {\n    start: 93053,\n    length: 19,\n    convRule: rule14\n}, {\n    start: 93760,\n    length: 32,\n    convRule: rule9\n}, {\n    start: 93792,\n    length: 32,\n    convRule: rule12\n}, {\n    start: 93824,\n    length: 23,\n    convRule: rule17\n}, {\n    start: 93847,\n    length: 4,\n    convRule: rule2\n}, {\n    start: 93952,\n    length: 75,\n    convRule: rule14\n}, {\n    start: 94031,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 94032,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 94033,\n    length: 55,\n    convRule: rule124\n}, {\n    start: 94095,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 94099,\n    length: 13,\n    convRule: rule91\n}, {\n    start: 94176,\n    length: 2,\n    convRule: rule91\n}, {\n    start: 94178,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 94179,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 94180,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 94192,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 94208,\n    length: 6136,\n    convRule: rule14\n}, {\n    start: 100352,\n    length: 1238,\n    convRule: rule14\n}, {\n    start: 101632,\n    length: 9,\n    convRule: rule14\n}, {\n    start: 110592,\n    length: 287,\n    convRule: rule14\n}, {\n    start: 110928,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 110948,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 110960,\n    length: 396,\n    convRule: rule14\n}, {\n    start: 113664,\n    length: 107,\n    convRule: rule14\n}, {\n    start: 113776,\n    length: 13,\n    convRule: rule14\n}, {\n    start: 113792,\n    length: 9,\n    convRule: rule14\n}, {\n    start: 113808,\n    length: 10,\n    convRule: rule14\n}, {\n    start: 113820,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 113821,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 113823,\n    length: 1,\n    convRule: rule2\n}, {\n    start: 113824,\n    length: 4,\n    convRule: rule16\n}, {\n    start: 118784,\n    length: 246,\n    convRule: rule13\n}, {\n    start: 119040,\n    length: 39,\n    convRule: rule13\n}, {\n    start: 119081,\n    length: 60,\n    convRule: rule13\n}, {\n    start: 119141,\n    length: 2,\n    convRule: rule124\n}, {\n    start: 119143,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 119146,\n    length: 3,\n    convRule: rule13\n}, {\n    start: 119149,\n    length: 6,\n    convRule: rule124\n}, {\n    start: 119155,\n    length: 8,\n    convRule: rule16\n}, {\n    start: 119163,\n    length: 8,\n    convRule: rule92\n}, {\n    start: 119171,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 119173,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 119180,\n    length: 30,\n    convRule: rule13\n}, {\n    start: 119210,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 119214,\n    length: 59,\n    convRule: rule13\n}, {\n    start: 119296,\n    length: 66,\n    convRule: rule13\n}, {\n    start: 119362,\n    length: 3,\n    convRule: rule92\n}, {\n    start: 119365,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 119520,\n    length: 20,\n    convRule: rule17\n}, {\n    start: 119552,\n    length: 87,\n    convRule: rule13\n}, {\n    start: 119648,\n    length: 25,\n    convRule: rule17\n}, {\n    start: 119808,\n    length: 26,\n    convRule: rule107\n}, {\n    start: 119834,\n    length: 26,\n    convRule: rule20\n}, {\n    start: 119860,\n    length: 26,\n    convRule: rule107\n}, {\n    start: 119886,\n    length: 7,\n    convRule: rule20\n}, {\n    start: 119894,\n    length: 18,\n    convRule: rule20\n}, {\n    start: 119912,\n    length: 26,\n    convRule: rule107\n}, {\n    start: 119938,\n    length: 26,\n    convRule: rule20\n}, {\n    start: 119964,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 119966,\n    length: 2,\n    convRule: rule107\n}, {\n    start: 119970,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 119973,\n    length: 2,\n    convRule: rule107\n}, {\n    start: 119977,\n    length: 4,\n    convRule: rule107\n}, {\n    start: 119982,\n    length: 8,\n    convRule: rule107\n}, {\n    start: 119990,\n    length: 4,\n    convRule: rule20\n}, {\n    start: 119995,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 119997,\n    length: 7,\n    convRule: rule20\n}, {\n    start: 120005,\n    length: 11,\n    convRule: rule20\n}, {\n    start: 120016,\n    length: 26,\n    convRule: rule107\n}, {\n    start: 120042,\n    length: 26,\n    convRule: rule20\n}, {\n    start: 120068,\n    length: 2,\n    convRule: rule107\n}, {\n    start: 120071,\n    length: 4,\n    convRule: rule107\n}, {\n    start: 120077,\n    length: 8,\n    convRule: rule107\n}, {\n    start: 120086,\n    length: 7,\n    convRule: rule107\n}, {\n    start: 120094,\n    length: 26,\n    convRule: rule20\n}, {\n    start: 120120,\n    length: 2,\n    convRule: rule107\n}, {\n    start: 120123,\n    length: 4,\n    convRule: rule107\n}, {\n    start: 120128,\n    length: 5,\n    convRule: rule107\n}, {\n    start: 120134,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 120138,\n    length: 7,\n    convRule: rule107\n}, {\n    start: 120146,\n    length: 26,\n    convRule: rule20\n}, {\n    start: 120172,\n    length: 26,\n    convRule: rule107\n}, {\n    start: 120198,\n    length: 26,\n    convRule: rule20\n}, {\n    start: 120224,\n    length: 26,\n    convRule: rule107\n}, {\n    start: 120250,\n    length: 26,\n    convRule: rule20\n}, {\n    start: 120276,\n    length: 26,\n    convRule: rule107\n}, {\n    start: 120302,\n    length: 26,\n    convRule: rule20\n}, {\n    start: 120328,\n    length: 26,\n    convRule: rule107\n}, {\n    start: 120354,\n    length: 26,\n    convRule: rule20\n}, {\n    start: 120380,\n    length: 26,\n    convRule: rule107\n}, {\n    start: 120406,\n    length: 26,\n    convRule: rule20\n}, {\n    start: 120432,\n    length: 26,\n    convRule: rule107\n}, {\n    start: 120458,\n    length: 28,\n    convRule: rule20\n}, {\n    start: 120488,\n    length: 25,\n    convRule: rule107\n}, {\n    start: 120513,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 120514,\n    length: 25,\n    convRule: rule20\n}, {\n    start: 120539,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 120540,\n    length: 6,\n    convRule: rule20\n}, {\n    start: 120546,\n    length: 25,\n    convRule: rule107\n}, {\n    start: 120571,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 120572,\n    length: 25,\n    convRule: rule20\n}, {\n    start: 120597,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 120598,\n    length: 6,\n    convRule: rule20\n}, {\n    start: 120604,\n    length: 25,\n    convRule: rule107\n}, {\n    start: 120629,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 120630,\n    length: 25,\n    convRule: rule20\n}, {\n    start: 120655,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 120656,\n    length: 6,\n    convRule: rule20\n}, {\n    start: 120662,\n    length: 25,\n    convRule: rule107\n}, {\n    start: 120687,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 120688,\n    length: 25,\n    convRule: rule20\n}, {\n    start: 120713,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 120714,\n    length: 6,\n    convRule: rule20\n}, {\n    start: 120720,\n    length: 25,\n    convRule: rule107\n}, {\n    start: 120745,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 120746,\n    length: 25,\n    convRule: rule20\n}, {\n    start: 120771,\n    length: 1,\n    convRule: rule6\n}, {\n    start: 120772,\n    length: 6,\n    convRule: rule20\n}, {\n    start: 120778,\n    length: 1,\n    convRule: rule107\n}, {\n    start: 120779,\n    length: 1,\n    convRule: rule20\n}, {\n    start: 120782,\n    length: 50,\n    convRule: rule8\n}, {\n    start: 120832,\n    length: 512,\n    convRule: rule13\n}, {\n    start: 121344,\n    length: 55,\n    convRule: rule92\n}, {\n    start: 121399,\n    length: 4,\n    convRule: rule13\n}, {\n    start: 121403,\n    length: 50,\n    convRule: rule92\n}, {\n    start: 121453,\n    length: 8,\n    convRule: rule13\n}, {\n    start: 121461,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 121462,\n    length: 14,\n    convRule: rule13\n}, {\n    start: 121476,\n    length: 1,\n    convRule: rule92\n}, {\n    start: 121477,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 121479,\n    length: 5,\n    convRule: rule2\n}, {\n    start: 121499,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 121505,\n    length: 15,\n    convRule: rule92\n}, {\n    start: 122880,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 122888,\n    length: 17,\n    convRule: rule92\n}, {\n    start: 122907,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 122915,\n    length: 2,\n    convRule: rule92\n}, {\n    start: 122918,\n    length: 5,\n    convRule: rule92\n}, {\n    start: 123136,\n    length: 45,\n    convRule: rule14\n}, {\n    start: 123184,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 123191,\n    length: 7,\n    convRule: rule91\n}, {\n    start: 123200,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 123214,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 123215,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 123584,\n    length: 44,\n    convRule: rule14\n}, {\n    start: 123628,\n    length: 4,\n    convRule: rule92\n}, {\n    start: 123632,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 123647,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 124928,\n    length: 197,\n    convRule: rule14\n}, {\n    start: 125127,\n    length: 9,\n    convRule: rule17\n}, {\n    start: 125136,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 125184,\n    length: 34,\n    convRule: rule203\n}, {\n    start: 125218,\n    length: 34,\n    convRule: rule204\n}, {\n    start: 125252,\n    length: 7,\n    convRule: rule92\n}, {\n    start: 125259,\n    length: 1,\n    convRule: rule91\n}, {\n    start: 125264,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 125278,\n    length: 2,\n    convRule: rule2\n}, {\n    start: 126065,\n    length: 59,\n    convRule: rule17\n}, {\n    start: 126124,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 126125,\n    length: 3,\n    convRule: rule17\n}, {\n    start: 126128,\n    length: 1,\n    convRule: rule3\n}, {\n    start: 126129,\n    length: 4,\n    convRule: rule17\n}, {\n    start: 126209,\n    length: 45,\n    convRule: rule17\n}, {\n    start: 126254,\n    length: 1,\n    convRule: rule13\n}, {\n    start: 126255,\n    length: 15,\n    convRule: rule17\n}, {\n    start: 126464,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 126469,\n    length: 27,\n    convRule: rule14\n}, {\n    start: 126497,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 126500,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126503,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126505,\n    length: 10,\n    convRule: rule14\n}, {\n    start: 126516,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 126521,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126523,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126530,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126535,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126537,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126539,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126541,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 126545,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 126548,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126551,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126553,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126555,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126557,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126559,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126561,\n    length: 2,\n    convRule: rule14\n}, {\n    start: 126564,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126567,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 126572,\n    length: 7,\n    convRule: rule14\n}, {\n    start: 126580,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 126585,\n    length: 4,\n    convRule: rule14\n}, {\n    start: 126590,\n    length: 1,\n    convRule: rule14\n}, {\n    start: 126592,\n    length: 10,\n    convRule: rule14\n}, {\n    start: 126603,\n    length: 17,\n    convRule: rule14\n}, {\n    start: 126625,\n    length: 3,\n    convRule: rule14\n}, {\n    start: 126629,\n    length: 5,\n    convRule: rule14\n}, {\n    start: 126635,\n    length: 17,\n    convRule: rule14\n}, {\n    start: 126704,\n    length: 2,\n    convRule: rule6\n}, {\n    start: 126976,\n    length: 44,\n    convRule: rule13\n}, {\n    start: 127024,\n    length: 100,\n    convRule: rule13\n}, {\n    start: 127136,\n    length: 15,\n    convRule: rule13\n}, {\n    start: 127153,\n    length: 15,\n    convRule: rule13\n}, {\n    start: 127169,\n    length: 15,\n    convRule: rule13\n}, {\n    start: 127185,\n    length: 37,\n    convRule: rule13\n}, {\n    start: 127232,\n    length: 13,\n    convRule: rule17\n}, {\n    start: 127245,\n    length: 161,\n    convRule: rule13\n}, {\n    start: 127462,\n    length: 29,\n    convRule: rule13\n}, {\n    start: 127504,\n    length: 44,\n    convRule: rule13\n}, {\n    start: 127552,\n    length: 9,\n    convRule: rule13\n}, {\n    start: 127568,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 127584,\n    length: 6,\n    convRule: rule13\n}, {\n    start: 127744,\n    length: 251,\n    convRule: rule13\n}, {\n    start: 127995,\n    length: 5,\n    convRule: rule10\n}, {\n    start: 128000,\n    length: 728,\n    convRule: rule13\n}, {\n    start: 128736,\n    length: 13,\n    convRule: rule13\n}, {\n    start: 128752,\n    length: 13,\n    convRule: rule13\n}, {\n    start: 128768,\n    length: 116,\n    convRule: rule13\n}, {\n    start: 128896,\n    length: 89,\n    convRule: rule13\n}, {\n    start: 128992,\n    length: 12,\n    convRule: rule13\n}, {\n    start: 129024,\n    length: 12,\n    convRule: rule13\n}, {\n    start: 129040,\n    length: 56,\n    convRule: rule13\n}, {\n    start: 129104,\n    length: 10,\n    convRule: rule13\n}, {\n    start: 129120,\n    length: 40,\n    convRule: rule13\n}, {\n    start: 129168,\n    length: 30,\n    convRule: rule13\n}, {\n    start: 129200,\n    length: 2,\n    convRule: rule13\n}, {\n    start: 129280,\n    length: 121,\n    convRule: rule13\n}, {\n    start: 129402,\n    length: 82,\n    convRule: rule13\n}, {\n    start: 129485,\n    length: 135,\n    convRule: rule13\n}, {\n    start: 129632,\n    length: 14,\n    convRule: rule13\n}, {\n    start: 129648,\n    length: 5,\n    convRule: rule13\n}, {\n    start: 129656,\n    length: 3,\n    convRule: rule13\n}, {\n    start: 129664,\n    length: 7,\n    convRule: rule13\n}, {\n    start: 129680,\n    length: 25,\n    convRule: rule13\n}, {\n    start: 129712,\n    length: 7,\n    convRule: rule13\n}, {\n    start: 129728,\n    length: 3,\n    convRule: rule13\n}, {\n    start: 129744,\n    length: 7,\n    convRule: rule13\n}, {\n    start: 129792,\n    length: 147,\n    convRule: rule13\n}, {\n    start: 129940,\n    length: 55,\n    convRule: rule13\n}, {\n    start: 130032,\n    length: 10,\n    convRule: rule8\n}, {\n    start: 131072,\n    length: 42718,\n    convRule: rule14\n}, {\n    start: 173824,\n    length: 4149,\n    convRule: rule14\n}, {\n    start: 177984,\n    length: 222,\n    convRule: rule14\n}, {\n    start: 178208,\n    length: 5762,\n    convRule: rule14\n}, {\n    start: 183984,\n    length: 7473,\n    convRule: rule14\n}, {\n    start: 194560,\n    length: 542,\n    convRule: rule14\n}, {\n    start: 196608,\n    length: 4939,\n    convRule: rule14\n}, {\n    start: 917505,\n    length: 1,\n    convRule: rule16\n}, {\n    start: 917536,\n    length: 96,\n    convRule: rule16\n}, {\n    start: 917760,\n    length: 240,\n    convRule: rule92\n}, {\n    start: 983040,\n    length: 65534,\n    convRule: rule200\n}, {\n    start: 1048576,\n    length: 65534,\n    convRule: rule200\n} ];\nvar checkAttr = function (categories) {\n    return function ($$char) {\n        var numOfBlocks = (function () {\n            var $28 = $$char < 256;\n            if ($28) {\n                return numLat1Blocks;\n            };\n            return numBlocks;\n        })();\n        var maybeConversionRule = getRule(allchars)($$char)(numOfBlocks);\n        if (maybeConversionRule instanceof Data_Maybe.Nothing) {\n            return false;\n        };\n        if (maybeConversionRule instanceof Data_Maybe.Just) {\n            return Data_Maybe.isJust(Data_Array.elemIndex(Data_Eq.eqInt)(maybeConversionRule.value0.category)(categories));\n        };\n        throw new Error(\"Failed pattern match at Data.CodePoint.Unicode.Internal (line 5628, column 8 - line 5630, column 92): \" + [ maybeConversionRule.constructor.name ]);\n    };\n};\nvar uIswalnum = checkAttr([ gencatLT, gencatLU, gencatLL, gencatLM, gencatLO, gencatMC, gencatME, gencatMN, gencatNO, gencatND, gencatNL ]);\nvar uIswalpha = checkAttr([ gencatLL, gencatLU, gencatLT, gencatLM, gencatLO ]);\nvar uIswcntrl = checkAttr([ gencatCC ]);\nvar uIswdigit = checkAttr([ gencatND ]);\nvar uIswlower = checkAttr([ gencatLL ]);\nvar uIswprint = checkAttr([ gencatMC, gencatNO, gencatSK, gencatME, gencatND, gencatPO, gencatLT, gencatPC, gencatSM, gencatZS, gencatLU, gencatPD, gencatSO, gencatPE, gencatPF, gencatPS, gencatSC, gencatLL, gencatLM, gencatPI, gencatNL, gencatMN, gencatLO ]);\nvar uIswupper = checkAttr([ gencatLU, gencatLT ]);\nvar uGencat = function ($$char) {\n    var conversionRule = getRule(allchars)($$char)(numBlocks);\n    return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {\n        return v.unicodeCat;\n    })(conversionRule);\n};\nmodule.exports = {\n    NUMCAT_LU: NUMCAT_LU,\n    NUMCAT_LL: NUMCAT_LL,\n    NUMCAT_LT: NUMCAT_LT,\n    NUMCAT_LM: NUMCAT_LM,\n    NUMCAT_LO: NUMCAT_LO,\n    NUMCAT_MN: NUMCAT_MN,\n    NUMCAT_MC: NUMCAT_MC,\n    NUMCAT_ME: NUMCAT_ME,\n    NUMCAT_ND: NUMCAT_ND,\n    NUMCAT_NL: NUMCAT_NL,\n    NUMCAT_NO: NUMCAT_NO,\n    NUMCAT_PC: NUMCAT_PC,\n    NUMCAT_PD: NUMCAT_PD,\n    NUMCAT_PS: NUMCAT_PS,\n    NUMCAT_PE: NUMCAT_PE,\n    NUMCAT_PI: NUMCAT_PI,\n    NUMCAT_PF: NUMCAT_PF,\n    NUMCAT_PO: NUMCAT_PO,\n    NUMCAT_SM: NUMCAT_SM,\n    NUMCAT_SC: NUMCAT_SC,\n    NUMCAT_SK: NUMCAT_SK,\n    NUMCAT_SO: NUMCAT_SO,\n    NUMCAT_ZS: NUMCAT_ZS,\n    NUMCAT_ZL: NUMCAT_ZL,\n    NUMCAT_ZP: NUMCAT_ZP,\n    NUMCAT_CC: NUMCAT_CC,\n    NUMCAT_CF: NUMCAT_CF,\n    NUMCAT_CS: NUMCAT_CS,\n    NUMCAT_CO: NUMCAT_CO,\n    NUMCAT_CN: NUMCAT_CN,\n    ConversionRule: ConversionRule,\n    CharBlock: CharBlock,\n    gencatPF: gencatPF,\n    gencatSM: gencatSM,\n    gencatSO: gencatSO,\n    gencatPI: gencatPI,\n    gencatMC: gencatMC,\n    gencatCO: gencatCO,\n    gencatME: gencatME,\n    gencatPO: gencatPO,\n    gencatCS: gencatCS,\n    gencatPS: gencatPS,\n    gencatMN: gencatMN,\n    gencatZL: gencatZL,\n    gencatZP: gencatZP,\n    gencatZS: gencatZS,\n    gencatLL: gencatLL,\n    gencatLM: gencatLM,\n    gencatLO: gencatLO,\n    gencatND: gencatND,\n    gencatLT: gencatLT,\n    gencatSC: gencatSC,\n    gencatLU: gencatLU,\n    gencatNL: gencatNL,\n    gencatCC: gencatCC,\n    gencatNO: gencatNO,\n    gencatCF: gencatCF,\n    gencatPC: gencatPC,\n    gencatSK: gencatSK,\n    gencatPD: gencatPD,\n    gencatPE: gencatPE,\n    maxUniChar: maxUniChar,\n    numBlocks: numBlocks,\n    numConvBlocks: numConvBlocks,\n    numSpaceBlocks: numSpaceBlocks,\n    numLat1Blocks: numLat1Blocks,\n    numRules: numRules,\n    rule201: rule201,\n    rule188: rule188,\n    rule63: rule63,\n    rule148: rule148,\n    rule184: rule184,\n    rule74: rule74,\n    rule194: rule194,\n    rule22: rule22,\n    rule192: rule192,\n    rule150: rule150,\n    rule45: rule45,\n    rule183: rule183,\n    rule115: rule115,\n    rule110: rule110,\n    rule44: rule44,\n    rule81: rule81,\n    rule165: rule165,\n    rule40: rule40,\n    rule42: rule42,\n    rule75: rule75,\n    rule29: rule29,\n    rule32: rule32,\n    rule37: rule37,\n    rule111: rule111,\n    rule86: rule86,\n    rule5: rule5,\n    rule123: rule123,\n    rule73: rule73,\n    rule164: rule164,\n    rule167: rule167,\n    rule130: rule130,\n    rule113: rule113,\n    rule102: rule102,\n    rule61: rule61,\n    rule89: rule89,\n    rule62: rule62,\n    rule112: rule112,\n    rule105: rule105,\n    rule60: rule60,\n    rule51: rule51,\n    rule96: rule96,\n    rule95: rule95,\n    rule145: rule145,\n    rule133: rule133,\n    rule203: rule203,\n    rule200: rule200,\n    rule202: rule202,\n    rule28: rule28,\n    rule84: rule84,\n    rule180: rule180,\n    rule179: rule179,\n    rule195: rule195,\n    rule193: rule193,\n    rule9: rule9,\n    rule181: rule181,\n    rule160: rule160,\n    rule4: rule4,\n    rule155: rule155,\n    rule69: rule69,\n    rule177: rule177,\n    rule154: rule154,\n    rule175: rule175,\n    rule25: rule25,\n    rule27: rule27,\n    rule127: rule127,\n    rule16: rule16,\n    rule78: rule78,\n    rule144: rule144,\n    rule26: rule26,\n    rule149: rule149,\n    rule41: rule41,\n    rule90: rule90,\n    rule31: rule31,\n    rule198: rule198,\n    rule129: rule129,\n    rule30: rule30,\n    rule71: rule71,\n    rule3: rule3,\n    rule157: rule157,\n    rule24: rule24,\n    rule33: rule33,\n    rule34: rule34,\n    rule50: rule50,\n    rule176: rule176,\n    rule58: rule58,\n    rule67: rule67,\n    rule80: rule80,\n    rule141: rule141,\n    rule131: rule131,\n    rule57: rule57,\n    rule106: rule106,\n    rule94: rule94,\n    rule118: rule118,\n    rule109: rule109,\n    rule72: rule72,\n    rule163: rule163,\n    rule161: rule161,\n    rule14: rule14,\n    rule100: rule100,\n    rule204: rule204,\n    rule187: rule187,\n    rule143: rule143,\n    rule138: rule138,\n    rule12: rule12,\n    rule93: rule93,\n    rule199: rule199,\n    rule17: rule17,\n    rule156: rule156,\n    rule169: rule169,\n    rule64: rule64,\n    rule83: rule83,\n    rule2: rule2,\n    rule92: rule92,\n    rule39: rule39,\n    rule185: rule185,\n    rule107: rule107,\n    rule43: rule43,\n    rule53: rule53,\n    rule91: rule91,\n    rule140: rule140,\n    rule158: rule158,\n    rule132: rule132,\n    rule142: rule142,\n    rule21: rule21,\n    rule125: rule125,\n    rule119: rule119,\n    rule13: rule13,\n    rule19: rule19,\n    rule147: rule147,\n    rule49: rule49,\n    rule85: rule85,\n    rule20: rule20,\n    rule135: rule135,\n    rule70: rule70,\n    rule170: rule170,\n    rule196: rule196,\n    rule108: rule108,\n    rule66: rule66,\n    rule162: rule162,\n    rule128: rule128,\n    rule8: rule8,\n    rule103: rule103,\n    rule77: rule77,\n    rule124: rule124,\n    rule6: rule6,\n    rule7: rule7,\n    rule55: rule55,\n    rule54: rule54,\n    rule186: rule186,\n    rule146: rule146,\n    rule134: rule134,\n    rule65: rule65,\n    rule82: rule82,\n    rule56: rule56,\n    rule190: rule190,\n    rule159: rule159,\n    rule153: rule153,\n    rule152: rule152,\n    rule120: rule120,\n    rule189: rule189,\n    rule48: rule48,\n    rule52: rule52,\n    rule197: rule197,\n    rule178: rule178,\n    rule79: rule79,\n    rule11: rule11,\n    rule151: rule151,\n    rule38: rule38,\n    rule18: rule18,\n    rule174: rule174,\n    rule36: rule36,\n    rule46: rule46,\n    rule88: rule88,\n    rule10: rule10,\n    rule35: rule35,\n    rule172: rule172,\n    rule117: rule117,\n    rule47: rule47,\n    rule182: rule182,\n    rule76: rule76,\n    rule136: rule136,\n    rule59: rule59,\n    rule116: rule116,\n    rule173: rule173,\n    rule15: rule15,\n    rule122: rule122,\n    rule99: rule99,\n    rule168: rule168,\n    rule126: rule126,\n    rule98: rule98,\n    rule87: rule87,\n    rule97: rule97,\n    rule114: rule114,\n    rule171: rule171,\n    rule121: rule121,\n    rule166: rule166,\n    rule101: rule101,\n    rule139: rule139,\n    rule104: rule104,\n    rule23: rule23,\n    rule68: rule68,\n    rule191: rule191,\n    rule0: rule0,\n    rule1: rule1,\n    rule137: rule137,\n    allchars: allchars,\n    convchars: convchars,\n    spacechars: spacechars,\n    nullrule: nullrule,\n    blkCmp: blkCmp,\n    getRule: getRule,\n    bsearch: bsearch,\n    checkAttr: checkAttr,\n    checkAttrS: checkAttrS,\n    uIswcntrl: uIswcntrl,\n    uIswprint: uIswprint,\n    uIswupper: uIswupper,\n    uIswlower: uIswlower,\n    uIswalpha: uIswalpha,\n    uIswdigit: uIswdigit,\n    uIswalnum: uIswalnum,\n    uIswspace: uIswspace,\n    caseConv: caseConv,\n    uTowupper: uTowupper,\n    uTowlower: uTowlower,\n    uTowtitle: uTowtitle,\n    uGencat: uGencat,\n    showUnicodeCategory: showUnicodeCategory,\n    showConversionRule: showConversionRule,\n    showCharBlock: showCharBlock\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal.purs?");

/***/ }),

/***/ "./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal/Casing.purs":
/*!*******************************************************************************!*\
  !*** ./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal/Casing.purs ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_CodePoint_Unicode_Internal = __webpack_require__(/*! ./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal.purs */ \"./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar zeroRec = function (code) {\n    return {\n        code: code,\n        lower: [  ],\n        title: [  ],\n        upper: [  ],\n        fold: 0,\n        foldFull: [  ]\n    };\n};\nvar rules = [ {\n    code: 65,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 97,\n    foldFull: [ 97 ]\n}, {\n    code: 66,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 98,\n    foldFull: [ 98 ]\n}, {\n    code: 67,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 99,\n    foldFull: [ 99 ]\n}, {\n    code: 68,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 100,\n    foldFull: [ 100 ]\n}, {\n    code: 69,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 101,\n    foldFull: [ 101 ]\n}, {\n    code: 70,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 102,\n    foldFull: [ 102 ]\n}, {\n    code: 71,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 103,\n    foldFull: [ 103 ]\n}, {\n    code: 72,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 104,\n    foldFull: [ 104 ]\n}, {\n    code: 73,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 105,\n    foldFull: [ 105 ]\n}, {\n    code: 74,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 106,\n    foldFull: [ 106 ]\n}, {\n    code: 75,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 107,\n    foldFull: [ 107 ]\n}, {\n    code: 76,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 108,\n    foldFull: [ 108 ]\n}, {\n    code: 77,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 109,\n    foldFull: [ 109 ]\n}, {\n    code: 78,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 110,\n    foldFull: [ 110 ]\n}, {\n    code: 79,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 111,\n    foldFull: [ 111 ]\n}, {\n    code: 80,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 112,\n    foldFull: [ 112 ]\n}, {\n    code: 81,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 113,\n    foldFull: [ 113 ]\n}, {\n    code: 82,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 114,\n    foldFull: [ 114 ]\n}, {\n    code: 83,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 115,\n    foldFull: [ 115 ]\n}, {\n    code: 84,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 116,\n    foldFull: [ 116 ]\n}, {\n    code: 85,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 117,\n    foldFull: [ 117 ]\n}, {\n    code: 86,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 118,\n    foldFull: [ 118 ]\n}, {\n    code: 87,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 119,\n    foldFull: [ 119 ]\n}, {\n    code: 88,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 120,\n    foldFull: [ 120 ]\n}, {\n    code: 89,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 121,\n    foldFull: [ 121 ]\n}, {\n    code: 90,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 122,\n    foldFull: [ 122 ]\n}, {\n    code: 181,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 956,\n    foldFull: [ 956 ]\n}, {\n    code: 192,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 224,\n    foldFull: [ 224 ]\n}, {\n    code: 193,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 225,\n    foldFull: [ 225 ]\n}, {\n    code: 194,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 226,\n    foldFull: [ 226 ]\n}, {\n    code: 195,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 227,\n    foldFull: [ 227 ]\n}, {\n    code: 196,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 228,\n    foldFull: [ 228 ]\n}, {\n    code: 197,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 229,\n    foldFull: [ 229 ]\n}, {\n    code: 198,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 230,\n    foldFull: [ 230 ]\n}, {\n    code: 199,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 231,\n    foldFull: [ 231 ]\n}, {\n    code: 200,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 232,\n    foldFull: [ 232 ]\n}, {\n    code: 201,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 233,\n    foldFull: [ 233 ]\n}, {\n    code: 202,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 234,\n    foldFull: [ 234 ]\n}, {\n    code: 203,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 235,\n    foldFull: [ 235 ]\n}, {\n    code: 204,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 236,\n    foldFull: [ 236 ]\n}, {\n    code: 205,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 237,\n    foldFull: [ 237 ]\n}, {\n    code: 206,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 238,\n    foldFull: [ 238 ]\n}, {\n    code: 207,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 239,\n    foldFull: [ 239 ]\n}, {\n    code: 208,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 240,\n    foldFull: [ 240 ]\n}, {\n    code: 209,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 241,\n    foldFull: [ 241 ]\n}, {\n    code: 210,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 242,\n    foldFull: [ 242 ]\n}, {\n    code: 211,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 243,\n    foldFull: [ 243 ]\n}, {\n    code: 212,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 244,\n    foldFull: [ 244 ]\n}, {\n    code: 213,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 245,\n    foldFull: [ 245 ]\n}, {\n    code: 214,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 246,\n    foldFull: [ 246 ]\n}, {\n    code: 216,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 248,\n    foldFull: [ 248 ]\n}, {\n    code: 217,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 249,\n    foldFull: [ 249 ]\n}, {\n    code: 218,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 250,\n    foldFull: [ 250 ]\n}, {\n    code: 219,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 251,\n    foldFull: [ 251 ]\n}, {\n    code: 220,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 252,\n    foldFull: [ 252 ]\n}, {\n    code: 221,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 253,\n    foldFull: [ 253 ]\n}, {\n    code: 222,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 254,\n    foldFull: [ 254 ]\n}, {\n    code: 223,\n    lower: [ 223 ],\n    title: [ 83, 115 ],\n    upper: [ 83, 83 ],\n    fold: 0,\n    foldFull: [ 115, 115 ]\n}, {\n    code: 223,\n    lower: [ 223 ],\n    title: [ 83, 115 ],\n    upper: [ 83, 83 ],\n    fold: 0,\n    foldFull: [ 115, 115 ]\n}, {\n    code: 256,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 257,\n    foldFull: [ 257 ]\n}, {\n    code: 258,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 259,\n    foldFull: [ 259 ]\n}, {\n    code: 260,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 261,\n    foldFull: [ 261 ]\n}, {\n    code: 262,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 263,\n    foldFull: [ 263 ]\n}, {\n    code: 264,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 265,\n    foldFull: [ 265 ]\n}, {\n    code: 266,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 267,\n    foldFull: [ 267 ]\n}, {\n    code: 268,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 269,\n    foldFull: [ 269 ]\n}, {\n    code: 270,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 271,\n    foldFull: [ 271 ]\n}, {\n    code: 272,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 273,\n    foldFull: [ 273 ]\n}, {\n    code: 274,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 275,\n    foldFull: [ 275 ]\n}, {\n    code: 276,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 277,\n    foldFull: [ 277 ]\n}, {\n    code: 278,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 279,\n    foldFull: [ 279 ]\n}, {\n    code: 280,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 281,\n    foldFull: [ 281 ]\n}, {\n    code: 282,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 283,\n    foldFull: [ 283 ]\n}, {\n    code: 284,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 285,\n    foldFull: [ 285 ]\n}, {\n    code: 286,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 287,\n    foldFull: [ 287 ]\n}, {\n    code: 288,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 289,\n    foldFull: [ 289 ]\n}, {\n    code: 290,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 291,\n    foldFull: [ 291 ]\n}, {\n    code: 292,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 293,\n    foldFull: [ 293 ]\n}, {\n    code: 294,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 295,\n    foldFull: [ 295 ]\n}, {\n    code: 296,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 297,\n    foldFull: [ 297 ]\n}, {\n    code: 298,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 299,\n    foldFull: [ 299 ]\n}, {\n    code: 300,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 301,\n    foldFull: [ 301 ]\n}, {\n    code: 302,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 303,\n    foldFull: [ 303 ]\n}, {\n    code: 304,\n    lower: [ 105, 775 ],\n    title: [ 304 ],\n    upper: [ 304 ],\n    fold: 0,\n    foldFull: [ 105, 775 ]\n}, {\n    code: 304,\n    lower: [ 105, 775 ],\n    title: [ 304 ],\n    upper: [ 304 ],\n    fold: 0,\n    foldFull: [ 105, 775 ]\n}, {\n    code: 306,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 307,\n    foldFull: [ 307 ]\n}, {\n    code: 308,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 309,\n    foldFull: [ 309 ]\n}, {\n    code: 310,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 311,\n    foldFull: [ 311 ]\n}, {\n    code: 313,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 314,\n    foldFull: [ 314 ]\n}, {\n    code: 315,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 316,\n    foldFull: [ 316 ]\n}, {\n    code: 317,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 318,\n    foldFull: [ 318 ]\n}, {\n    code: 319,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 320,\n    foldFull: [ 320 ]\n}, {\n    code: 321,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 322,\n    foldFull: [ 322 ]\n}, {\n    code: 323,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 324,\n    foldFull: [ 324 ]\n}, {\n    code: 325,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 326,\n    foldFull: [ 326 ]\n}, {\n    code: 327,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 328,\n    foldFull: [ 328 ]\n}, {\n    code: 329,\n    lower: [ 329 ],\n    title: [ 700, 78 ],\n    upper: [ 700, 78 ],\n    fold: 0,\n    foldFull: [ 700, 110 ]\n}, {\n    code: 329,\n    lower: [ 329 ],\n    title: [ 700, 78 ],\n    upper: [ 700, 78 ],\n    fold: 0,\n    foldFull: [ 700, 110 ]\n}, {\n    code: 330,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 331,\n    foldFull: [ 331 ]\n}, {\n    code: 332,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 333,\n    foldFull: [ 333 ]\n}, {\n    code: 334,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 335,\n    foldFull: [ 335 ]\n}, {\n    code: 336,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 337,\n    foldFull: [ 337 ]\n}, {\n    code: 338,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 339,\n    foldFull: [ 339 ]\n}, {\n    code: 340,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 341,\n    foldFull: [ 341 ]\n}, {\n    code: 342,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 343,\n    foldFull: [ 343 ]\n}, {\n    code: 344,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 345,\n    foldFull: [ 345 ]\n}, {\n    code: 346,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 347,\n    foldFull: [ 347 ]\n}, {\n    code: 348,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 349,\n    foldFull: [ 349 ]\n}, {\n    code: 350,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 351,\n    foldFull: [ 351 ]\n}, {\n    code: 352,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 353,\n    foldFull: [ 353 ]\n}, {\n    code: 354,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 355,\n    foldFull: [ 355 ]\n}, {\n    code: 356,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 357,\n    foldFull: [ 357 ]\n}, {\n    code: 358,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 359,\n    foldFull: [ 359 ]\n}, {\n    code: 360,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 361,\n    foldFull: [ 361 ]\n}, {\n    code: 362,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 363,\n    foldFull: [ 363 ]\n}, {\n    code: 364,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 365,\n    foldFull: [ 365 ]\n}, {\n    code: 366,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 367,\n    foldFull: [ 367 ]\n}, {\n    code: 368,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 369,\n    foldFull: [ 369 ]\n}, {\n    code: 370,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 371,\n    foldFull: [ 371 ]\n}, {\n    code: 372,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 373,\n    foldFull: [ 373 ]\n}, {\n    code: 374,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 375,\n    foldFull: [ 375 ]\n}, {\n    code: 376,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 255,\n    foldFull: [ 255 ]\n}, {\n    code: 377,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 378,\n    foldFull: [ 378 ]\n}, {\n    code: 379,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 380,\n    foldFull: [ 380 ]\n}, {\n    code: 381,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 382,\n    foldFull: [ 382 ]\n}, {\n    code: 383,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 115,\n    foldFull: [ 115 ]\n}, {\n    code: 385,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 595,\n    foldFull: [ 595 ]\n}, {\n    code: 386,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 387,\n    foldFull: [ 387 ]\n}, {\n    code: 388,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 389,\n    foldFull: [ 389 ]\n}, {\n    code: 390,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 596,\n    foldFull: [ 596 ]\n}, {\n    code: 391,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 392,\n    foldFull: [ 392 ]\n}, {\n    code: 393,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 598,\n    foldFull: [ 598 ]\n}, {\n    code: 394,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 599,\n    foldFull: [ 599 ]\n}, {\n    code: 395,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 396,\n    foldFull: [ 396 ]\n}, {\n    code: 398,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 477,\n    foldFull: [ 477 ]\n}, {\n    code: 399,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 601,\n    foldFull: [ 601 ]\n}, {\n    code: 400,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 603,\n    foldFull: [ 603 ]\n}, {\n    code: 401,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 402,\n    foldFull: [ 402 ]\n}, {\n    code: 403,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 608,\n    foldFull: [ 608 ]\n}, {\n    code: 404,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 611,\n    foldFull: [ 611 ]\n}, {\n    code: 406,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 617,\n    foldFull: [ 617 ]\n}, {\n    code: 407,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 616,\n    foldFull: [ 616 ]\n}, {\n    code: 408,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 409,\n    foldFull: [ 409 ]\n}, {\n    code: 412,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 623,\n    foldFull: [ 623 ]\n}, {\n    code: 413,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 626,\n    foldFull: [ 626 ]\n}, {\n    code: 415,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 629,\n    foldFull: [ 629 ]\n}, {\n    code: 416,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 417,\n    foldFull: [ 417 ]\n}, {\n    code: 418,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 419,\n    foldFull: [ 419 ]\n}, {\n    code: 420,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 421,\n    foldFull: [ 421 ]\n}, {\n    code: 422,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 640,\n    foldFull: [ 640 ]\n}, {\n    code: 423,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 424,\n    foldFull: [ 424 ]\n}, {\n    code: 425,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 643,\n    foldFull: [ 643 ]\n}, {\n    code: 428,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 429,\n    foldFull: [ 429 ]\n}, {\n    code: 430,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 648,\n    foldFull: [ 648 ]\n}, {\n    code: 431,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 432,\n    foldFull: [ 432 ]\n}, {\n    code: 433,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 650,\n    foldFull: [ 650 ]\n}, {\n    code: 434,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 651,\n    foldFull: [ 651 ]\n}, {\n    code: 435,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 436,\n    foldFull: [ 436 ]\n}, {\n    code: 437,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 438,\n    foldFull: [ 438 ]\n}, {\n    code: 439,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 658,\n    foldFull: [ 658 ]\n}, {\n    code: 440,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 441,\n    foldFull: [ 441 ]\n}, {\n    code: 444,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 445,\n    foldFull: [ 445 ]\n}, {\n    code: 452,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 454,\n    foldFull: [ 454 ]\n}, {\n    code: 453,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 454,\n    foldFull: [ 454 ]\n}, {\n    code: 455,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 457,\n    foldFull: [ 457 ]\n}, {\n    code: 456,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 457,\n    foldFull: [ 457 ]\n}, {\n    code: 458,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 460,\n    foldFull: [ 460 ]\n}, {\n    code: 459,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 460,\n    foldFull: [ 460 ]\n}, {\n    code: 461,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 462,\n    foldFull: [ 462 ]\n}, {\n    code: 463,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 464,\n    foldFull: [ 464 ]\n}, {\n    code: 465,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 466,\n    foldFull: [ 466 ]\n}, {\n    code: 467,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 468,\n    foldFull: [ 468 ]\n}, {\n    code: 469,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 470,\n    foldFull: [ 470 ]\n}, {\n    code: 471,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 472,\n    foldFull: [ 472 ]\n}, {\n    code: 473,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 474,\n    foldFull: [ 474 ]\n}, {\n    code: 475,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 476,\n    foldFull: [ 476 ]\n}, {\n    code: 478,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 479,\n    foldFull: [ 479 ]\n}, {\n    code: 480,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 481,\n    foldFull: [ 481 ]\n}, {\n    code: 482,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 483,\n    foldFull: [ 483 ]\n}, {\n    code: 484,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 485,\n    foldFull: [ 485 ]\n}, {\n    code: 486,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 487,\n    foldFull: [ 487 ]\n}, {\n    code: 488,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 489,\n    foldFull: [ 489 ]\n}, {\n    code: 490,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 491,\n    foldFull: [ 491 ]\n}, {\n    code: 492,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 493,\n    foldFull: [ 493 ]\n}, {\n    code: 494,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 495,\n    foldFull: [ 495 ]\n}, {\n    code: 496,\n    lower: [ 496 ],\n    title: [ 74, 780 ],\n    upper: [ 74, 780 ],\n    fold: 0,\n    foldFull: [ 106, 780 ]\n}, {\n    code: 496,\n    lower: [ 496 ],\n    title: [ 74, 780 ],\n    upper: [ 74, 780 ],\n    fold: 0,\n    foldFull: [ 106, 780 ]\n}, {\n    code: 497,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 499,\n    foldFull: [ 499 ]\n}, {\n    code: 498,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 499,\n    foldFull: [ 499 ]\n}, {\n    code: 500,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 501,\n    foldFull: [ 501 ]\n}, {\n    code: 502,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 405,\n    foldFull: [ 405 ]\n}, {\n    code: 503,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 447,\n    foldFull: [ 447 ]\n}, {\n    code: 504,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 505,\n    foldFull: [ 505 ]\n}, {\n    code: 506,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 507,\n    foldFull: [ 507 ]\n}, {\n    code: 508,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 509,\n    foldFull: [ 509 ]\n}, {\n    code: 510,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 511,\n    foldFull: [ 511 ]\n}, {\n    code: 512,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 513,\n    foldFull: [ 513 ]\n}, {\n    code: 514,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 515,\n    foldFull: [ 515 ]\n}, {\n    code: 516,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 517,\n    foldFull: [ 517 ]\n}, {\n    code: 518,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 519,\n    foldFull: [ 519 ]\n}, {\n    code: 520,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 521,\n    foldFull: [ 521 ]\n}, {\n    code: 522,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 523,\n    foldFull: [ 523 ]\n}, {\n    code: 524,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 525,\n    foldFull: [ 525 ]\n}, {\n    code: 526,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 527,\n    foldFull: [ 527 ]\n}, {\n    code: 528,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 529,\n    foldFull: [ 529 ]\n}, {\n    code: 530,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 531,\n    foldFull: [ 531 ]\n}, {\n    code: 532,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 533,\n    foldFull: [ 533 ]\n}, {\n    code: 534,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 535,\n    foldFull: [ 535 ]\n}, {\n    code: 536,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 537,\n    foldFull: [ 537 ]\n}, {\n    code: 538,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 539,\n    foldFull: [ 539 ]\n}, {\n    code: 540,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 541,\n    foldFull: [ 541 ]\n}, {\n    code: 542,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 543,\n    foldFull: [ 543 ]\n}, {\n    code: 544,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 414,\n    foldFull: [ 414 ]\n}, {\n    code: 546,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 547,\n    foldFull: [ 547 ]\n}, {\n    code: 548,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 549,\n    foldFull: [ 549 ]\n}, {\n    code: 550,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 551,\n    foldFull: [ 551 ]\n}, {\n    code: 552,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 553,\n    foldFull: [ 553 ]\n}, {\n    code: 554,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 555,\n    foldFull: [ 555 ]\n}, {\n    code: 556,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 557,\n    foldFull: [ 557 ]\n}, {\n    code: 558,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 559,\n    foldFull: [ 559 ]\n}, {\n    code: 560,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 561,\n    foldFull: [ 561 ]\n}, {\n    code: 562,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 563,\n    foldFull: [ 563 ]\n}, {\n    code: 570,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11365,\n    foldFull: [ 11365 ]\n}, {\n    code: 571,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 572,\n    foldFull: [ 572 ]\n}, {\n    code: 573,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 410,\n    foldFull: [ 410 ]\n}, {\n    code: 574,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11366,\n    foldFull: [ 11366 ]\n}, {\n    code: 577,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 578,\n    foldFull: [ 578 ]\n}, {\n    code: 579,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 384,\n    foldFull: [ 384 ]\n}, {\n    code: 580,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 649,\n    foldFull: [ 649 ]\n}, {\n    code: 581,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 652,\n    foldFull: [ 652 ]\n}, {\n    code: 582,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 583,\n    foldFull: [ 583 ]\n}, {\n    code: 584,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 585,\n    foldFull: [ 585 ]\n}, {\n    code: 586,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 587,\n    foldFull: [ 587 ]\n}, {\n    code: 588,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 589,\n    foldFull: [ 589 ]\n}, {\n    code: 590,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 591,\n    foldFull: [ 591 ]\n}, {\n    code: 837,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 953,\n    foldFull: [ 953 ]\n}, {\n    code: 880,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 881,\n    foldFull: [ 881 ]\n}, {\n    code: 882,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 883,\n    foldFull: [ 883 ]\n}, {\n    code: 886,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 887,\n    foldFull: [ 887 ]\n}, {\n    code: 895,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1011,\n    foldFull: [ 1011 ]\n}, {\n    code: 902,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 940,\n    foldFull: [ 940 ]\n}, {\n    code: 904,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 941,\n    foldFull: [ 941 ]\n}, {\n    code: 905,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 942,\n    foldFull: [ 942 ]\n}, {\n    code: 906,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 943,\n    foldFull: [ 943 ]\n}, {\n    code: 908,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 972,\n    foldFull: [ 972 ]\n}, {\n    code: 910,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 973,\n    foldFull: [ 973 ]\n}, {\n    code: 911,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 974,\n    foldFull: [ 974 ]\n}, {\n    code: 912,\n    lower: [ 912 ],\n    title: [ 921, 776, 769 ],\n    upper: [ 921, 776, 769 ],\n    fold: 0,\n    foldFull: [ 953, 776, 769 ]\n}, {\n    code: 912,\n    lower: [ 912 ],\n    title: [ 921, 776, 769 ],\n    upper: [ 921, 776, 769 ],\n    fold: 0,\n    foldFull: [ 953, 776, 769 ]\n}, {\n    code: 913,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 945,\n    foldFull: [ 945 ]\n}, {\n    code: 914,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 946,\n    foldFull: [ 946 ]\n}, {\n    code: 915,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 947,\n    foldFull: [ 947 ]\n}, {\n    code: 916,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 948,\n    foldFull: [ 948 ]\n}, {\n    code: 917,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 949,\n    foldFull: [ 949 ]\n}, {\n    code: 918,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 950,\n    foldFull: [ 950 ]\n}, {\n    code: 919,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 951,\n    foldFull: [ 951 ]\n}, {\n    code: 920,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 952,\n    foldFull: [ 952 ]\n}, {\n    code: 921,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 953,\n    foldFull: [ 953 ]\n}, {\n    code: 922,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 954,\n    foldFull: [ 954 ]\n}, {\n    code: 923,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 955,\n    foldFull: [ 955 ]\n}, {\n    code: 924,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 956,\n    foldFull: [ 956 ]\n}, {\n    code: 925,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 957,\n    foldFull: [ 957 ]\n}, {\n    code: 926,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 958,\n    foldFull: [ 958 ]\n}, {\n    code: 927,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 959,\n    foldFull: [ 959 ]\n}, {\n    code: 928,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 960,\n    foldFull: [ 960 ]\n}, {\n    code: 929,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 961,\n    foldFull: [ 961 ]\n}, {\n    code: 931,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 963,\n    foldFull: [ 963 ]\n}, {\n    code: 932,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 964,\n    foldFull: [ 964 ]\n}, {\n    code: 933,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 965,\n    foldFull: [ 965 ]\n}, {\n    code: 934,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 966,\n    foldFull: [ 966 ]\n}, {\n    code: 935,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 967,\n    foldFull: [ 967 ]\n}, {\n    code: 936,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 968,\n    foldFull: [ 968 ]\n}, {\n    code: 937,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 969,\n    foldFull: [ 969 ]\n}, {\n    code: 938,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 970,\n    foldFull: [ 970 ]\n}, {\n    code: 939,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 971,\n    foldFull: [ 971 ]\n}, {\n    code: 944,\n    lower: [ 944 ],\n    title: [ 933, 776, 769 ],\n    upper: [ 933, 776, 769 ],\n    fold: 0,\n    foldFull: [ 965, 776, 769 ]\n}, {\n    code: 944,\n    lower: [ 944 ],\n    title: [ 933, 776, 769 ],\n    upper: [ 933, 776, 769 ],\n    fold: 0,\n    foldFull: [ 965, 776, 769 ]\n}, {\n    code: 962,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 963,\n    foldFull: [ 963 ]\n}, {\n    code: 975,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 983,\n    foldFull: [ 983 ]\n}, {\n    code: 976,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 946,\n    foldFull: [ 946 ]\n}, {\n    code: 977,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 952,\n    foldFull: [ 952 ]\n}, {\n    code: 981,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 966,\n    foldFull: [ 966 ]\n}, {\n    code: 982,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 960,\n    foldFull: [ 960 ]\n}, {\n    code: 984,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 985,\n    foldFull: [ 985 ]\n}, {\n    code: 986,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 987,\n    foldFull: [ 987 ]\n}, {\n    code: 988,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 989,\n    foldFull: [ 989 ]\n}, {\n    code: 990,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 991,\n    foldFull: [ 991 ]\n}, {\n    code: 992,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 993,\n    foldFull: [ 993 ]\n}, {\n    code: 994,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 995,\n    foldFull: [ 995 ]\n}, {\n    code: 996,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 997,\n    foldFull: [ 997 ]\n}, {\n    code: 998,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 999,\n    foldFull: [ 999 ]\n}, {\n    code: 1000,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1001,\n    foldFull: [ 1001 ]\n}, {\n    code: 1002,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1003,\n    foldFull: [ 1003 ]\n}, {\n    code: 1004,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1005,\n    foldFull: [ 1005 ]\n}, {\n    code: 1006,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1007,\n    foldFull: [ 1007 ]\n}, {\n    code: 1008,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 954,\n    foldFull: [ 954 ]\n}, {\n    code: 1009,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 961,\n    foldFull: [ 961 ]\n}, {\n    code: 1012,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 952,\n    foldFull: [ 952 ]\n}, {\n    code: 1013,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 949,\n    foldFull: [ 949 ]\n}, {\n    code: 1015,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1016,\n    foldFull: [ 1016 ]\n}, {\n    code: 1017,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1010,\n    foldFull: [ 1010 ]\n}, {\n    code: 1018,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1019,\n    foldFull: [ 1019 ]\n}, {\n    code: 1021,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 891,\n    foldFull: [ 891 ]\n}, {\n    code: 1022,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 892,\n    foldFull: [ 892 ]\n}, {\n    code: 1023,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 893,\n    foldFull: [ 893 ]\n}, {\n    code: 1024,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1104,\n    foldFull: [ 1104 ]\n}, {\n    code: 1025,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1105,\n    foldFull: [ 1105 ]\n}, {\n    code: 1026,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1106,\n    foldFull: [ 1106 ]\n}, {\n    code: 1027,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1107,\n    foldFull: [ 1107 ]\n}, {\n    code: 1028,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1108,\n    foldFull: [ 1108 ]\n}, {\n    code: 1029,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1109,\n    foldFull: [ 1109 ]\n}, {\n    code: 1030,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1110,\n    foldFull: [ 1110 ]\n}, {\n    code: 1031,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1111,\n    foldFull: [ 1111 ]\n}, {\n    code: 1032,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1112,\n    foldFull: [ 1112 ]\n}, {\n    code: 1033,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1113,\n    foldFull: [ 1113 ]\n}, {\n    code: 1034,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1114,\n    foldFull: [ 1114 ]\n}, {\n    code: 1035,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1115,\n    foldFull: [ 1115 ]\n}, {\n    code: 1036,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1116,\n    foldFull: [ 1116 ]\n}, {\n    code: 1037,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1117,\n    foldFull: [ 1117 ]\n}, {\n    code: 1038,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1118,\n    foldFull: [ 1118 ]\n}, {\n    code: 1039,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1119,\n    foldFull: [ 1119 ]\n}, {\n    code: 1040,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1072,\n    foldFull: [ 1072 ]\n}, {\n    code: 1041,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1073,\n    foldFull: [ 1073 ]\n}, {\n    code: 1042,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1074,\n    foldFull: [ 1074 ]\n}, {\n    code: 1043,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1075,\n    foldFull: [ 1075 ]\n}, {\n    code: 1044,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1076,\n    foldFull: [ 1076 ]\n}, {\n    code: 1045,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1077,\n    foldFull: [ 1077 ]\n}, {\n    code: 1046,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1078,\n    foldFull: [ 1078 ]\n}, {\n    code: 1047,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1079,\n    foldFull: [ 1079 ]\n}, {\n    code: 1048,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1080,\n    foldFull: [ 1080 ]\n}, {\n    code: 1049,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1081,\n    foldFull: [ 1081 ]\n}, {\n    code: 1050,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1082,\n    foldFull: [ 1082 ]\n}, {\n    code: 1051,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1083,\n    foldFull: [ 1083 ]\n}, {\n    code: 1052,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1084,\n    foldFull: [ 1084 ]\n}, {\n    code: 1053,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1085,\n    foldFull: [ 1085 ]\n}, {\n    code: 1054,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1086,\n    foldFull: [ 1086 ]\n}, {\n    code: 1055,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1087,\n    foldFull: [ 1087 ]\n}, {\n    code: 1056,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1088,\n    foldFull: [ 1088 ]\n}, {\n    code: 1057,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1089,\n    foldFull: [ 1089 ]\n}, {\n    code: 1058,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1090,\n    foldFull: [ 1090 ]\n}, {\n    code: 1059,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1091,\n    foldFull: [ 1091 ]\n}, {\n    code: 1060,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1092,\n    foldFull: [ 1092 ]\n}, {\n    code: 1061,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1093,\n    foldFull: [ 1093 ]\n}, {\n    code: 1062,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1094,\n    foldFull: [ 1094 ]\n}, {\n    code: 1063,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1095,\n    foldFull: [ 1095 ]\n}, {\n    code: 1064,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1096,\n    foldFull: [ 1096 ]\n}, {\n    code: 1065,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1097,\n    foldFull: [ 1097 ]\n}, {\n    code: 1066,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1098,\n    foldFull: [ 1098 ]\n}, {\n    code: 1067,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1099,\n    foldFull: [ 1099 ]\n}, {\n    code: 1068,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1100,\n    foldFull: [ 1100 ]\n}, {\n    code: 1069,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1101,\n    foldFull: [ 1101 ]\n}, {\n    code: 1070,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1102,\n    foldFull: [ 1102 ]\n}, {\n    code: 1071,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1103,\n    foldFull: [ 1103 ]\n}, {\n    code: 1120,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1121,\n    foldFull: [ 1121 ]\n}, {\n    code: 1122,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1123,\n    foldFull: [ 1123 ]\n}, {\n    code: 1124,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1125,\n    foldFull: [ 1125 ]\n}, {\n    code: 1126,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1127,\n    foldFull: [ 1127 ]\n}, {\n    code: 1128,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1129,\n    foldFull: [ 1129 ]\n}, {\n    code: 1130,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1131,\n    foldFull: [ 1131 ]\n}, {\n    code: 1132,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1133,\n    foldFull: [ 1133 ]\n}, {\n    code: 1134,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1135,\n    foldFull: [ 1135 ]\n}, {\n    code: 1136,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1137,\n    foldFull: [ 1137 ]\n}, {\n    code: 1138,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1139,\n    foldFull: [ 1139 ]\n}, {\n    code: 1140,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1141,\n    foldFull: [ 1141 ]\n}, {\n    code: 1142,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1143,\n    foldFull: [ 1143 ]\n}, {\n    code: 1144,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1145,\n    foldFull: [ 1145 ]\n}, {\n    code: 1146,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1147,\n    foldFull: [ 1147 ]\n}, {\n    code: 1148,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1149,\n    foldFull: [ 1149 ]\n}, {\n    code: 1150,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1151,\n    foldFull: [ 1151 ]\n}, {\n    code: 1152,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1153,\n    foldFull: [ 1153 ]\n}, {\n    code: 1162,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1163,\n    foldFull: [ 1163 ]\n}, {\n    code: 1164,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1165,\n    foldFull: [ 1165 ]\n}, {\n    code: 1166,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1167,\n    foldFull: [ 1167 ]\n}, {\n    code: 1168,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1169,\n    foldFull: [ 1169 ]\n}, {\n    code: 1170,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1171,\n    foldFull: [ 1171 ]\n}, {\n    code: 1172,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1173,\n    foldFull: [ 1173 ]\n}, {\n    code: 1174,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1175,\n    foldFull: [ 1175 ]\n}, {\n    code: 1176,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1177,\n    foldFull: [ 1177 ]\n}, {\n    code: 1178,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1179,\n    foldFull: [ 1179 ]\n}, {\n    code: 1180,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1181,\n    foldFull: [ 1181 ]\n}, {\n    code: 1182,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1183,\n    foldFull: [ 1183 ]\n}, {\n    code: 1184,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1185,\n    foldFull: [ 1185 ]\n}, {\n    code: 1186,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1187,\n    foldFull: [ 1187 ]\n}, {\n    code: 1188,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1189,\n    foldFull: [ 1189 ]\n}, {\n    code: 1190,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1191,\n    foldFull: [ 1191 ]\n}, {\n    code: 1192,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1193,\n    foldFull: [ 1193 ]\n}, {\n    code: 1194,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1195,\n    foldFull: [ 1195 ]\n}, {\n    code: 1196,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1197,\n    foldFull: [ 1197 ]\n}, {\n    code: 1198,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1199,\n    foldFull: [ 1199 ]\n}, {\n    code: 1200,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1201,\n    foldFull: [ 1201 ]\n}, {\n    code: 1202,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1203,\n    foldFull: [ 1203 ]\n}, {\n    code: 1204,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1205,\n    foldFull: [ 1205 ]\n}, {\n    code: 1206,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1207,\n    foldFull: [ 1207 ]\n}, {\n    code: 1208,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1209,\n    foldFull: [ 1209 ]\n}, {\n    code: 1210,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1211,\n    foldFull: [ 1211 ]\n}, {\n    code: 1212,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1213,\n    foldFull: [ 1213 ]\n}, {\n    code: 1214,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1215,\n    foldFull: [ 1215 ]\n}, {\n    code: 1216,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1231,\n    foldFull: [ 1231 ]\n}, {\n    code: 1217,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1218,\n    foldFull: [ 1218 ]\n}, {\n    code: 1219,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1220,\n    foldFull: [ 1220 ]\n}, {\n    code: 1221,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1222,\n    foldFull: [ 1222 ]\n}, {\n    code: 1223,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1224,\n    foldFull: [ 1224 ]\n}, {\n    code: 1225,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1226,\n    foldFull: [ 1226 ]\n}, {\n    code: 1227,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1228,\n    foldFull: [ 1228 ]\n}, {\n    code: 1229,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1230,\n    foldFull: [ 1230 ]\n}, {\n    code: 1232,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1233,\n    foldFull: [ 1233 ]\n}, {\n    code: 1234,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1235,\n    foldFull: [ 1235 ]\n}, {\n    code: 1236,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1237,\n    foldFull: [ 1237 ]\n}, {\n    code: 1238,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1239,\n    foldFull: [ 1239 ]\n}, {\n    code: 1240,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1241,\n    foldFull: [ 1241 ]\n}, {\n    code: 1242,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1243,\n    foldFull: [ 1243 ]\n}, {\n    code: 1244,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1245,\n    foldFull: [ 1245 ]\n}, {\n    code: 1246,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1247,\n    foldFull: [ 1247 ]\n}, {\n    code: 1248,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1249,\n    foldFull: [ 1249 ]\n}, {\n    code: 1250,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1251,\n    foldFull: [ 1251 ]\n}, {\n    code: 1252,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1253,\n    foldFull: [ 1253 ]\n}, {\n    code: 1254,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1255,\n    foldFull: [ 1255 ]\n}, {\n    code: 1256,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1257,\n    foldFull: [ 1257 ]\n}, {\n    code: 1258,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1259,\n    foldFull: [ 1259 ]\n}, {\n    code: 1260,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1261,\n    foldFull: [ 1261 ]\n}, {\n    code: 1262,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1263,\n    foldFull: [ 1263 ]\n}, {\n    code: 1264,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1265,\n    foldFull: [ 1265 ]\n}, {\n    code: 1266,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1267,\n    foldFull: [ 1267 ]\n}, {\n    code: 1268,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1269,\n    foldFull: [ 1269 ]\n}, {\n    code: 1270,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1271,\n    foldFull: [ 1271 ]\n}, {\n    code: 1272,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1273,\n    foldFull: [ 1273 ]\n}, {\n    code: 1274,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1275,\n    foldFull: [ 1275 ]\n}, {\n    code: 1276,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1277,\n    foldFull: [ 1277 ]\n}, {\n    code: 1278,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1279,\n    foldFull: [ 1279 ]\n}, {\n    code: 1280,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1281,\n    foldFull: [ 1281 ]\n}, {\n    code: 1282,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1283,\n    foldFull: [ 1283 ]\n}, {\n    code: 1284,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1285,\n    foldFull: [ 1285 ]\n}, {\n    code: 1286,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1287,\n    foldFull: [ 1287 ]\n}, {\n    code: 1288,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1289,\n    foldFull: [ 1289 ]\n}, {\n    code: 1290,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1291,\n    foldFull: [ 1291 ]\n}, {\n    code: 1292,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1293,\n    foldFull: [ 1293 ]\n}, {\n    code: 1294,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1295,\n    foldFull: [ 1295 ]\n}, {\n    code: 1296,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1297,\n    foldFull: [ 1297 ]\n}, {\n    code: 1298,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1299,\n    foldFull: [ 1299 ]\n}, {\n    code: 1300,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1301,\n    foldFull: [ 1301 ]\n}, {\n    code: 1302,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1303,\n    foldFull: [ 1303 ]\n}, {\n    code: 1304,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1305,\n    foldFull: [ 1305 ]\n}, {\n    code: 1306,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1307,\n    foldFull: [ 1307 ]\n}, {\n    code: 1308,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1309,\n    foldFull: [ 1309 ]\n}, {\n    code: 1310,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1311,\n    foldFull: [ 1311 ]\n}, {\n    code: 1312,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1313,\n    foldFull: [ 1313 ]\n}, {\n    code: 1314,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1315,\n    foldFull: [ 1315 ]\n}, {\n    code: 1316,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1317,\n    foldFull: [ 1317 ]\n}, {\n    code: 1318,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1319,\n    foldFull: [ 1319 ]\n}, {\n    code: 1320,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1321,\n    foldFull: [ 1321 ]\n}, {\n    code: 1322,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1323,\n    foldFull: [ 1323 ]\n}, {\n    code: 1324,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1325,\n    foldFull: [ 1325 ]\n}, {\n    code: 1326,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1327,\n    foldFull: [ 1327 ]\n}, {\n    code: 1329,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1377,\n    foldFull: [ 1377 ]\n}, {\n    code: 1330,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1378,\n    foldFull: [ 1378 ]\n}, {\n    code: 1331,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1379,\n    foldFull: [ 1379 ]\n}, {\n    code: 1332,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1380,\n    foldFull: [ 1380 ]\n}, {\n    code: 1333,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1381,\n    foldFull: [ 1381 ]\n}, {\n    code: 1334,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1382,\n    foldFull: [ 1382 ]\n}, {\n    code: 1335,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1383,\n    foldFull: [ 1383 ]\n}, {\n    code: 1336,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1384,\n    foldFull: [ 1384 ]\n}, {\n    code: 1337,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1385,\n    foldFull: [ 1385 ]\n}, {\n    code: 1338,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1386,\n    foldFull: [ 1386 ]\n}, {\n    code: 1339,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1387,\n    foldFull: [ 1387 ]\n}, {\n    code: 1340,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1388,\n    foldFull: [ 1388 ]\n}, {\n    code: 1341,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1389,\n    foldFull: [ 1389 ]\n}, {\n    code: 1342,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1390,\n    foldFull: [ 1390 ]\n}, {\n    code: 1343,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1391,\n    foldFull: [ 1391 ]\n}, {\n    code: 1344,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1392,\n    foldFull: [ 1392 ]\n}, {\n    code: 1345,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1393,\n    foldFull: [ 1393 ]\n}, {\n    code: 1346,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1394,\n    foldFull: [ 1394 ]\n}, {\n    code: 1347,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1395,\n    foldFull: [ 1395 ]\n}, {\n    code: 1348,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1396,\n    foldFull: [ 1396 ]\n}, {\n    code: 1349,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1397,\n    foldFull: [ 1397 ]\n}, {\n    code: 1350,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1398,\n    foldFull: [ 1398 ]\n}, {\n    code: 1351,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1399,\n    foldFull: [ 1399 ]\n}, {\n    code: 1352,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1400,\n    foldFull: [ 1400 ]\n}, {\n    code: 1353,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1401,\n    foldFull: [ 1401 ]\n}, {\n    code: 1354,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1402,\n    foldFull: [ 1402 ]\n}, {\n    code: 1355,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1403,\n    foldFull: [ 1403 ]\n}, {\n    code: 1356,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1404,\n    foldFull: [ 1404 ]\n}, {\n    code: 1357,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1405,\n    foldFull: [ 1405 ]\n}, {\n    code: 1358,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1406,\n    foldFull: [ 1406 ]\n}, {\n    code: 1359,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1407,\n    foldFull: [ 1407 ]\n}, {\n    code: 1360,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1408,\n    foldFull: [ 1408 ]\n}, {\n    code: 1361,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1409,\n    foldFull: [ 1409 ]\n}, {\n    code: 1362,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1410,\n    foldFull: [ 1410 ]\n}, {\n    code: 1363,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1411,\n    foldFull: [ 1411 ]\n}, {\n    code: 1364,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1412,\n    foldFull: [ 1412 ]\n}, {\n    code: 1365,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1413,\n    foldFull: [ 1413 ]\n}, {\n    code: 1366,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1414,\n    foldFull: [ 1414 ]\n}, {\n    code: 1415,\n    lower: [ 1415 ],\n    title: [ 1333, 1410 ],\n    upper: [ 1333, 1362 ],\n    fold: 0,\n    foldFull: [ 1381, 1410 ]\n}, {\n    code: 1415,\n    lower: [ 1415 ],\n    title: [ 1333, 1410 ],\n    upper: [ 1333, 1362 ],\n    fold: 0,\n    foldFull: [ 1381, 1410 ]\n}, {\n    code: 4256,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11520,\n    foldFull: [ 11520 ]\n}, {\n    code: 4257,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11521,\n    foldFull: [ 11521 ]\n}, {\n    code: 4258,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11522,\n    foldFull: [ 11522 ]\n}, {\n    code: 4259,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11523,\n    foldFull: [ 11523 ]\n}, {\n    code: 4260,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11524,\n    foldFull: [ 11524 ]\n}, {\n    code: 4261,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11525,\n    foldFull: [ 11525 ]\n}, {\n    code: 4262,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11526,\n    foldFull: [ 11526 ]\n}, {\n    code: 4263,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11527,\n    foldFull: [ 11527 ]\n}, {\n    code: 4264,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11528,\n    foldFull: [ 11528 ]\n}, {\n    code: 4265,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11529,\n    foldFull: [ 11529 ]\n}, {\n    code: 4266,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11530,\n    foldFull: [ 11530 ]\n}, {\n    code: 4267,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11531,\n    foldFull: [ 11531 ]\n}, {\n    code: 4268,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11532,\n    foldFull: [ 11532 ]\n}, {\n    code: 4269,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11533,\n    foldFull: [ 11533 ]\n}, {\n    code: 4270,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11534,\n    foldFull: [ 11534 ]\n}, {\n    code: 4271,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11535,\n    foldFull: [ 11535 ]\n}, {\n    code: 4272,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11536,\n    foldFull: [ 11536 ]\n}, {\n    code: 4273,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11537,\n    foldFull: [ 11537 ]\n}, {\n    code: 4274,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11538,\n    foldFull: [ 11538 ]\n}, {\n    code: 4275,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11539,\n    foldFull: [ 11539 ]\n}, {\n    code: 4276,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11540,\n    foldFull: [ 11540 ]\n}, {\n    code: 4277,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11541,\n    foldFull: [ 11541 ]\n}, {\n    code: 4278,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11542,\n    foldFull: [ 11542 ]\n}, {\n    code: 4279,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11543,\n    foldFull: [ 11543 ]\n}, {\n    code: 4280,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11544,\n    foldFull: [ 11544 ]\n}, {\n    code: 4281,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11545,\n    foldFull: [ 11545 ]\n}, {\n    code: 4282,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11546,\n    foldFull: [ 11546 ]\n}, {\n    code: 4283,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11547,\n    foldFull: [ 11547 ]\n}, {\n    code: 4284,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11548,\n    foldFull: [ 11548 ]\n}, {\n    code: 4285,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11549,\n    foldFull: [ 11549 ]\n}, {\n    code: 4286,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11550,\n    foldFull: [ 11550 ]\n}, {\n    code: 4287,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11551,\n    foldFull: [ 11551 ]\n}, {\n    code: 4288,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11552,\n    foldFull: [ 11552 ]\n}, {\n    code: 4289,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11553,\n    foldFull: [ 11553 ]\n}, {\n    code: 4290,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11554,\n    foldFull: [ 11554 ]\n}, {\n    code: 4291,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11555,\n    foldFull: [ 11555 ]\n}, {\n    code: 4292,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11556,\n    foldFull: [ 11556 ]\n}, {\n    code: 4293,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11557,\n    foldFull: [ 11557 ]\n}, {\n    code: 4295,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11559,\n    foldFull: [ 11559 ]\n}, {\n    code: 4301,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11565,\n    foldFull: [ 11565 ]\n}, {\n    code: 5112,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5104,\n    foldFull: [ 5104 ]\n}, {\n    code: 5113,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5105,\n    foldFull: [ 5105 ]\n}, {\n    code: 5114,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5106,\n    foldFull: [ 5106 ]\n}, {\n    code: 5115,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5107,\n    foldFull: [ 5107 ]\n}, {\n    code: 5116,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5108,\n    foldFull: [ 5108 ]\n}, {\n    code: 5117,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5109,\n    foldFull: [ 5109 ]\n}, {\n    code: 7296,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1074,\n    foldFull: [ 1074 ]\n}, {\n    code: 7297,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1076,\n    foldFull: [ 1076 ]\n}, {\n    code: 7298,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1086,\n    foldFull: [ 1086 ]\n}, {\n    code: 7299,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1089,\n    foldFull: [ 1089 ]\n}, {\n    code: 7300,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1090,\n    foldFull: [ 1090 ]\n}, {\n    code: 7301,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1090,\n    foldFull: [ 1090 ]\n}, {\n    code: 7302,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1098,\n    foldFull: [ 1098 ]\n}, {\n    code: 7303,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 1123,\n    foldFull: [ 1123 ]\n}, {\n    code: 7304,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42571,\n    foldFull: [ 42571 ]\n}, {\n    code: 7312,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4304,\n    foldFull: [ 4304 ]\n}, {\n    code: 7313,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4305,\n    foldFull: [ 4305 ]\n}, {\n    code: 7314,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4306,\n    foldFull: [ 4306 ]\n}, {\n    code: 7315,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4307,\n    foldFull: [ 4307 ]\n}, {\n    code: 7316,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4308,\n    foldFull: [ 4308 ]\n}, {\n    code: 7317,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4309,\n    foldFull: [ 4309 ]\n}, {\n    code: 7318,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4310,\n    foldFull: [ 4310 ]\n}, {\n    code: 7319,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4311,\n    foldFull: [ 4311 ]\n}, {\n    code: 7320,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4312,\n    foldFull: [ 4312 ]\n}, {\n    code: 7321,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4313,\n    foldFull: [ 4313 ]\n}, {\n    code: 7322,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4314,\n    foldFull: [ 4314 ]\n}, {\n    code: 7323,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4315,\n    foldFull: [ 4315 ]\n}, {\n    code: 7324,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4316,\n    foldFull: [ 4316 ]\n}, {\n    code: 7325,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4317,\n    foldFull: [ 4317 ]\n}, {\n    code: 7326,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4318,\n    foldFull: [ 4318 ]\n}, {\n    code: 7327,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4319,\n    foldFull: [ 4319 ]\n}, {\n    code: 7328,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4320,\n    foldFull: [ 4320 ]\n}, {\n    code: 7329,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4321,\n    foldFull: [ 4321 ]\n}, {\n    code: 7330,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4322,\n    foldFull: [ 4322 ]\n}, {\n    code: 7331,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4323,\n    foldFull: [ 4323 ]\n}, {\n    code: 7332,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4324,\n    foldFull: [ 4324 ]\n}, {\n    code: 7333,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4325,\n    foldFull: [ 4325 ]\n}, {\n    code: 7334,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4326,\n    foldFull: [ 4326 ]\n}, {\n    code: 7335,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4327,\n    foldFull: [ 4327 ]\n}, {\n    code: 7336,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4328,\n    foldFull: [ 4328 ]\n}, {\n    code: 7337,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4329,\n    foldFull: [ 4329 ]\n}, {\n    code: 7338,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4330,\n    foldFull: [ 4330 ]\n}, {\n    code: 7339,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4331,\n    foldFull: [ 4331 ]\n}, {\n    code: 7340,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4332,\n    foldFull: [ 4332 ]\n}, {\n    code: 7341,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4333,\n    foldFull: [ 4333 ]\n}, {\n    code: 7342,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4334,\n    foldFull: [ 4334 ]\n}, {\n    code: 7343,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4335,\n    foldFull: [ 4335 ]\n}, {\n    code: 7344,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4336,\n    foldFull: [ 4336 ]\n}, {\n    code: 7345,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4337,\n    foldFull: [ 4337 ]\n}, {\n    code: 7346,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4338,\n    foldFull: [ 4338 ]\n}, {\n    code: 7347,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4339,\n    foldFull: [ 4339 ]\n}, {\n    code: 7348,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4340,\n    foldFull: [ 4340 ]\n}, {\n    code: 7349,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4341,\n    foldFull: [ 4341 ]\n}, {\n    code: 7350,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4342,\n    foldFull: [ 4342 ]\n}, {\n    code: 7351,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4343,\n    foldFull: [ 4343 ]\n}, {\n    code: 7352,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4344,\n    foldFull: [ 4344 ]\n}, {\n    code: 7353,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4345,\n    foldFull: [ 4345 ]\n}, {\n    code: 7354,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4346,\n    foldFull: [ 4346 ]\n}, {\n    code: 7357,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4349,\n    foldFull: [ 4349 ]\n}, {\n    code: 7358,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4350,\n    foldFull: [ 4350 ]\n}, {\n    code: 7359,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 4351,\n    foldFull: [ 4351 ]\n}, {\n    code: 7680,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7681,\n    foldFull: [ 7681 ]\n}, {\n    code: 7682,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7683,\n    foldFull: [ 7683 ]\n}, {\n    code: 7684,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7685,\n    foldFull: [ 7685 ]\n}, {\n    code: 7686,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7687,\n    foldFull: [ 7687 ]\n}, {\n    code: 7688,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7689,\n    foldFull: [ 7689 ]\n}, {\n    code: 7690,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7691,\n    foldFull: [ 7691 ]\n}, {\n    code: 7692,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7693,\n    foldFull: [ 7693 ]\n}, {\n    code: 7694,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7695,\n    foldFull: [ 7695 ]\n}, {\n    code: 7696,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7697,\n    foldFull: [ 7697 ]\n}, {\n    code: 7698,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7699,\n    foldFull: [ 7699 ]\n}, {\n    code: 7700,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7701,\n    foldFull: [ 7701 ]\n}, {\n    code: 7702,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7703,\n    foldFull: [ 7703 ]\n}, {\n    code: 7704,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7705,\n    foldFull: [ 7705 ]\n}, {\n    code: 7706,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7707,\n    foldFull: [ 7707 ]\n}, {\n    code: 7708,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7709,\n    foldFull: [ 7709 ]\n}, {\n    code: 7710,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7711,\n    foldFull: [ 7711 ]\n}, {\n    code: 7712,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7713,\n    foldFull: [ 7713 ]\n}, {\n    code: 7714,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7715,\n    foldFull: [ 7715 ]\n}, {\n    code: 7716,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7717,\n    foldFull: [ 7717 ]\n}, {\n    code: 7718,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7719,\n    foldFull: [ 7719 ]\n}, {\n    code: 7720,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7721,\n    foldFull: [ 7721 ]\n}, {\n    code: 7722,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7723,\n    foldFull: [ 7723 ]\n}, {\n    code: 7724,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7725,\n    foldFull: [ 7725 ]\n}, {\n    code: 7726,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7727,\n    foldFull: [ 7727 ]\n}, {\n    code: 7728,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7729,\n    foldFull: [ 7729 ]\n}, {\n    code: 7730,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7731,\n    foldFull: [ 7731 ]\n}, {\n    code: 7732,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7733,\n    foldFull: [ 7733 ]\n}, {\n    code: 7734,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7735,\n    foldFull: [ 7735 ]\n}, {\n    code: 7736,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7737,\n    foldFull: [ 7737 ]\n}, {\n    code: 7738,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7739,\n    foldFull: [ 7739 ]\n}, {\n    code: 7740,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7741,\n    foldFull: [ 7741 ]\n}, {\n    code: 7742,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7743,\n    foldFull: [ 7743 ]\n}, {\n    code: 7744,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7745,\n    foldFull: [ 7745 ]\n}, {\n    code: 7746,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7747,\n    foldFull: [ 7747 ]\n}, {\n    code: 7748,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7749,\n    foldFull: [ 7749 ]\n}, {\n    code: 7750,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7751,\n    foldFull: [ 7751 ]\n}, {\n    code: 7752,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7753,\n    foldFull: [ 7753 ]\n}, {\n    code: 7754,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7755,\n    foldFull: [ 7755 ]\n}, {\n    code: 7756,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7757,\n    foldFull: [ 7757 ]\n}, {\n    code: 7758,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7759,\n    foldFull: [ 7759 ]\n}, {\n    code: 7760,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7761,\n    foldFull: [ 7761 ]\n}, {\n    code: 7762,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7763,\n    foldFull: [ 7763 ]\n}, {\n    code: 7764,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7765,\n    foldFull: [ 7765 ]\n}, {\n    code: 7766,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7767,\n    foldFull: [ 7767 ]\n}, {\n    code: 7768,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7769,\n    foldFull: [ 7769 ]\n}, {\n    code: 7770,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7771,\n    foldFull: [ 7771 ]\n}, {\n    code: 7772,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7773,\n    foldFull: [ 7773 ]\n}, {\n    code: 7774,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7775,\n    foldFull: [ 7775 ]\n}, {\n    code: 7776,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7777,\n    foldFull: [ 7777 ]\n}, {\n    code: 7778,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7779,\n    foldFull: [ 7779 ]\n}, {\n    code: 7780,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7781,\n    foldFull: [ 7781 ]\n}, {\n    code: 7782,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7783,\n    foldFull: [ 7783 ]\n}, {\n    code: 7784,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7785,\n    foldFull: [ 7785 ]\n}, {\n    code: 7786,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7787,\n    foldFull: [ 7787 ]\n}, {\n    code: 7788,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7789,\n    foldFull: [ 7789 ]\n}, {\n    code: 7790,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7791,\n    foldFull: [ 7791 ]\n}, {\n    code: 7792,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7793,\n    foldFull: [ 7793 ]\n}, {\n    code: 7794,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7795,\n    foldFull: [ 7795 ]\n}, {\n    code: 7796,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7797,\n    foldFull: [ 7797 ]\n}, {\n    code: 7798,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7799,\n    foldFull: [ 7799 ]\n}, {\n    code: 7800,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7801,\n    foldFull: [ 7801 ]\n}, {\n    code: 7802,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7803,\n    foldFull: [ 7803 ]\n}, {\n    code: 7804,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7805,\n    foldFull: [ 7805 ]\n}, {\n    code: 7806,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7807,\n    foldFull: [ 7807 ]\n}, {\n    code: 7808,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7809,\n    foldFull: [ 7809 ]\n}, {\n    code: 7810,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7811,\n    foldFull: [ 7811 ]\n}, {\n    code: 7812,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7813,\n    foldFull: [ 7813 ]\n}, {\n    code: 7814,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7815,\n    foldFull: [ 7815 ]\n}, {\n    code: 7816,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7817,\n    foldFull: [ 7817 ]\n}, {\n    code: 7818,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7819,\n    foldFull: [ 7819 ]\n}, {\n    code: 7820,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7821,\n    foldFull: [ 7821 ]\n}, {\n    code: 7822,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7823,\n    foldFull: [ 7823 ]\n}, {\n    code: 7824,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7825,\n    foldFull: [ 7825 ]\n}, {\n    code: 7826,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7827,\n    foldFull: [ 7827 ]\n}, {\n    code: 7828,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7829,\n    foldFull: [ 7829 ]\n}, {\n    code: 7830,\n    lower: [ 7830 ],\n    title: [ 72, 817 ],\n    upper: [ 72, 817 ],\n    fold: 0,\n    foldFull: [ 104, 817 ]\n}, {\n    code: 7830,\n    lower: [ 7830 ],\n    title: [ 72, 817 ],\n    upper: [ 72, 817 ],\n    fold: 0,\n    foldFull: [ 104, 817 ]\n}, {\n    code: 7831,\n    lower: [ 7831 ],\n    title: [ 84, 776 ],\n    upper: [ 84, 776 ],\n    fold: 0,\n    foldFull: [ 116, 776 ]\n}, {\n    code: 7831,\n    lower: [ 7831 ],\n    title: [ 84, 776 ],\n    upper: [ 84, 776 ],\n    fold: 0,\n    foldFull: [ 116, 776 ]\n}, {\n    code: 7832,\n    lower: [ 7832 ],\n    title: [ 87, 778 ],\n    upper: [ 87, 778 ],\n    fold: 0,\n    foldFull: [ 119, 778 ]\n}, {\n    code: 7832,\n    lower: [ 7832 ],\n    title: [ 87, 778 ],\n    upper: [ 87, 778 ],\n    fold: 0,\n    foldFull: [ 119, 778 ]\n}, {\n    code: 7833,\n    lower: [ 7833 ],\n    title: [ 89, 778 ],\n    upper: [ 89, 778 ],\n    fold: 0,\n    foldFull: [ 121, 778 ]\n}, {\n    code: 7833,\n    lower: [ 7833 ],\n    title: [ 89, 778 ],\n    upper: [ 89, 778 ],\n    fold: 0,\n    foldFull: [ 121, 778 ]\n}, {\n    code: 7834,\n    lower: [ 7834 ],\n    title: [ 65, 702 ],\n    upper: [ 65, 702 ],\n    fold: 0,\n    foldFull: [ 97, 702 ]\n}, {\n    code: 7834,\n    lower: [ 7834 ],\n    title: [ 65, 702 ],\n    upper: [ 65, 702 ],\n    fold: 0,\n    foldFull: [ 97, 702 ]\n}, {\n    code: 7835,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7777,\n    foldFull: [ 7777 ]\n}, {\n    code: 7838,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 223,\n    foldFull: [ 115, 115 ]\n}, {\n    code: 7840,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7841,\n    foldFull: [ 7841 ]\n}, {\n    code: 7842,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7843,\n    foldFull: [ 7843 ]\n}, {\n    code: 7844,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7845,\n    foldFull: [ 7845 ]\n}, {\n    code: 7846,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7847,\n    foldFull: [ 7847 ]\n}, {\n    code: 7848,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7849,\n    foldFull: [ 7849 ]\n}, {\n    code: 7850,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7851,\n    foldFull: [ 7851 ]\n}, {\n    code: 7852,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7853,\n    foldFull: [ 7853 ]\n}, {\n    code: 7854,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7855,\n    foldFull: [ 7855 ]\n}, {\n    code: 7856,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7857,\n    foldFull: [ 7857 ]\n}, {\n    code: 7858,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7859,\n    foldFull: [ 7859 ]\n}, {\n    code: 7860,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7861,\n    foldFull: [ 7861 ]\n}, {\n    code: 7862,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7863,\n    foldFull: [ 7863 ]\n}, {\n    code: 7864,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7865,\n    foldFull: [ 7865 ]\n}, {\n    code: 7866,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7867,\n    foldFull: [ 7867 ]\n}, {\n    code: 7868,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7869,\n    foldFull: [ 7869 ]\n}, {\n    code: 7870,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7871,\n    foldFull: [ 7871 ]\n}, {\n    code: 7872,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7873,\n    foldFull: [ 7873 ]\n}, {\n    code: 7874,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7875,\n    foldFull: [ 7875 ]\n}, {\n    code: 7876,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7877,\n    foldFull: [ 7877 ]\n}, {\n    code: 7878,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7879,\n    foldFull: [ 7879 ]\n}, {\n    code: 7880,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7881,\n    foldFull: [ 7881 ]\n}, {\n    code: 7882,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7883,\n    foldFull: [ 7883 ]\n}, {\n    code: 7884,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7885,\n    foldFull: [ 7885 ]\n}, {\n    code: 7886,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7887,\n    foldFull: [ 7887 ]\n}, {\n    code: 7888,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7889,\n    foldFull: [ 7889 ]\n}, {\n    code: 7890,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7891,\n    foldFull: [ 7891 ]\n}, {\n    code: 7892,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7893,\n    foldFull: [ 7893 ]\n}, {\n    code: 7894,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7895,\n    foldFull: [ 7895 ]\n}, {\n    code: 7896,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7897,\n    foldFull: [ 7897 ]\n}, {\n    code: 7898,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7899,\n    foldFull: [ 7899 ]\n}, {\n    code: 7900,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7901,\n    foldFull: [ 7901 ]\n}, {\n    code: 7902,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7903,\n    foldFull: [ 7903 ]\n}, {\n    code: 7904,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7905,\n    foldFull: [ 7905 ]\n}, {\n    code: 7906,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7907,\n    foldFull: [ 7907 ]\n}, {\n    code: 7908,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7909,\n    foldFull: [ 7909 ]\n}, {\n    code: 7910,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7911,\n    foldFull: [ 7911 ]\n}, {\n    code: 7912,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7913,\n    foldFull: [ 7913 ]\n}, {\n    code: 7914,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7915,\n    foldFull: [ 7915 ]\n}, {\n    code: 7916,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7917,\n    foldFull: [ 7917 ]\n}, {\n    code: 7918,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7919,\n    foldFull: [ 7919 ]\n}, {\n    code: 7920,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7921,\n    foldFull: [ 7921 ]\n}, {\n    code: 7922,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7923,\n    foldFull: [ 7923 ]\n}, {\n    code: 7924,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7925,\n    foldFull: [ 7925 ]\n}, {\n    code: 7926,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7927,\n    foldFull: [ 7927 ]\n}, {\n    code: 7928,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7929,\n    foldFull: [ 7929 ]\n}, {\n    code: 7930,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7931,\n    foldFull: [ 7931 ]\n}, {\n    code: 7932,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7933,\n    foldFull: [ 7933 ]\n}, {\n    code: 7934,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7935,\n    foldFull: [ 7935 ]\n}, {\n    code: 7944,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7936,\n    foldFull: [ 7936 ]\n}, {\n    code: 7945,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7937,\n    foldFull: [ 7937 ]\n}, {\n    code: 7946,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7938,\n    foldFull: [ 7938 ]\n}, {\n    code: 7947,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7939,\n    foldFull: [ 7939 ]\n}, {\n    code: 7948,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7940,\n    foldFull: [ 7940 ]\n}, {\n    code: 7949,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7941,\n    foldFull: [ 7941 ]\n}, {\n    code: 7950,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7942,\n    foldFull: [ 7942 ]\n}, {\n    code: 7951,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7943,\n    foldFull: [ 7943 ]\n}, {\n    code: 7960,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7952,\n    foldFull: [ 7952 ]\n}, {\n    code: 7961,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7953,\n    foldFull: [ 7953 ]\n}, {\n    code: 7962,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7954,\n    foldFull: [ 7954 ]\n}, {\n    code: 7963,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7955,\n    foldFull: [ 7955 ]\n}, {\n    code: 7964,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7956,\n    foldFull: [ 7956 ]\n}, {\n    code: 7965,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7957,\n    foldFull: [ 7957 ]\n}, {\n    code: 7976,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7968,\n    foldFull: [ 7968 ]\n}, {\n    code: 7977,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7969,\n    foldFull: [ 7969 ]\n}, {\n    code: 7978,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7970,\n    foldFull: [ 7970 ]\n}, {\n    code: 7979,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7971,\n    foldFull: [ 7971 ]\n}, {\n    code: 7980,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7972,\n    foldFull: [ 7972 ]\n}, {\n    code: 7981,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7973,\n    foldFull: [ 7973 ]\n}, {\n    code: 7982,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7974,\n    foldFull: [ 7974 ]\n}, {\n    code: 7983,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7975,\n    foldFull: [ 7975 ]\n}, {\n    code: 7992,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7984,\n    foldFull: [ 7984 ]\n}, {\n    code: 7993,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7985,\n    foldFull: [ 7985 ]\n}, {\n    code: 7994,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7986,\n    foldFull: [ 7986 ]\n}, {\n    code: 7995,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7987,\n    foldFull: [ 7987 ]\n}, {\n    code: 7996,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7988,\n    foldFull: [ 7988 ]\n}, {\n    code: 7997,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7989,\n    foldFull: [ 7989 ]\n}, {\n    code: 7998,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7990,\n    foldFull: [ 7990 ]\n}, {\n    code: 7999,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7991,\n    foldFull: [ 7991 ]\n}, {\n    code: 8008,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8000,\n    foldFull: [ 8000 ]\n}, {\n    code: 8009,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8001,\n    foldFull: [ 8001 ]\n}, {\n    code: 8010,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8002,\n    foldFull: [ 8002 ]\n}, {\n    code: 8011,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8003,\n    foldFull: [ 8003 ]\n}, {\n    code: 8012,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8004,\n    foldFull: [ 8004 ]\n}, {\n    code: 8013,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8005,\n    foldFull: [ 8005 ]\n}, {\n    code: 8016,\n    lower: [ 8016 ],\n    title: [ 933, 787 ],\n    upper: [ 933, 787 ],\n    fold: 0,\n    foldFull: [ 965, 787 ]\n}, {\n    code: 8016,\n    lower: [ 8016 ],\n    title: [ 933, 787 ],\n    upper: [ 933, 787 ],\n    fold: 0,\n    foldFull: [ 965, 787 ]\n}, {\n    code: 8018,\n    lower: [ 8018 ],\n    title: [ 933, 787, 768 ],\n    upper: [ 933, 787, 768 ],\n    fold: 0,\n    foldFull: [ 965, 787, 768 ]\n}, {\n    code: 8018,\n    lower: [ 8018 ],\n    title: [ 933, 787, 768 ],\n    upper: [ 933, 787, 768 ],\n    fold: 0,\n    foldFull: [ 965, 787, 768 ]\n}, {\n    code: 8020,\n    lower: [ 8020 ],\n    title: [ 933, 787, 769 ],\n    upper: [ 933, 787, 769 ],\n    fold: 0,\n    foldFull: [ 965, 787, 769 ]\n}, {\n    code: 8020,\n    lower: [ 8020 ],\n    title: [ 933, 787, 769 ],\n    upper: [ 933, 787, 769 ],\n    fold: 0,\n    foldFull: [ 965, 787, 769 ]\n}, {\n    code: 8022,\n    lower: [ 8022 ],\n    title: [ 933, 787, 834 ],\n    upper: [ 933, 787, 834 ],\n    fold: 0,\n    foldFull: [ 965, 787, 834 ]\n}, {\n    code: 8022,\n    lower: [ 8022 ],\n    title: [ 933, 787, 834 ],\n    upper: [ 933, 787, 834 ],\n    fold: 0,\n    foldFull: [ 965, 787, 834 ]\n}, {\n    code: 8025,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8017,\n    foldFull: [ 8017 ]\n}, {\n    code: 8027,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8019,\n    foldFull: [ 8019 ]\n}, {\n    code: 8029,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8021,\n    foldFull: [ 8021 ]\n}, {\n    code: 8031,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8023,\n    foldFull: [ 8023 ]\n}, {\n    code: 8040,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8032,\n    foldFull: [ 8032 ]\n}, {\n    code: 8041,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8033,\n    foldFull: [ 8033 ]\n}, {\n    code: 8042,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8034,\n    foldFull: [ 8034 ]\n}, {\n    code: 8043,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8035,\n    foldFull: [ 8035 ]\n}, {\n    code: 8044,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8036,\n    foldFull: [ 8036 ]\n}, {\n    code: 8045,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8037,\n    foldFull: [ 8037 ]\n}, {\n    code: 8046,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8038,\n    foldFull: [ 8038 ]\n}, {\n    code: 8047,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8039,\n    foldFull: [ 8039 ]\n}, {\n    code: 8064,\n    lower: [ 8064 ],\n    title: [ 8072 ],\n    upper: [ 7944, 921 ],\n    fold: 0,\n    foldFull: [ 7936, 953 ]\n}, {\n    code: 8064,\n    lower: [ 8064 ],\n    title: [ 8072 ],\n    upper: [ 7944, 921 ],\n    fold: 0,\n    foldFull: [ 7936, 953 ]\n}, {\n    code: 8065,\n    lower: [ 8065 ],\n    title: [ 8073 ],\n    upper: [ 7945, 921 ],\n    fold: 0,\n    foldFull: [ 7937, 953 ]\n}, {\n    code: 8065,\n    lower: [ 8065 ],\n    title: [ 8073 ],\n    upper: [ 7945, 921 ],\n    fold: 0,\n    foldFull: [ 7937, 953 ]\n}, {\n    code: 8066,\n    lower: [ 8066 ],\n    title: [ 8074 ],\n    upper: [ 7946, 921 ],\n    fold: 0,\n    foldFull: [ 7938, 953 ]\n}, {\n    code: 8066,\n    lower: [ 8066 ],\n    title: [ 8074 ],\n    upper: [ 7946, 921 ],\n    fold: 0,\n    foldFull: [ 7938, 953 ]\n}, {\n    code: 8067,\n    lower: [ 8067 ],\n    title: [ 8075 ],\n    upper: [ 7947, 921 ],\n    fold: 0,\n    foldFull: [ 7939, 953 ]\n}, {\n    code: 8067,\n    lower: [ 8067 ],\n    title: [ 8075 ],\n    upper: [ 7947, 921 ],\n    fold: 0,\n    foldFull: [ 7939, 953 ]\n}, {\n    code: 8068,\n    lower: [ 8068 ],\n    title: [ 8076 ],\n    upper: [ 7948, 921 ],\n    fold: 0,\n    foldFull: [ 7940, 953 ]\n}, {\n    code: 8068,\n    lower: [ 8068 ],\n    title: [ 8076 ],\n    upper: [ 7948, 921 ],\n    fold: 0,\n    foldFull: [ 7940, 953 ]\n}, {\n    code: 8069,\n    lower: [ 8069 ],\n    title: [ 8077 ],\n    upper: [ 7949, 921 ],\n    fold: 0,\n    foldFull: [ 7941, 953 ]\n}, {\n    code: 8069,\n    lower: [ 8069 ],\n    title: [ 8077 ],\n    upper: [ 7949, 921 ],\n    fold: 0,\n    foldFull: [ 7941, 953 ]\n}, {\n    code: 8070,\n    lower: [ 8070 ],\n    title: [ 8078 ],\n    upper: [ 7950, 921 ],\n    fold: 0,\n    foldFull: [ 7942, 953 ]\n}, {\n    code: 8070,\n    lower: [ 8070 ],\n    title: [ 8078 ],\n    upper: [ 7950, 921 ],\n    fold: 0,\n    foldFull: [ 7942, 953 ]\n}, {\n    code: 8071,\n    lower: [ 8071 ],\n    title: [ 8079 ],\n    upper: [ 7951, 921 ],\n    fold: 0,\n    foldFull: [ 7943, 953 ]\n}, {\n    code: 8071,\n    lower: [ 8071 ],\n    title: [ 8079 ],\n    upper: [ 7951, 921 ],\n    fold: 0,\n    foldFull: [ 7943, 953 ]\n}, {\n    code: 8072,\n    lower: [ 8064 ],\n    title: [ 8072 ],\n    upper: [ 7944, 921 ],\n    fold: 8064,\n    foldFull: [ 7936, 953 ]\n}, {\n    code: 8072,\n    lower: [ 8064 ],\n    title: [ 8072 ],\n    upper: [ 7944, 921 ],\n    fold: 8064,\n    foldFull: [ 7936, 953 ]\n}, {\n    code: 8073,\n    lower: [ 8065 ],\n    title: [ 8073 ],\n    upper: [ 7945, 921 ],\n    fold: 8065,\n    foldFull: [ 7937, 953 ]\n}, {\n    code: 8073,\n    lower: [ 8065 ],\n    title: [ 8073 ],\n    upper: [ 7945, 921 ],\n    fold: 8065,\n    foldFull: [ 7937, 953 ]\n}, {\n    code: 8074,\n    lower: [ 8066 ],\n    title: [ 8074 ],\n    upper: [ 7946, 921 ],\n    fold: 8066,\n    foldFull: [ 7938, 953 ]\n}, {\n    code: 8074,\n    lower: [ 8066 ],\n    title: [ 8074 ],\n    upper: [ 7946, 921 ],\n    fold: 8066,\n    foldFull: [ 7938, 953 ]\n}, {\n    code: 8075,\n    lower: [ 8067 ],\n    title: [ 8075 ],\n    upper: [ 7947, 921 ],\n    fold: 8067,\n    foldFull: [ 7939, 953 ]\n}, {\n    code: 8075,\n    lower: [ 8067 ],\n    title: [ 8075 ],\n    upper: [ 7947, 921 ],\n    fold: 8067,\n    foldFull: [ 7939, 953 ]\n}, {\n    code: 8076,\n    lower: [ 8068 ],\n    title: [ 8076 ],\n    upper: [ 7948, 921 ],\n    fold: 8068,\n    foldFull: [ 7940, 953 ]\n}, {\n    code: 8076,\n    lower: [ 8068 ],\n    title: [ 8076 ],\n    upper: [ 7948, 921 ],\n    fold: 8068,\n    foldFull: [ 7940, 953 ]\n}, {\n    code: 8077,\n    lower: [ 8069 ],\n    title: [ 8077 ],\n    upper: [ 7949, 921 ],\n    fold: 8069,\n    foldFull: [ 7941, 953 ]\n}, {\n    code: 8077,\n    lower: [ 8069 ],\n    title: [ 8077 ],\n    upper: [ 7949, 921 ],\n    fold: 8069,\n    foldFull: [ 7941, 953 ]\n}, {\n    code: 8078,\n    lower: [ 8070 ],\n    title: [ 8078 ],\n    upper: [ 7950, 921 ],\n    fold: 8070,\n    foldFull: [ 7942, 953 ]\n}, {\n    code: 8078,\n    lower: [ 8070 ],\n    title: [ 8078 ],\n    upper: [ 7950, 921 ],\n    fold: 8070,\n    foldFull: [ 7942, 953 ]\n}, {\n    code: 8079,\n    lower: [ 8071 ],\n    title: [ 8079 ],\n    upper: [ 7951, 921 ],\n    fold: 8071,\n    foldFull: [ 7943, 953 ]\n}, {\n    code: 8079,\n    lower: [ 8071 ],\n    title: [ 8079 ],\n    upper: [ 7951, 921 ],\n    fold: 8071,\n    foldFull: [ 7943, 953 ]\n}, {\n    code: 8080,\n    lower: [ 8080 ],\n    title: [ 8088 ],\n    upper: [ 7976, 921 ],\n    fold: 0,\n    foldFull: [ 7968, 953 ]\n}, {\n    code: 8080,\n    lower: [ 8080 ],\n    title: [ 8088 ],\n    upper: [ 7976, 921 ],\n    fold: 0,\n    foldFull: [ 7968, 953 ]\n}, {\n    code: 8081,\n    lower: [ 8081 ],\n    title: [ 8089 ],\n    upper: [ 7977, 921 ],\n    fold: 0,\n    foldFull: [ 7969, 953 ]\n}, {\n    code: 8081,\n    lower: [ 8081 ],\n    title: [ 8089 ],\n    upper: [ 7977, 921 ],\n    fold: 0,\n    foldFull: [ 7969, 953 ]\n}, {\n    code: 8082,\n    lower: [ 8082 ],\n    title: [ 8090 ],\n    upper: [ 7978, 921 ],\n    fold: 0,\n    foldFull: [ 7970, 953 ]\n}, {\n    code: 8082,\n    lower: [ 8082 ],\n    title: [ 8090 ],\n    upper: [ 7978, 921 ],\n    fold: 0,\n    foldFull: [ 7970, 953 ]\n}, {\n    code: 8083,\n    lower: [ 8083 ],\n    title: [ 8091 ],\n    upper: [ 7979, 921 ],\n    fold: 0,\n    foldFull: [ 7971, 953 ]\n}, {\n    code: 8083,\n    lower: [ 8083 ],\n    title: [ 8091 ],\n    upper: [ 7979, 921 ],\n    fold: 0,\n    foldFull: [ 7971, 953 ]\n}, {\n    code: 8084,\n    lower: [ 8084 ],\n    title: [ 8092 ],\n    upper: [ 7980, 921 ],\n    fold: 0,\n    foldFull: [ 7972, 953 ]\n}, {\n    code: 8084,\n    lower: [ 8084 ],\n    title: [ 8092 ],\n    upper: [ 7980, 921 ],\n    fold: 0,\n    foldFull: [ 7972, 953 ]\n}, {\n    code: 8085,\n    lower: [ 8085 ],\n    title: [ 8093 ],\n    upper: [ 7981, 921 ],\n    fold: 0,\n    foldFull: [ 7973, 953 ]\n}, {\n    code: 8085,\n    lower: [ 8085 ],\n    title: [ 8093 ],\n    upper: [ 7981, 921 ],\n    fold: 0,\n    foldFull: [ 7973, 953 ]\n}, {\n    code: 8086,\n    lower: [ 8086 ],\n    title: [ 8094 ],\n    upper: [ 7982, 921 ],\n    fold: 0,\n    foldFull: [ 7974, 953 ]\n}, {\n    code: 8086,\n    lower: [ 8086 ],\n    title: [ 8094 ],\n    upper: [ 7982, 921 ],\n    fold: 0,\n    foldFull: [ 7974, 953 ]\n}, {\n    code: 8087,\n    lower: [ 8087 ],\n    title: [ 8095 ],\n    upper: [ 7983, 921 ],\n    fold: 0,\n    foldFull: [ 7975, 953 ]\n}, {\n    code: 8087,\n    lower: [ 8087 ],\n    title: [ 8095 ],\n    upper: [ 7983, 921 ],\n    fold: 0,\n    foldFull: [ 7975, 953 ]\n}, {\n    code: 8088,\n    lower: [ 8080 ],\n    title: [ 8088 ],\n    upper: [ 7976, 921 ],\n    fold: 8080,\n    foldFull: [ 7968, 953 ]\n}, {\n    code: 8088,\n    lower: [ 8080 ],\n    title: [ 8088 ],\n    upper: [ 7976, 921 ],\n    fold: 8080,\n    foldFull: [ 7968, 953 ]\n}, {\n    code: 8089,\n    lower: [ 8081 ],\n    title: [ 8089 ],\n    upper: [ 7977, 921 ],\n    fold: 8081,\n    foldFull: [ 7969, 953 ]\n}, {\n    code: 8089,\n    lower: [ 8081 ],\n    title: [ 8089 ],\n    upper: [ 7977, 921 ],\n    fold: 8081,\n    foldFull: [ 7969, 953 ]\n}, {\n    code: 8090,\n    lower: [ 8082 ],\n    title: [ 8090 ],\n    upper: [ 7978, 921 ],\n    fold: 8082,\n    foldFull: [ 7970, 953 ]\n}, {\n    code: 8090,\n    lower: [ 8082 ],\n    title: [ 8090 ],\n    upper: [ 7978, 921 ],\n    fold: 8082,\n    foldFull: [ 7970, 953 ]\n}, {\n    code: 8091,\n    lower: [ 8083 ],\n    title: [ 8091 ],\n    upper: [ 7979, 921 ],\n    fold: 8083,\n    foldFull: [ 7971, 953 ]\n}, {\n    code: 8091,\n    lower: [ 8083 ],\n    title: [ 8091 ],\n    upper: [ 7979, 921 ],\n    fold: 8083,\n    foldFull: [ 7971, 953 ]\n}, {\n    code: 8092,\n    lower: [ 8084 ],\n    title: [ 8092 ],\n    upper: [ 7980, 921 ],\n    fold: 8084,\n    foldFull: [ 7972, 953 ]\n}, {\n    code: 8092,\n    lower: [ 8084 ],\n    title: [ 8092 ],\n    upper: [ 7980, 921 ],\n    fold: 8084,\n    foldFull: [ 7972, 953 ]\n}, {\n    code: 8093,\n    lower: [ 8085 ],\n    title: [ 8093 ],\n    upper: [ 7981, 921 ],\n    fold: 8085,\n    foldFull: [ 7973, 953 ]\n}, {\n    code: 8093,\n    lower: [ 8085 ],\n    title: [ 8093 ],\n    upper: [ 7981, 921 ],\n    fold: 8085,\n    foldFull: [ 7973, 953 ]\n}, {\n    code: 8094,\n    lower: [ 8086 ],\n    title: [ 8094 ],\n    upper: [ 7982, 921 ],\n    fold: 8086,\n    foldFull: [ 7974, 953 ]\n}, {\n    code: 8094,\n    lower: [ 8086 ],\n    title: [ 8094 ],\n    upper: [ 7982, 921 ],\n    fold: 8086,\n    foldFull: [ 7974, 953 ]\n}, {\n    code: 8095,\n    lower: [ 8087 ],\n    title: [ 8095 ],\n    upper: [ 7983, 921 ],\n    fold: 8087,\n    foldFull: [ 7975, 953 ]\n}, {\n    code: 8095,\n    lower: [ 8087 ],\n    title: [ 8095 ],\n    upper: [ 7983, 921 ],\n    fold: 8087,\n    foldFull: [ 7975, 953 ]\n}, {\n    code: 8096,\n    lower: [ 8096 ],\n    title: [ 8104 ],\n    upper: [ 8040, 921 ],\n    fold: 0,\n    foldFull: [ 8032, 953 ]\n}, {\n    code: 8096,\n    lower: [ 8096 ],\n    title: [ 8104 ],\n    upper: [ 8040, 921 ],\n    fold: 0,\n    foldFull: [ 8032, 953 ]\n}, {\n    code: 8097,\n    lower: [ 8097 ],\n    title: [ 8105 ],\n    upper: [ 8041, 921 ],\n    fold: 0,\n    foldFull: [ 8033, 953 ]\n}, {\n    code: 8097,\n    lower: [ 8097 ],\n    title: [ 8105 ],\n    upper: [ 8041, 921 ],\n    fold: 0,\n    foldFull: [ 8033, 953 ]\n}, {\n    code: 8098,\n    lower: [ 8098 ],\n    title: [ 8106 ],\n    upper: [ 8042, 921 ],\n    fold: 0,\n    foldFull: [ 8034, 953 ]\n}, {\n    code: 8098,\n    lower: [ 8098 ],\n    title: [ 8106 ],\n    upper: [ 8042, 921 ],\n    fold: 0,\n    foldFull: [ 8034, 953 ]\n}, {\n    code: 8099,\n    lower: [ 8099 ],\n    title: [ 8107 ],\n    upper: [ 8043, 921 ],\n    fold: 0,\n    foldFull: [ 8035, 953 ]\n}, {\n    code: 8099,\n    lower: [ 8099 ],\n    title: [ 8107 ],\n    upper: [ 8043, 921 ],\n    fold: 0,\n    foldFull: [ 8035, 953 ]\n}, {\n    code: 8100,\n    lower: [ 8100 ],\n    title: [ 8108 ],\n    upper: [ 8044, 921 ],\n    fold: 0,\n    foldFull: [ 8036, 953 ]\n}, {\n    code: 8100,\n    lower: [ 8100 ],\n    title: [ 8108 ],\n    upper: [ 8044, 921 ],\n    fold: 0,\n    foldFull: [ 8036, 953 ]\n}, {\n    code: 8101,\n    lower: [ 8101 ],\n    title: [ 8109 ],\n    upper: [ 8045, 921 ],\n    fold: 0,\n    foldFull: [ 8037, 953 ]\n}, {\n    code: 8101,\n    lower: [ 8101 ],\n    title: [ 8109 ],\n    upper: [ 8045, 921 ],\n    fold: 0,\n    foldFull: [ 8037, 953 ]\n}, {\n    code: 8102,\n    lower: [ 8102 ],\n    title: [ 8110 ],\n    upper: [ 8046, 921 ],\n    fold: 0,\n    foldFull: [ 8038, 953 ]\n}, {\n    code: 8102,\n    lower: [ 8102 ],\n    title: [ 8110 ],\n    upper: [ 8046, 921 ],\n    fold: 0,\n    foldFull: [ 8038, 953 ]\n}, {\n    code: 8103,\n    lower: [ 8103 ],\n    title: [ 8111 ],\n    upper: [ 8047, 921 ],\n    fold: 0,\n    foldFull: [ 8039, 953 ]\n}, {\n    code: 8103,\n    lower: [ 8103 ],\n    title: [ 8111 ],\n    upper: [ 8047, 921 ],\n    fold: 0,\n    foldFull: [ 8039, 953 ]\n}, {\n    code: 8104,\n    lower: [ 8096 ],\n    title: [ 8104 ],\n    upper: [ 8040, 921 ],\n    fold: 8096,\n    foldFull: [ 8032, 953 ]\n}, {\n    code: 8104,\n    lower: [ 8096 ],\n    title: [ 8104 ],\n    upper: [ 8040, 921 ],\n    fold: 8096,\n    foldFull: [ 8032, 953 ]\n}, {\n    code: 8105,\n    lower: [ 8097 ],\n    title: [ 8105 ],\n    upper: [ 8041, 921 ],\n    fold: 8097,\n    foldFull: [ 8033, 953 ]\n}, {\n    code: 8105,\n    lower: [ 8097 ],\n    title: [ 8105 ],\n    upper: [ 8041, 921 ],\n    fold: 8097,\n    foldFull: [ 8033, 953 ]\n}, {\n    code: 8106,\n    lower: [ 8098 ],\n    title: [ 8106 ],\n    upper: [ 8042, 921 ],\n    fold: 8098,\n    foldFull: [ 8034, 953 ]\n}, {\n    code: 8106,\n    lower: [ 8098 ],\n    title: [ 8106 ],\n    upper: [ 8042, 921 ],\n    fold: 8098,\n    foldFull: [ 8034, 953 ]\n}, {\n    code: 8107,\n    lower: [ 8099 ],\n    title: [ 8107 ],\n    upper: [ 8043, 921 ],\n    fold: 8099,\n    foldFull: [ 8035, 953 ]\n}, {\n    code: 8107,\n    lower: [ 8099 ],\n    title: [ 8107 ],\n    upper: [ 8043, 921 ],\n    fold: 8099,\n    foldFull: [ 8035, 953 ]\n}, {\n    code: 8108,\n    lower: [ 8100 ],\n    title: [ 8108 ],\n    upper: [ 8044, 921 ],\n    fold: 8100,\n    foldFull: [ 8036, 953 ]\n}, {\n    code: 8108,\n    lower: [ 8100 ],\n    title: [ 8108 ],\n    upper: [ 8044, 921 ],\n    fold: 8100,\n    foldFull: [ 8036, 953 ]\n}, {\n    code: 8109,\n    lower: [ 8101 ],\n    title: [ 8109 ],\n    upper: [ 8045, 921 ],\n    fold: 8101,\n    foldFull: [ 8037, 953 ]\n}, {\n    code: 8109,\n    lower: [ 8101 ],\n    title: [ 8109 ],\n    upper: [ 8045, 921 ],\n    fold: 8101,\n    foldFull: [ 8037, 953 ]\n}, {\n    code: 8110,\n    lower: [ 8102 ],\n    title: [ 8110 ],\n    upper: [ 8046, 921 ],\n    fold: 8102,\n    foldFull: [ 8038, 953 ]\n}, {\n    code: 8110,\n    lower: [ 8102 ],\n    title: [ 8110 ],\n    upper: [ 8046, 921 ],\n    fold: 8102,\n    foldFull: [ 8038, 953 ]\n}, {\n    code: 8111,\n    lower: [ 8103 ],\n    title: [ 8111 ],\n    upper: [ 8047, 921 ],\n    fold: 8103,\n    foldFull: [ 8039, 953 ]\n}, {\n    code: 8111,\n    lower: [ 8103 ],\n    title: [ 8111 ],\n    upper: [ 8047, 921 ],\n    fold: 8103,\n    foldFull: [ 8039, 953 ]\n}, {\n    code: 8114,\n    lower: [ 8114 ],\n    title: [ 8122, 837 ],\n    upper: [ 8122, 921 ],\n    fold: 0,\n    foldFull: [ 8048, 953 ]\n}, {\n    code: 8114,\n    lower: [ 8114 ],\n    title: [ 8122, 837 ],\n    upper: [ 8122, 921 ],\n    fold: 0,\n    foldFull: [ 8048, 953 ]\n}, {\n    code: 8115,\n    lower: [ 8115 ],\n    title: [ 8124 ],\n    upper: [ 913, 921 ],\n    fold: 0,\n    foldFull: [ 945, 953 ]\n}, {\n    code: 8115,\n    lower: [ 8115 ],\n    title: [ 8124 ],\n    upper: [ 913, 921 ],\n    fold: 0,\n    foldFull: [ 945, 953 ]\n}, {\n    code: 8116,\n    lower: [ 8116 ],\n    title: [ 902, 837 ],\n    upper: [ 902, 921 ],\n    fold: 0,\n    foldFull: [ 940, 953 ]\n}, {\n    code: 8116,\n    lower: [ 8116 ],\n    title: [ 902, 837 ],\n    upper: [ 902, 921 ],\n    fold: 0,\n    foldFull: [ 940, 953 ]\n}, {\n    code: 8118,\n    lower: [ 8118 ],\n    title: [ 913, 834 ],\n    upper: [ 913, 834 ],\n    fold: 0,\n    foldFull: [ 945, 834 ]\n}, {\n    code: 8118,\n    lower: [ 8118 ],\n    title: [ 913, 834 ],\n    upper: [ 913, 834 ],\n    fold: 0,\n    foldFull: [ 945, 834 ]\n}, {\n    code: 8119,\n    lower: [ 8119 ],\n    title: [ 913, 834, 837 ],\n    upper: [ 913, 834, 921 ],\n    fold: 0,\n    foldFull: [ 945, 834, 953 ]\n}, {\n    code: 8119,\n    lower: [ 8119 ],\n    title: [ 913, 834, 837 ],\n    upper: [ 913, 834, 921 ],\n    fold: 0,\n    foldFull: [ 945, 834, 953 ]\n}, {\n    code: 8120,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8112,\n    foldFull: [ 8112 ]\n}, {\n    code: 8121,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8113,\n    foldFull: [ 8113 ]\n}, {\n    code: 8122,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8048,\n    foldFull: [ 8048 ]\n}, {\n    code: 8123,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8049,\n    foldFull: [ 8049 ]\n}, {\n    code: 8124,\n    lower: [ 8115 ],\n    title: [ 8124 ],\n    upper: [ 913, 921 ],\n    fold: 8115,\n    foldFull: [ 945, 953 ]\n}, {\n    code: 8124,\n    lower: [ 8115 ],\n    title: [ 8124 ],\n    upper: [ 913, 921 ],\n    fold: 8115,\n    foldFull: [ 945, 953 ]\n}, {\n    code: 8126,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 953,\n    foldFull: [ 953 ]\n}, {\n    code: 8130,\n    lower: [ 8130 ],\n    title: [ 8138, 837 ],\n    upper: [ 8138, 921 ],\n    fold: 0,\n    foldFull: [ 8052, 953 ]\n}, {\n    code: 8130,\n    lower: [ 8130 ],\n    title: [ 8138, 837 ],\n    upper: [ 8138, 921 ],\n    fold: 0,\n    foldFull: [ 8052, 953 ]\n}, {\n    code: 8131,\n    lower: [ 8131 ],\n    title: [ 8140 ],\n    upper: [ 919, 921 ],\n    fold: 0,\n    foldFull: [ 951, 953 ]\n}, {\n    code: 8131,\n    lower: [ 8131 ],\n    title: [ 8140 ],\n    upper: [ 919, 921 ],\n    fold: 0,\n    foldFull: [ 951, 953 ]\n}, {\n    code: 8132,\n    lower: [ 8132 ],\n    title: [ 905, 837 ],\n    upper: [ 905, 921 ],\n    fold: 0,\n    foldFull: [ 942, 953 ]\n}, {\n    code: 8132,\n    lower: [ 8132 ],\n    title: [ 905, 837 ],\n    upper: [ 905, 921 ],\n    fold: 0,\n    foldFull: [ 942, 953 ]\n}, {\n    code: 8134,\n    lower: [ 8134 ],\n    title: [ 919, 834 ],\n    upper: [ 919, 834 ],\n    fold: 0,\n    foldFull: [ 951, 834 ]\n}, {\n    code: 8134,\n    lower: [ 8134 ],\n    title: [ 919, 834 ],\n    upper: [ 919, 834 ],\n    fold: 0,\n    foldFull: [ 951, 834 ]\n}, {\n    code: 8135,\n    lower: [ 8135 ],\n    title: [ 919, 834, 837 ],\n    upper: [ 919, 834, 921 ],\n    fold: 0,\n    foldFull: [ 951, 834, 953 ]\n}, {\n    code: 8135,\n    lower: [ 8135 ],\n    title: [ 919, 834, 837 ],\n    upper: [ 919, 834, 921 ],\n    fold: 0,\n    foldFull: [ 951, 834, 953 ]\n}, {\n    code: 8136,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8050,\n    foldFull: [ 8050 ]\n}, {\n    code: 8137,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8051,\n    foldFull: [ 8051 ]\n}, {\n    code: 8138,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8052,\n    foldFull: [ 8052 ]\n}, {\n    code: 8139,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8053,\n    foldFull: [ 8053 ]\n}, {\n    code: 8140,\n    lower: [ 8131 ],\n    title: [ 8140 ],\n    upper: [ 919, 921 ],\n    fold: 8131,\n    foldFull: [ 951, 953 ]\n}, {\n    code: 8140,\n    lower: [ 8131 ],\n    title: [ 8140 ],\n    upper: [ 919, 921 ],\n    fold: 8131,\n    foldFull: [ 951, 953 ]\n}, {\n    code: 8146,\n    lower: [ 8146 ],\n    title: [ 921, 776, 768 ],\n    upper: [ 921, 776, 768 ],\n    fold: 0,\n    foldFull: [ 953, 776, 768 ]\n}, {\n    code: 8146,\n    lower: [ 8146 ],\n    title: [ 921, 776, 768 ],\n    upper: [ 921, 776, 768 ],\n    fold: 0,\n    foldFull: [ 953, 776, 768 ]\n}, {\n    code: 8147,\n    lower: [ 8147 ],\n    title: [ 921, 776, 769 ],\n    upper: [ 921, 776, 769 ],\n    fold: 0,\n    foldFull: [ 953, 776, 769 ]\n}, {\n    code: 8147,\n    lower: [ 8147 ],\n    title: [ 921, 776, 769 ],\n    upper: [ 921, 776, 769 ],\n    fold: 0,\n    foldFull: [ 953, 776, 769 ]\n}, {\n    code: 8150,\n    lower: [ 8150 ],\n    title: [ 921, 834 ],\n    upper: [ 921, 834 ],\n    fold: 0,\n    foldFull: [ 953, 834 ]\n}, {\n    code: 8150,\n    lower: [ 8150 ],\n    title: [ 921, 834 ],\n    upper: [ 921, 834 ],\n    fold: 0,\n    foldFull: [ 953, 834 ]\n}, {\n    code: 8151,\n    lower: [ 8151 ],\n    title: [ 921, 776, 834 ],\n    upper: [ 921, 776, 834 ],\n    fold: 0,\n    foldFull: [ 953, 776, 834 ]\n}, {\n    code: 8151,\n    lower: [ 8151 ],\n    title: [ 921, 776, 834 ],\n    upper: [ 921, 776, 834 ],\n    fold: 0,\n    foldFull: [ 953, 776, 834 ]\n}, {\n    code: 8152,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8144,\n    foldFull: [ 8144 ]\n}, {\n    code: 8153,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8145,\n    foldFull: [ 8145 ]\n}, {\n    code: 8154,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8054,\n    foldFull: [ 8054 ]\n}, {\n    code: 8155,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8055,\n    foldFull: [ 8055 ]\n}, {\n    code: 8162,\n    lower: [ 8162 ],\n    title: [ 933, 776, 768 ],\n    upper: [ 933, 776, 768 ],\n    fold: 0,\n    foldFull: [ 965, 776, 768 ]\n}, {\n    code: 8162,\n    lower: [ 8162 ],\n    title: [ 933, 776, 768 ],\n    upper: [ 933, 776, 768 ],\n    fold: 0,\n    foldFull: [ 965, 776, 768 ]\n}, {\n    code: 8163,\n    lower: [ 8163 ],\n    title: [ 933, 776, 769 ],\n    upper: [ 933, 776, 769 ],\n    fold: 0,\n    foldFull: [ 965, 776, 769 ]\n}, {\n    code: 8163,\n    lower: [ 8163 ],\n    title: [ 933, 776, 769 ],\n    upper: [ 933, 776, 769 ],\n    fold: 0,\n    foldFull: [ 965, 776, 769 ]\n}, {\n    code: 8164,\n    lower: [ 8164 ],\n    title: [ 929, 787 ],\n    upper: [ 929, 787 ],\n    fold: 0,\n    foldFull: [ 961, 787 ]\n}, {\n    code: 8164,\n    lower: [ 8164 ],\n    title: [ 929, 787 ],\n    upper: [ 929, 787 ],\n    fold: 0,\n    foldFull: [ 961, 787 ]\n}, {\n    code: 8166,\n    lower: [ 8166 ],\n    title: [ 933, 834 ],\n    upper: [ 933, 834 ],\n    fold: 0,\n    foldFull: [ 965, 834 ]\n}, {\n    code: 8166,\n    lower: [ 8166 ],\n    title: [ 933, 834 ],\n    upper: [ 933, 834 ],\n    fold: 0,\n    foldFull: [ 965, 834 ]\n}, {\n    code: 8167,\n    lower: [ 8167 ],\n    title: [ 933, 776, 834 ],\n    upper: [ 933, 776, 834 ],\n    fold: 0,\n    foldFull: [ 965, 776, 834 ]\n}, {\n    code: 8167,\n    lower: [ 8167 ],\n    title: [ 933, 776, 834 ],\n    upper: [ 933, 776, 834 ],\n    fold: 0,\n    foldFull: [ 965, 776, 834 ]\n}, {\n    code: 8168,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8160,\n    foldFull: [ 8160 ]\n}, {\n    code: 8169,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8161,\n    foldFull: [ 8161 ]\n}, {\n    code: 8170,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8058,\n    foldFull: [ 8058 ]\n}, {\n    code: 8171,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8059,\n    foldFull: [ 8059 ]\n}, {\n    code: 8172,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8165,\n    foldFull: [ 8165 ]\n}, {\n    code: 8178,\n    lower: [ 8178 ],\n    title: [ 8186, 837 ],\n    upper: [ 8186, 921 ],\n    fold: 0,\n    foldFull: [ 8060, 953 ]\n}, {\n    code: 8178,\n    lower: [ 8178 ],\n    title: [ 8186, 837 ],\n    upper: [ 8186, 921 ],\n    fold: 0,\n    foldFull: [ 8060, 953 ]\n}, {\n    code: 8179,\n    lower: [ 8179 ],\n    title: [ 8188 ],\n    upper: [ 937, 921 ],\n    fold: 0,\n    foldFull: [ 969, 953 ]\n}, {\n    code: 8179,\n    lower: [ 8179 ],\n    title: [ 8188 ],\n    upper: [ 937, 921 ],\n    fold: 0,\n    foldFull: [ 969, 953 ]\n}, {\n    code: 8180,\n    lower: [ 8180 ],\n    title: [ 911, 837 ],\n    upper: [ 911, 921 ],\n    fold: 0,\n    foldFull: [ 974, 953 ]\n}, {\n    code: 8180,\n    lower: [ 8180 ],\n    title: [ 911, 837 ],\n    upper: [ 911, 921 ],\n    fold: 0,\n    foldFull: [ 974, 953 ]\n}, {\n    code: 8182,\n    lower: [ 8182 ],\n    title: [ 937, 834 ],\n    upper: [ 937, 834 ],\n    fold: 0,\n    foldFull: [ 969, 834 ]\n}, {\n    code: 8182,\n    lower: [ 8182 ],\n    title: [ 937, 834 ],\n    upper: [ 937, 834 ],\n    fold: 0,\n    foldFull: [ 969, 834 ]\n}, {\n    code: 8183,\n    lower: [ 8183 ],\n    title: [ 937, 834, 837 ],\n    upper: [ 937, 834, 921 ],\n    fold: 0,\n    foldFull: [ 969, 834, 953 ]\n}, {\n    code: 8183,\n    lower: [ 8183 ],\n    title: [ 937, 834, 837 ],\n    upper: [ 937, 834, 921 ],\n    fold: 0,\n    foldFull: [ 969, 834, 953 ]\n}, {\n    code: 8184,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8056,\n    foldFull: [ 8056 ]\n}, {\n    code: 8185,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8057,\n    foldFull: [ 8057 ]\n}, {\n    code: 8186,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8060,\n    foldFull: [ 8060 ]\n}, {\n    code: 8187,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8061,\n    foldFull: [ 8061 ]\n}, {\n    code: 8188,\n    lower: [ 8179 ],\n    title: [ 8188 ],\n    upper: [ 937, 921 ],\n    fold: 8179,\n    foldFull: [ 969, 953 ]\n}, {\n    code: 8188,\n    lower: [ 8179 ],\n    title: [ 8188 ],\n    upper: [ 937, 921 ],\n    fold: 8179,\n    foldFull: [ 969, 953 ]\n}, {\n    code: 8486,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 969,\n    foldFull: [ 969 ]\n}, {\n    code: 8490,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 107,\n    foldFull: [ 107 ]\n}, {\n    code: 8491,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 229,\n    foldFull: [ 229 ]\n}, {\n    code: 8498,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8526,\n    foldFull: [ 8526 ]\n}, {\n    code: 8544,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8560,\n    foldFull: [ 8560 ]\n}, {\n    code: 8545,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8561,\n    foldFull: [ 8561 ]\n}, {\n    code: 8546,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8562,\n    foldFull: [ 8562 ]\n}, {\n    code: 8547,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8563,\n    foldFull: [ 8563 ]\n}, {\n    code: 8548,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8564,\n    foldFull: [ 8564 ]\n}, {\n    code: 8549,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8565,\n    foldFull: [ 8565 ]\n}, {\n    code: 8550,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8566,\n    foldFull: [ 8566 ]\n}, {\n    code: 8551,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8567,\n    foldFull: [ 8567 ]\n}, {\n    code: 8552,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8568,\n    foldFull: [ 8568 ]\n}, {\n    code: 8553,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8569,\n    foldFull: [ 8569 ]\n}, {\n    code: 8554,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8570,\n    foldFull: [ 8570 ]\n}, {\n    code: 8555,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8571,\n    foldFull: [ 8571 ]\n}, {\n    code: 8556,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8572,\n    foldFull: [ 8572 ]\n}, {\n    code: 8557,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8573,\n    foldFull: [ 8573 ]\n}, {\n    code: 8558,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8574,\n    foldFull: [ 8574 ]\n}, {\n    code: 8559,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8575,\n    foldFull: [ 8575 ]\n}, {\n    code: 8579,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 8580,\n    foldFull: [ 8580 ]\n}, {\n    code: 9398,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9424,\n    foldFull: [ 9424 ]\n}, {\n    code: 9399,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9425,\n    foldFull: [ 9425 ]\n}, {\n    code: 9400,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9426,\n    foldFull: [ 9426 ]\n}, {\n    code: 9401,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9427,\n    foldFull: [ 9427 ]\n}, {\n    code: 9402,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9428,\n    foldFull: [ 9428 ]\n}, {\n    code: 9403,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9429,\n    foldFull: [ 9429 ]\n}, {\n    code: 9404,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9430,\n    foldFull: [ 9430 ]\n}, {\n    code: 9405,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9431,\n    foldFull: [ 9431 ]\n}, {\n    code: 9406,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9432,\n    foldFull: [ 9432 ]\n}, {\n    code: 9407,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9433,\n    foldFull: [ 9433 ]\n}, {\n    code: 9408,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9434,\n    foldFull: [ 9434 ]\n}, {\n    code: 9409,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9435,\n    foldFull: [ 9435 ]\n}, {\n    code: 9410,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9436,\n    foldFull: [ 9436 ]\n}, {\n    code: 9411,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9437,\n    foldFull: [ 9437 ]\n}, {\n    code: 9412,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9438,\n    foldFull: [ 9438 ]\n}, {\n    code: 9413,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9439,\n    foldFull: [ 9439 ]\n}, {\n    code: 9414,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9440,\n    foldFull: [ 9440 ]\n}, {\n    code: 9415,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9441,\n    foldFull: [ 9441 ]\n}, {\n    code: 9416,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9442,\n    foldFull: [ 9442 ]\n}, {\n    code: 9417,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9443,\n    foldFull: [ 9443 ]\n}, {\n    code: 9418,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9444,\n    foldFull: [ 9444 ]\n}, {\n    code: 9419,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9445,\n    foldFull: [ 9445 ]\n}, {\n    code: 9420,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9446,\n    foldFull: [ 9446 ]\n}, {\n    code: 9421,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9447,\n    foldFull: [ 9447 ]\n}, {\n    code: 9422,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9448,\n    foldFull: [ 9448 ]\n}, {\n    code: 9423,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 9449,\n    foldFull: [ 9449 ]\n}, {\n    code: 11264,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11312,\n    foldFull: [ 11312 ]\n}, {\n    code: 11265,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11313,\n    foldFull: [ 11313 ]\n}, {\n    code: 11266,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11314,\n    foldFull: [ 11314 ]\n}, {\n    code: 11267,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11315,\n    foldFull: [ 11315 ]\n}, {\n    code: 11268,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11316,\n    foldFull: [ 11316 ]\n}, {\n    code: 11269,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11317,\n    foldFull: [ 11317 ]\n}, {\n    code: 11270,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11318,\n    foldFull: [ 11318 ]\n}, {\n    code: 11271,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11319,\n    foldFull: [ 11319 ]\n}, {\n    code: 11272,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11320,\n    foldFull: [ 11320 ]\n}, {\n    code: 11273,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11321,\n    foldFull: [ 11321 ]\n}, {\n    code: 11274,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11322,\n    foldFull: [ 11322 ]\n}, {\n    code: 11275,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11323,\n    foldFull: [ 11323 ]\n}, {\n    code: 11276,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11324,\n    foldFull: [ 11324 ]\n}, {\n    code: 11277,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11325,\n    foldFull: [ 11325 ]\n}, {\n    code: 11278,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11326,\n    foldFull: [ 11326 ]\n}, {\n    code: 11279,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11327,\n    foldFull: [ 11327 ]\n}, {\n    code: 11280,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11328,\n    foldFull: [ 11328 ]\n}, {\n    code: 11281,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11329,\n    foldFull: [ 11329 ]\n}, {\n    code: 11282,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11330,\n    foldFull: [ 11330 ]\n}, {\n    code: 11283,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11331,\n    foldFull: [ 11331 ]\n}, {\n    code: 11284,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11332,\n    foldFull: [ 11332 ]\n}, {\n    code: 11285,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11333,\n    foldFull: [ 11333 ]\n}, {\n    code: 11286,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11334,\n    foldFull: [ 11334 ]\n}, {\n    code: 11287,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11335,\n    foldFull: [ 11335 ]\n}, {\n    code: 11288,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11336,\n    foldFull: [ 11336 ]\n}, {\n    code: 11289,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11337,\n    foldFull: [ 11337 ]\n}, {\n    code: 11290,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11338,\n    foldFull: [ 11338 ]\n}, {\n    code: 11291,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11339,\n    foldFull: [ 11339 ]\n}, {\n    code: 11292,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11340,\n    foldFull: [ 11340 ]\n}, {\n    code: 11293,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11341,\n    foldFull: [ 11341 ]\n}, {\n    code: 11294,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11342,\n    foldFull: [ 11342 ]\n}, {\n    code: 11295,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11343,\n    foldFull: [ 11343 ]\n}, {\n    code: 11296,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11344,\n    foldFull: [ 11344 ]\n}, {\n    code: 11297,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11345,\n    foldFull: [ 11345 ]\n}, {\n    code: 11298,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11346,\n    foldFull: [ 11346 ]\n}, {\n    code: 11299,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11347,\n    foldFull: [ 11347 ]\n}, {\n    code: 11300,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11348,\n    foldFull: [ 11348 ]\n}, {\n    code: 11301,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11349,\n    foldFull: [ 11349 ]\n}, {\n    code: 11302,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11350,\n    foldFull: [ 11350 ]\n}, {\n    code: 11303,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11351,\n    foldFull: [ 11351 ]\n}, {\n    code: 11304,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11352,\n    foldFull: [ 11352 ]\n}, {\n    code: 11305,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11353,\n    foldFull: [ 11353 ]\n}, {\n    code: 11306,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11354,\n    foldFull: [ 11354 ]\n}, {\n    code: 11307,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11355,\n    foldFull: [ 11355 ]\n}, {\n    code: 11308,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11356,\n    foldFull: [ 11356 ]\n}, {\n    code: 11309,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11357,\n    foldFull: [ 11357 ]\n}, {\n    code: 11310,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11358,\n    foldFull: [ 11358 ]\n}, {\n    code: 11360,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11361,\n    foldFull: [ 11361 ]\n}, {\n    code: 11362,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 619,\n    foldFull: [ 619 ]\n}, {\n    code: 11363,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7549,\n    foldFull: [ 7549 ]\n}, {\n    code: 11364,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 637,\n    foldFull: [ 637 ]\n}, {\n    code: 11367,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11368,\n    foldFull: [ 11368 ]\n}, {\n    code: 11369,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11370,\n    foldFull: [ 11370 ]\n}, {\n    code: 11371,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11372,\n    foldFull: [ 11372 ]\n}, {\n    code: 11373,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 593,\n    foldFull: [ 593 ]\n}, {\n    code: 11374,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 625,\n    foldFull: [ 625 ]\n}, {\n    code: 11375,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 592,\n    foldFull: [ 592 ]\n}, {\n    code: 11376,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 594,\n    foldFull: [ 594 ]\n}, {\n    code: 11378,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11379,\n    foldFull: [ 11379 ]\n}, {\n    code: 11381,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11382,\n    foldFull: [ 11382 ]\n}, {\n    code: 11390,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 575,\n    foldFull: [ 575 ]\n}, {\n    code: 11391,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 576,\n    foldFull: [ 576 ]\n}, {\n    code: 11392,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11393,\n    foldFull: [ 11393 ]\n}, {\n    code: 11394,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11395,\n    foldFull: [ 11395 ]\n}, {\n    code: 11396,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11397,\n    foldFull: [ 11397 ]\n}, {\n    code: 11398,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11399,\n    foldFull: [ 11399 ]\n}, {\n    code: 11400,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11401,\n    foldFull: [ 11401 ]\n}, {\n    code: 11402,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11403,\n    foldFull: [ 11403 ]\n}, {\n    code: 11404,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11405,\n    foldFull: [ 11405 ]\n}, {\n    code: 11406,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11407,\n    foldFull: [ 11407 ]\n}, {\n    code: 11408,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11409,\n    foldFull: [ 11409 ]\n}, {\n    code: 11410,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11411,\n    foldFull: [ 11411 ]\n}, {\n    code: 11412,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11413,\n    foldFull: [ 11413 ]\n}, {\n    code: 11414,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11415,\n    foldFull: [ 11415 ]\n}, {\n    code: 11416,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11417,\n    foldFull: [ 11417 ]\n}, {\n    code: 11418,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11419,\n    foldFull: [ 11419 ]\n}, {\n    code: 11420,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11421,\n    foldFull: [ 11421 ]\n}, {\n    code: 11422,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11423,\n    foldFull: [ 11423 ]\n}, {\n    code: 11424,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11425,\n    foldFull: [ 11425 ]\n}, {\n    code: 11426,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11427,\n    foldFull: [ 11427 ]\n}, {\n    code: 11428,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11429,\n    foldFull: [ 11429 ]\n}, {\n    code: 11430,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11431,\n    foldFull: [ 11431 ]\n}, {\n    code: 11432,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11433,\n    foldFull: [ 11433 ]\n}, {\n    code: 11434,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11435,\n    foldFull: [ 11435 ]\n}, {\n    code: 11436,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11437,\n    foldFull: [ 11437 ]\n}, {\n    code: 11438,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11439,\n    foldFull: [ 11439 ]\n}, {\n    code: 11440,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11441,\n    foldFull: [ 11441 ]\n}, {\n    code: 11442,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11443,\n    foldFull: [ 11443 ]\n}, {\n    code: 11444,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11445,\n    foldFull: [ 11445 ]\n}, {\n    code: 11446,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11447,\n    foldFull: [ 11447 ]\n}, {\n    code: 11448,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11449,\n    foldFull: [ 11449 ]\n}, {\n    code: 11450,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11451,\n    foldFull: [ 11451 ]\n}, {\n    code: 11452,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11453,\n    foldFull: [ 11453 ]\n}, {\n    code: 11454,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11455,\n    foldFull: [ 11455 ]\n}, {\n    code: 11456,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11457,\n    foldFull: [ 11457 ]\n}, {\n    code: 11458,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11459,\n    foldFull: [ 11459 ]\n}, {\n    code: 11460,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11461,\n    foldFull: [ 11461 ]\n}, {\n    code: 11462,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11463,\n    foldFull: [ 11463 ]\n}, {\n    code: 11464,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11465,\n    foldFull: [ 11465 ]\n}, {\n    code: 11466,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11467,\n    foldFull: [ 11467 ]\n}, {\n    code: 11468,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11469,\n    foldFull: [ 11469 ]\n}, {\n    code: 11470,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11471,\n    foldFull: [ 11471 ]\n}, {\n    code: 11472,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11473,\n    foldFull: [ 11473 ]\n}, {\n    code: 11474,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11475,\n    foldFull: [ 11475 ]\n}, {\n    code: 11476,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11477,\n    foldFull: [ 11477 ]\n}, {\n    code: 11478,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11479,\n    foldFull: [ 11479 ]\n}, {\n    code: 11480,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11481,\n    foldFull: [ 11481 ]\n}, {\n    code: 11482,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11483,\n    foldFull: [ 11483 ]\n}, {\n    code: 11484,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11485,\n    foldFull: [ 11485 ]\n}, {\n    code: 11486,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11487,\n    foldFull: [ 11487 ]\n}, {\n    code: 11488,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11489,\n    foldFull: [ 11489 ]\n}, {\n    code: 11490,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11491,\n    foldFull: [ 11491 ]\n}, {\n    code: 11499,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11500,\n    foldFull: [ 11500 ]\n}, {\n    code: 11501,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11502,\n    foldFull: [ 11502 ]\n}, {\n    code: 11506,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 11507,\n    foldFull: [ 11507 ]\n}, {\n    code: 42560,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42561,\n    foldFull: [ 42561 ]\n}, {\n    code: 42562,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42563,\n    foldFull: [ 42563 ]\n}, {\n    code: 42564,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42565,\n    foldFull: [ 42565 ]\n}, {\n    code: 42566,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42567,\n    foldFull: [ 42567 ]\n}, {\n    code: 42568,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42569,\n    foldFull: [ 42569 ]\n}, {\n    code: 42570,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42571,\n    foldFull: [ 42571 ]\n}, {\n    code: 42572,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42573,\n    foldFull: [ 42573 ]\n}, {\n    code: 42574,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42575,\n    foldFull: [ 42575 ]\n}, {\n    code: 42576,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42577,\n    foldFull: [ 42577 ]\n}, {\n    code: 42578,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42579,\n    foldFull: [ 42579 ]\n}, {\n    code: 42580,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42581,\n    foldFull: [ 42581 ]\n}, {\n    code: 42582,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42583,\n    foldFull: [ 42583 ]\n}, {\n    code: 42584,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42585,\n    foldFull: [ 42585 ]\n}, {\n    code: 42586,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42587,\n    foldFull: [ 42587 ]\n}, {\n    code: 42588,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42589,\n    foldFull: [ 42589 ]\n}, {\n    code: 42590,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42591,\n    foldFull: [ 42591 ]\n}, {\n    code: 42592,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42593,\n    foldFull: [ 42593 ]\n}, {\n    code: 42594,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42595,\n    foldFull: [ 42595 ]\n}, {\n    code: 42596,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42597,\n    foldFull: [ 42597 ]\n}, {\n    code: 42598,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42599,\n    foldFull: [ 42599 ]\n}, {\n    code: 42600,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42601,\n    foldFull: [ 42601 ]\n}, {\n    code: 42602,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42603,\n    foldFull: [ 42603 ]\n}, {\n    code: 42604,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42605,\n    foldFull: [ 42605 ]\n}, {\n    code: 42624,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42625,\n    foldFull: [ 42625 ]\n}, {\n    code: 42626,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42627,\n    foldFull: [ 42627 ]\n}, {\n    code: 42628,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42629,\n    foldFull: [ 42629 ]\n}, {\n    code: 42630,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42631,\n    foldFull: [ 42631 ]\n}, {\n    code: 42632,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42633,\n    foldFull: [ 42633 ]\n}, {\n    code: 42634,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42635,\n    foldFull: [ 42635 ]\n}, {\n    code: 42636,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42637,\n    foldFull: [ 42637 ]\n}, {\n    code: 42638,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42639,\n    foldFull: [ 42639 ]\n}, {\n    code: 42640,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42641,\n    foldFull: [ 42641 ]\n}, {\n    code: 42642,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42643,\n    foldFull: [ 42643 ]\n}, {\n    code: 42644,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42645,\n    foldFull: [ 42645 ]\n}, {\n    code: 42646,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42647,\n    foldFull: [ 42647 ]\n}, {\n    code: 42648,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42649,\n    foldFull: [ 42649 ]\n}, {\n    code: 42650,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42651,\n    foldFull: [ 42651 ]\n}, {\n    code: 42786,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42787,\n    foldFull: [ 42787 ]\n}, {\n    code: 42788,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42789,\n    foldFull: [ 42789 ]\n}, {\n    code: 42790,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42791,\n    foldFull: [ 42791 ]\n}, {\n    code: 42792,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42793,\n    foldFull: [ 42793 ]\n}, {\n    code: 42794,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42795,\n    foldFull: [ 42795 ]\n}, {\n    code: 42796,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42797,\n    foldFull: [ 42797 ]\n}, {\n    code: 42798,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42799,\n    foldFull: [ 42799 ]\n}, {\n    code: 42802,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42803,\n    foldFull: [ 42803 ]\n}, {\n    code: 42804,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42805,\n    foldFull: [ 42805 ]\n}, {\n    code: 42806,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42807,\n    foldFull: [ 42807 ]\n}, {\n    code: 42808,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42809,\n    foldFull: [ 42809 ]\n}, {\n    code: 42810,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42811,\n    foldFull: [ 42811 ]\n}, {\n    code: 42812,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42813,\n    foldFull: [ 42813 ]\n}, {\n    code: 42814,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42815,\n    foldFull: [ 42815 ]\n}, {\n    code: 42816,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42817,\n    foldFull: [ 42817 ]\n}, {\n    code: 42818,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42819,\n    foldFull: [ 42819 ]\n}, {\n    code: 42820,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42821,\n    foldFull: [ 42821 ]\n}, {\n    code: 42822,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42823,\n    foldFull: [ 42823 ]\n}, {\n    code: 42824,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42825,\n    foldFull: [ 42825 ]\n}, {\n    code: 42826,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42827,\n    foldFull: [ 42827 ]\n}, {\n    code: 42828,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42829,\n    foldFull: [ 42829 ]\n}, {\n    code: 42830,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42831,\n    foldFull: [ 42831 ]\n}, {\n    code: 42832,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42833,\n    foldFull: [ 42833 ]\n}, {\n    code: 42834,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42835,\n    foldFull: [ 42835 ]\n}, {\n    code: 42836,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42837,\n    foldFull: [ 42837 ]\n}, {\n    code: 42838,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42839,\n    foldFull: [ 42839 ]\n}, {\n    code: 42840,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42841,\n    foldFull: [ 42841 ]\n}, {\n    code: 42842,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42843,\n    foldFull: [ 42843 ]\n}, {\n    code: 42844,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42845,\n    foldFull: [ 42845 ]\n}, {\n    code: 42846,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42847,\n    foldFull: [ 42847 ]\n}, {\n    code: 42848,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42849,\n    foldFull: [ 42849 ]\n}, {\n    code: 42850,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42851,\n    foldFull: [ 42851 ]\n}, {\n    code: 42852,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42853,\n    foldFull: [ 42853 ]\n}, {\n    code: 42854,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42855,\n    foldFull: [ 42855 ]\n}, {\n    code: 42856,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42857,\n    foldFull: [ 42857 ]\n}, {\n    code: 42858,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42859,\n    foldFull: [ 42859 ]\n}, {\n    code: 42860,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42861,\n    foldFull: [ 42861 ]\n}, {\n    code: 42862,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42863,\n    foldFull: [ 42863 ]\n}, {\n    code: 42873,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42874,\n    foldFull: [ 42874 ]\n}, {\n    code: 42875,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42876,\n    foldFull: [ 42876 ]\n}, {\n    code: 42877,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7545,\n    foldFull: [ 7545 ]\n}, {\n    code: 42878,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42879,\n    foldFull: [ 42879 ]\n}, {\n    code: 42880,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42881,\n    foldFull: [ 42881 ]\n}, {\n    code: 42882,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42883,\n    foldFull: [ 42883 ]\n}, {\n    code: 42884,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42885,\n    foldFull: [ 42885 ]\n}, {\n    code: 42886,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42887,\n    foldFull: [ 42887 ]\n}, {\n    code: 42891,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42892,\n    foldFull: [ 42892 ]\n}, {\n    code: 42893,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 613,\n    foldFull: [ 613 ]\n}, {\n    code: 42896,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42897,\n    foldFull: [ 42897 ]\n}, {\n    code: 42898,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42899,\n    foldFull: [ 42899 ]\n}, {\n    code: 42902,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42903,\n    foldFull: [ 42903 ]\n}, {\n    code: 42904,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42905,\n    foldFull: [ 42905 ]\n}, {\n    code: 42906,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42907,\n    foldFull: [ 42907 ]\n}, {\n    code: 42908,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42909,\n    foldFull: [ 42909 ]\n}, {\n    code: 42910,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42911,\n    foldFull: [ 42911 ]\n}, {\n    code: 42912,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42913,\n    foldFull: [ 42913 ]\n}, {\n    code: 42914,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42915,\n    foldFull: [ 42915 ]\n}, {\n    code: 42916,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42917,\n    foldFull: [ 42917 ]\n}, {\n    code: 42918,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42919,\n    foldFull: [ 42919 ]\n}, {\n    code: 42920,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42921,\n    foldFull: [ 42921 ]\n}, {\n    code: 42922,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 614,\n    foldFull: [ 614 ]\n}, {\n    code: 42923,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 604,\n    foldFull: [ 604 ]\n}, {\n    code: 42924,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 609,\n    foldFull: [ 609 ]\n}, {\n    code: 42925,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 620,\n    foldFull: [ 620 ]\n}, {\n    code: 42926,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 618,\n    foldFull: [ 618 ]\n}, {\n    code: 42928,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 670,\n    foldFull: [ 670 ]\n}, {\n    code: 42929,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 647,\n    foldFull: [ 647 ]\n}, {\n    code: 42930,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 669,\n    foldFull: [ 669 ]\n}, {\n    code: 42931,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 43859,\n    foldFull: [ 43859 ]\n}, {\n    code: 42932,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42933,\n    foldFull: [ 42933 ]\n}, {\n    code: 42934,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42935,\n    foldFull: [ 42935 ]\n}, {\n    code: 42936,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42937,\n    foldFull: [ 42937 ]\n}, {\n    code: 42938,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42939,\n    foldFull: [ 42939 ]\n}, {\n    code: 42940,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42941,\n    foldFull: [ 42941 ]\n}, {\n    code: 42942,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42943,\n    foldFull: [ 42943 ]\n}, {\n    code: 42946,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42947,\n    foldFull: [ 42947 ]\n}, {\n    code: 42948,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42900,\n    foldFull: [ 42900 ]\n}, {\n    code: 42949,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 642,\n    foldFull: [ 642 ]\n}, {\n    code: 42950,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 7566,\n    foldFull: [ 7566 ]\n}, {\n    code: 42951,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42952,\n    foldFull: [ 42952 ]\n}, {\n    code: 42953,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42954,\n    foldFull: [ 42954 ]\n}, {\n    code: 42997,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 42998,\n    foldFull: [ 42998 ]\n}, {\n    code: 43888,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5024,\n    foldFull: [ 5024 ]\n}, {\n    code: 43889,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5025,\n    foldFull: [ 5025 ]\n}, {\n    code: 43890,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5026,\n    foldFull: [ 5026 ]\n}, {\n    code: 43891,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5027,\n    foldFull: [ 5027 ]\n}, {\n    code: 43892,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5028,\n    foldFull: [ 5028 ]\n}, {\n    code: 43893,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5029,\n    foldFull: [ 5029 ]\n}, {\n    code: 43894,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5030,\n    foldFull: [ 5030 ]\n}, {\n    code: 43895,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5031,\n    foldFull: [ 5031 ]\n}, {\n    code: 43896,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5032,\n    foldFull: [ 5032 ]\n}, {\n    code: 43897,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5033,\n    foldFull: [ 5033 ]\n}, {\n    code: 43898,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5034,\n    foldFull: [ 5034 ]\n}, {\n    code: 43899,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5035,\n    foldFull: [ 5035 ]\n}, {\n    code: 43900,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5036,\n    foldFull: [ 5036 ]\n}, {\n    code: 43901,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5037,\n    foldFull: [ 5037 ]\n}, {\n    code: 43902,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5038,\n    foldFull: [ 5038 ]\n}, {\n    code: 43903,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5039,\n    foldFull: [ 5039 ]\n}, {\n    code: 43904,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5040,\n    foldFull: [ 5040 ]\n}, {\n    code: 43905,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5041,\n    foldFull: [ 5041 ]\n}, {\n    code: 43906,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5042,\n    foldFull: [ 5042 ]\n}, {\n    code: 43907,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5043,\n    foldFull: [ 5043 ]\n}, {\n    code: 43908,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5044,\n    foldFull: [ 5044 ]\n}, {\n    code: 43909,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5045,\n    foldFull: [ 5045 ]\n}, {\n    code: 43910,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5046,\n    foldFull: [ 5046 ]\n}, {\n    code: 43911,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5047,\n    foldFull: [ 5047 ]\n}, {\n    code: 43912,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5048,\n    foldFull: [ 5048 ]\n}, {\n    code: 43913,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5049,\n    foldFull: [ 5049 ]\n}, {\n    code: 43914,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5050,\n    foldFull: [ 5050 ]\n}, {\n    code: 43915,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5051,\n    foldFull: [ 5051 ]\n}, {\n    code: 43916,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5052,\n    foldFull: [ 5052 ]\n}, {\n    code: 43917,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5053,\n    foldFull: [ 5053 ]\n}, {\n    code: 43918,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5054,\n    foldFull: [ 5054 ]\n}, {\n    code: 43919,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5055,\n    foldFull: [ 5055 ]\n}, {\n    code: 43920,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5056,\n    foldFull: [ 5056 ]\n}, {\n    code: 43921,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5057,\n    foldFull: [ 5057 ]\n}, {\n    code: 43922,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5058,\n    foldFull: [ 5058 ]\n}, {\n    code: 43923,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5059,\n    foldFull: [ 5059 ]\n}, {\n    code: 43924,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5060,\n    foldFull: [ 5060 ]\n}, {\n    code: 43925,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5061,\n    foldFull: [ 5061 ]\n}, {\n    code: 43926,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5062,\n    foldFull: [ 5062 ]\n}, {\n    code: 43927,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5063,\n    foldFull: [ 5063 ]\n}, {\n    code: 43928,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5064,\n    foldFull: [ 5064 ]\n}, {\n    code: 43929,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5065,\n    foldFull: [ 5065 ]\n}, {\n    code: 43930,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5066,\n    foldFull: [ 5066 ]\n}, {\n    code: 43931,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5067,\n    foldFull: [ 5067 ]\n}, {\n    code: 43932,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5068,\n    foldFull: [ 5068 ]\n}, {\n    code: 43933,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5069,\n    foldFull: [ 5069 ]\n}, {\n    code: 43934,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5070,\n    foldFull: [ 5070 ]\n}, {\n    code: 43935,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5071,\n    foldFull: [ 5071 ]\n}, {\n    code: 43936,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5072,\n    foldFull: [ 5072 ]\n}, {\n    code: 43937,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5073,\n    foldFull: [ 5073 ]\n}, {\n    code: 43938,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5074,\n    foldFull: [ 5074 ]\n}, {\n    code: 43939,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5075,\n    foldFull: [ 5075 ]\n}, {\n    code: 43940,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5076,\n    foldFull: [ 5076 ]\n}, {\n    code: 43941,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5077,\n    foldFull: [ 5077 ]\n}, {\n    code: 43942,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5078,\n    foldFull: [ 5078 ]\n}, {\n    code: 43943,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5079,\n    foldFull: [ 5079 ]\n}, {\n    code: 43944,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5080,\n    foldFull: [ 5080 ]\n}, {\n    code: 43945,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5081,\n    foldFull: [ 5081 ]\n}, {\n    code: 43946,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5082,\n    foldFull: [ 5082 ]\n}, {\n    code: 43947,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5083,\n    foldFull: [ 5083 ]\n}, {\n    code: 43948,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5084,\n    foldFull: [ 5084 ]\n}, {\n    code: 43949,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5085,\n    foldFull: [ 5085 ]\n}, {\n    code: 43950,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5086,\n    foldFull: [ 5086 ]\n}, {\n    code: 43951,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5087,\n    foldFull: [ 5087 ]\n}, {\n    code: 43952,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5088,\n    foldFull: [ 5088 ]\n}, {\n    code: 43953,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5089,\n    foldFull: [ 5089 ]\n}, {\n    code: 43954,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5090,\n    foldFull: [ 5090 ]\n}, {\n    code: 43955,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5091,\n    foldFull: [ 5091 ]\n}, {\n    code: 43956,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5092,\n    foldFull: [ 5092 ]\n}, {\n    code: 43957,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5093,\n    foldFull: [ 5093 ]\n}, {\n    code: 43958,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5094,\n    foldFull: [ 5094 ]\n}, {\n    code: 43959,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5095,\n    foldFull: [ 5095 ]\n}, {\n    code: 43960,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5096,\n    foldFull: [ 5096 ]\n}, {\n    code: 43961,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5097,\n    foldFull: [ 5097 ]\n}, {\n    code: 43962,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5098,\n    foldFull: [ 5098 ]\n}, {\n    code: 43963,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5099,\n    foldFull: [ 5099 ]\n}, {\n    code: 43964,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5100,\n    foldFull: [ 5100 ]\n}, {\n    code: 43965,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5101,\n    foldFull: [ 5101 ]\n}, {\n    code: 43966,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5102,\n    foldFull: [ 5102 ]\n}, {\n    code: 43967,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 5103,\n    foldFull: [ 5103 ]\n}, {\n    code: 64256,\n    lower: [ 64256 ],\n    title: [ 70, 102 ],\n    upper: [ 70, 70 ],\n    fold: 0,\n    foldFull: [ 102, 102 ]\n}, {\n    code: 64256,\n    lower: [ 64256 ],\n    title: [ 70, 102 ],\n    upper: [ 70, 70 ],\n    fold: 0,\n    foldFull: [ 102, 102 ]\n}, {\n    code: 64257,\n    lower: [ 64257 ],\n    title: [ 70, 105 ],\n    upper: [ 70, 73 ],\n    fold: 0,\n    foldFull: [ 102, 105 ]\n}, {\n    code: 64257,\n    lower: [ 64257 ],\n    title: [ 70, 105 ],\n    upper: [ 70, 73 ],\n    fold: 0,\n    foldFull: [ 102, 105 ]\n}, {\n    code: 64258,\n    lower: [ 64258 ],\n    title: [ 70, 108 ],\n    upper: [ 70, 76 ],\n    fold: 0,\n    foldFull: [ 102, 108 ]\n}, {\n    code: 64258,\n    lower: [ 64258 ],\n    title: [ 70, 108 ],\n    upper: [ 70, 76 ],\n    fold: 0,\n    foldFull: [ 102, 108 ]\n}, {\n    code: 64259,\n    lower: [ 64259 ],\n    title: [ 70, 102, 105 ],\n    upper: [ 70, 70, 73 ],\n    fold: 0,\n    foldFull: [ 102, 102, 105 ]\n}, {\n    code: 64259,\n    lower: [ 64259 ],\n    title: [ 70, 102, 105 ],\n    upper: [ 70, 70, 73 ],\n    fold: 0,\n    foldFull: [ 102, 102, 105 ]\n}, {\n    code: 64260,\n    lower: [ 64260 ],\n    title: [ 70, 102, 108 ],\n    upper: [ 70, 70, 76 ],\n    fold: 0,\n    foldFull: [ 102, 102, 108 ]\n}, {\n    code: 64260,\n    lower: [ 64260 ],\n    title: [ 70, 102, 108 ],\n    upper: [ 70, 70, 76 ],\n    fold: 0,\n    foldFull: [ 102, 102, 108 ]\n}, {\n    code: 64261,\n    lower: [ 64261 ],\n    title: [ 83, 116 ],\n    upper: [ 83, 84 ],\n    fold: 0,\n    foldFull: [ 115, 116 ]\n}, {\n    code: 64261,\n    lower: [ 64261 ],\n    title: [ 83, 116 ],\n    upper: [ 83, 84 ],\n    fold: 0,\n    foldFull: [ 115, 116 ]\n}, {\n    code: 64262,\n    lower: [ 64262 ],\n    title: [ 83, 116 ],\n    upper: [ 83, 84 ],\n    fold: 0,\n    foldFull: [ 115, 116 ]\n}, {\n    code: 64262,\n    lower: [ 64262 ],\n    title: [ 83, 116 ],\n    upper: [ 83, 84 ],\n    fold: 0,\n    foldFull: [ 115, 116 ]\n}, {\n    code: 64275,\n    lower: [ 64275 ],\n    title: [ 1348, 1398 ],\n    upper: [ 1348, 1350 ],\n    fold: 0,\n    foldFull: [ 1396, 1398 ]\n}, {\n    code: 64275,\n    lower: [ 64275 ],\n    title: [ 1348, 1398 ],\n    upper: [ 1348, 1350 ],\n    fold: 0,\n    foldFull: [ 1396, 1398 ]\n}, {\n    code: 64276,\n    lower: [ 64276 ],\n    title: [ 1348, 1381 ],\n    upper: [ 1348, 1333 ],\n    fold: 0,\n    foldFull: [ 1396, 1381 ]\n}, {\n    code: 64276,\n    lower: [ 64276 ],\n    title: [ 1348, 1381 ],\n    upper: [ 1348, 1333 ],\n    fold: 0,\n    foldFull: [ 1396, 1381 ]\n}, {\n    code: 64277,\n    lower: [ 64277 ],\n    title: [ 1348, 1387 ],\n    upper: [ 1348, 1339 ],\n    fold: 0,\n    foldFull: [ 1396, 1387 ]\n}, {\n    code: 64277,\n    lower: [ 64277 ],\n    title: [ 1348, 1387 ],\n    upper: [ 1348, 1339 ],\n    fold: 0,\n    foldFull: [ 1396, 1387 ]\n}, {\n    code: 64278,\n    lower: [ 64278 ],\n    title: [ 1358, 1398 ],\n    upper: [ 1358, 1350 ],\n    fold: 0,\n    foldFull: [ 1406, 1398 ]\n}, {\n    code: 64278,\n    lower: [ 64278 ],\n    title: [ 1358, 1398 ],\n    upper: [ 1358, 1350 ],\n    fold: 0,\n    foldFull: [ 1406, 1398 ]\n}, {\n    code: 64279,\n    lower: [ 64279 ],\n    title: [ 1348, 1389 ],\n    upper: [ 1348, 1341 ],\n    fold: 0,\n    foldFull: [ 1396, 1389 ]\n}, {\n    code: 64279,\n    lower: [ 64279 ],\n    title: [ 1348, 1389 ],\n    upper: [ 1348, 1341 ],\n    fold: 0,\n    foldFull: [ 1396, 1389 ]\n}, {\n    code: 65313,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65345,\n    foldFull: [ 65345 ]\n}, {\n    code: 65314,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65346,\n    foldFull: [ 65346 ]\n}, {\n    code: 65315,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65347,\n    foldFull: [ 65347 ]\n}, {\n    code: 65316,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65348,\n    foldFull: [ 65348 ]\n}, {\n    code: 65317,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65349,\n    foldFull: [ 65349 ]\n}, {\n    code: 65318,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65350,\n    foldFull: [ 65350 ]\n}, {\n    code: 65319,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65351,\n    foldFull: [ 65351 ]\n}, {\n    code: 65320,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65352,\n    foldFull: [ 65352 ]\n}, {\n    code: 65321,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65353,\n    foldFull: [ 65353 ]\n}, {\n    code: 65322,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65354,\n    foldFull: [ 65354 ]\n}, {\n    code: 65323,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65355,\n    foldFull: [ 65355 ]\n}, {\n    code: 65324,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65356,\n    foldFull: [ 65356 ]\n}, {\n    code: 65325,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65357,\n    foldFull: [ 65357 ]\n}, {\n    code: 65326,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65358,\n    foldFull: [ 65358 ]\n}, {\n    code: 65327,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65359,\n    foldFull: [ 65359 ]\n}, {\n    code: 65328,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65360,\n    foldFull: [ 65360 ]\n}, {\n    code: 65329,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65361,\n    foldFull: [ 65361 ]\n}, {\n    code: 65330,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65362,\n    foldFull: [ 65362 ]\n}, {\n    code: 65331,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65363,\n    foldFull: [ 65363 ]\n}, {\n    code: 65332,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65364,\n    foldFull: [ 65364 ]\n}, {\n    code: 65333,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65365,\n    foldFull: [ 65365 ]\n}, {\n    code: 65334,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65366,\n    foldFull: [ 65366 ]\n}, {\n    code: 65335,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65367,\n    foldFull: [ 65367 ]\n}, {\n    code: 65336,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65368,\n    foldFull: [ 65368 ]\n}, {\n    code: 65337,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65369,\n    foldFull: [ 65369 ]\n}, {\n    code: 65338,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 65370,\n    foldFull: [ 65370 ]\n}, {\n    code: 66560,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66600,\n    foldFull: [ 66600 ]\n}, {\n    code: 66561,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66601,\n    foldFull: [ 66601 ]\n}, {\n    code: 66562,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66602,\n    foldFull: [ 66602 ]\n}, {\n    code: 66563,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66603,\n    foldFull: [ 66603 ]\n}, {\n    code: 66564,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66604,\n    foldFull: [ 66604 ]\n}, {\n    code: 66565,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66605,\n    foldFull: [ 66605 ]\n}, {\n    code: 66566,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66606,\n    foldFull: [ 66606 ]\n}, {\n    code: 66567,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66607,\n    foldFull: [ 66607 ]\n}, {\n    code: 66568,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66608,\n    foldFull: [ 66608 ]\n}, {\n    code: 66569,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66609,\n    foldFull: [ 66609 ]\n}, {\n    code: 66570,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66610,\n    foldFull: [ 66610 ]\n}, {\n    code: 66571,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66611,\n    foldFull: [ 66611 ]\n}, {\n    code: 66572,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66612,\n    foldFull: [ 66612 ]\n}, {\n    code: 66573,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66613,\n    foldFull: [ 66613 ]\n}, {\n    code: 66574,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66614,\n    foldFull: [ 66614 ]\n}, {\n    code: 66575,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66615,\n    foldFull: [ 66615 ]\n}, {\n    code: 66576,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66616,\n    foldFull: [ 66616 ]\n}, {\n    code: 66577,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66617,\n    foldFull: [ 66617 ]\n}, {\n    code: 66578,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66618,\n    foldFull: [ 66618 ]\n}, {\n    code: 66579,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66619,\n    foldFull: [ 66619 ]\n}, {\n    code: 66580,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66620,\n    foldFull: [ 66620 ]\n}, {\n    code: 66581,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66621,\n    foldFull: [ 66621 ]\n}, {\n    code: 66582,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66622,\n    foldFull: [ 66622 ]\n}, {\n    code: 66583,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66623,\n    foldFull: [ 66623 ]\n}, {\n    code: 66584,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66624,\n    foldFull: [ 66624 ]\n}, {\n    code: 66585,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66625,\n    foldFull: [ 66625 ]\n}, {\n    code: 66586,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66626,\n    foldFull: [ 66626 ]\n}, {\n    code: 66587,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66627,\n    foldFull: [ 66627 ]\n}, {\n    code: 66588,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66628,\n    foldFull: [ 66628 ]\n}, {\n    code: 66589,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66629,\n    foldFull: [ 66629 ]\n}, {\n    code: 66590,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66630,\n    foldFull: [ 66630 ]\n}, {\n    code: 66591,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66631,\n    foldFull: [ 66631 ]\n}, {\n    code: 66592,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66632,\n    foldFull: [ 66632 ]\n}, {\n    code: 66593,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66633,\n    foldFull: [ 66633 ]\n}, {\n    code: 66594,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66634,\n    foldFull: [ 66634 ]\n}, {\n    code: 66595,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66635,\n    foldFull: [ 66635 ]\n}, {\n    code: 66596,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66636,\n    foldFull: [ 66636 ]\n}, {\n    code: 66597,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66637,\n    foldFull: [ 66637 ]\n}, {\n    code: 66598,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66638,\n    foldFull: [ 66638 ]\n}, {\n    code: 66599,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66639,\n    foldFull: [ 66639 ]\n}, {\n    code: 66736,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66776,\n    foldFull: [ 66776 ]\n}, {\n    code: 66737,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66777,\n    foldFull: [ 66777 ]\n}, {\n    code: 66738,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66778,\n    foldFull: [ 66778 ]\n}, {\n    code: 66739,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66779,\n    foldFull: [ 66779 ]\n}, {\n    code: 66740,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66780,\n    foldFull: [ 66780 ]\n}, {\n    code: 66741,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66781,\n    foldFull: [ 66781 ]\n}, {\n    code: 66742,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66782,\n    foldFull: [ 66782 ]\n}, {\n    code: 66743,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66783,\n    foldFull: [ 66783 ]\n}, {\n    code: 66744,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66784,\n    foldFull: [ 66784 ]\n}, {\n    code: 66745,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66785,\n    foldFull: [ 66785 ]\n}, {\n    code: 66746,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66786,\n    foldFull: [ 66786 ]\n}, {\n    code: 66747,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66787,\n    foldFull: [ 66787 ]\n}, {\n    code: 66748,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66788,\n    foldFull: [ 66788 ]\n}, {\n    code: 66749,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66789,\n    foldFull: [ 66789 ]\n}, {\n    code: 66750,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66790,\n    foldFull: [ 66790 ]\n}, {\n    code: 66751,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66791,\n    foldFull: [ 66791 ]\n}, {\n    code: 66752,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66792,\n    foldFull: [ 66792 ]\n}, {\n    code: 66753,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66793,\n    foldFull: [ 66793 ]\n}, {\n    code: 66754,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66794,\n    foldFull: [ 66794 ]\n}, {\n    code: 66755,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66795,\n    foldFull: [ 66795 ]\n}, {\n    code: 66756,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66796,\n    foldFull: [ 66796 ]\n}, {\n    code: 66757,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66797,\n    foldFull: [ 66797 ]\n}, {\n    code: 66758,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66798,\n    foldFull: [ 66798 ]\n}, {\n    code: 66759,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66799,\n    foldFull: [ 66799 ]\n}, {\n    code: 66760,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66800,\n    foldFull: [ 66800 ]\n}, {\n    code: 66761,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66801,\n    foldFull: [ 66801 ]\n}, {\n    code: 66762,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66802,\n    foldFull: [ 66802 ]\n}, {\n    code: 66763,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66803,\n    foldFull: [ 66803 ]\n}, {\n    code: 66764,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66804,\n    foldFull: [ 66804 ]\n}, {\n    code: 66765,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66805,\n    foldFull: [ 66805 ]\n}, {\n    code: 66766,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66806,\n    foldFull: [ 66806 ]\n}, {\n    code: 66767,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66807,\n    foldFull: [ 66807 ]\n}, {\n    code: 66768,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66808,\n    foldFull: [ 66808 ]\n}, {\n    code: 66769,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66809,\n    foldFull: [ 66809 ]\n}, {\n    code: 66770,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66810,\n    foldFull: [ 66810 ]\n}, {\n    code: 66771,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 66811,\n    foldFull: [ 66811 ]\n}, {\n    code: 68736,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68800,\n    foldFull: [ 68800 ]\n}, {\n    code: 68737,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68801,\n    foldFull: [ 68801 ]\n}, {\n    code: 68738,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68802,\n    foldFull: [ 68802 ]\n}, {\n    code: 68739,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68803,\n    foldFull: [ 68803 ]\n}, {\n    code: 68740,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68804,\n    foldFull: [ 68804 ]\n}, {\n    code: 68741,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68805,\n    foldFull: [ 68805 ]\n}, {\n    code: 68742,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68806,\n    foldFull: [ 68806 ]\n}, {\n    code: 68743,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68807,\n    foldFull: [ 68807 ]\n}, {\n    code: 68744,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68808,\n    foldFull: [ 68808 ]\n}, {\n    code: 68745,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68809,\n    foldFull: [ 68809 ]\n}, {\n    code: 68746,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68810,\n    foldFull: [ 68810 ]\n}, {\n    code: 68747,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68811,\n    foldFull: [ 68811 ]\n}, {\n    code: 68748,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68812,\n    foldFull: [ 68812 ]\n}, {\n    code: 68749,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68813,\n    foldFull: [ 68813 ]\n}, {\n    code: 68750,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68814,\n    foldFull: [ 68814 ]\n}, {\n    code: 68751,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68815,\n    foldFull: [ 68815 ]\n}, {\n    code: 68752,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68816,\n    foldFull: [ 68816 ]\n}, {\n    code: 68753,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68817,\n    foldFull: [ 68817 ]\n}, {\n    code: 68754,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68818,\n    foldFull: [ 68818 ]\n}, {\n    code: 68755,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68819,\n    foldFull: [ 68819 ]\n}, {\n    code: 68756,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68820,\n    foldFull: [ 68820 ]\n}, {\n    code: 68757,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68821,\n    foldFull: [ 68821 ]\n}, {\n    code: 68758,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68822,\n    foldFull: [ 68822 ]\n}, {\n    code: 68759,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68823,\n    foldFull: [ 68823 ]\n}, {\n    code: 68760,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68824,\n    foldFull: [ 68824 ]\n}, {\n    code: 68761,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68825,\n    foldFull: [ 68825 ]\n}, {\n    code: 68762,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68826,\n    foldFull: [ 68826 ]\n}, {\n    code: 68763,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68827,\n    foldFull: [ 68827 ]\n}, {\n    code: 68764,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68828,\n    foldFull: [ 68828 ]\n}, {\n    code: 68765,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68829,\n    foldFull: [ 68829 ]\n}, {\n    code: 68766,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68830,\n    foldFull: [ 68830 ]\n}, {\n    code: 68767,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68831,\n    foldFull: [ 68831 ]\n}, {\n    code: 68768,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68832,\n    foldFull: [ 68832 ]\n}, {\n    code: 68769,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68833,\n    foldFull: [ 68833 ]\n}, {\n    code: 68770,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68834,\n    foldFull: [ 68834 ]\n}, {\n    code: 68771,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68835,\n    foldFull: [ 68835 ]\n}, {\n    code: 68772,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68836,\n    foldFull: [ 68836 ]\n}, {\n    code: 68773,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68837,\n    foldFull: [ 68837 ]\n}, {\n    code: 68774,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68838,\n    foldFull: [ 68838 ]\n}, {\n    code: 68775,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68839,\n    foldFull: [ 68839 ]\n}, {\n    code: 68776,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68840,\n    foldFull: [ 68840 ]\n}, {\n    code: 68777,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68841,\n    foldFull: [ 68841 ]\n}, {\n    code: 68778,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68842,\n    foldFull: [ 68842 ]\n}, {\n    code: 68779,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68843,\n    foldFull: [ 68843 ]\n}, {\n    code: 68780,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68844,\n    foldFull: [ 68844 ]\n}, {\n    code: 68781,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68845,\n    foldFull: [ 68845 ]\n}, {\n    code: 68782,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68846,\n    foldFull: [ 68846 ]\n}, {\n    code: 68783,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68847,\n    foldFull: [ 68847 ]\n}, {\n    code: 68784,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68848,\n    foldFull: [ 68848 ]\n}, {\n    code: 68785,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68849,\n    foldFull: [ 68849 ]\n}, {\n    code: 68786,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 68850,\n    foldFull: [ 68850 ]\n}, {\n    code: 71840,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71872,\n    foldFull: [ 71872 ]\n}, {\n    code: 71841,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71873,\n    foldFull: [ 71873 ]\n}, {\n    code: 71842,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71874,\n    foldFull: [ 71874 ]\n}, {\n    code: 71843,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71875,\n    foldFull: [ 71875 ]\n}, {\n    code: 71844,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71876,\n    foldFull: [ 71876 ]\n}, {\n    code: 71845,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71877,\n    foldFull: [ 71877 ]\n}, {\n    code: 71846,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71878,\n    foldFull: [ 71878 ]\n}, {\n    code: 71847,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71879,\n    foldFull: [ 71879 ]\n}, {\n    code: 71848,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71880,\n    foldFull: [ 71880 ]\n}, {\n    code: 71849,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71881,\n    foldFull: [ 71881 ]\n}, {\n    code: 71850,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71882,\n    foldFull: [ 71882 ]\n}, {\n    code: 71851,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71883,\n    foldFull: [ 71883 ]\n}, {\n    code: 71852,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71884,\n    foldFull: [ 71884 ]\n}, {\n    code: 71853,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71885,\n    foldFull: [ 71885 ]\n}, {\n    code: 71854,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71886,\n    foldFull: [ 71886 ]\n}, {\n    code: 71855,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71887,\n    foldFull: [ 71887 ]\n}, {\n    code: 71856,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71888,\n    foldFull: [ 71888 ]\n}, {\n    code: 71857,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71889,\n    foldFull: [ 71889 ]\n}, {\n    code: 71858,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71890,\n    foldFull: [ 71890 ]\n}, {\n    code: 71859,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71891,\n    foldFull: [ 71891 ]\n}, {\n    code: 71860,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71892,\n    foldFull: [ 71892 ]\n}, {\n    code: 71861,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71893,\n    foldFull: [ 71893 ]\n}, {\n    code: 71862,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71894,\n    foldFull: [ 71894 ]\n}, {\n    code: 71863,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71895,\n    foldFull: [ 71895 ]\n}, {\n    code: 71864,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71896,\n    foldFull: [ 71896 ]\n}, {\n    code: 71865,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71897,\n    foldFull: [ 71897 ]\n}, {\n    code: 71866,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71898,\n    foldFull: [ 71898 ]\n}, {\n    code: 71867,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71899,\n    foldFull: [ 71899 ]\n}, {\n    code: 71868,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71900,\n    foldFull: [ 71900 ]\n}, {\n    code: 71869,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71901,\n    foldFull: [ 71901 ]\n}, {\n    code: 71870,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71902,\n    foldFull: [ 71902 ]\n}, {\n    code: 71871,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 71903,\n    foldFull: [ 71903 ]\n}, {\n    code: 93760,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93792,\n    foldFull: [ 93792 ]\n}, {\n    code: 93761,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93793,\n    foldFull: [ 93793 ]\n}, {\n    code: 93762,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93794,\n    foldFull: [ 93794 ]\n}, {\n    code: 93763,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93795,\n    foldFull: [ 93795 ]\n}, {\n    code: 93764,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93796,\n    foldFull: [ 93796 ]\n}, {\n    code: 93765,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93797,\n    foldFull: [ 93797 ]\n}, {\n    code: 93766,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93798,\n    foldFull: [ 93798 ]\n}, {\n    code: 93767,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93799,\n    foldFull: [ 93799 ]\n}, {\n    code: 93768,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93800,\n    foldFull: [ 93800 ]\n}, {\n    code: 93769,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93801,\n    foldFull: [ 93801 ]\n}, {\n    code: 93770,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93802,\n    foldFull: [ 93802 ]\n}, {\n    code: 93771,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93803,\n    foldFull: [ 93803 ]\n}, {\n    code: 93772,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93804,\n    foldFull: [ 93804 ]\n}, {\n    code: 93773,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93805,\n    foldFull: [ 93805 ]\n}, {\n    code: 93774,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93806,\n    foldFull: [ 93806 ]\n}, {\n    code: 93775,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93807,\n    foldFull: [ 93807 ]\n}, {\n    code: 93776,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93808,\n    foldFull: [ 93808 ]\n}, {\n    code: 93777,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93809,\n    foldFull: [ 93809 ]\n}, {\n    code: 93778,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93810,\n    foldFull: [ 93810 ]\n}, {\n    code: 93779,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93811,\n    foldFull: [ 93811 ]\n}, {\n    code: 93780,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93812,\n    foldFull: [ 93812 ]\n}, {\n    code: 93781,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93813,\n    foldFull: [ 93813 ]\n}, {\n    code: 93782,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93814,\n    foldFull: [ 93814 ]\n}, {\n    code: 93783,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93815,\n    foldFull: [ 93815 ]\n}, {\n    code: 93784,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93816,\n    foldFull: [ 93816 ]\n}, {\n    code: 93785,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93817,\n    foldFull: [ 93817 ]\n}, {\n    code: 93786,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93818,\n    foldFull: [ 93818 ]\n}, {\n    code: 93787,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93819,\n    foldFull: [ 93819 ]\n}, {\n    code: 93788,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93820,\n    foldFull: [ 93820 ]\n}, {\n    code: 93789,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93821,\n    foldFull: [ 93821 ]\n}, {\n    code: 93790,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93822,\n    foldFull: [ 93822 ]\n}, {\n    code: 93791,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 93823,\n    foldFull: [ 93823 ]\n}, {\n    code: 125184,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125218,\n    foldFull: [ 125218 ]\n}, {\n    code: 125185,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125219,\n    foldFull: [ 125219 ]\n}, {\n    code: 125186,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125220,\n    foldFull: [ 125220 ]\n}, {\n    code: 125187,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125221,\n    foldFull: [ 125221 ]\n}, {\n    code: 125188,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125222,\n    foldFull: [ 125222 ]\n}, {\n    code: 125189,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125223,\n    foldFull: [ 125223 ]\n}, {\n    code: 125190,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125224,\n    foldFull: [ 125224 ]\n}, {\n    code: 125191,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125225,\n    foldFull: [ 125225 ]\n}, {\n    code: 125192,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125226,\n    foldFull: [ 125226 ]\n}, {\n    code: 125193,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125227,\n    foldFull: [ 125227 ]\n}, {\n    code: 125194,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125228,\n    foldFull: [ 125228 ]\n}, {\n    code: 125195,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125229,\n    foldFull: [ 125229 ]\n}, {\n    code: 125196,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125230,\n    foldFull: [ 125230 ]\n}, {\n    code: 125197,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125231,\n    foldFull: [ 125231 ]\n}, {\n    code: 125198,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125232,\n    foldFull: [ 125232 ]\n}, {\n    code: 125199,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125233,\n    foldFull: [ 125233 ]\n}, {\n    code: 125200,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125234,\n    foldFull: [ 125234 ]\n}, {\n    code: 125201,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125235,\n    foldFull: [ 125235 ]\n}, {\n    code: 125202,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125236,\n    foldFull: [ 125236 ]\n}, {\n    code: 125203,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125237,\n    foldFull: [ 125237 ]\n}, {\n    code: 125204,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125238,\n    foldFull: [ 125238 ]\n}, {\n    code: 125205,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125239,\n    foldFull: [ 125239 ]\n}, {\n    code: 125206,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125240,\n    foldFull: [ 125240 ]\n}, {\n    code: 125207,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125241,\n    foldFull: [ 125241 ]\n}, {\n    code: 125208,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125242,\n    foldFull: [ 125242 ]\n}, {\n    code: 125209,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125243,\n    foldFull: [ 125243 ]\n}, {\n    code: 125210,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125244,\n    foldFull: [ 125244 ]\n}, {\n    code: 125211,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125245,\n    foldFull: [ 125245 ]\n}, {\n    code: 125212,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125246,\n    foldFull: [ 125246 ]\n}, {\n    code: 125213,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125247,\n    foldFull: [ 125247 ]\n}, {\n    code: 125214,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125248,\n    foldFull: [ 125248 ]\n}, {\n    code: 125215,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125249,\n    foldFull: [ 125249 ]\n}, {\n    code: 125216,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125250,\n    foldFull: [ 125250 ]\n}, {\n    code: 125217,\n    lower: [  ],\n    title: [  ],\n    upper: [  ],\n    fold: 125251,\n    foldFull: [ 125251 ]\n} ];\nvar recCmp = function (v) {\n    return function (v1) {\n        return Data_Ord.compare(Data_Ord.ordInt)(v.code)(v1.code);\n    };\n};\nvar findRule = function (code) {\n    var v = Data_CodePoint_Unicode_Internal.bsearch(zeroRec(code))(rules)(Data_Array.length(rules))(recCmp);\n    if (v instanceof Data_Maybe.Nothing) {\n        return zeroRec(code);\n    };\n    if (v instanceof Data_Maybe.Just) {\n        return v.value0;\n    };\n    throw new Error(\"Failed pattern match at Data.CodePoint.Unicode.Internal.Casing (line 1628, column 17 - line 1630, column 14): \" + [ v.constructor.name ]);\n};\nvar fold = function (code) {\n    var folded = (findRule(code)).fold;\n    var $9 = folded === 0;\n    if ($9) {\n        return Data_CodePoint_Unicode_Internal.uTowlower(code);\n    };\n    return folded;\n};\nvar foldFull = function (code) {\n    var folded = (findRule(code)).foldFull;\n    var $10 = Data_Array[\"null\"](folded);\n    if ($10) {\n        return [ Data_CodePoint_Unicode_Internal.uTowlower(code) ];\n    };\n    return folded;\n};\nvar lower = function (code) {\n    var lowered = (findRule(code)).lower;\n    var $11 = Data_Array[\"null\"](lowered);\n    if ($11) {\n        return [ Data_CodePoint_Unicode_Internal.uTowlower(code) ];\n    };\n    return lowered;\n};\nvar title = function (code) {\n    var titled = (findRule(code)).title;\n    var $12 = Data_Array[\"null\"](titled);\n    if ($12) {\n        return [ Data_CodePoint_Unicode_Internal.uTowtitle(code) ];\n    };\n    return titled;\n};\nvar upper = function (code) {\n    var uppered = (findRule(code)).upper;\n    var $13 = Data_Array[\"null\"](uppered);\n    if ($13) {\n        return [ Data_CodePoint_Unicode_Internal.uTowupper(code) ];\n    };\n    return uppered;\n};\nmodule.exports = {\n    rules: rules,\n    zeroRec: zeroRec,\n    recCmp: recCmp,\n    findRule: findRule,\n    fold: fold,\n    foldFull: foldFull,\n    lower: lower,\n    title: title,\n    upper: upper\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode/Internal/Casing.purs?");

/***/ }),

/***/ "./.spago/unicode/v5.0.0/src/Data/String/Unicode.purs":
/*!************************************************************!*\
  !*** ./.spago/unicode/v5.0.0/src/Data/String/Unicode.purs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Data_CodePoint_Unicode = __webpack_require__(/*! ./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs */ \"./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_String_CodePoints = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs\");\nvar convertFull = function (f) {\n    var $0 = Control_Bind.bindFlipped(Control_Bind.bindArray)(f);\n    return function ($1) {\n        return Data_String_CodePoints.fromCodePointArray($0(Data_String_CodePoints.toCodePointArray($1)));\n    };\n};\nvar toLower = convertFull(Data_CodePoint_Unicode.toLower);\nvar toUpper = convertFull(Data_CodePoint_Unicode.toUpper);\nvar convert = function (f) {\n    var $2 = Data_Functor.map(Data_Functor.functorArray)(f);\n    return function ($3) {\n        return Data_String_CodePoints.fromCodePointArray($2(Data_String_CodePoints.toCodePointArray($3)));\n    };\n};\nvar toLowerSimple = convert(Data_CodePoint_Unicode.toLowerSimple);\nvar toUpperSimple = convert(Data_CodePoint_Unicode.toUpperSimple);\nvar caseFoldSimple = convert(Data_CodePoint_Unicode.caseFoldSimple);\nvar caseFold = convertFull(Data_CodePoint_Unicode.caseFold);\nvar caselessMatch = function (s1) {\n    return function (s2) {\n        return caseFold(s1) === caseFold(s2);\n    };\n};\nmodule.exports = {\n    toUpper: toUpper,\n    toLower: toLower,\n    caseFold: caseFold,\n    caselessMatch: caselessMatch,\n    toUpperSimple: toUpperSimple,\n    toLowerSimple: toLowerSimple,\n    caseFoldSimple: caseFoldSimple\n};\n\n\n\n//# sourceURL=webpack://bundle/./.spago/unicode/v5.0.0/src/Data/String/Unicode.purs?");

/***/ }),

/***/ "./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs":
/*!************************************************************!*\
  !*** ./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.js */ \"./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.js\");\nmodule.exports = {\n    unsafeCoerce: $foreign.unsafeCoerce\n};\n\n\n//# sourceURL=webpack://bundle/./.spago/unsafe-coerce/v5.0.0/src/Unsafe/Coerce.purs?");

/***/ }),

/***/ "./src/CP.purs":
/*!*********************!*\
  !*** ./src/CP.purs ***!
  \*********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Generic_Rep = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs */ \"./.spago/prelude/v5.0.1/src/Data/Generic/Rep.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Show_Generic = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show/Generic.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show/Generic.purs\");\nvar Data_String_Common = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Common.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Common.purs\");\nvar Effect = __webpack_require__(/*! ./.spago/effect/v3.0.0/src/Effect.purs */ \"./.spago/effect/v3.0.0/src/Effect.purs\");\nvar Effect_Console = __webpack_require__(/*! ./.spago/console/v5.0.0/src/Effect/Console.purs */ \"./.spago/console/v5.0.0/src/Effect/Console.purs\");\nvar Effect_Exception = __webpack_require__(/*! ./.spago/exceptions/v5.0.0/src/Effect/Exception.purs */ \"./.spago/exceptions/v5.0.0/src/Effect/Exception.purs\");\nvar Language_CP_Context = __webpack_require__(/*! ./src/CP/Context.purs */ \"./src/CP/Context.purs\");\nvar Language_CP_Desugar = __webpack_require__(/*! ./src/CP/Desugar.purs */ \"./src/CP/Desugar.purs\");\nvar Language_CP_Parser = __webpack_require__(/*! ./src/CP/Parser.purs */ \"./src/CP/Parser.purs\");\nvar Language_CP_Semantics_HOAS = __webpack_require__(/*! ./src/CP/Semantics/HOAS.purs */ \"./src/CP/Semantics/HOAS.purs\");\nvar Language_CP_Semantics_NaturalClosure = __webpack_require__(/*! ./src/CP/Semantics/NaturalClosure.purs */ \"./src/CP/Semantics/NaturalClosure.purs\");\nvar Language_CP_Semantics_NaturalSubst = __webpack_require__(/*! ./src/CP/Semantics/NaturalSubst.purs */ \"./src/CP/Semantics/NaturalSubst.purs\");\nvar Language_CP_Semantics_StepTrace = __webpack_require__(/*! ./src/CP/Semantics/StepTrace.purs */ \"./src/CP/Semantics/StepTrace.purs\");\nvar Language_CP_Semantics_Subst = __webpack_require__(/*! ./src/CP/Semantics/Subst.purs */ \"./src/CP/Semantics/Subst.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar Language_CP_Syntax_Source = __webpack_require__(/*! ./src/CP/Syntax/Source.purs */ \"./src/CP/Syntax/Source.purs\");\nvar Language_CP_Typing = __webpack_require__(/*! ./src/CP/Typing.purs */ \"./src/CP/Typing.purs\");\nvar Text_Parsing_Parser = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs\");\nvar Text_Parsing_Parser_String = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs\");\nvar SmallStep = (function () {\n    function SmallStep() {\n\n    };\n    SmallStep.value = new SmallStep();\n    return SmallStep;\n})();\nvar StepTrace = (function () {\n    function StepTrace() {\n\n    };\n    StepTrace.value = new StepTrace();\n    return StepTrace;\n})();\nvar BigStep = (function () {\n    function BigStep() {\n\n    };\n    BigStep.value = new BigStep();\n    return BigStep;\n})();\nvar HOAS = (function () {\n    function HOAS() {\n\n    };\n    HOAS.value = new HOAS();\n    return HOAS;\n})();\nvar Closure = (function () {\n    function Closure() {\n\n    };\n    Closure.value = new Closure();\n    return Closure;\n})();\nvar genericMode_ = {\n    to: function (x) {\n        if (x instanceof Data_Generic_Rep.Inl) {\n            return SmallStep.value;\n        };\n        if (x instanceof Data_Generic_Rep.Inr && x.value0 instanceof Data_Generic_Rep.Inl) {\n            return StepTrace.value;\n        };\n        if (x instanceof Data_Generic_Rep.Inr && (x.value0 instanceof Data_Generic_Rep.Inr && x.value0.value0 instanceof Data_Generic_Rep.Inl)) {\n            return BigStep.value;\n        };\n        if (x instanceof Data_Generic_Rep.Inr && (x.value0 instanceof Data_Generic_Rep.Inr && (x.value0.value0 instanceof Data_Generic_Rep.Inr && x.value0.value0.value0 instanceof Data_Generic_Rep.Inl))) {\n            return HOAS.value;\n        };\n        if (x instanceof Data_Generic_Rep.Inr && (x.value0 instanceof Data_Generic_Rep.Inr && (x.value0.value0 instanceof Data_Generic_Rep.Inr && x.value0.value0.value0 instanceof Data_Generic_Rep.Inr))) {\n            return Closure.value;\n        };\n        throw new Error(\"Failed pattern match at Language.CP (line 31, column 1 - line 31, column 31): \" + [ x.constructor.name ]);\n    },\n    from: function (x) {\n        if (x instanceof SmallStep) {\n            return new Data_Generic_Rep.Inl(Data_Generic_Rep.NoArguments.value);\n        };\n        if (x instanceof StepTrace) {\n            return new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inl(Data_Generic_Rep.NoArguments.value));\n        };\n        if (x instanceof BigStep) {\n            return new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inl(Data_Generic_Rep.NoArguments.value)));\n        };\n        if (x instanceof HOAS) {\n            return new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inl(Data_Generic_Rep.NoArguments.value))));\n        };\n        if (x instanceof Closure) {\n            return new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inr(Data_Generic_Rep.NoArguments.value))));\n        };\n        throw new Error(\"Failed pattern match at Language.CP (line 31, column 1 - line 31, column 31): \" + [ x.constructor.name ]);\n    }\n};\nvar showMode = {\n    show: Data_Show_Generic.genericShow(genericMode_)(Data_Show_Generic.genericShowSum(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsNoArguments)({\n        reflectSymbol: function () {\n            return \"SmallStep\";\n        }\n    }))(Data_Show_Generic.genericShowSum(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsNoArguments)({\n        reflectSymbol: function () {\n            return \"StepTrace\";\n        }\n    }))(Data_Show_Generic.genericShowSum(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsNoArguments)({\n        reflectSymbol: function () {\n            return \"BigStep\";\n        }\n    }))(Data_Show_Generic.genericShowSum(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsNoArguments)({\n        reflectSymbol: function () {\n            return \"HOAS\";\n        }\n    }))(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsNoArguments)({\n        reflectSymbol: function () {\n            return \"Closure\";\n        }\n    }))))))\n};\nvar showPosition = function (v) {\n    return Data_Show.show(Data_Show.showInt)(v.line) + (\":\" + Data_Show.show(Data_Show.showInt)(v.column));\n};\nvar showTypeError = function (v) {\n    if (v.value1 instanceof Language_CP_Context.UnknownPos) {\n        return v.value0;\n    };\n    if (v.value1 instanceof Language_CP_Context.Pos) {\n        return showPosition(v.value1.value0) + (\": \" + (v.value0 + (\"\\x0ain the expression: \" + (function () {\n            if (v.value1.value2) {\n                return Language_CP_Syntax_Source.showDoc;\n            };\n            return Data_Show.show(Language_CP_Syntax_Source.showTm);\n        })()(v.value1.value1))));\n    };\n    throw new Error(\"Failed pattern match at Language.CP (line 75, column 1 - line 75, column 37): \" + [ v.constructor.name ]);\n};\nvar showParseError = function (v) {\n    return function (source) {\n        var seek = function (line) {\n            return Data_Array.index(Data_String_Common.split(\"\\x0a\")(source))(line - 1 | 0);\n        };\n        var rep = function (n) {\n            return function (s) {\n                if (n <= 0) {\n                    return \"\";\n                };\n                if (Data_Boolean.otherwise) {\n                    return s + rep(n - 1 | 0)(s);\n                };\n                throw new Error(\"Failed pattern match at Language.CP (line 71, column 5 - line 71, column 35): \" + [ n.constructor.name, s.constructor.name ]);\n            };\n        };\n        return showPosition(v.value1) + (\": parse error:\\x0a\" + (function () {\n            var v1 = seek(v.value1.line);\n            if (v1 instanceof Data_Maybe.Just) {\n                return v1.value0 + (\"\\x0a\" + (rep(v.value1.column - 1 | 0)(\" \") + \"^\"));\n            };\n            if (v1 instanceof Data_Maybe.Nothing) {\n                return \"\";\n            };\n            throw new Error(\"Failed pattern match at Language.CP (line 66, column 3 - line 67, column 31): \" + [ v1.constructor.name ]);\n        })());\n    };\n};\nvar parse = function (code) {\n    var v = Text_Parsing_Parser.runParser(code)(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Language_CP_Parser.whiteSpace)(Language_CP_Parser.program))(Text_Parsing_Parser_String.eof(Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)));\n    if (v instanceof Data_Either.Left) {\n        return Effect_Exception[\"throw\"](showParseError(v.value0)(code));\n    };\n    if (v instanceof Data_Either.Right) {\n        return Control_Applicative.pure(Effect.applicativeEffect)(v.value0);\n    };\n    throw new Error(\"Failed pattern match at Language.CP (line 35, column 14 - line 37, column 20): \" + [ v.constructor.name ]);\n};\nvar interpret = function (code) {\n    return function (mode) {\n        var v = Text_Parsing_Parser.runParser(code)(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Language_CP_Parser.whiteSpace)(Language_CP_Parser.program))(Text_Parsing_Parser_String.eof(Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)));\n        if (v instanceof Data_Either.Left) {\n            return Effect_Exception[\"throw\"](showParseError(v.value0)(code));\n        };\n        if (v instanceof Data_Either.Right) {\n            var e$prime = Language_CP_Desugar.desugar(v.value0);\n            var v1 = Language_CP_Context.runTyping(Language_CP_Typing.infer(e$prime));\n            if (v1 instanceof Data_Either.Left) {\n                return Effect_Exception[\"throw\"](showTypeError(v1.value0));\n            };\n            if (v1 instanceof Data_Either.Right) {\n                if (mode instanceof SmallStep) {\n                    return Control_Applicative.pure(Effect.applicativeEffect)(Data_Show.show(Language_CP_Syntax_Core.showTm)(Language_CP_Semantics_Subst[\"eval\"](v1.value0.value0)));\n                };\n                if (mode instanceof StepTrace) {\n                    var v2 = Language_CP_Semantics_StepTrace[\"eval\"](v1.value0.value0);\n                    return Control_Applicative.pure(Effect.applicativeEffect)(Data_Show.show(Language_CP_Syntax_Source.showTm)(v.value0) + (\"\\x0a\\u21e3 Desugar\\x0a\" + (Data_Show.show(Language_CP_Syntax_Source.showTm)(e$prime) + (\"\\x0a\\u21af Elaborate\\x0a\" + v2.value1(\"\")))));\n                };\n                if (mode instanceof BigStep) {\n                    return Control_Applicative.pure(Effect.applicativeEffect)(Data_Show.show(Language_CP_Syntax_Core.showTm)(Language_CP_Semantics_NaturalSubst[\"eval\"](v1.value0.value0)));\n                };\n                if (mode instanceof HOAS) {\n                    return Control_Applicative.pure(Effect.applicativeEffect)(Data_Show.show(Language_CP_Syntax_Core.showTm)(Language_CP_Semantics_HOAS[\"eval\"](v1.value0.value0)));\n                };\n                if (mode instanceof Closure) {\n                    return Control_Applicative.pure(Effect.applicativeEffect)(Data_Show.show(Language_CP_Syntax_Core.showTm)(Language_CP_Semantics_NaturalClosure[\"eval\"](v1.value0.value0)));\n                };\n                throw new Error(\"Failed pattern match at Language.CP (line 51, column 28 - line 57, column 48): \" + [ mode.constructor.name ]);\n            };\n            throw new Error(\"Failed pattern match at Language.CP (line 49, column 36 - line 57, column 48): \" + [ v1.constructor.name ]);\n        };\n        throw new Error(\"Failed pattern match at Language.CP (line 47, column 23 - line 57, column 48): \" + [ v.constructor.name ]);\n    };\n};\nvar execute = function (e) {\n    return function __do() {\n        Effect_Console.log(Data_Show.show(Language_CP_Syntax_Source.showTm)(e))();\n        var e$prime = Language_CP_Desugar.desugar(e);\n        var v = Language_CP_Context.runTyping(Language_CP_Typing.infer(e$prime));\n        if (v instanceof Data_Either.Left) {\n            return Effect_Exception[\"throw\"](showTypeError(v.value0))();\n        };\n        if (v instanceof Data_Either.Right) {\n            return Data_Show.show(Language_CP_Syntax_Core.showTm)(Language_CP_Semantics_NaturalSubst[\"eval\"](v.value0.value0));\n        };\n        throw new Error(\"Failed pattern match at Language.CP (line 42, column 17 - line 44, column 72): \" + [ v.constructor.name ]);\n    };\n};\nmodule.exports = {\n    SmallStep: SmallStep,\n    StepTrace: StepTrace,\n    BigStep: BigStep,\n    HOAS: HOAS,\n    Closure: Closure,\n    parse: parse,\n    execute: execute,\n    interpret: interpret,\n    showPosition: showPosition,\n    showParseError: showParseError,\n    showTypeError: showTypeError,\n    genericMode_: genericMode_,\n    showMode: showMode\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP.purs?");

/***/ }),

/***/ "./src/CP/Context.purs":
/*!*****************************!*\
  !*** ./src/CP/Context.purs ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Monad_Error_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Error/Class.purs\");\nvar Control_Monad_Except = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Except.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Except.purs\");\nvar Control_Monad_Except_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs\");\nvar Control_Monad_Reader_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs\");\nvar Control_Monad_Reader_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Map_Internal = __webpack_require__(/*! ./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs */ \"./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar UnknownPos = (function () {\n    function UnknownPos() {\n\n    };\n    UnknownPos.value = new UnknownPos();\n    return UnknownPos;\n})();\nvar Pos = (function () {\n    function Pos(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    Pos.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new Pos(value0, value1, value2);\n            };\n        };\n    };\n    return Pos;\n})();\nvar $$TypeError = (function () {\n    function $$TypeError(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    $$TypeError.create = function (value0) {\n        return function (value1) {\n            return new $$TypeError(value0, value1);\n        };\n    };\n    return $$TypeError;\n})();\nvar runTyping = function (m) {\n    return Control_Monad_Except.runExcept(Control_Monad_Reader_Trans.runReaderT(m)({\n        tmBindEnv: Data_Map_Internal.empty,\n        tyBindEnv: Data_Map_Internal.empty,\n        tyAliasEnv: Data_Map_Internal.empty,\n        sortEnv: Data_Map_Internal.empty,\n        pos: UnknownPos.value\n    }));\n};\nvar lookupTyBind = function (name) {\n    return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Data_Map_Internal.lookup(Data_Ord.ordString)(name))(Control_Monad_Reader_Class.asks(Control_Monad_Reader_Trans.monadAskReaderT(Control_Monad_Except_Trans.monadExceptT(Data_Identity.monadIdentity)))(function (v) {\n        return v.tyBindEnv;\n    }));\n};\nvar lookupTyAlias = function (name) {\n    return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Data_Map_Internal.lookup(Data_Ord.ordString)(name))(Control_Monad_Reader_Class.asks(Control_Monad_Reader_Trans.monadAskReaderT(Control_Monad_Except_Trans.monadExceptT(Data_Identity.monadIdentity)))(function (v) {\n        return v.tyAliasEnv;\n    }));\n};\nvar lookupSort = function (name) {\n    return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Data_Map_Internal.lookup(Data_Ord.ordString)(name))(Control_Monad_Reader_Class.asks(Control_Monad_Reader_Trans.monadAskReaderT(Control_Monad_Except_Trans.monadExceptT(Data_Identity.monadIdentity)))(function (v) {\n        return v.sortEnv;\n    }));\n};\nvar localPos = function (f) {\n    return Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(Control_Monad_Except_Trans.monadExceptT(Data_Identity.monadIdentity)))(function (r) {\n        var $11 = {};\n        for (var $12 in r) {\n            if ({}.hasOwnProperty.call(r, $12)) {\n                $11[$12] = r[$12];\n            };\n        };\n        $11.pos = f(r.pos);\n        return $11;\n    });\n};\nvar askPos = Control_Monad_Reader_Class.asks(Control_Monad_Reader_Trans.monadAskReaderT(Control_Monad_Except_Trans.monadExceptT(Data_Identity.monadIdentity)))(function (v) {\n    return v.pos;\n});\nvar throwTypeError = function (msg) {\n    return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))($$TypeError.create(msg))(askPos))(Control_Monad_Error_Class.throwError(Control_Monad_Reader_Trans.monadThrowReaderT(Control_Monad_Except_Trans.monadThrowExceptT(Data_Identity.monadIdentity))));\n};\nvar lookupTmBind = function (name) {\n    return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Control_Monad_Reader_Class.asks(Control_Monad_Reader_Trans.monadAskReaderT(Control_Monad_Except_Trans.monadExceptT(Data_Identity.monadIdentity)))(function (v) {\n        return v.tmBindEnv;\n    }))(function (env) {\n        var v = Data_Map_Internal.lookup(Data_Ord.ordString)(name)(env);\n        if (v instanceof Data_Maybe.Just) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(v.value0);\n        };\n        if (v instanceof Data_Maybe.Nothing) {\n            return throwTypeError(\"term variable \" + (Data_Show.show(Data_Show.showString)(name) + \" is undefined\"));\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Context (line 38, column 3 - line 40, column 81): \" + [ v.constructor.name ]);\n    });\n};\nvar addToEnv = function (map) {\n    return function (name) {\n        return function (ty) {\n            var $16 = name === \"_\";\n            if ($16) {\n                return Control_Category.identity(Control_Category.categoryFn);\n            };\n            return Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(Control_Monad_Except_Trans.monadExceptT(Data_Identity.monadIdentity)))(map(function (env) {\n                return Data_Map_Internal.insert(Data_Ord.ordString)(name)(ty)(env);\n            }));\n        };\n    };\n};\nvar addTyAlias = addToEnv(function (f) {\n    return function (r) {\n        return {\n            tmBindEnv: r.tmBindEnv,\n            tyBindEnv: r.tyBindEnv,\n            tyAliasEnv: f(r.tyAliasEnv),\n            sortEnv: r.sortEnv,\n            pos: r.pos\n        };\n    };\n});\nvar addTyBind = addToEnv(function (f) {\n    return function (r) {\n        return {\n            tmBindEnv: r.tmBindEnv,\n            tyBindEnv: f(r.tyBindEnv),\n            tyAliasEnv: r.tyAliasEnv,\n            sortEnv: r.sortEnv,\n            pos: r.pos\n        };\n    };\n});\nvar addTmBind = addToEnv(function (f) {\n    return function (r) {\n        return {\n            tmBindEnv: f(r.tmBindEnv),\n            tyBindEnv: r.tyBindEnv,\n            tyAliasEnv: r.tyAliasEnv,\n            sortEnv: r.sortEnv,\n            pos: r.pos\n        };\n    };\n});\nvar addSort = addToEnv(function (f) {\n    return function (r) {\n        return {\n            tmBindEnv: r.tmBindEnv,\n            tyBindEnv: r.tyBindEnv,\n            tyAliasEnv: r.tyAliasEnv,\n            sortEnv: f(r.sortEnv),\n            pos: r.pos\n        };\n    };\n});\nmodule.exports = {\n    UnknownPos: UnknownPos,\n    Pos: Pos,\n    runTyping: runTyping,\n    lookupTmBind: lookupTmBind,\n    lookupTyBind: lookupTyBind,\n    lookupTyAlias: lookupTyAlias,\n    lookupSort: lookupSort,\n    addToEnv: addToEnv,\n    addTmBind: addTmBind,\n    addTyBind: addTyBind,\n    addTyAlias: addTyAlias,\n    addSort: addSort,\n    localPos: localPos,\n    askPos: askPos,\n    \"TypeError\": $$TypeError,\n    throwTypeError: throwTypeError\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Context.purs?");

/***/ }),

/***/ "./src/CP/Desugar.purs":
/*!*****************************!*\
  !*** ./src/CP/Desugar.purs ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_List = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List.purs */ \"./.spago/lists/v6.0.1/src/Data/List.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Language_CP_Syntax_Source = __webpack_require__(/*! ./src/CP/Syntax/Source.purs */ \"./src/CP/Syntax/Source.purs\");\nvar Language_CP_Util = __webpack_require__(/*! ./src/CP/Util.purs */ \"./src/CP/Util.purs\");\nvar desugarMethodPattern = function (v) {\n    return desugar(new Language_CP_Syntax_Source.TmTrait(v.value0, Data_Maybe.Nothing.value, Data_Maybe.Nothing.value, new Language_CP_Syntax_Source.TmRcd(Data_List.singleton(new Language_CP_Syntax_Source.RcdField(false, v.value1, v.value2, new Data_Either.Left(v.value3))))));\n};\nvar desugar = function (v) {\n    if (v instanceof Language_CP_Syntax_Source.TmAbs) {\n        return Data_Foldable.foldr(Data_List_Types.foldableList)(function (x) {\n            return function (s) {\n                return new Language_CP_Syntax_Source.TmAbs(Data_List.singleton(x), s);\n            };\n        })(desugar(v.value1))(v.value0);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmTAbs) {\n        var disjointness = function (t) {\n            return new Data_Maybe.Just(Data_Maybe.fromMaybe(Language_CP_Syntax_Source.TyTop.value)(t));\n        };\n        return Data_Foldable.foldr(Data_List_Types.foldableList)(function (x) {\n            return function (s) {\n                return new Language_CP_Syntax_Source.TmTAbs(Data_List.singleton(Data_Bifunctor.rmap(Data_Bifunctor.bifunctorTuple)(disjointness)(x)), s);\n            };\n        })(desugar(v.value1))(v.value0);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmRcd && v.value0 instanceof Data_List_Types.Nil) {\n        return Language_CP_Syntax_Source.TmUnit.value;\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmRcd) {\n        var desugarField = function (v1) {\n            if (v1 instanceof Language_CP_Syntax_Source.RcdField) {\n                return Language_CP_Syntax_Source.RcdField.create(v1.value0)(v1.value1)(Data_List_Types.Nil.value)(Data_Either.Left.create(desugar(Language_CP_Syntax_Source.TmAbs.create(v1.value2)((function () {\n                    if (v1.value3 instanceof Data_Either.Left) {\n                        return v1.value3.value0;\n                    };\n                    if (v1.value3 instanceof Data_Either.Right) {\n                        return desugarMethodPattern(v1.value3.value0);\n                    };\n                    throw new Error(\"Failed pattern match at Language.CP.Desugar (line 27, column 53 - line 29, column 46): \" + [ v1.value3.constructor.name ]);\n                })()))));\n            };\n            if (v1 instanceof Language_CP_Syntax_Source.DefaultPattern) {\n                return v1;\n            };\n            throw new Error(\"Failed pattern match at Language.CP.Desugar (line 24, column 5 - line 24, column 41): \" + [ v1.constructor.name ]);\n        };\n        return Language_CP_Util.foldl1(Language_CP_Syntax_Source.TmMerge.create)(Data_Functor.mapFlipped(Data_List_Types.functorList)(v.value0)(function (x) {\n            return new Language_CP_Syntax_Source.TmRcd(Data_List.singleton(desugarField(x)));\n        }));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmTrait) {\n        var v1 = Data_Maybe.fromMaybe(new Data_Tuple.Tuple(\"#self\", Data_Maybe.Nothing.value))(v.value0);\n        return new Language_CP_Syntax_Source.TmTrait(new Data_Maybe.Just(v1), new Data_Maybe.Just(Data_Maybe.fromMaybe(Language_CP_Syntax_Source.TyTop.value)(v.value1)), Data_Functor.map(Data_Maybe.functorMaybe)(desugar)(v.value2), new Language_CP_Syntax_Source.TmOpen(new Language_CP_Syntax_Source.TmVar(v1.value0), desugar(v.value3)));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmDef) {\n        return desugar((function () {\n            if (v.value3 instanceof Data_Maybe.Just) {\n                return new Language_CP_Syntax_Source.TmLetrec(v.value0, v.value1, v.value2, v.value3.value0, v.value4, v.value5);\n            };\n            if (v.value3 instanceof Data_Maybe.Nothing) {\n                return new Language_CP_Syntax_Source.TmLet(v.value0, v.value1, v.value2, v.value4, v.value5);\n            };\n            throw new Error(\"Failed pattern match at Language.CP.Desugar (line 38, column 3 - line 39, column 55): \" + [ v.value3.constructor.name ]);\n        })());\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmLet) {\n        return new Language_CP_Syntax_Source.TmLet(v.value0, Data_List_Types.Nil.value, Data_List_Types.Nil.value, desugar(new Language_CP_Syntax_Source.TmTAbs(v.value1, new Language_CP_Syntax_Source.TmAbs(v.value2, v.value3))), desugar(v.value4));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmLetrec) {\n        var tyOf = function (v1) {\n            if (v1 instanceof Language_CP_Syntax_Source.TmParam && v1.value1 instanceof Data_Maybe.Just) {\n                return v1.value1.value0;\n            };\n            if (v1 instanceof Language_CP_Syntax_Source.TmParam && v1.value1 instanceof Data_Maybe.Nothing) {\n                return Language_CP_Syntax_Source.TyBot.value;\n            };\n            if (v1 instanceof Language_CP_Syntax_Source.WildCard) {\n                return Language_CP_Syntax_Source.TyBot.value;\n            };\n            throw new Error(\"Failed pattern match at Language.CP.Desugar (line 45, column 16 - line 47, column 45): \" + [ v1.constructor.name ]);\n        };\n        var t$prime = new Language_CP_Syntax_Source.TyForall(v.value1, Data_Foldable.foldr(Data_List_Types.foldableList)(Language_CP_Syntax_Source.TyArrow.create)(v.value3)(Data_Functor.map(Data_List_Types.functorList)(tyOf)(v.value2)));\n        return new Language_CP_Syntax_Source.TmLetrec(v.value0, Data_List_Types.Nil.value, Data_List_Types.Nil.value, t$prime, desugar(new Language_CP_Syntax_Source.TmTAbs(v.value1, new Language_CP_Syntax_Source.TmAbs(v.value2, v.value4))), desugar(v.value5));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmUnary) {\n        return new Language_CP_Syntax_Source.TmUnary(v.value0, desugar(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmBinary) {\n        return new Language_CP_Syntax_Source.TmBinary(v.value0, desugar(v.value1), desugar(v.value2));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmIf) {\n        return new Language_CP_Syntax_Source.TmIf(desugar(v.value0), desugar(v.value1), desugar(v.value2));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmApp) {\n        return new Language_CP_Syntax_Source.TmApp(desugar(v.value0), desugar(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmAnno) {\n        return new Language_CP_Syntax_Source.TmAnno(desugar(v.value0), v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmMerge) {\n        return new Language_CP_Syntax_Source.TmMerge(desugar(v.value0), desugar(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmPrj) {\n        return new Language_CP_Syntax_Source.TmPrj(desugar(v.value0), v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmTApp) {\n        return new Language_CP_Syntax_Source.TmTApp(desugar(v.value0), v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmOpen) {\n        return new Language_CP_Syntax_Source.TmOpen(desugar(v.value0), desugar(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmUpdate) {\n        return new Language_CP_Syntax_Source.TmUpdate(desugar(v.value0), Data_Functor.map(Data_List_Types.functorList)(Data_Bifunctor.rmap(Data_Bifunctor.bifunctorTuple)(desugar))(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmNew) {\n        return new Language_CP_Syntax_Source.TmNew(desugar(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmForward) {\n        return new Language_CP_Syntax_Source.TmForward(desugar(v.value0), desugar(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmExclude) {\n        return new Language_CP_Syntax_Source.TmExclude(desugar(v.value0), v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmFold) {\n        return new Language_CP_Syntax_Source.TmFold(v.value0, desugar(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmUnfold) {\n        return new Language_CP_Syntax_Source.TmUnfold(v.value0, desugar(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmToString) {\n        return new Language_CP_Syntax_Source.TmToString(desugar(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmArray) {\n        return new Language_CP_Syntax_Source.TmArray(Data_Functor.map(Data_Functor.functorArray)(desugar)(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmDoc) {\n        return new Language_CP_Syntax_Source.TmDoc(desugar(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmPos) {\n        return new Language_CP_Syntax_Source.TmPos(v.value0, desugar(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmType) {\n        return new Language_CP_Syntax_Source.TmType(v.value0, v.value1, v.value2, v.value3, desugar(v.value4));\n    };\n    return v;\n};\nmodule.exports = {\n    desugar: desugar,\n    desugarMethodPattern: desugarMethodPattern\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Desugar.purs?");

/***/ }),

/***/ "./src/CP/Parser.purs":
/*!****************************!*\
  !*** ./src/CP/Parser.purs ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Lazy = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Lazy.purs */ \"./.spago/control/v5.0.0/src/Control/Lazy.purs\");\nvar Control_Monad_State_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/State/Class.purs\");\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_Array_NonEmpty = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array/NonEmpty.purs\");\nvar Data_CodePoint_Unicode = __webpack_require__(/*! ./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs */ \"./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_List = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List.purs */ \"./.spago/lists/v6.0.1/src/Data/List.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_String_CodePoints = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs\");\nvar Data_String_CodeUnits = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodeUnits.purs\");\nvar Data_String_Regex = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Regex.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Regex.purs\");\nvar Data_String_Regex_Flags = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Regex/Flags.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Regex/Flags.purs\");\nvar Data_String_Regex_Unsafe = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/Regex/Unsafe.purs */ \"./.spago/strings/v5.0.0/src/Data/String/Regex/Unsafe.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unfoldable = __webpack_require__(/*! ./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs */ \"./.spago/unfoldable/v5.0.0/src/Data/Unfoldable.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Language_CP_Syntax_Common = __webpack_require__(/*! ./src/CP/Syntax/Common.purs */ \"./src/CP/Syntax/Common.purs\");\nvar Language_CP_Syntax_Source = __webpack_require__(/*! ./src/CP/Syntax/Source.purs */ \"./src/CP/Syntax/Source.purs\");\nvar Language_CP_Util = __webpack_require__(/*! ./src/CP/Util.purs */ \"./src/CP/Util.purs\");\nvar Text_Parsing_Parser = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser.purs\");\nvar Text_Parsing_Parser_Combinators = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Combinators.purs\");\nvar Text_Parsing_Parser_Expr = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Expr.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Expr.purs\");\nvar Text_Parsing_Parser_Language = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Language.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Language.purs\");\nvar Text_Parsing_Parser_Pos = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Pos.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Pos.purs\");\nvar Text_Parsing_Parser_String = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/String.purs\");\nvar Text_Parsing_Parser_Token = __webpack_require__(/*! ./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Token.purs */ \"./.spago/parsing/v6.0.2/src/Text/Parsing/Parser/Token.purs\");\nvar stringMatching = function (re) {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Control_Monad_State_Class.gets(Text_Parsing_Parser.monadStateParserT(Data_Identity.monadIdentity))(function (v) {\n        return v.value0;\n    }))(function (input) {\n        var v = Data_String_Regex.match(re)(input);\n        if (v instanceof Data_Maybe.Just) {\n            var v1 = Data_Array_NonEmpty.head(v.value0);\n            if (v1 instanceof Data_Maybe.Just) {\n                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Control_Monad_State_Class.modify_(Text_Parsing_Parser.monadStateParserT(Data_Identity.monadIdentity))(function (v2) {\n                    return new Text_Parsing_Parser.ParseState(Data_String_Regex.replace(re)(\"\")(input), Text_Parsing_Parser_Pos.updatePosString(v2.value1)(v1.value0), true);\n                }))(function () {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(v1.value0);\n                });\n            };\n            if (v1 instanceof Data_Maybe.Nothing) {\n                return Text_Parsing_Parser.fail(Data_Identity.monadIdentity)(\"Failed to match \" + Data_Show.show(Data_String_Regex.showRegex)(re));\n            };\n            throw new Error(\"Failed pattern match at Language.CP.Parser (line 492, column 17 - line 497, column 54): \" + [ v1.constructor.name ]);\n        };\n        if (v instanceof Data_Maybe.Nothing) {\n            return Text_Parsing_Parser.fail(Data_Identity.monadIdentity)(\"Failed to match \" + Data_Show.show(Data_String_Regex.showRegex)(re));\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Parser (line 491, column 3 - line 498, column 52): \" + [ v.constructor.name ]);\n    });\n};\nvar lower = Text_Parsing_Parser_String.satisfy(Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(function ($32) {\n    return Data_CodePoint_Unicode.isLower(Data_String_CodePoints.codePointFromChar($32));\n});\nvar langDef = (function () {\n    var v = Text_Parsing_Parser_Token.unGenLanguageDef(Text_Parsing_Parser_Language.haskellStyle);\n    return {\n        commentStart: v.commentStart,\n        commentEnd: v.commentEnd,\n        commentLine: v.commentLine,\n        nestedComments: v.nestedComments,\n        identStart: v.identStart,\n        identLetter: v.identLetter,\n        opStart: v.opStart,\n        opLetter: v.opLetter,\n        reservedNames: [ \"true\", \"false\", \"undefined\", \"if\", \"then\", \"else\", \"toString\", \"trait\", \"implements\", \"inherits\", \"override\", \"new\", \"fold\", \"unfold\", \"let\", \"letrec\", \"open\", \"in\", \"type\", \"forall\", \"mu\", \"Int\", \"Double\", \"String\", \"Bool\", \"Top\", \"Bot\", \"Trait\" ],\n        reservedOpNames: v.reservedOpNames,\n        caseSensitive: v.caseSensitive\n    };\n})();\nvar lang = Text_Parsing_Parser_Token.makeTokenParser(Data_Identity.monadIdentity)(langDef);\nvar lexeme = lang.lexeme;\nvar naturalOrFloat = lang.naturalOrFloat;\nvar operator = lang.operator;\nvar parens = lang.parens;\nvar reserved = lang.reserved;\nvar reservedOp = lang.reservedOp;\nvar operators = [ [ new Text_Parsing_Parser_Expr.Prefix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"-\"))(Language_CP_Syntax_Source.TmUnary.create(Language_CP_Syntax_Common.Neg.value))), new Text_Parsing_Parser_Expr.Prefix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"!\"))(Language_CP_Syntax_Source.TmUnary.create(Language_CP_Syntax_Common.Not.value))), new Text_Parsing_Parser_Expr.Prefix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"#\"))(Language_CP_Syntax_Source.TmUnary.create(Language_CP_Syntax_Common.Len.value))) ], [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"!!\"))(Language_CP_Syntax_Source.TmBinary.create(Language_CP_Syntax_Common.Index.value)), Text_Parsing_Parser_Expr.AssocLeft.value) ], [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"*\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Arith(Language_CP_Syntax_Common.Mul.value))), Text_Parsing_Parser_Expr.AssocLeft.value), new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"/\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Arith(Language_CP_Syntax_Common.Div.value))), Text_Parsing_Parser_Expr.AssocLeft.value), new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"%\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Arith(Language_CP_Syntax_Common.Mod.value))), Text_Parsing_Parser_Expr.AssocLeft.value) ], [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"+\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Arith(Language_CP_Syntax_Common.Add.value))), Text_Parsing_Parser_Expr.AssocLeft.value), new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"-\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Arith(Language_CP_Syntax_Common.Sub.value))), Text_Parsing_Parser_Expr.AssocLeft.value) ], [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"++\"))(Language_CP_Syntax_Source.TmBinary.create(Language_CP_Syntax_Common.Append.value)), Text_Parsing_Parser_Expr.AssocLeft.value) ], [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"==\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Comp(Language_CP_Syntax_Common.Eql.value))), Text_Parsing_Parser_Expr.AssocNone.value), new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"!=\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Comp(Language_CP_Syntax_Common.Neq.value))), Text_Parsing_Parser_Expr.AssocNone.value), new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"<\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Comp(Language_CP_Syntax_Common.Lt.value))), Text_Parsing_Parser_Expr.AssocNone.value), new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"<=\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Comp(Language_CP_Syntax_Common.Le.value))), Text_Parsing_Parser_Expr.AssocNone.value), new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\">\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Comp(Language_CP_Syntax_Common.Gt.value))), Text_Parsing_Parser_Expr.AssocNone.value), new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\">=\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Comp(Language_CP_Syntax_Common.Ge.value))), Text_Parsing_Parser_Expr.AssocNone.value) ], [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"&&\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Logic(Language_CP_Syntax_Common.And.value))), Text_Parsing_Parser_Expr.AssocRight.value) ], [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"||\"))(Language_CP_Syntax_Source.TmBinary.create(new Language_CP_Syntax_Common.Logic(Language_CP_Syntax_Common.Or.value))), Text_Parsing_Parser_Expr.AssocRight.value) ], [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"^\"))(Language_CP_Syntax_Source.TmForward.create), Text_Parsing_Parser_Expr.AssocLeft.value) ], [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\",\"))(Language_CP_Syntax_Source.TmMerge.create), Text_Parsing_Parser_Expr.AssocLeft.value) ] ];\nvar toperators = [ [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"&\"))(Language_CP_Syntax_Source.TyAnd.create), Text_Parsing_Parser_Expr.AssocLeft.value) ], [ new Text_Parsing_Parser_Expr.Infix(Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reservedOp(\"->\"))(Language_CP_Syntax_Source.TyArrow.create), Text_Parsing_Parser_Expr.AssocRight.value) ] ];\nvar stringLiteral = lang.stringLiteral;\nvar symbol = function (s) {\n    return Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(lang.symbol(s))(Data_Unit.unit);\n};\nvar parensWithoutTrailingSpace = Text_Parsing_Parser_Combinators.between(Data_Identity.monadIdentity)(symbol(\"(\"))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\")\"));\nvar sepEndBySemi = function (p) {\n    return Text_Parsing_Parser_Combinators.sepEndBy(Data_Identity.monadIdentity)(p)(symbol(\";\"));\n};\nvar underscore = lang.symbol(\"_\");\nvar whiteSpace = lang.whiteSpace;\nvar identifier = lang.identifier;\nvar recordUpdate = function (p) {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators[\"try\"](Data_Identity.monadIdentity)(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(p)(symbol(\"|\"))))(function (rcd) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(sepEndBySemi(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Tuple.Tuple.create)(identifier))(symbol(\"=\")))(p)))(function (fields) {\n            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmUpdate(rcd, fields));\n        });\n    });\n};\nvar ident = function (identStart) {\n    return lexeme(Text_Parsing_Parser_Combinators[\"try\"](Data_Identity.monadIdentity)((function () {\n        var languageDef = Text_Parsing_Parser_Token.unGenLanguageDef(langDef);\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(identStart)(function (c) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Array.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(languageDef.identLetter))(function (cs) {\n                var word = Data_String_CodeUnits.singleton(c) + Data_String_CodeUnits.fromCharArray(cs);\n                var $19 = !Data_Array.elem(Data_Eq.eqString)(word)(languageDef.reservedNames);\n                if ($19) {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(word);\n                };\n                return Text_Parsing_Parser.fail(Data_Identity.monadIdentity)(\"Unexpected reserved word \" + Data_Show.show(Data_Show.showString)(word));\n            });\n        });\n    })()));\n};\nvar lowerIdentifier = ident(lower);\nvar upperIdentifier = ident(Text_Parsing_Parser_Token.upper(Data_Identity.monadIdentity));\nvar fromIntOrNumber = function (v) {\n    if (v instanceof Data_Either.Left) {\n        return new Language_CP_Syntax_Source.TmInt(v.value0);\n    };\n    if (v instanceof Data_Either.Right) {\n        return new Language_CP_Syntax_Source.TmDouble(v.value0);\n    };\n    throw new Error(\"Failed pattern match at Language.CP.Parser (line 381, column 1 - line 381, column 43): \" + [ v.constructor.name ]);\n};\nvar bracketsWithoutConsumingSpace = Text_Parsing_Parser_Combinators.between(Data_Identity.monadIdentity)(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\"[\"))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\"]\"));\nvar brackets = lang.brackets;\nvar bracesWithoutTrailingSpace = Text_Parsing_Parser_Combinators.between(Data_Identity.monadIdentity)(symbol(\"{\"))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\"}\"));\nvar braces = lang.braces;\nvar angles = lang.angles;\nvar sortTy = function (t) {\n    return angles(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(t)(function (ti) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Maybe.optional(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(symbol(\"=>\"))(t)))(function (to) {\n            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TySort(ti, to));\n        });\n    }));\n};\nvar tyParams = function (us) {\n    var id = (function () {\n        if (us) {\n            return Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(underscore)(upperIdentifier);\n        };\n        return upperIdentifier;\n    })();\n    return Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Tuple.Tuple.create)(id))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Data_Maybe.Nothing.value)))(parens(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Tuple.Tuple.create)(id))(symbol(\"*\")))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Maybe.Just.create)(ty))));\n};\nvar ty = Control_Lazy.fix(Text_Parsing_Parser.lazyParserT)(function (t) {\n    return Text_Parsing_Parser_Expr.buildExprParser(Data_Identity.monadIdentity)(toperators)(bty(t));\n});\nvar traitTy = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"Trait\"))(function () {\n    return angles(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Maybe.optional(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators[\"try\"](Data_Identity.monadIdentity)(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(ty)(symbol(\"=>\")))))(function (ti) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(ty)(function (to) {\n            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TyTrait(ti, to));\n        });\n    }));\n});\nvar recordTy = braces(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Language_CP_Syntax_Source.TyRcd.create)(sepEndBySemi(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(identifier)(function (l) {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Maybe.isJust)(Data_Maybe.optional(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(symbol(\"?\"))))(function (opt) {\n        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\":\"))(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(ty)(function (t) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.RcdTy(l, t, opt));\n            });\n        });\n    });\n}))));\nvar muTy = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"mu\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(upperIdentifier)(function (a) {\n        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\".\"))(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(ty)(function (t) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TyRec(a, t));\n            });\n        });\n    });\n});\nvar forallTy = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"forall\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.some(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(tyParams(true)))(function (xs) {\n        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\".\"))(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(ty)(function (t) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TyForall(xs, t));\n            });\n        });\n    });\n});\nvar bty = function (t) {\n    return Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Foldable.foldl(Data_List_Types.foldableList)(Language_CP_Syntax_Source.TyApp.create))(aty(t)))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(aty(t))(sortTy(t)))))(forallTy))(traitTy))(muTy);\n};\nvar aty = function (t) {\n    return Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(Data_Identity.monadIdentity)([ Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reserved(\"Int\"))(Language_CP_Syntax_Source.TyInt.value), Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reserved(\"Double\"))(Language_CP_Syntax_Source.TyDouble.value), Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reserved(\"String\"))(Language_CP_Syntax_Source.TyString.value), Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reserved(\"Bool\"))(Language_CP_Syntax_Source.TyBool.value), Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reserved(\"Top\"))(Language_CP_Syntax_Source.TyTop.value), Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reserved(\"Bot\"))(Language_CP_Syntax_Source.TyBot.value), Data_Functor.mapFlipped(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(upperIdentifier)(Language_CP_Syntax_Source.TyVar.create), Data_Functor.mapFlipped(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(brackets(t))(Language_CP_Syntax_Source.TyArray.create), recordTy, parens(t) ]);\n};\nvar selfAnno = Data_Maybe.optional(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(brackets(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Tuple.Tuple.create)(lowerIdentifier))(Data_Maybe.optional(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(symbol(\":\"))(ty)))));\nvar tyDef = function (p) {\n    return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"type\"))(function () {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(upperIdentifier)(function (a) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(angles(upperIdentifier)))(function (sorts) {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(upperIdentifier))(function (parms) {\n                    return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"=\"))(function () {\n                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(ty)(function (t) {\n                            return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\";\"))(function () {\n                                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(p)(function (e) {\n                                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmType(a, sorts, parms, t, e));\n                                });\n                            });\n                        });\n                    });\n                });\n            });\n        });\n    });\n};\nvar unfold = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"unfold\"))(function () {\n    return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"@\"))(function () {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(aty(ty))(function (t) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(dotexpr(expr))(function (e) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmUnfold(t, e));\n            });\n        });\n    });\n});\nvar tyLambdaAbs = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"/\\\\\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.some(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(tyParams(true)))(function (xs) {\n        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\".\"))(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmTAbs(xs, e));\n            });\n        });\n    });\n});\nvar trait = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"trait\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(selfAnno)(function (self) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Maybe.optional(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(reserved(\"implements\"))(ty)))(function (sig) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Maybe.optional(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(reserved(\"inherits\"))(expr)))(function (e1) {\n                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"=>\"))(function () {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e2) {\n                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmTrait(self, sig, e1, e2));\n                    });\n                });\n            });\n        });\n    });\n});\nvar toString = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"toString\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(dotexpr(expr))(function (e) {\n        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmToString(e));\n    });\n});\nvar tmParams = (function () {\n    var id = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(lowerIdentifier)(underscore);\n    var parensNameColonType = parens(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(id)(function (x) {\n        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\":\"))(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(ty)(function (t) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmParam(x, new Data_Maybe.Just(t)));\n            });\n        });\n    }));\n    var defaultField = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(lowerIdentifier)(function (x) {\n        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"=\"))(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Data_Tuple.Tuple(x, e));\n            });\n        });\n    });\n    return Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(Data_Identity.monadIdentity)([ parensNameColonType, Data_Functor.flap(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Language_CP_Syntax_Source.TmParam.create)(id))(Data_Maybe.Nothing.value), Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Language_CP_Syntax_Source.WildCard.create)(braces(Control_Apply.applyFirst(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(sepEndBySemi(defaultField))(symbol(\"..\")))) ]);\n})();\nvar recordLit = function (p) {\n    return Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Language_CP_Syntax_Source.TmRcd.create)(sepEndBySemi(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Maybe.isJust)(Data_Maybe.optional(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(reserved(\"override\"))))(function (o) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(selfAnno)(function (self) {\n            return Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(recordField(p)(o))(methodPattern(p)(o)(self)))(defaultPattern(p)(self));\n        });\n    })));\n};\nvar recordField = function (p) {\n    return function (o) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(identifier)(function (l) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(tmParams))(function (params) {\n                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"=\"))(function () {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(p)(function (e) {\n                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.RcdField(o, l, params, new Data_Either.Left(e)));\n                    });\n                });\n            });\n        });\n    };\n};\nvar opexpr = function (e) {\n    return Text_Parsing_Parser_Expr.buildExprParser(Data_Identity.monadIdentity)(operators)(lexpr(e));\n};\nvar open = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"open\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e1) {\n        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"in\"))(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e2) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmOpen(e1, e2));\n            });\n        });\n    });\n});\nvar $$new = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"new\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(opexpr(expr))(function (e) {\n        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmNew(e));\n    });\n});\nvar methodPattern = function (p) {\n    return function (o) {\n        return function (self) {\n            return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))((function () {\n                var $24 = Data_Maybe.isJust(self);\n                if ($24) {\n                    return symbol(\"@\");\n                };\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Data_Unit.unit);\n            })())(function () {\n                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"(\"))(function () {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(identifier)(function (l) {\n                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(tmParams))(function (params) {\n                            return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\")\"))(function () {\n                                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\".\"))(function () {\n                                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(identifier)(function (l$prime) {\n                                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(tmParams))(function (params$prime) {\n                                            return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"=\"))(function () {\n                                                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(p)(function (e) {\n                                                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.RcdField(o, l, params, new Data_Either.Right(new Language_CP_Syntax_Source.MethodPattern(self, l$prime, params$prime, e))));\n                                                });\n                                            });\n                                        });\n                                    });\n                                });\n                            });\n                        });\n                    });\n                });\n            });\n        };\n    };\n};\nvar lexpr = function (e) {\n    return Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(fexpr(e))(lambdaAbs))(tyLambdaAbs))(trait))($$new))(ifThenElse))(letIn))(letrec))(open))(toString))(fold))(unfold);\n};\nvar letrec = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"letrec\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(lowerIdentifier)(function (x) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Text_Parsing_Parser_Combinators[\"try\"](Data_Identity.monadIdentity)(tyParams(false))))(function (tys) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(tmParams))(function (tms) {\n                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\":\"))(function () {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(ty)(function (t) {\n                        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"=\"))(function () {\n                            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e1) {\n                                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"in\"))(function () {\n                                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e2) {\n                                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmLetrec(x, tys, tms, t, e1, e2));\n                                    });\n                                });\n                            });\n                        });\n                    });\n                });\n            });\n        });\n    });\n});\nvar letIn = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"let\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(lowerIdentifier)(function (x) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Text_Parsing_Parser_Combinators[\"try\"](Data_Identity.monadIdentity)(tyParams(false))))(function (tys) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(tmParams))(function (tms) {\n                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"=\"))(function () {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e1) {\n                        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"in\"))(function () {\n                            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e2) {\n                                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmLet(x, tys, tms, e1, e2));\n                            });\n                        });\n                    });\n                });\n            });\n        });\n    });\n});\nvar lambdaAbs = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"\\\\\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.some(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(tmParams))(function (xs) {\n        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"->\"))(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmAbs(xs, e));\n            });\n        });\n    });\n});\nvar ifThenElse = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"if\"))(function () {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e1) {\n        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"then\"))(function () {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e2) {\n                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"else\"))(function () {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e3) {\n                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmIf(e1, e2, e3));\n                    });\n                });\n            });\n        });\n    });\n});\nvar fold = Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(reserved(\"fold\"))(function () {\n    return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"@\"))(function () {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(aty(ty))(function (t) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(dotexpr(expr))(function (e) {\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmFold(t, e));\n            });\n        });\n    });\n});\nvar fexpr = function (e) {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))((function () {\n        var $33 = Data_Tuple.Tuple.create(true);\n        return function ($34) {\n            return $33(Language_CP_Syntax_Source.TmVar.create($34));\n        };\n    })())(upperIdentifier))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Tuple.Tuple.create(false))(dotexpr(e))))(function (v) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.voidRight(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Function.flip(Language_CP_Syntax_Source.TmTApp.create))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\"@\")))(aty(ty)))(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Function.flip(Language_CP_Syntax_Source.TmApp.create))(dotexpr(e)))))(function (args) {\n            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))((function () {\n                if (v.value0) {\n                    return Language_CP_Syntax_Source.TmNew.create;\n                };\n                return Control_Category.identity(Control_Category.categoryFn);\n            })()(Data_Foldable.foldl(Data_List_Types.foldableList)(Data_Function.applyFlipped)(v.value1)(args)));\n        });\n    });\n};\nvar expr = Control_Lazy.fix(Text_Parsing_Parser.lazyParserT)(function (e) {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.position(Data_Identity.monadIdentity))(function (p) {\n        return Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Language_CP_Syntax_Source.TmPos.create(p))(colonexpr(e));\n    });\n});\nvar dotexpr = function (e) {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(aexpr(e))(function (e$prime) {\n        return Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Foldable.foldl(Data_List_Types.foldableList)(Data_Function.applyFlipped)(e$prime))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.voidRight(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Data_Function.flip(Language_CP_Syntax_Source.TmPrj.create))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\".\")))(identifier)));\n    });\n};\nvar document = function (p) {\n    var recordArg = Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Language_CP_Syntax_Source.TmRcd.create)(sepEndBySemi(recordField(p)(false)));\n    var re = Data_String_Regex_Unsafe.unsafeRegex(\"^[^\\\\\\\\\\\\]`]+\")(Data_String_Regex_Flags.noFlags);\n    var newStr = function (s) {\n        return new Language_CP_Syntax_Source.TmNew(new Language_CP_Syntax_Source.TmApp(new Language_CP_Syntax_Source.TmVar(\"Str\"), s));\n    };\n    var plaintext = Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(function ($35) {\n        return newStr(Language_CP_Syntax_Source.TmString.create($35));\n    })(stringMatching(re));\n    var newEndl = new Language_CP_Syntax_Source.TmNew(new Language_CP_Syntax_Source.TmVar(\"Endl\"));\n    var newline = Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\"\\\\\"))(newEndl);\n    var newComp = function (x) {\n        return function (y) {\n            return new Language_CP_Syntax_Source.TmNew(new Language_CP_Syntax_Source.TmApp(new Language_CP_Syntax_Source.TmApp(new Language_CP_Syntax_Source.TmVar(\"Comp\"), x), y));\n        };\n    };\n    var interpolation = Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(function ($36) {\n        return newStr(Language_CP_Syntax_Source.TmToString.create($36));\n    })(parensWithoutTrailingSpace(p));\n    var command = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.position(Data_Identity.monadIdentity))(function (pos) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(identifier)(function (cmd) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(Data_Identity.monadIdentity)([ parensWithoutTrailingSpace(p), bracesWithoutTrailingSpace(recordArg), bracketsWithoutConsumingSpace(document(p)) ])))(function (args) {\n                var f = (function () {\n                    var $29 = Language_CP_Util.isCapitalized(cmd);\n                    if ($29) {\n                        return Language_CP_Syntax_Source.TmNew.create;\n                    };\n                    return Control_Category.identity(Control_Category.categoryFn);\n                })();\n                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.TmPos(pos, f(Data_Foldable.foldl(Data_List_Types.foldableList)(Language_CP_Syntax_Source.TmApp.create)(new Language_CP_Syntax_Source.TmVar(cmd))(args))));\n            });\n        });\n    });\n    var backslash = Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\"\\\\\"))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(command)(interpolation))(newline));\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.position(Data_Identity.monadIdentity))(function (pos) {\n        return Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))((function () {\n            var $37 = Language_CP_Syntax_Source.TmPos.create(pos);\n            return function ($38) {\n                return $37(Language_CP_Syntax_Source.TmDoc.create($38));\n            };\n        })())(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(backslash)(plaintext)))(function (docs) {\n            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))((function () {\n                var $30 = Data_List[\"null\"](docs);\n                if ($30) {\n                    return newStr(new Language_CP_Syntax_Source.TmString(\"\"));\n                };\n                return Language_CP_Util.foldl1(newComp)(docs);\n            })());\n        }));\n    });\n};\nvar defaultPattern = function (p) {\n    return function (self) {\n        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))((function () {\n            var $31 = Data_Maybe.isNothing(self);\n            if ($31) {\n                return symbol(\"_\");\n            };\n            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Data_Unit.unit);\n        })())(function () {\n            return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\".\"))(function () {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(identifier)(function (l) {\n                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(tmParams))(function (params) {\n                        return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"=\"))(function () {\n                            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(p)(function (e) {\n                                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Language_CP_Syntax_Source.DefaultPattern(new Language_CP_Syntax_Source.MethodPattern(self, l, params, e)));\n                            });\n                        });\n                    });\n                });\n            });\n        });\n    };\n};\nvar colonexpr = function (e) {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(opexpr(e))(function (e$prime) {\n        return Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.voidRight(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Language_CP_Syntax_Source.TmAnno.create(e$prime))(symbol(\":\")))(ty))(Control_Apply.apply(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Functor.voidRight(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Language_CP_Syntax_Source.TmExclude.create(e$prime))(symbol(\"\\\\\")))(ty)))(Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(e$prime));\n    });\n};\nvar aexpr = function (e) {\n    return Text_Parsing_Parser_Combinators.choice(Data_Foldable.foldableArray)(Data_Identity.monadIdentity)([ Data_Functor.mapFlipped(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(naturalOrFloat)(fromIntOrNumber), Text_Parsing_Parser_Combinators.between(Data_Identity.monadIdentity)(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\"`\"))(symbol(\"`\"))(document(e)), Data_Functor.mapFlipped(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(stringLiteral)(Language_CP_Syntax_Source.TmString.create), Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reserved(\"true\"))(new Language_CP_Syntax_Source.TmBool(true)), Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reserved(\"false\"))(new Language_CP_Syntax_Source.TmBool(false)), Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(symbol(\"()\"))(Language_CP_Syntax_Source.TmUnit.value), Data_Functor.voidLeft(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(reserved(\"undefined\"))(Language_CP_Syntax_Source.TmUndefined.value), Data_Functor.mapFlipped(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(lowerIdentifier)(Language_CP_Syntax_Source.TmVar.create), Data_Functor.mapFlipped(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(upperIdentifier)(function ($39) {\n        return Language_CP_Syntax_Source.TmNew.create(Language_CP_Syntax_Source.TmVar.create($39));\n    }), Data_Functor.mapFlipped(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_String[\"char\"](Text_Parsing_Parser_String.stringLikeString)(Data_Identity.monadIdentity)(\"$\"))(upperIdentifier))(Language_CP_Syntax_Source.TmVar.create), brackets(Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))((function () {\n        var $40 = Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray);\n        return function ($41) {\n            return Language_CP_Syntax_Source.TmArray.create($40($41));\n        };\n    })())(sepEndBySemi(e))), braces(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(recordUpdate(e))(recordLit(e))), parens(e) ]);\n};\nvar tmDef = function (p) {\n    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators[\"try\"](Data_Identity.monadIdentity)(Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(lowerIdentifier)(function (x) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Text_Parsing_Parser_Combinators[\"try\"](Data_Identity.monadIdentity)(tyParams(false))))(function (tys) {\n            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.many(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(tmParams))(function (tms) {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Maybe.optional(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(symbol(\":\"))(ty)))(function (t) {\n                    return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\"=\"))(function () {\n                        return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(Language_CP_Syntax_Source.TmDef.create(x)(tys)(tms)(t));\n                    });\n                });\n            });\n        });\n    })))(function (def) {\n        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(expr)(function (e1) {\n            return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(symbol(\";\"))(function () {\n                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(p)(function (e2) {\n                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(def(e1)(e2));\n                });\n            });\n        });\n    });\n};\nvar program = Control_Lazy.fix(Text_Parsing_Parser.lazyParserT)(function (p) {\n    return Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(tyDef(p))(tmDef(p)))(expr);\n});\nmodule.exports = {\n    program: program,\n    tyDef: tyDef,\n    tmDef: tmDef,\n    expr: expr,\n    colonexpr: colonexpr,\n    opexpr: opexpr,\n    lexpr: lexpr,\n    fexpr: fexpr,\n    dotexpr: dotexpr,\n    aexpr: aexpr,\n    lambdaAbs: lambdaAbs,\n    tyLambdaAbs: tyLambdaAbs,\n    trait: trait,\n    \"new\": $$new,\n    ifThenElse: ifThenElse,\n    letIn: letIn,\n    letrec: letrec,\n    open: open,\n    toString: toString,\n    fold: fold,\n    unfold: unfold,\n    document: document,\n    parensWithoutTrailingSpace: parensWithoutTrailingSpace,\n    bracesWithoutTrailingSpace: bracesWithoutTrailingSpace,\n    bracketsWithoutConsumingSpace: bracketsWithoutConsumingSpace,\n    recordUpdate: recordUpdate,\n    recordLit: recordLit,\n    recordField: recordField,\n    methodPattern: methodPattern,\n    defaultPattern: defaultPattern,\n    operators: operators,\n    ty: ty,\n    bty: bty,\n    aty: aty,\n    sortTy: sortTy,\n    forallTy: forallTy,\n    traitTy: traitTy,\n    muTy: muTy,\n    recordTy: recordTy,\n    toperators: toperators,\n    fromIntOrNumber: fromIntOrNumber,\n    tyParams: tyParams,\n    tmParams: tmParams,\n    selfAnno: selfAnno,\n    langDef: langDef,\n    lang: lang,\n    identifier: identifier,\n    reserved: reserved,\n    operator: operator,\n    reservedOp: reservedOp,\n    stringLiteral: stringLiteral,\n    naturalOrFloat: naturalOrFloat,\n    symbol: symbol,\n    underscore: underscore,\n    lexeme: lexeme,\n    whiteSpace: whiteSpace,\n    parens: parens,\n    braces: braces,\n    angles: angles,\n    brackets: brackets,\n    sepEndBySemi: sepEndBySemi,\n    lower: lower,\n    ident: ident,\n    lowerIdentifier: lowerIdentifier,\n    upperIdentifier: upperIdentifier,\n    stringMatching: stringMatching\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Parser.purs?");

/***/ }),

/***/ "./src/CP/Semantics/Closure.purs":
/*!***************************************!*\
  !*** ./src/CP/Semantics/Closure.purs ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_Maybe_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Maybe/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Maybe/Trans.purs\");\nvar Control_Monad_Reader = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader.purs\");\nvar Control_Monad_Reader_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs\");\nvar Control_Monad_Reader_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs\");\nvar Control_Monad_Trans_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Trans/Class.purs\");\nvar Control_Plus = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Plus.purs */ \"./.spago/control/v5.0.0/src/Control/Plus.purs\");\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Map_Internal = __webpack_require__(/*! ./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs */ \"./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Language_CP_Semantics_Common = __webpack_require__(/*! ./src/CP/Semantics/Common.purs */ \"./src/CP/Semantics/Common.purs\");\nvar Language_CP_Subtyping = __webpack_require__(/*! ./src/CP/Subtyping.purs */ \"./src/CP/Subtyping.purs\");\nvar Language_CP_Syntax_Common = __webpack_require__(/*! ./src/CP/Syntax/Common.purs */ \"./src/CP/Syntax/Common.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar Language_CP_Util = __webpack_require__(/*! ./src/CP/Util.purs */ \"./src/CP/Util.purs\");\nvar Partial_Unsafe = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.purs\");\nvar unop$prime = function (v) {\n    return function (v1) {\n        if (v instanceof Language_CP_Syntax_Common.Len && (v1 instanceof Language_CP_Syntax_Core.TmClosure && v1.value1 instanceof Language_CP_Syntax_Core.TmArray)) {\n            return new Language_CP_Syntax_Core.TmInt(Data_Array.length(v1.value1.value1));\n        };\n        return Language_CP_Semantics_Common.unop(v)(v1);\n    };\n};\nvar selectLabel = function (v) {\n    return function (v1) {\n        if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n            var v2 = selectLabel(v.value1)(v1);\n            var v3 = selectLabel(v.value0)(v1);\n            if (v3 instanceof Language_CP_Syntax_Core.TmUndefined && v2 instanceof Language_CP_Syntax_Core.TmUndefined) {\n                return Language_CP_Syntax_Core.TmUndefined.value;\n            };\n            if (v3 instanceof Language_CP_Syntax_Core.TmUndefined) {\n                return v2;\n            };\n            if (v2 instanceof Language_CP_Syntax_Core.TmUndefined) {\n                return v3;\n            };\n            return new Language_CP_Syntax_Core.TmMerge(v3, v2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmClosure && (v.value1 instanceof Language_CP_Syntax_Core.TmRcd && v1 === v.value1.value0)) {\n            return new Language_CP_Syntax_Core.TmClosure(v.value0, new Language_CP_Syntax_Core.TmAnno(v.value1.value2, v.value1.value1));\n        };\n        return Language_CP_Syntax_Core.TmUndefined.value;\n    };\n};\nvar paraApp = function (v) {\n    return function (v1) {\n        if (v instanceof Language_CP_Syntax_Core.TmUnit) {\n            return Language_CP_Syntax_Core.TmUnit.value;\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmClosure && (v.value1 instanceof Language_CP_Syntax_Core.TmAbs && (!v.value1.value4 && v1 instanceof Language_CP_Semantics_Common.TmArg))) {\n            return new Language_CP_Syntax_Core.TmClosure(Data_Map_Internal.insert(Data_Ord.ordString)(v.value1.value0)(new Language_CP_Syntax_Core.TmBind(v1.value0))(v.value0), v.value1.value1);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmClosure && (v.value1 instanceof Language_CP_Syntax_Core.TmAbs && (v.value1.value4 && v1 instanceof Language_CP_Semantics_Common.TmArg))) {\n            return new Language_CP_Syntax_Core.TmClosure(Data_Map_Internal.insert(Data_Ord.ordString)(v.value1.value0)(new Language_CP_Syntax_Core.TmBind(v1.value0))(v.value0), new Language_CP_Syntax_Core.TmAnno(v.value1.value1, v.value1.value3));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmClosure && (v.value1 instanceof Language_CP_Syntax_Core.TmAbs && v1 instanceof Language_CP_Semantics_Common.TmAnnoArg)) {\n            return new Language_CP_Syntax_Core.TmClosure(Data_Map_Internal.insert(Data_Ord.ordString)(v.value1.value0)(new Language_CP_Syntax_Core.TmBind(new Language_CP_Syntax_Core.TmAnno(v1.value0, v.value1.value2)))(v.value0), new Language_CP_Syntax_Core.TmAnno(v.value1.value1, v.value1.value3));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmClosure && (v.value1 instanceof Language_CP_Syntax_Core.TmTAbs && v1 instanceof Language_CP_Semantics_Common.TyArg)) {\n            return new Language_CP_Syntax_Core.TmClosure(Data_Map_Internal.insert(Data_Ord.ordString)(v.value1.value0)(new Language_CP_Syntax_Core.TyBind(new Data_Maybe.Just(v1.value0)))(v.value0), v.value1.value2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n            return new Language_CP_Syntax_Core.TmMerge(paraApp(v.value0)(v1), paraApp(v.value1)(v1));\n        };\n        return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Closure.paraApp: \" + (\"impossible application \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(v) + (\" \\u2022 \" + Data_Show.show(Language_CP_Semantics_Common.showArg)(v1)))));\n    };\n};\nvar isValue = function (v) {\n    if (v instanceof Language_CP_Syntax_Core.TmInt) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmDouble) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmString) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmBool) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmUnit) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmUndefined) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n        return isValue(v.value0) && isValue(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmFold) {\n        return isValue(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmClosure && v.value1 instanceof Language_CP_Syntax_Core.TmRcd) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmClosure && v.value1 instanceof Language_CP_Syntax_Core.TmAbs) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmClosure && v.value1 instanceof Language_CP_Syntax_Core.TmTAbs) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmClosure && v.value1 instanceof Language_CP_Syntax_Core.TmArray) {\n        return true;\n    };\n    return false;\n};\nvar expand = function (dictMonad) {\n    return function (v) {\n        if (v instanceof Language_CP_Syntax_Core.TyArrow) {\n            return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT((dictMonad.Bind1()).Apply0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TyArrow.create)(expand(dictMonad)(v.value0)))(expand(dictMonad)(v.value1)))(v.value2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyAnd) {\n            return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT((dictMonad.Bind1()).Apply0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TyAnd.create)(expand(dictMonad)(v.value0)))(expand(dictMonad)(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyRcd) {\n            return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TyRcd.create(v.value0))(expand(dictMonad)(v.value1)))(v.value2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyVar) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(dictMonad.Bind1()))(Control_Monad_Reader_Class.ask(Control_Monad_Reader_Trans.monadAskReaderT(dictMonad)))(function (env) {\n                var v1 = Data_Map_Internal.lookup(Data_Ord.ordString)(v.value0)(env);\n                if (v1 instanceof Data_Maybe.Just && (v1.value0 instanceof Language_CP_Syntax_Core.TyBind && v1.value0.value0 instanceof Data_Maybe.Nothing)) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(new Language_CP_Syntax_Core.TyVar(v.value0));\n                };\n                if (v1 instanceof Data_Maybe.Just && (v1.value0 instanceof Language_CP_Syntax_Core.TyBind && v1.value0.value0 instanceof Data_Maybe.Just)) {\n                    return expand(dictMonad)(v1.value0.value0.value0);\n                };\n                return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Closure.expand: \" + (v.value0 + (\" is \" + Data_Show.show(Data_Maybe.showMaybe(Language_CP_Syntax_Core.showEvalBind))(v1))));\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyForall) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(dictMonad.Bind1()))(expand(dictMonad)(v.value1))(function (td$prime) {\n                return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(dictMonad.Bind1()))(Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(dictMonad))(function (env) {\n                    return Data_Map_Internal.insert(Data_Ord.ordString)(v.value0)(new Language_CP_Syntax_Core.TyBind(Data_Maybe.Nothing.value))(env);\n                })(expand(dictMonad)(v.value2)))(function (t$prime) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(new Language_CP_Syntax_Core.TyForall(v.value0, td$prime, t$prime));\n                });\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyRec) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(dictMonad.Bind1()))(Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(dictMonad))(function (env) {\n                return Data_Map_Internal.insert(Data_Ord.ordString)(v.value0)(new Language_CP_Syntax_Core.TyBind(Data_Maybe.Nothing.value))(env);\n            })(expand(dictMonad)(v.value1)))(function (t$prime) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(new Language_CP_Syntax_Core.TyRec(v.value0, t$prime));\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyArray) {\n            return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TyArray.create)(expand(dictMonad)(v.value0));\n        };\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(v);\n    };\n};\nvar typedReduce = function (dictMonad) {\n    return function (tm) {\n        return function (ty) {\n            var go = function (v) {\n                return function (v1) {\n                    if (!isValue(v)) {\n                        return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Closure.typedReduce: \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(v) + \" is not a value\"));\n                    };\n                    if (Language_CP_Subtyping.isTopLike(v1)) {\n                        return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Language_CP_Syntax_Core.TmUnit.value);\n                    };\n                    var v2 = function (v3) {\n                        if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n                            return Control_Alt.alt(Control_Monad_Maybe_Trans.altMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(go(v.value0)(v1))(go(v.value1)(v1));\n                        };\n                        if (v instanceof Language_CP_Syntax_Core.TmInt && v1 instanceof Language_CP_Syntax_Core.TyInt) {\n                            return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(new Language_CP_Syntax_Core.TmInt(v.value0));\n                        };\n                        if (v instanceof Language_CP_Syntax_Core.TmDouble && v1 instanceof Language_CP_Syntax_Core.TyDouble) {\n                            return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(new Language_CP_Syntax_Core.TmDouble(v.value0));\n                        };\n                        if (v instanceof Language_CP_Syntax_Core.TmString && v1 instanceof Language_CP_Syntax_Core.TyString) {\n                            return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(new Language_CP_Syntax_Core.TmString(v.value0));\n                        };\n                        if (v instanceof Language_CP_Syntax_Core.TmBool && v1 instanceof Language_CP_Syntax_Core.TyBool) {\n                            return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(new Language_CP_Syntax_Core.TmBool(v.value0));\n                        };\n                        if (v instanceof Language_CP_Syntax_Core.TmFold && (v1 instanceof Language_CP_Syntax_Core.TyRec && Language_CP_Subtyping.subtype(v.value0)(v1))) {\n                            return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(new Language_CP_Syntax_Core.TmFold(v1, v.value1));\n                        };\n                        if (v instanceof Language_CP_Syntax_Core.TmClosure && (v.value1 instanceof Language_CP_Syntax_Core.TmRcd && v1 instanceof Language_CP_Syntax_Core.TyRcd)) {\n                            return Control_Bind.bind(Control_Monad_Maybe_Trans.bindMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Control_Monad_Trans_Class.lift(Control_Monad_Maybe_Trans.monadTransMaybeT)(Control_Monad_Reader_Trans.monadReaderT(dictMonad))(Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(dictMonad))(Data_Function[\"const\"](v.value0))(expand(dictMonad)(v.value1.value1))))(function (t1$prime) {\n                                var $150 = v.value1.value0 === v1.value0 && Language_CP_Subtyping.subtype(t1$prime)(v1.value1);\n                                if ($150) {\n                                    return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(new Language_CP_Syntax_Core.TmClosure(v.value0, new Language_CP_Syntax_Core.TmRcd(v1.value0, v1.value1, v.value1.value2)));\n                                };\n                                return Control_Plus.empty(Control_Monad_Maybe_Trans.plusMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)));\n                            });\n                        };\n                        if (v instanceof Language_CP_Syntax_Core.TmClosure && (v.value1 instanceof Language_CP_Syntax_Core.TmAbs && v1 instanceof Language_CP_Syntax_Core.TyArrow)) {\n                            return Control_Bind.bind(Control_Monad_Maybe_Trans.bindMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Control_Monad_Trans_Class.lift(Control_Monad_Maybe_Trans.monadTransMaybeT)(Control_Monad_Reader_Trans.monadReaderT(dictMonad))(Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(dictMonad))(Data_Function[\"const\"](v.value0))(expand(dictMonad)(v.value1.value2))))(function (targ1$prime) {\n                                return Control_Bind.bind(Control_Monad_Maybe_Trans.bindMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Control_Monad_Trans_Class.lift(Control_Monad_Maybe_Trans.monadTransMaybeT)(Control_Monad_Reader_Trans.monadReaderT(dictMonad))(Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(dictMonad))(Data_Function[\"const\"](v.value0))(expand(dictMonad)(v.value1.value3))))(function (tret1$prime) {\n                                    var $159 = Language_CP_Subtyping.subtype(tret1$prime)(v1.value1);\n                                    if ($159) {\n                                        return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(new Language_CP_Syntax_Core.TmClosure(v.value0, new Language_CP_Syntax_Core.TmAbs(v.value1.value0, v.value1.value1, targ1$prime, v1.value1, true)));\n                                    };\n                                    return Control_Plus.empty(Control_Monad_Maybe_Trans.plusMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)));\n                                });\n                            });\n                        };\n                        if (v instanceof Language_CP_Syntax_Core.TmClosure && (v.value1 instanceof Language_CP_Syntax_Core.TmTAbs && v1 instanceof Language_CP_Syntax_Core.TyForall)) {\n                            return Control_Bind.bind(Control_Monad_Maybe_Trans.bindMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Control_Monad_Trans_Class.lift(Control_Monad_Maybe_Trans.monadTransMaybeT)(Control_Monad_Reader_Trans.monadReaderT(dictMonad))(Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(dictMonad))(Data_Function[\"const\"](v.value0))(expand(dictMonad)(v.value1.value1))))(function (td1$prime) {\n                                var env$prime = Data_Map_Internal.insert(Data_Ord.ordString)(v.value1.value0)(new Language_CP_Syntax_Core.TyBind(Data_Maybe.Nothing.value))(v.value0);\n                                return Control_Bind.bind(Control_Monad_Maybe_Trans.bindMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Control_Monad_Trans_Class.lift(Control_Monad_Maybe_Trans.monadTransMaybeT)(Control_Monad_Reader_Trans.monadReaderT(dictMonad))(Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(dictMonad))(Data_Function[\"const\"](env$prime))(expand(dictMonad)(v.value1.value3))))(function (t1$prime) {\n                                    var $170 = v.value1.value0 === v1.value0 && (Language_CP_Subtyping.subtype(v1.value1)(td1$prime) && Language_CP_Subtyping.subtype(t1$prime)(v1.value2));\n                                    if ($170) {\n                                        return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(new Language_CP_Syntax_Core.TmClosure(env$prime, new Language_CP_Syntax_Core.TmTAbs(v1.value0, td1$prime, v.value1.value2, v1.value2)));\n                                    };\n                                    return Control_Plus.empty(Control_Monad_Maybe_Trans.plusMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)));\n                                });\n                            });\n                        };\n                        if (v instanceof Language_CP_Syntax_Core.TmClosure && (v.value1 instanceof Language_CP_Syntax_Core.TmArray && v1 instanceof Language_CP_Syntax_Core.TyArray)) {\n                            return Control_Bind.bind(Control_Monad_Maybe_Trans.bindMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Control_Monad_Trans_Class.lift(Control_Monad_Maybe_Trans.monadTransMaybeT)(Control_Monad_Reader_Trans.monadReaderT(dictMonad))(Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(dictMonad))(Data_Function[\"const\"](v.value0))(expand(dictMonad)(v.value1.value0))))(function (t1$prime) {\n                                var $180 = Language_CP_Subtyping.subtype(t1$prime)(v1.value0);\n                                if ($180) {\n                                    return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(new Language_CP_Syntax_Core.TmClosure(v.value0, new Language_CP_Syntax_Core.TmArray(v1.value0, v.value1.value1)));\n                                };\n                                return Control_Plus.empty(Control_Monad_Maybe_Trans.plusMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)));\n                            });\n                        };\n                        return Control_Plus.empty(Control_Monad_Maybe_Trans.plusMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)));\n                    };\n                    var $188 = Language_CP_Subtyping.split(v1);\n                    if ($188 instanceof Data_Maybe.Just) {\n                        var isOptionalRcd = function (v4) {\n                            if (v4 instanceof Language_CP_Syntax_Core.TyRcd && v4.value2) {\n                                return Control_Applicative.pure(Control_Monad_Maybe_Trans.applicativeMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Language_CP_Syntax_Core.TmUnit.value);\n                            };\n                            return Control_Plus.empty(Control_Monad_Maybe_Trans.plusMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)));\n                        };\n                        var v21 = go(v)($188.value0.value1);\n                        var v11 = go(v)($188.value0.value0);\n                        var m2 = isOptionalRcd($188.value0.value1);\n                        var m1 = isOptionalRcd($188.value0.value0);\n                        return Control_Alt.alt(Control_Monad_Maybe_Trans.altMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Control_Alt.alt(Control_Monad_Maybe_Trans.altMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Control_Alt.alt(Control_Monad_Maybe_Trans.altMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Control_Apply.apply(Control_Monad_Maybe_Trans.applyMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(Data_Functor.map(Control_Monad_Maybe_Trans.functorMaybeT(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0())))(Language_CP_Syntax_Core.TmMerge.create)(v11))(v21))(Control_Apply.applySecond(Control_Monad_Maybe_Trans.applyMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(m1)(v21)))(Control_Apply.applySecond(Control_Monad_Maybe_Trans.applyMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(m2)(v11)))(Control_Apply.applySecond(Control_Monad_Maybe_Trans.applyMaybeT(Control_Monad_Reader_Trans.monadReaderT(dictMonad)))(m1)(m2));\n                    };\n                    return v2(true);\n                };\n            };\n            return Control_Monad_Maybe_Trans.runMaybeT(go(tm)(ty));\n        };\n    };\n};\nvar closure = function (dictMonad) {\n    return function (e) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(dictMonad.Bind1()))(Control_Monad_Reader_Class.ask(Control_Monad_Reader_Trans.monadAskReaderT(dictMonad)))(function (env) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(new Language_CP_Syntax_Core.TmClosure(env, e));\n        });\n    };\n};\nvar closureWithTmBind = function (dictMonad) {\n    return function (name) {\n        return function (tm) {\n            return function (e) {\n                return Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(dictMonad))(function (env) {\n                    return Data_Map_Internal.insert(Data_Ord.ordString)(name)(new Language_CP_Syntax_Core.TmBind(tm))(env);\n                })(closure(dictMonad)(e));\n            };\n        };\n    };\n};\nvar binop$prime = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v instanceof Language_CP_Syntax_Common.Append && (v1 instanceof Language_CP_Syntax_Core.TmClosure && (v1.value1 instanceof Language_CP_Syntax_Core.TmArray && (v2 instanceof Language_CP_Syntax_Core.TmClosure && v2.value1 instanceof Language_CP_Syntax_Core.TmArray)))) {\n                return new Language_CP_Syntax_Core.TmClosure(Data_Map_Internal.union(Data_Ord.ordString)(v1.value0)(v2.value0), new Language_CP_Syntax_Core.TmArray(v1.value1.value0, Data_Semigroup.append(Data_Semigroup.semigroupArray)(v1.value1.value1)(v2.value1.value1)));\n            };\n            if (v instanceof Language_CP_Syntax_Common.Index && (v1 instanceof Language_CP_Syntax_Core.TmClosure && (v1.value1 instanceof Language_CP_Syntax_Core.TmArray && v2 instanceof Language_CP_Syntax_Core.TmInt))) {\n                var v3 = Data_Array.index(v1.value1.value1)(v2.value0);\n                if (v3 instanceof Data_Maybe.Just) {\n                    return new Language_CP_Syntax_Core.TmClosure(v1.value0, new Language_CP_Syntax_Core.TmAnno(v3.value0, v1.value1.value0));\n                };\n                if (v3 instanceof Data_Maybe.Nothing) {\n                    return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Closure.binop': the index \" + (Data_Show.show(Data_Show.showInt)(v2.value0) + (\" is out of bounds for \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(new Language_CP_Syntax_Core.TmArray(v1.value1.value0, v1.value1.value1)))));\n                };\n                throw new Error(\"Failed pattern match at Language.CP.Semantics.Closure (line 149, column 58 - line 152, column 63): \" + [ v3.constructor.name ]);\n            };\n            return Language_CP_Semantics_Common.binop(v)(v1)(v2);\n        };\n    };\n};\nvar step = function (dictMonad) {\n    return function (v) {\n        if (v instanceof Language_CP_Syntax_Core.TmUnary) {\n            if (isValue(v.value1)) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(unop$prime(v.value0)(v.value1));\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmUnary.create(v.value0))(step(dictMonad)(v.value1));\n            };\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmBinary) {\n            if (isValue(v.value1) && isValue(v.value2)) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(binop$prime(v.value0)(v.value1)(v.value2));\n            };\n            if (isValue(v.value1)) {\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmBinary.create(v.value0)(v.value1))(step(dictMonad)(v.value2));\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmBinary.create(v.value0))(step(dictMonad)(v.value1)))(v.value2);\n            };\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmIf && (v.value0 instanceof Language_CP_Syntax_Core.TmBool && v.value0.value0)) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(v.value1);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmIf && (v.value0 instanceof Language_CP_Syntax_Core.TmBool && !v.value0.value0)) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(v.value2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmIf) {\n            return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmIf.create)(step(dictMonad)(v.value0)))(v.value1))(v.value2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmVar) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(dictMonad.Bind1()))(Control_Monad_Reader_Class.ask(Control_Monad_Reader_Trans.monadAskReaderT(dictMonad)))(function (env) {\n                var v1 = Data_Map_Internal.lookup(Data_Ord.ordString)(v.value0)(env);\n                if (v1 instanceof Data_Maybe.Just && v1.value0 instanceof Language_CP_Syntax_Core.TmBind) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(v1.value0.value0);\n                };\n                return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Closure.step: \" + (v.value0 + (\" is \" + Data_Show.show(Data_Maybe.showMaybe(Language_CP_Syntax_Core.showEvalBind))(v1))));\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmApp) {\n            if (isValue(v.value0)) {\n                var arg = (function () {\n                    if (v.value2) {\n                        return Language_CP_Semantics_Common.TmAnnoArg.create;\n                    };\n                    return Language_CP_Semantics_Common.TmArg.create;\n                })();\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))((function () {\n                    var $291 = paraApp(v.value0);\n                    return function ($292) {\n                        return $291(arg($292));\n                    };\n                })())(closure(dictMonad)(v.value1));\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmApp.create)(step(dictMonad)(v.value0)))(v.value1))(v.value2);\n            };\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmAbs) {\n            return closure(dictMonad)(v);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmFix) {\n            return closureWithTmBind(dictMonad)(v.value0)(v)(v.value1);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmAnno && v.value0 instanceof Language_CP_Syntax_Core.TmAnno) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(new Language_CP_Syntax_Core.TmAnno(v.value0.value0, v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmAnno) {\n            if (isValue(v.value0)) {\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Util.unsafeFromJust)(Control_Bind.bindFlipped(Control_Monad_Reader_Trans.bindReaderT(dictMonad.Bind1()))(typedReduce(dictMonad)(v.value0))(expand(dictMonad)(v.value1)));\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmAnno.create)(step(dictMonad)(v.value0)))(v.value1);\n            };\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n            if (isValue(v.value0)) {\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmMerge.create(v.value0))(step(dictMonad)(v.value1));\n            };\n            if (isValue(v.value1)) {\n                return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmMerge.create)(step(dictMonad)(v.value0)))(v.value1);\n            };\n            if (Data_Boolean.otherwise) {\n                return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT((dictMonad.Bind1()).Apply0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmMerge.create)(step(dictMonad)(v.value0)))(step(dictMonad)(v.value1));\n            };\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmRcd) {\n            return closure(dictMonad)(v);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmPrj) {\n            if (isValue(v.value0)) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(selectLabel(v.value0)(v.value1));\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmPrj.create)(step(dictMonad)(v.value0)))(v.value1);\n            };\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmTApp) {\n            if (isValue(v.value0)) {\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))((function () {\n                    var $293 = paraApp(v.value0);\n                    return function ($294) {\n                        return $293(Language_CP_Semantics_Common.TyArg.create($294));\n                    };\n                })())(expand(dictMonad)(v.value1));\n            };\n            if (Data_Boolean.otherwise) {\n                return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmTApp.create)(step(dictMonad)(v.value0)))(v.value1);\n            };\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmTAbs) {\n            return closure(dictMonad)(v);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmFold) {\n            return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmFold.create(v.value0))(step(dictMonad)(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnfold && Language_CP_Subtyping.isTopLike(v.value0)) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(Language_CP_Syntax_Core.TmUnit.value);\n        };\n        var v1 = function (v2) {\n            var v3 = function (v4) {\n                if (v instanceof Language_CP_Syntax_Core.TmUnfold && Data_Boolean.otherwise) {\n                    return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmUnfold.create(v.value0))(step(dictMonad)(v.value1));\n                };\n                if (v instanceof Language_CP_Syntax_Core.TmToString) {\n                    if (isValue(v.value0)) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(Language_CP_Semantics_Common.toString(v.value0));\n                    };\n                    if (Data_Boolean.otherwise) {\n                        return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmToString.create)(step(dictMonad)(v.value0));\n                    };\n                };\n                if (v instanceof Language_CP_Syntax_Core.TmArray) {\n                    return closure(dictMonad)(v);\n                };\n                if (v instanceof Language_CP_Syntax_Core.TmClosure) {\n                    if (isValue(v.value1)) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(v.value1);\n                    };\n                    if (Data_Boolean.otherwise) {\n                        return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(((dictMonad.Bind1()).Apply0()).Functor0()))(Language_CP_Syntax_Core.TmClosure.create(v.value0))(Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(dictMonad))(Data_Function[\"const\"](v.value0))(step(dictMonad)(v.value1)));\n                    };\n                };\n                return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Closure.step: \" + (\"well-typed programs don't get stuck, but got \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v)));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmUnfold) {\n                if (v.value1 instanceof Language_CP_Syntax_Core.TmMerge) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(new Language_CP_Syntax_Core.TmUnfold(v.value0, new Language_CP_Syntax_Core.TmAnno(v.value1, v.value0)));\n                };\n                return v3(true);\n            };\n            return v3(true);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnfold) {\n            if (v.value1 instanceof Language_CP_Syntax_Core.TmFold) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(dictMonad.Applicative0()))(new Language_CP_Syntax_Core.TmAnno(v.value1.value1, Language_CP_Syntax_Core.unfold(v.value0)));\n            };\n            return v1(true);\n        };\n        return v1(true);\n    };\n};\nvar $$eval = function (tm) {\n    var go = function (e) {\n        if (isValue(e)) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Data_Identity.applicativeIdentity))(e);\n        };\n        if (Data_Boolean.otherwise) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Data_Identity.bindIdentity))(step(Data_Identity.monadIdentity)(e))(go);\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Semantics.Closure (line 27, column 9 - line 27, column 38): \" + [ e.constructor.name ]);\n    };\n    return Control_Monad_Reader.runReader(go(tm))(Data_Map_Internal.empty);\n};\nmodule.exports = {\n    \"eval\": $$eval,\n    step: step,\n    typedReduce: typedReduce,\n    paraApp: paraApp,\n    selectLabel: selectLabel,\n    \"unop'\": unop$prime,\n    \"binop'\": binop$prime,\n    expand: expand,\n    isValue: isValue,\n    closure: closure,\n    closureWithTmBind: closureWithTmBind\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Semantics/Closure.purs?");

/***/ }),

/***/ "./src/CP/Semantics/Common.purs":
/*!**************************************!*\
  !*** ./src/CP/Semantics/Common.purs ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_EuclideanRing = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs */ \"./.spago/prelude/v5.0.1/src/Data/EuclideanRing.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Language_CP_Syntax_Common = __webpack_require__(/*! ./src/CP/Syntax/Common.purs */ \"./src/CP/Syntax/Common.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar $$Math = __webpack_require__(/*! ./.spago/math/v3.0.0/src/Math.purs */ \"./.spago/math/v3.0.0/src/Math.purs\");\nvar Partial_Unsafe = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.purs\");\nvar TmArg = (function () {\n    function TmArg(value0) {\n        this.value0 = value0;\n    };\n    TmArg.create = function (value0) {\n        return new TmArg(value0);\n    };\n    return TmArg;\n})();\nvar TmAnnoArg = (function () {\n    function TmAnnoArg(value0) {\n        this.value0 = value0;\n    };\n    TmAnnoArg.create = function (value0) {\n        return new TmAnnoArg(value0);\n    };\n    return TmAnnoArg;\n})();\nvar TyArg = (function () {\n    function TyArg(value0) {\n        this.value0 = value0;\n    };\n    TyArg.create = function (value0) {\n        return new TyArg(value0);\n    };\n    return TyArg;\n})();\nvar showArg = {\n    show: function (v) {\n        if (v instanceof TmArg) {\n            return Data_Show.show(Language_CP_Syntax_Core.showTm)(v.value0);\n        };\n        if (v instanceof TmAnnoArg) {\n            return Data_Show.show(Language_CP_Syntax_Core.showTm)(v.value0);\n        };\n        if (v instanceof TyArg) {\n            return Data_Show.show(Language_CP_Syntax_Core.showTy)(v.value0);\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Semantics.Common (line 104, column 1 - line 107, column 28): \" + [ v.constructor.name ]);\n    }\n};\nvar unsafeCrashWithBinop = function (op) {\n    return function (v1) {\n        return function (v2) {\n            return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Common.binop: impossible binary operation \" + (Data_Show.show(Language_CP_Syntax_Common.showBinOp)(op) + (\" between \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(v1) + (\" and \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v2))))));\n        };\n    };\n};\nvar unop = function (v) {\n    return function (v1) {\n        if (v instanceof Language_CP_Syntax_Common.Neg && v1 instanceof Language_CP_Syntax_Core.TmInt) {\n            return new Language_CP_Syntax_Core.TmInt(-v1.value0 | 0);\n        };\n        if (v instanceof Language_CP_Syntax_Common.Neg && v1 instanceof Language_CP_Syntax_Core.TmDouble) {\n            return new Language_CP_Syntax_Core.TmDouble(-v1.value0);\n        };\n        if (v instanceof Language_CP_Syntax_Common.Not && v1 instanceof Language_CP_Syntax_Core.TmBool) {\n            return new Language_CP_Syntax_Core.TmBool(!v1.value0);\n        };\n        if (v instanceof Language_CP_Syntax_Common.Len && v1 instanceof Language_CP_Syntax_Core.TmArray) {\n            return new Language_CP_Syntax_Core.TmInt(Data_Array.length(v1.value1));\n        };\n        return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Common.unop: impossible unary operation \" + (Data_Show.show(Language_CP_Syntax_Common.showUnOp)(v) + (\" on \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v1))));\n    };\n};\nvar toString = function (v) {\n    if (v instanceof Language_CP_Syntax_Core.TmString) {\n        return v;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmInt) {\n        return new Language_CP_Syntax_Core.TmString(Data_Show.show(Data_Show.showInt)(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmDouble) {\n        return new Language_CP_Syntax_Core.TmString(Data_Show.show(Data_Show.showNumber)(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmBool) {\n        return new Language_CP_Syntax_Core.TmString(Data_Show.show(Data_Show.showBoolean)(v.value0));\n    };\n    return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Common.toString: impossible from \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(v) + \" to string\"));\n};\nvar selectLabel = function (v) {\n    return function (v1) {\n        if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n            var v2 = selectLabel(v.value1)(v1);\n            var v3 = selectLabel(v.value0)(v1);\n            if (v3 instanceof Language_CP_Syntax_Core.TmUndefined && v2 instanceof Language_CP_Syntax_Core.TmUndefined) {\n                return Language_CP_Syntax_Core.TmUndefined.value;\n            };\n            if (v3 instanceof Language_CP_Syntax_Core.TmUndefined) {\n                return v2;\n            };\n            if (v2 instanceof Language_CP_Syntax_Core.TmUndefined) {\n                return v3;\n            };\n            return new Language_CP_Syntax_Core.TmMerge(v3, v2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmRcd && v1 === v.value0) {\n            return new Language_CP_Syntax_Core.TmAnno(v.value2, v.value1);\n        };\n        return Language_CP_Syntax_Core.TmUndefined.value;\n    };\n};\nvar logic = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v instanceof Language_CP_Syntax_Common.And && (v1 instanceof Language_CP_Syntax_Core.TmBool && v2 instanceof Language_CP_Syntax_Core.TmBool)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 && v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Or && (v1 instanceof Language_CP_Syntax_Core.TmBool && v2 instanceof Language_CP_Syntax_Core.TmBool)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 || v2.value0);\n            };\n            return unsafeCrashWithBinop(new Language_CP_Syntax_Common.Logic(v))(v1)(v2);\n        };\n    };\n};\nvar comp = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v instanceof Language_CP_Syntax_Common.Eql && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 === v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Neq && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 !== v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Lt && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 < v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Le && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 <= v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Gt && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 > v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Ge && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 >= v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Eql && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 === v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Neq && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 !== v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Lt && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 < v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Le && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 <= v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Gt && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 > v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Ge && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 >= v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Eql && (v1 instanceof Language_CP_Syntax_Core.TmString && v2 instanceof Language_CP_Syntax_Core.TmString)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 === v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Neq && (v1 instanceof Language_CP_Syntax_Core.TmString && v2 instanceof Language_CP_Syntax_Core.TmString)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 !== v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Lt && (v1 instanceof Language_CP_Syntax_Core.TmString && v2 instanceof Language_CP_Syntax_Core.TmString)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 < v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Le && (v1 instanceof Language_CP_Syntax_Core.TmString && v2 instanceof Language_CP_Syntax_Core.TmString)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 <= v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Gt && (v1 instanceof Language_CP_Syntax_Core.TmString && v2 instanceof Language_CP_Syntax_Core.TmString)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 > v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Ge && (v1 instanceof Language_CP_Syntax_Core.TmString && v2 instanceof Language_CP_Syntax_Core.TmString)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 >= v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Eql && (v1 instanceof Language_CP_Syntax_Core.TmBool && v2 instanceof Language_CP_Syntax_Core.TmBool)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 === v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Neq && (v1 instanceof Language_CP_Syntax_Core.TmBool && v2 instanceof Language_CP_Syntax_Core.TmBool)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 !== v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Lt && (v1 instanceof Language_CP_Syntax_Core.TmBool && v2 instanceof Language_CP_Syntax_Core.TmBool)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 < v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Le && (v1 instanceof Language_CP_Syntax_Core.TmBool && v2 instanceof Language_CP_Syntax_Core.TmBool)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 <= v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Gt && (v1 instanceof Language_CP_Syntax_Core.TmBool && v2 instanceof Language_CP_Syntax_Core.TmBool)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 > v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Ge && (v1 instanceof Language_CP_Syntax_Core.TmBool && v2 instanceof Language_CP_Syntax_Core.TmBool)) {\n                return new Language_CP_Syntax_Core.TmBool(v1.value0 >= v2.value0);\n            };\n            return unsafeCrashWithBinop(new Language_CP_Syntax_Common.Comp(v))(v1)(v2);\n        };\n    };\n};\nvar arith = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v instanceof Language_CP_Syntax_Common.Add && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmInt(v1.value0 + v2.value0 | 0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Sub && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmInt(v1.value0 - v2.value0 | 0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Mul && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmInt(v1.value0 * v2.value0 | 0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Div && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmInt(Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt)(v1.value0)(v2.value0));\n            };\n            if (v instanceof Language_CP_Syntax_Common.Mod && (v1 instanceof Language_CP_Syntax_Core.TmInt && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                return new Language_CP_Syntax_Core.TmInt(Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(v1.value0)(v2.value0));\n            };\n            if (v instanceof Language_CP_Syntax_Common.Add && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmDouble(v1.value0 + v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Sub && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmDouble(v1.value0 - v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Mul && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmDouble(v1.value0 * v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Div && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmDouble(v1.value0 / v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Mod && (v1 instanceof Language_CP_Syntax_Core.TmDouble && v2 instanceof Language_CP_Syntax_Core.TmDouble)) {\n                return new Language_CP_Syntax_Core.TmDouble($$Math.remainder(v1.value0)(v2.value0));\n            };\n            return unsafeCrashWithBinop(new Language_CP_Syntax_Common.Arith(v))(v1)(v2);\n        };\n    };\n};\nvar binop = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v instanceof Language_CP_Syntax_Common.Arith) {\n                return arith(v.value0)(v1)(v2);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Comp) {\n                return comp(v.value0)(v1)(v2);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Logic) {\n                return logic(v.value0)(v1)(v2);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Append && (v1 instanceof Language_CP_Syntax_Core.TmString && v2 instanceof Language_CP_Syntax_Core.TmString)) {\n                return new Language_CP_Syntax_Core.TmString(v1.value0 + v2.value0);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Append && (v1 instanceof Language_CP_Syntax_Core.TmArray && v2 instanceof Language_CP_Syntax_Core.TmArray)) {\n                return new Language_CP_Syntax_Core.TmArray(v1.value0, Data_Semigroup.append(Data_Semigroup.semigroupArray)(v1.value1)(v2.value1));\n            };\n            if (v instanceof Language_CP_Syntax_Common.Index && (v1 instanceof Language_CP_Syntax_Core.TmArray && v2 instanceof Language_CP_Syntax_Core.TmInt)) {\n                var v3 = Data_Array.index(v1.value1)(v2.value0);\n                if (v3 instanceof Data_Maybe.Just) {\n                    return new Language_CP_Syntax_Core.TmAnno(v3.value0, v1.value0);\n                };\n                if (v3 instanceof Data_Maybe.Nothing) {\n                    return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Common.binop: the index \" + (Data_Show.show(Data_Show.showInt)(v2.value0) + (\" is out of bounds for \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(new Language_CP_Syntax_Core.TmArray(v1.value0, v1.value1)))));\n                };\n                throw new Error(\"Failed pattern match at Language.CP.Semantics.Common (line 27, column 41 - line 30, column 63): \" + [ v3.constructor.name ]);\n            };\n            if (v instanceof Language_CP_Syntax_Common.Coalesce && v1 instanceof Language_CP_Syntax_Core.TmUndefined) {\n                return v2;\n            };\n            if (v instanceof Language_CP_Syntax_Common.Coalesce) {\n                return v1;\n            };\n            return unsafeCrashWithBinop(v)(v1)(v2);\n        };\n    };\n};\nmodule.exports = {\n    unop: unop,\n    binop: binop,\n    arith: arith,\n    comp: comp,\n    logic: logic,\n    unsafeCrashWithBinop: unsafeCrashWithBinop,\n    toString: toString,\n    selectLabel: selectLabel,\n    TmArg: TmArg,\n    TmAnnoArg: TmAnnoArg,\n    TyArg: TyArg,\n    showArg: showArg\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Semantics/Common.purs?");

/***/ }),

/***/ "./src/CP/Semantics/HOAS.purs":
/*!************************************!*\
  !*** ./src/CP/Semantics/HOAS.purs ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_Free = __webpack_require__(/*! ./.spago/free/v6.0.1/src/Control/Monad/Free.purs */ \"./.spago/free/v6.0.1/src/Control/Monad/Free.purs\");\nvar Control_Monad_Trampoline = __webpack_require__(/*! ./.spago/free/v6.0.1/src/Control/Monad/Trampoline.purs */ \"./.spago/free/v6.0.1/src/Control/Monad/Trampoline.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Language_CP_Semantics_Common = __webpack_require__(/*! ./src/CP/Semantics/Common.purs */ \"./src/CP/Semantics/Common.purs\");\nvar Language_CP_Subtyping = __webpack_require__(/*! ./src/CP/Subtyping.purs */ \"./src/CP/Subtyping.purs\");\nvar Language_CP_Syntax_Common = __webpack_require__(/*! ./src/CP/Syntax/Common.purs */ \"./src/CP/Syntax/Common.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar Partial_Unsafe = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.purs\");\nvar paraApp = function (v) {\n    return function (v1) {\n        if (v instanceof Language_CP_Syntax_Core.TmUnit) {\n            return Language_CP_Syntax_Core.TmUnit.value;\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmHAbs && (!v.value3 && v1 instanceof Language_CP_Semantics_Common.TmArg)) {\n            return v.value0(Language_CP_Syntax_Core.TmRef.create(Language_CP_Syntax_Core[\"new\"](v1.value0)));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmHAbs && (v.value3 && v1 instanceof Language_CP_Semantics_Common.TmArg)) {\n            return new Language_CP_Syntax_Core.TmAnno(v.value0(Language_CP_Syntax_Core.TmRef.create(Language_CP_Syntax_Core[\"new\"](v1.value0))), v.value2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmHAbs && v1 instanceof Language_CP_Semantics_Common.TmAnnoArg) {\n            return new Language_CP_Syntax_Core.TmAnno(v.value0(Language_CP_Syntax_Core.TmRef.create(Language_CP_Syntax_Core[\"new\"](new Language_CP_Syntax_Core.TmAnno(v1.value0, v.value1)))), v.value2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmHTAbs && v1 instanceof Language_CP_Semantics_Common.TyArg) {\n            return v.value0(v1.value0);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n            return new Language_CP_Syntax_Core.TmMerge(paraApp(v.value0)(v1), paraApp(v.value1)(v1));\n        };\n        return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.HOAS.paraApp: \" + (\"impossible application \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(v) + (\" \\u2022 \" + Data_Show.show(Language_CP_Semantics_Common.showArg)(v1)))));\n    };\n};\nvar isValue = function (v) {\n    if (v instanceof Language_CP_Syntax_Core.TmInt) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmDouble) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmString) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmBool) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmUnit) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmUndefined) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmHAbs) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n        return isValue(v.value0) && isValue(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmRcd) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmHTAbs) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmFold) {\n        return isValue(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmArray) {\n        return true;\n    };\n    return false;\n};\nvar typedReduce = function (v) {\n    return function (v1) {\n        if (!isValue(v)) {\n            return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.HOAS.typedReduce: \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(v) + \" is not a value\"));\n        };\n        if (Language_CP_Subtyping.isTopLike(v1)) {\n            return new Data_Maybe.Just(Language_CP_Syntax_Core.TmUnit.value);\n        };\n        var v2 = function (v3) {\n            if (v instanceof Language_CP_Syntax_Core.TmInt && v1 instanceof Language_CP_Syntax_Core.TyInt) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmInt(v.value0));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmDouble && v1 instanceof Language_CP_Syntax_Core.TyDouble) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmDouble(v.value0));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmString && v1 instanceof Language_CP_Syntax_Core.TyString) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmString(v.value0));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmBool && v1 instanceof Language_CP_Syntax_Core.TyBool) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmBool(v.value0));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmHAbs && (v1 instanceof Language_CP_Syntax_Core.TyArrow && Language_CP_Subtyping.subtype(v.value2)(v1.value1))) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmHAbs(v.value0, v.value1, v1.value1, true));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n                return Control_Alt.alt(Data_Maybe.altMaybe)(typedReduce(v.value0)(v1))(typedReduce(v.value1)(v1));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmRcd && (v1 instanceof Language_CP_Syntax_Core.TyRcd && (v.value0 === v1.value0 && Language_CP_Subtyping.subtype(v.value1)(v1.value1)))) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmRcd(v.value0, v1.value1, v.value2));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmHTAbs && (v1 instanceof Language_CP_Syntax_Core.TyForall && (Language_CP_Subtyping.subtype(v1.value1)(v.value1) && Language_CP_Subtyping.subtype(v.value2(new Language_CP_Syntax_Core.TyVar(v1.value0)))(v1.value2)))) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmHTAbs(v.value0, v.value1, Language_CP_Syntax_Core.tyHoas(v1.value0)(v1.value2)));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmFold && (v1 instanceof Language_CP_Syntax_Core.TyRec && Language_CP_Subtyping.subtype(v.value0)(v1))) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmFold(v1, v.value1));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmArray && (v1 instanceof Language_CP_Syntax_Core.TyArray && Language_CP_Subtyping.subtype(v.value0)(v1.value0))) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmArray(v1.value0, v.value1));\n            };\n            return Data_Maybe.Nothing.value;\n        };\n        var $94 = Language_CP_Subtyping.split(v1);\n        if ($94 instanceof Data_Maybe.Just) {\n            var isOptionalRcd = function (v4) {\n                if (v4 instanceof Language_CP_Syntax_Core.TyRcd && v4.value2) {\n                    return new Data_Maybe.Just(Language_CP_Syntax_Core.TmUnit.value);\n                };\n                return Data_Maybe.Nothing.value;\n            };\n            var v21 = typedReduce(v)($94.value0.value1);\n            var v11 = typedReduce(v)($94.value0.value0);\n            var m2 = isOptionalRcd($94.value0.value1);\n            var m1 = isOptionalRcd($94.value0.value0);\n            return Control_Alt.alt(Data_Maybe.altMaybe)(Control_Alt.alt(Data_Maybe.altMaybe)(Control_Alt.alt(Data_Maybe.altMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(Data_Functor.map(Data_Maybe.functorMaybe)(Language_CP_Syntax_Core.TmMerge.create)(v11))(v21))(Control_Apply.applySecond(Data_Maybe.applyMaybe)(m1)(v21)))(Control_Apply.applySecond(Data_Maybe.applyMaybe)(m2)(v11)))(Control_Apply.applySecond(Data_Maybe.applyMaybe)(m1)(m2));\n        };\n        return v2(true);\n    };\n};\nvar $$eval = (function () {\n    var go = function (v) {\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmInt) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmDouble) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmString) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmBool) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnit) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(Language_CP_Syntax_Core.TmUnit.value);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUndefined) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(Language_CP_Syntax_Core.TmUndefined.value);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnary) {\n            return Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Semantics_Common.unop(v.value0))(go(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmBinary) {\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(v.value1))(function (e1$prime) {\n                return Control_Bind.bind(Control_Monad_Free.freeBind)(go(v.value2))(function (e2$prime) {\n                    var e = Language_CP_Semantics_Common.binop(v.value0)(e1$prime)(e2$prime);\n                    if (v.value0 instanceof Language_CP_Syntax_Common.Index) {\n                        return go(e);\n                    };\n                    return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n                });\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmIf) {\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(v.value0))(function (e1$prime) {\n                if (e1$prime instanceof Language_CP_Syntax_Core.TmBool && e1$prime.value0) {\n                    return go(v.value1);\n                };\n                if (e1$prime instanceof Language_CP_Syntax_Core.TmBool && !e1$prime.value0) {\n                    return go(v.value2);\n                };\n                return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.HOAS.eval: impossible if \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(e1$prime) + \" ...\"));\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmApp) {\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(v.value0))(function (e1$prime) {\n                return go(paraApp(e1$prime)((function () {\n                    if (v.value2) {\n                        return Language_CP_Semantics_Common.TmAnnoArg.create;\n                    };\n                    return Language_CP_Semantics_Common.TmArg.create;\n                })()(v.value1)));\n            });\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmHAbs) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmHFix) {\n            return go(v.value0(e));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmAnno) {\n            var go$prime = function ($copy_v1) {\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(v1) {\n                    if (v1 instanceof Language_CP_Syntax_Core.TmAnno) {\n                        $copy_v1 = v1.value0;\n                        return;\n                    };\n                    $tco_done = true;\n                    return go(v1);\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($copy_v1);\n                };\n                return $tco_result;\n            };\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go$prime(v.value0))(function (e$prime) {\n                var v1 = typedReduce(e$prime)(v.value1);\n                if (v1 instanceof Data_Maybe.Just) {\n                    return go(v1.value0);\n                };\n                if (v1 instanceof Data_Maybe.Nothing) {\n                    return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.HOAS.eval: impossible typed reduction \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v));\n                };\n                throw new Error(\"Failed pattern match at Language.CP.Semantics.HOAS (line 48, column 7 - line 51, column 77): \" + [ v1.constructor.name ]);\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n            return Control_Apply.apply(Control_Monad_Free.freeApply)(Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Syntax_Core.TmMerge.create)(go(v.value0)))(go(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmRcd) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(new Language_CP_Syntax_Core.TmRcd(v.value0, v.value1, new Language_CP_Syntax_Core.TmRef(Language_CP_Syntax_Core[\"new\"](v.value2))));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmPrj) {\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(Data_Functor.flap(Control_Monad_Free.freeFunctor)(Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Semantics_Common.selectLabel)(go(v.value0)))(v.value1))(go);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmTApp) {\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(Data_Functor.flap(Control_Monad_Free.freeFunctor)(Data_Functor.map(Control_Monad_Free.freeFunctor)(paraApp)(go(v.value0)))(new Language_CP_Semantics_Common.TyArg(v.value1)))(go);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmHTAbs) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmFold) {\n            return Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Syntax_Core.TmFold.create(v.value0))(go(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnfold) {\n            var go$prime = function (v1) {\n                if (v1 instanceof Language_CP_Syntax_Core.TmMerge) {\n                    return Control_Bind.composeKleisliFlipped(Control_Monad_Free.freeBind)(go$prime)(go)(new Language_CP_Syntax_Core.TmAnno(v1, v.value0));\n                };\n                if (v1 instanceof Language_CP_Syntax_Core.TmFold) {\n                    return go(new Language_CP_Syntax_Core.TmAnno(v1.value1, Language_CP_Syntax_Core.unfold(v.value0)));\n                };\n                return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.HOAS.eval: \" + (\"impossible unfold \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v1)));\n            };\n            var $155 = Language_CP_Subtyping.isTopLike(v.value0);\n            if ($155) {\n                return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(Language_CP_Syntax_Core.TmUnit.value);\n            };\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(v.value1))(go$prime);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmToString) {\n            return Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Semantics_Common.toString)(go(v.value0));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmArray) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(new Language_CP_Syntax_Core.TmArray(v.value0, Data_Functor.map(Data_Functor.functorArray)(function ($163) {\n                return Language_CP_Syntax_Core.TmRef.create(Language_CP_Syntax_Core[\"new\"]($163));\n            })(v.value1)));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmRef) {\n            var e = Language_CP_Syntax_Core.read(v.value0);\n            var $161 = Language_CP_Syntax_Core.done(v.value0);\n            if ($161) {\n                return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n            };\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(e))(function (e$prime) {\n                return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(Language_CP_Syntax_Core.write(e$prime)(v.value0));\n            });\n        };\n        return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.HOAS.eval: \" + (\"well-typed programs don't get stuck, but got \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v)));\n    };\n    return function ($164) {\n        return Control_Monad_Trampoline.runTrampoline(go(Language_CP_Syntax_Core.tmHoas($164)));\n    };\n})();\nmodule.exports = {\n    \"eval\": $$eval,\n    typedReduce: typedReduce,\n    paraApp: paraApp,\n    isValue: isValue\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Semantics/HOAS.purs?");

/***/ }),

/***/ "./src/CP/Semantics/NaturalClosure.purs":
/*!**********************************************!*\
  !*** ./src/CP/Semantics/NaturalClosure.purs ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_Free = __webpack_require__(/*! ./.spago/free/v6.0.1/src/Control/Monad/Free.purs */ \"./.spago/free/v6.0.1/src/Control/Monad/Free.purs\");\nvar Control_Monad_Reader_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Class.purs\");\nvar Control_Monad_Reader_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs\");\nvar Control_Monad_Trampoline = __webpack_require__(/*! ./.spago/free/v6.0.1/src/Control/Monad/Trampoline.purs */ \"./.spago/free/v6.0.1/src/Control/Monad/Trampoline.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Map_Internal = __webpack_require__(/*! ./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs */ \"./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Language_CP_Semantics_Closure = __webpack_require__(/*! ./src/CP/Semantics/Closure.purs */ \"./src/CP/Semantics/Closure.purs\");\nvar Language_CP_Semantics_Common = __webpack_require__(/*! ./src/CP/Semantics/Common.purs */ \"./src/CP/Semantics/Common.purs\");\nvar Language_CP_Subtyping = __webpack_require__(/*! ./src/CP/Subtyping.purs */ \"./src/CP/Subtyping.purs\");\nvar Language_CP_Syntax_Common = __webpack_require__(/*! ./src/CP/Syntax/Common.purs */ \"./src/CP/Syntax/Common.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar Partial_Unsafe = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.purs\");\nvar $$eval = function (tm) {\n    var go = function (v) {\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmInt) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(e);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmDouble) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(e);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmString) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(e);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmBool) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(e);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnit) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(Language_CP_Syntax_Core.TmUnit.value);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUndefined) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(Language_CP_Syntax_Core.TmUndefined.value);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnary) {\n            return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Free.freeFunctor))(Language_CP_Semantics_Closure[\"unop'\"](v.value0))(go(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmBinary) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(go(v.value1))(function (e1$prime) {\n                return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(go(v.value2))(function (e2$prime) {\n                    var e = Language_CP_Semantics_Closure[\"binop'\"](v.value0)(e1$prime)(e2$prime);\n                    if (v.value0 instanceof Language_CP_Syntax_Common.Index) {\n                        return go(e);\n                    };\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(e);\n                });\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmIf) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(go(v.value0))(function (e1$prime) {\n                if (e1$prime instanceof Language_CP_Syntax_Core.TmBool && e1$prime.value0) {\n                    return go(v.value1);\n                };\n                if (e1$prime instanceof Language_CP_Syntax_Core.TmBool && !e1$prime.value0) {\n                    return go(v.value2);\n                };\n                return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.NaturalClosure.eval: \" + (\"impossible if \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(e1$prime) + \" ...\")));\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmVar) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(Control_Monad_Reader_Class.ask(Control_Monad_Reader_Trans.monadAskReaderT(Control_Monad_Free.freeMonad)))(function (env) {\n                var v1 = Data_Map_Internal.lookup(Data_Ord.ordString)(v.value0)(env);\n                if (v1 instanceof Data_Maybe.Just && v1.value0 instanceof Language_CP_Syntax_Core.TmBind) {\n                    return go(v1.value0.value0);\n                };\n                return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.NaturalClosure.eval: \" + (\"variable \" + (Data_Show.show(Data_Show.showString)(v.value0) + (\" is \" + Data_Show.show(Data_Maybe.showMaybe(Language_CP_Syntax_Core.showEvalBind))(v1)))));\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmApp) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(go(v.value0))(function (e1$prime) {\n                return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(Language_CP_Semantics_Closure.closure(Control_Monad_Free.freeMonad)(v.value1))(function (e2$prime) {\n                    var arg = (function () {\n                        if (v.value2) {\n                            return Language_CP_Semantics_Common.TmAnnoArg.create;\n                        };\n                        return Language_CP_Semantics_Common.TmArg.create;\n                    })();\n                    return go(Language_CP_Semantics_Closure.paraApp(e1$prime)(arg(new Language_CP_Syntax_Core.TmRef(Language_CP_Syntax_Core[\"new\"](e2$prime)))));\n                });\n            });\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmAbs) {\n            return Language_CP_Semantics_Closure.closure(Control_Monad_Free.freeMonad)(e);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmFix) {\n            return Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(Control_Monad_Free.freeMonad))(function (env) {\n                return Data_Map_Internal.insert(Data_Ord.ordString)(v.value0)(new Language_CP_Syntax_Core.TmBind(v.value1))(env);\n            })(go(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmAnno) {\n            var go$prime = function ($copy_v1) {\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(v1) {\n                    if (v1 instanceof Language_CP_Syntax_Core.TmAnno) {\n                        $copy_v1 = v1.value0;\n                        return;\n                    };\n                    $tco_done = true;\n                    return go(v1);\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($copy_v1);\n                };\n                return $tco_result;\n            };\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(go$prime(v.value0))(function (e$prime) {\n                return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(Language_CP_Semantics_Closure.expand(Control_Monad_Free.freeMonad)(v.value1))(function (t$prime) {\n                    return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(Language_CP_Semantics_Closure.typedReduce(Control_Monad_Free.freeMonad)(e$prime)(t$prime))(function (s) {\n                        if (s instanceof Data_Maybe.Just) {\n                            return go(s.value0);\n                        };\n                        if (s instanceof Data_Maybe.Nothing) {\n                            return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.NaturalClosure.eval: \" + (\"impossible typed reduction \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v)));\n                        };\n                        throw new Error(\"Failed pattern match at Language.CP.Semantics.NaturalClosure (line 59, column 7 - line 62, column 80): \" + [ s.constructor.name ]);\n                    });\n                });\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n            return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Free.freeApply))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Free.freeFunctor))(Language_CP_Syntax_Core.TmMerge.create)(go(v.value0)))(go(v.value1));\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmRcd) {\n            return Language_CP_Semantics_Closure.closure(Control_Monad_Free.freeMonad)(e);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmPrj) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Free.freeFunctor))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Free.freeFunctor))(Language_CP_Semantics_Closure.selectLabel)(go(v.value0)))(v.value1))(go);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmTApp) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(go(v.value0))(function (e$prime) {\n                return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(Language_CP_Semantics_Closure.expand(Control_Monad_Free.freeMonad)(v.value1))(function (t$prime) {\n                    return go(Language_CP_Semantics_Closure.paraApp(e$prime)(new Language_CP_Semantics_Common.TyArg(t$prime)));\n                });\n            });\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmTAbs) {\n            return Language_CP_Semantics_Closure.closure(Control_Monad_Free.freeMonad)(e);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmFold) {\n            return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Free.freeFunctor))(Language_CP_Syntax_Core.TmFold.create(v.value0))(go(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnfold) {\n            var go$prime = function (v1) {\n                if (v1 instanceof Language_CP_Syntax_Core.TmMerge) {\n                    return Control_Bind.composeKleisliFlipped(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(go$prime)(go)(new Language_CP_Syntax_Core.TmAnno(v1, v.value0));\n                };\n                if (v1 instanceof Language_CP_Syntax_Core.TmFold) {\n                    return go(new Language_CP_Syntax_Core.TmAnno(v1.value1, Language_CP_Syntax_Core.unfold(v.value0)));\n                };\n                return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.NaturalClosure.eval: \" + (\"impossible unfold \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v1)));\n            };\n            var $64 = Language_CP_Subtyping.isTopLike(v.value0);\n            if ($64) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(Language_CP_Syntax_Core.TmUnit.value);\n            };\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(go(v.value1))(go$prime);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmToString) {\n            return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Free.freeFunctor))(Language_CP_Semantics_Common.toString)(go(v.value0));\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmArray) {\n            return Language_CP_Semantics_Closure.closure(Control_Monad_Free.freeMonad)(e);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmRef) {\n            var e = Language_CP_Syntax_Core.read(v.value0);\n            var $70 = Language_CP_Syntax_Core.done(v.value0);\n            if ($70) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(e);\n            };\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Free.freeBind))(go(e))(function (e$prime) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(Language_CP_Syntax_Core.write(e$prime)(v.value0));\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmClosure && v.value1 instanceof Language_CP_Syntax_Core.TmRcd) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(v);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmClosure && v.value1 instanceof Language_CP_Syntax_Core.TmAbs) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(v);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmClosure && v.value1 instanceof Language_CP_Syntax_Core.TmTAbs) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(v);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmClosure && v.value1 instanceof Language_CP_Syntax_Core.TmArray) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Free.freeApplicative))(v);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmClosure) {\n            return Control_Monad_Reader_Class.local(Control_Monad_Reader_Trans.monadReaderReaderT(Control_Monad_Free.freeMonad))(Data_Function[\"const\"](v.value0))(go(v.value1));\n        };\n        return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.NaturalClosure.eval: \" + (\"well-typed programs don't get stuck, but got \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v)));\n    };\n    return Control_Monad_Trampoline.runTrampoline(Control_Monad_Reader_Trans.runReaderT(go(tm))(Data_Map_Internal.empty));\n};\nmodule.exports = {\n    \"eval\": $$eval\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Semantics/NaturalClosure.purs?");

/***/ }),

/***/ "./src/CP/Semantics/NaturalSubst.purs":
/*!********************************************!*\
  !*** ./src/CP/Semantics/NaturalSubst.purs ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_Free = __webpack_require__(/*! ./.spago/free/v6.0.1/src/Control/Monad/Free.purs */ \"./.spago/free/v6.0.1/src/Control/Monad/Free.purs\");\nvar Control_Monad_Trampoline = __webpack_require__(/*! ./.spago/free/v6.0.1/src/Control/Monad/Trampoline.purs */ \"./.spago/free/v6.0.1/src/Control/Monad/Trampoline.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Language_CP_Semantics_Common = __webpack_require__(/*! ./src/CP/Semantics/Common.purs */ \"./src/CP/Semantics/Common.purs\");\nvar Language_CP_Semantics_Subst = __webpack_require__(/*! ./src/CP/Semantics/Subst.purs */ \"./src/CP/Semantics/Subst.purs\");\nvar Language_CP_Subtyping = __webpack_require__(/*! ./src/CP/Subtyping.purs */ \"./src/CP/Subtyping.purs\");\nvar Language_CP_Syntax_Common = __webpack_require__(/*! ./src/CP/Syntax/Common.purs */ \"./src/CP/Syntax/Common.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar Partial_Unsafe = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.purs\");\nvar $$eval = (function () {\n    var go = function (v) {\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmInt) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmDouble) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmString) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmBool) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnit) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(Language_CP_Syntax_Core.TmUnit.value);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUndefined) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(Language_CP_Syntax_Core.TmUndefined.value);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnary) {\n            return Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Semantics_Common.unop(v.value0))(go(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmBinary) {\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(v.value1))(function (e1$prime) {\n                return Control_Bind.bind(Control_Monad_Free.freeBind)(go(v.value2))(function (e2$prime) {\n                    var e = Language_CP_Semantics_Common.binop(v.value0)(e1$prime)(e2$prime);\n                    if (v.value0 instanceof Language_CP_Syntax_Common.Index) {\n                        return go(e);\n                    };\n                    return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n                });\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmIf) {\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(v.value0))(function (e1$prime) {\n                if (e1$prime instanceof Language_CP_Syntax_Core.TmBool && e1$prime.value0) {\n                    return go(v.value1);\n                };\n                if (e1$prime instanceof Language_CP_Syntax_Core.TmBool && !e1$prime.value0) {\n                    return go(v.value2);\n                };\n                return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.NaturalSubst.eval: \" + (\"impossible if \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(e1$prime) + \" ...\")));\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmApp) {\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(v.value0))(function (e1$prime) {\n                var arg = (function () {\n                    if (v.value2) {\n                        return Language_CP_Semantics_Common.TmAnnoArg.create;\n                    };\n                    return Language_CP_Semantics_Common.TmArg.create;\n                })();\n                return go(Language_CP_Semantics_Subst.paraApp(e1$prime)(arg(new Language_CP_Syntax_Core.TmRef(Language_CP_Syntax_Core[\"new\"](v.value1)))));\n            });\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmAbs) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmFix) {\n            var ref = Language_CP_Syntax_Core[\"new\"](v);\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(Language_CP_Syntax_Core.tmSubst(v.value0)(new Language_CP_Syntax_Core.TmRef(ref))(v.value1)))(function (res) {\n                return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(Language_CP_Syntax_Core.write(res)(ref));\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmAnno) {\n            var go$prime = function ($copy_v1) {\n                var $tco_done = false;\n                var $tco_result;\n                function $tco_loop(v1) {\n                    if (v1 instanceof Language_CP_Syntax_Core.TmAnno) {\n                        $copy_v1 = v1.value0;\n                        return;\n                    };\n                    $tco_done = true;\n                    return go(v1);\n                };\n                while (!$tco_done) {\n                    $tco_result = $tco_loop($copy_v1);\n                };\n                return $tco_result;\n            };\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go$prime(v.value0))(function (e$prime) {\n                var v1 = Language_CP_Semantics_Subst.typedReduce(e$prime)(v.value1);\n                if (v1 instanceof Data_Maybe.Just) {\n                    return go(v1.value0);\n                };\n                if (v1 instanceof Data_Maybe.Nothing) {\n                    return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.NaturalSubst.eval: \" + (\"impossible typed reduction \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v)));\n                };\n                throw new Error(\"Failed pattern match at Language.CP.Semantics.NaturalSubst (line 51, column 7 - line 54, column 80): \" + [ v1.constructor.name ]);\n            });\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n            return Control_Apply.apply(Control_Monad_Free.freeApply)(Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Syntax_Core.TmMerge.create)(go(v.value0)))(go(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmRcd) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(new Language_CP_Syntax_Core.TmRcd(v.value0, v.value1, new Language_CP_Syntax_Core.TmRef(Language_CP_Syntax_Core[\"new\"](v.value2))));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmPrj) {\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(Data_Functor.flap(Control_Monad_Free.freeFunctor)(Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Semantics_Common.selectLabel)(go(v.value0)))(v.value1))(go);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmTApp) {\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(Data_Functor.flap(Control_Monad_Free.freeFunctor)(Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Semantics_Subst.paraApp)(go(v.value0)))(new Language_CP_Semantics_Common.TyArg(v.value1)))(go);\n        };\n        var e = v;\n        if (v instanceof Language_CP_Syntax_Core.TmTAbs) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmFold) {\n            return Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Syntax_Core.TmFold.create(v.value0))(go(v.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnfold) {\n            var go$prime = function (v1) {\n                if (v1 instanceof Language_CP_Syntax_Core.TmMerge) {\n                    return Control_Bind.composeKleisliFlipped(Control_Monad_Free.freeBind)(go$prime)(go)(new Language_CP_Syntax_Core.TmAnno(v1, v.value0));\n                };\n                if (v1 instanceof Language_CP_Syntax_Core.TmFold) {\n                    return go(new Language_CP_Syntax_Core.TmAnno(v1.value1, Language_CP_Syntax_Core.unfold(v.value0)));\n                };\n                return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.NaturalSubst.eval: \" + (\"impossible unfold \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v1)));\n            };\n            var $60 = Language_CP_Subtyping.isTopLike(v.value0);\n            if ($60) {\n                return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(Language_CP_Syntax_Core.TmUnit.value);\n            };\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(v.value1))(go$prime);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmToString) {\n            return Data_Functor.map(Control_Monad_Free.freeFunctor)(Language_CP_Semantics_Common.toString)(go(v.value0));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmArray) {\n            return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(new Language_CP_Syntax_Core.TmArray(v.value0, Data_Functor.map(Data_Functor.functorArray)(function ($68) {\n                return Language_CP_Syntax_Core.TmRef.create(Language_CP_Syntax_Core[\"new\"]($68));\n            })(v.value1)));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmRef) {\n            var e = Language_CP_Syntax_Core.read(v.value0);\n            var $66 = Language_CP_Syntax_Core.done(v.value0);\n            if ($66) {\n                return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(e);\n            };\n            return Control_Bind.bind(Control_Monad_Free.freeBind)(go(e))(function (e$prime) {\n                return Control_Applicative.pure(Control_Monad_Free.freeApplicative)(Language_CP_Syntax_Core.write(e$prime)(v.value0));\n            });\n        };\n        return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.NaturalSubst.eval: \" + (\"well-typed programs don't get stuck, but got \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v)));\n    };\n    return function ($69) {\n        return Control_Monad_Trampoline.runTrampoline(go($69));\n    };\n})();\nmodule.exports = {\n    \"eval\": $$eval\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Semantics/NaturalSubst.purs?");

/***/ }),

/***/ "./src/CP/Semantics/StepTrace.purs":
/*!*****************************************!*\
  !*** ./src/CP/Semantics/StepTrace.purs ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Category = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Category.purs */ \"./.spago/prelude/v5.0.1/src/Control/Category.purs\");\nvar Control_Monad_Writer = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Writer.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Writer.purs\");\nvar Control_Monad_Writer_Class = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Class.purs\");\nvar Control_Monad_Writer_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Writer/Trans.purs\");\nvar Control_Semigroupoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs */ \"./.spago/prelude/v5.0.1/src/Control/Semigroupoid.purs\");\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_Monoid_Endo = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid/Endo.purs\");\nvar Data_Newtype = __webpack_require__(/*! ./.spago/newtype/v4.0.0/src/Data/Newtype.purs */ \"./.spago/newtype/v4.0.0/src/Data/Newtype.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Language_CP_Semantics_Common = __webpack_require__(/*! ./src/CP/Semantics/Common.purs */ \"./src/CP/Semantics/Common.purs\");\nvar Language_CP_Semantics_Subst = __webpack_require__(/*! ./src/CP/Semantics/Subst.purs */ \"./src/CP/Semantics/Subst.purs\");\nvar Language_CP_Subtyping = __webpack_require__(/*! ./src/CP/Subtyping.purs */ \"./src/CP/Subtyping.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar Language_CP_Util = __webpack_require__(/*! ./src/CP/Util.purs */ \"./src/CP/Util.purs\");\nvar Partial_Unsafe = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.purs\");\nvar endoS = function (s) {\n    return function (v) {\n        return s + v;\n    };\n};\nvar congruence = function (w) {\n    return Control_Monad_Writer_Class.tell(Control_Monad_Writer_Trans.monadTellWriterT(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn))(Data_Identity.monadIdentity))(endoS(\"\\u2192 Step-\" + (w + \"\\x0a\")));\n};\nvar computation = function (w) {\n    return Control_Monad_Writer_Class.tell(Control_Monad_Writer_Trans.monadTellWriterT(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn))(Data_Identity.monadIdentity))(endoS(\"\\u2193 Step-\" + (w + \"\\x0a\")));\n};\nvar step = function (v) {\n    if (v instanceof Language_CP_Syntax_Core.TmUnary) {\n        if (Language_CP_Semantics_Subst.isValue(v.value1)) {\n            return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"UnaryV\"))(Language_CP_Semantics_Common.unop(v.value0)(v.value1));\n        };\n        if (Data_Boolean.otherwise) {\n            return Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"Unary\"))(Language_CP_Syntax_Core.TmUnary.create(v.value0)))(step(v.value1));\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmBinary) {\n        if (Language_CP_Semantics_Subst.isValue(v.value1) && Language_CP_Semantics_Subst.isValue(v.value2)) {\n            return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"BinaryV\"))(Language_CP_Semantics_Common.binop(v.value0)(v.value1)(v.value2));\n        };\n        if (Language_CP_Semantics_Subst.isValue(v.value1)) {\n            return Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"BinaryR\"))(Language_CP_Syntax_Core.TmBinary.create(v.value0)(v.value1)))(step(v.value2));\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Functor.flap(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"BinaryL\"))(Language_CP_Syntax_Core.TmBinary.create(v.value0)))(step(v.value1)))(v.value2);\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmIf && (v.value0 instanceof Language_CP_Syntax_Core.TmBool && v.value0.value0)) {\n        return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"IfTrue\"))(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmIf && (v.value0 instanceof Language_CP_Syntax_Core.TmBool && !v.value0.value0)) {\n        return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"IfFalse\"))(v.value2);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmIf) {\n        return Data_Functor.flap(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Data_Functor.flap(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"If\"))(Language_CP_Syntax_Core.TmIf.create))(step(v.value0)))(v.value1))(v.value2);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmApp) {\n        if (Language_CP_Semantics_Subst.isValue(v.value0)) {\n            return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"PApp\"))(Language_CP_Semantics_Subst.paraApp(v.value0)((function () {\n                if (v.value2) {\n                    return Language_CP_Semantics_Common.TmAnnoArg.create;\n                };\n                return Language_CP_Semantics_Common.TmArg.create;\n            })()(v.value1)));\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Functor.flap(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Data_Functor.flap(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"AppL\"))(Language_CP_Syntax_Core.TmApp.create))(step(v.value0)))(v.value1))(v.value2);\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmFix) {\n        return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"Fix\"))(Language_CP_Syntax_Core.tmSubst(v.value0)(v)(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmAnno && v.value0 instanceof Language_CP_Syntax_Core.TmAnno) {\n        return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"AnnoAnno\"))(new Language_CP_Syntax_Core.TmAnno(v.value0.value0, v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmAnno) {\n        if (Language_CP_Semantics_Subst.isValue(v.value0)) {\n            return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"AnnoV\"))(Language_CP_Util.unsafeFromJust(Language_CP_Semantics_Subst.typedReduce(v.value0)(v.value1)));\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Functor.flap(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"Anno\"))(Language_CP_Syntax_Core.TmAnno.create))(step(v.value0)))(v.value1);\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n        if (Language_CP_Semantics_Subst.isValue(v.value0)) {\n            return Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"MergeR\"))(Language_CP_Syntax_Core.TmMerge.create(v.value0)))(step(v.value1));\n        };\n        if (Language_CP_Semantics_Subst.isValue(v.value1)) {\n            return Data_Functor.flap(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"MergeL\"))(Language_CP_Syntax_Core.TmMerge.create))(step(v.value0)))(v.value1);\n        };\n        if (Data_Boolean.otherwise) {\n            return Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"Merge\"))(Language_CP_Syntax_Core.TmMerge.create))(step(v.value0)))(step(v.value1));\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmPrj) {\n        if (Language_CP_Semantics_Subst.isValue(v.value0)) {\n            return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"PProj\"))(Language_CP_Semantics_Common.selectLabel(v.value0)(v.value1));\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Functor.flap(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"Proj\"))(Language_CP_Syntax_Core.TmPrj.create))(step(v.value0)))(v.value1);\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmTApp) {\n        if (Language_CP_Semantics_Subst.isValue(v.value0)) {\n            return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"PTApp\"))(Language_CP_Semantics_Subst.paraApp(v.value0)(new Language_CP_Semantics_Common.TyArg(v.value1)));\n        };\n        if (Data_Boolean.otherwise) {\n            return Data_Functor.flap(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"TApp\"))(Language_CP_Syntax_Core.TmTApp.create))(step(v.value0)))(v.value1);\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmFold) {\n        return Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"Fold\"))(Language_CP_Syntax_Core.TmFold.create(v.value0)))(step(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmUnfold && Language_CP_Subtyping.isTopLike(v.value0)) {\n        return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"UnfoldTop\"))(Language_CP_Syntax_Core.TmUnit.value);\n    };\n    var v1 = function (v2) {\n        var v3 = function (v4) {\n            if (v instanceof Language_CP_Syntax_Core.TmUnfold && Data_Boolean.otherwise) {\n                return Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"Unfold\"))(Language_CP_Syntax_Core.TmUnfold.create(v.value0)))(step(v.value1));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmToString) {\n                if (Language_CP_Semantics_Subst.isValue(v.value0)) {\n                    return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"ToStringV\"))(Language_CP_Semantics_Common.toString(v.value0));\n                };\n                if (Data_Boolean.otherwise) {\n                    return Control_Apply.apply(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(congruence(\"ToString\"))(Language_CP_Syntax_Core.TmToString.create))(step(v.value0));\n                };\n            };\n            return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.StepTrace.step: \" + (\"well-typed programs don't get stuck, but got \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v)));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnfold) {\n            if (v.value1 instanceof Language_CP_Syntax_Core.TmMerge) {\n                return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"UnfoldMerge\"))(new Language_CP_Syntax_Core.TmUnfold(v.value0, new Language_CP_Syntax_Core.TmAnno(v.value1, v.value0)));\n            };\n            return v3(true);\n        };\n        return v3(true);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmUnfold) {\n        if (v.value1 instanceof Language_CP_Syntax_Core.TmFold) {\n            return Data_Functor.flap(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(computation(\"UnfoldFold\"))(Language_CP_Syntax_Core.TmAnno.create(v.value1.value1)))(Language_CP_Syntax_Core.unfold(v.value0));\n        };\n        return v1(true);\n    };\n    return v1(true);\n};\nvar $$eval = (function () {\n    var go = function (e) {\n        if (Language_CP_Semantics_Subst.isValue(e)) {\n            return Data_Functor.voidLeft(Control_Monad_Writer_Trans.functorWriterT(Data_Identity.functorIdentity))(Control_Monad_Writer_Class.tell(Control_Monad_Writer_Trans.monadTellWriterT(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn))(Data_Identity.monadIdentity))(endoS(Data_Show.show(Language_CP_Syntax_Core.showTm)(e) + \"\\x0a\")))(e);\n        };\n        if (Data_Boolean.otherwise) {\n            return Control_Bind.bind(Control_Monad_Writer_Trans.bindWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.bindIdentity))(Control_Apply.applySecond(Control_Monad_Writer_Trans.applyWriterT(Data_Monoid_Endo.semigroupEndo(Control_Semigroupoid.semigroupoidFn))(Data_Identity.applyIdentity))(Control_Monad_Writer_Class.tell(Control_Monad_Writer_Trans.monadTellWriterT(Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn))(Data_Identity.monadIdentity))(endoS(Data_Show.show(Language_CP_Syntax_Core.showTm)(e) + \"\\x0a\")))(step(e)))(go);\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Semantics.StepTrace (line 32, column 9 - line 32, column 28): \" + [ e.constructor.name ]);\n    };\n    var $63 = Data_Bifunctor.rmap(Data_Bifunctor.bifunctorTuple)(Data_Newtype.unwrap());\n    return function ($64) {\n        return $63(Control_Monad_Writer.runWriter(go($64)));\n    };\n})();\nmodule.exports = {\n    endoS: endoS,\n    computation: computation,\n    congruence: congruence,\n    \"eval\": $$eval,\n    step: step\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Semantics/StepTrace.purs?");

/***/ }),

/***/ "./src/CP/Semantics/Subst.purs":
/*!*************************************!*\
  !*** ./src/CP/Semantics/Subst.purs ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Language_CP_Semantics_Common = __webpack_require__(/*! ./src/CP/Semantics/Common.purs */ \"./src/CP/Semantics/Common.purs\");\nvar Language_CP_Subtyping = __webpack_require__(/*! ./src/CP/Subtyping.purs */ \"./src/CP/Subtyping.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar Language_CP_Util = __webpack_require__(/*! ./src/CP/Util.purs */ \"./src/CP/Util.purs\");\nvar Partial_Unsafe = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.purs\");\nvar paraApp = function (v) {\n    return function (v1) {\n        if (v instanceof Language_CP_Syntax_Core.TmUnit) {\n            return Language_CP_Syntax_Core.TmUnit.value;\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmAbs && (!v.value4 && v1 instanceof Language_CP_Semantics_Common.TmArg)) {\n            return Language_CP_Syntax_Core.tmSubst(v.value0)(v1.value0)(v.value1);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmAbs && (v.value4 && v1 instanceof Language_CP_Semantics_Common.TmArg)) {\n            return new Language_CP_Syntax_Core.TmAnno(Language_CP_Syntax_Core.tmSubst(v.value0)(v1.value0)(v.value1), v.value3);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmAbs && v1 instanceof Language_CP_Semantics_Common.TmAnnoArg) {\n            return new Language_CP_Syntax_Core.TmAnno(Language_CP_Syntax_Core.tmSubst(v.value0)(new Language_CP_Syntax_Core.TmAnno(v1.value0, v.value2))(v.value1), v.value3);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmTAbs && v1 instanceof Language_CP_Semantics_Common.TyArg) {\n            return Language_CP_Syntax_Core.tmTSubst(v.value0)(v1.value0)(v.value2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n            return new Language_CP_Syntax_Core.TmMerge(paraApp(v.value0)(v1), paraApp(v.value1)(v1));\n        };\n        return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Subst.paraApp: \" + (\"impossible application \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(v) + (\" \\u2022 \" + Data_Show.show(Language_CP_Semantics_Common.showArg)(v1)))));\n    };\n};\nvar isValue = function (v) {\n    if (v instanceof Language_CP_Syntax_Core.TmInt) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmDouble) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmString) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmBool) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmUnit) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmUndefined) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmAbs) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n        return isValue(v.value0) && isValue(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmRcd) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmTAbs) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmFold) {\n        return isValue(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmArray) {\n        return true;\n    };\n    return false;\n};\nvar typedReduce = function (v) {\n    return function (v1) {\n        if (!isValue(v)) {\n            return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Subst.typedReduce: \" + (Data_Show.show(Language_CP_Syntax_Core.showTm)(v) + \" is not a value\"));\n        };\n        if (Language_CP_Subtyping.isTopLike(v1)) {\n            return new Data_Maybe.Just(Language_CP_Syntax_Core.TmUnit.value);\n        };\n        var v2 = function (v3) {\n            if (v instanceof Language_CP_Syntax_Core.TmInt && v1 instanceof Language_CP_Syntax_Core.TyInt) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmInt(v.value0));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmDouble && v1 instanceof Language_CP_Syntax_Core.TyDouble) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmDouble(v.value0));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmString && v1 instanceof Language_CP_Syntax_Core.TyString) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmString(v.value0));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmBool && v1 instanceof Language_CP_Syntax_Core.TyBool) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmBool(v.value0));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmAbs && (v1 instanceof Language_CP_Syntax_Core.TyArrow && Language_CP_Subtyping.subtype(v.value3)(v1.value1))) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmAbs(v.value0, v.value1, v.value2, v1.value1, true));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n                return Control_Alt.alt(Data_Maybe.altMaybe)(typedReduce(v.value0)(v1))(typedReduce(v.value1)(v1));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmRcd && (v1 instanceof Language_CP_Syntax_Core.TyRcd && (v.value0 === v1.value0 && Language_CP_Subtyping.subtype(v.value1)(v1.value1)))) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmRcd(v.value0, v1.value1, v.value2));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmTAbs && (v1 instanceof Language_CP_Syntax_Core.TyForall && (Language_CP_Subtyping.subtype(v1.value1)(v.value1) && Language_CP_Subtyping.subtype(Language_CP_Syntax_Core.tySubst(v.value0)(new Language_CP_Syntax_Core.TyVar(v1.value0))(v.value3))(v1.value2)))) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmTAbs(v1.value0, v.value1, Language_CP_Syntax_Core.tmTSubst(v.value0)(new Language_CP_Syntax_Core.TyVar(v1.value0))(v.value2), v1.value2));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmFold && (v1 instanceof Language_CP_Syntax_Core.TyRec && Language_CP_Subtyping.subtype(v.value0)(v1))) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmFold(v1, v.value1));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmArray && (v1 instanceof Language_CP_Syntax_Core.TyArray && Language_CP_Subtyping.subtype(v.value0)(v1.value0))) {\n                return Data_Maybe.Just.create(new Language_CP_Syntax_Core.TmArray(v1.value0, v.value1));\n            };\n            return Data_Maybe.Nothing.value;\n        };\n        var $103 = Language_CP_Subtyping.split(v1);\n        if ($103 instanceof Data_Maybe.Just) {\n            var isOptionalRcd = function (v4) {\n                if (v4 instanceof Language_CP_Syntax_Core.TyRcd && v4.value2) {\n                    return new Data_Maybe.Just(Language_CP_Syntax_Core.TmUnit.value);\n                };\n                return Data_Maybe.Nothing.value;\n            };\n            var v21 = typedReduce(v)($103.value0.value1);\n            var v11 = typedReduce(v)($103.value0.value0);\n            var m2 = isOptionalRcd($103.value0.value1);\n            var m1 = isOptionalRcd($103.value0.value0);\n            return Control_Alt.alt(Data_Maybe.altMaybe)(Control_Alt.alt(Data_Maybe.altMaybe)(Control_Alt.alt(Data_Maybe.altMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(Data_Functor.map(Data_Maybe.functorMaybe)(Language_CP_Syntax_Core.TmMerge.create)(v11))(v21))(Control_Apply.applySecond(Data_Maybe.applyMaybe)(m1)(v21)))(Control_Apply.applySecond(Data_Maybe.applyMaybe)(m2)(v11)))(Control_Apply.applySecond(Data_Maybe.applyMaybe)(m1)(m2));\n        };\n        return v2(true);\n    };\n};\nvar step = function (v) {\n    if (v instanceof Language_CP_Syntax_Core.TmUnary) {\n        if (isValue(v.value1)) {\n            return Language_CP_Semantics_Common.unop(v.value0)(v.value1);\n        };\n        if (Data_Boolean.otherwise) {\n            return new Language_CP_Syntax_Core.TmUnary(v.value0, step(v.value1));\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmBinary) {\n        if (isValue(v.value1) && isValue(v.value2)) {\n            return Language_CP_Semantics_Common.binop(v.value0)(v.value1)(v.value2);\n        };\n        if (isValue(v.value1)) {\n            return new Language_CP_Syntax_Core.TmBinary(v.value0, v.value1, step(v.value2));\n        };\n        if (Data_Boolean.otherwise) {\n            return new Language_CP_Syntax_Core.TmBinary(v.value0, step(v.value1), v.value2);\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmIf && (v.value0 instanceof Language_CP_Syntax_Core.TmBool && v.value0.value0)) {\n        return v.value1;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmIf && (v.value0 instanceof Language_CP_Syntax_Core.TmBool && !v.value0.value0)) {\n        return v.value2;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmIf) {\n        return new Language_CP_Syntax_Core.TmIf(step(v.value0), v.value1, v.value2);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmApp) {\n        if (isValue(v.value0)) {\n            return paraApp(v.value0)((function () {\n                if (v.value2) {\n                    return Language_CP_Semantics_Common.TmAnnoArg.create;\n                };\n                return Language_CP_Semantics_Common.TmArg.create;\n            })()(v.value1));\n        };\n        if (Data_Boolean.otherwise) {\n            return new Language_CP_Syntax_Core.TmApp(step(v.value0), v.value1, v.value2);\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmFix) {\n        return Language_CP_Syntax_Core.tmSubst(v.value0)(v)(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmAnno && v.value0 instanceof Language_CP_Syntax_Core.TmAnno) {\n        return new Language_CP_Syntax_Core.TmAnno(v.value0.value0, v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmAnno) {\n        if (isValue(v.value0)) {\n            return Language_CP_Util.unsafeFromJust(typedReduce(v.value0)(v.value1));\n        };\n        if (Data_Boolean.otherwise) {\n            return new Language_CP_Syntax_Core.TmAnno(step(v.value0), v.value1);\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmMerge) {\n        if (isValue(v.value0)) {\n            return new Language_CP_Syntax_Core.TmMerge(v.value0, step(v.value1));\n        };\n        if (isValue(v.value1)) {\n            return new Language_CP_Syntax_Core.TmMerge(step(v.value0), v.value1);\n        };\n        if (Data_Boolean.otherwise) {\n            return new Language_CP_Syntax_Core.TmMerge(step(v.value0), step(v.value1));\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmPrj) {\n        if (isValue(v.value0)) {\n            return Language_CP_Semantics_Common.selectLabel(v.value0)(v.value1);\n        };\n        if (Data_Boolean.otherwise) {\n            return new Language_CP_Syntax_Core.TmPrj(step(v.value0), v.value1);\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmTApp) {\n        if (isValue(v.value0)) {\n            return paraApp(v.value0)(new Language_CP_Semantics_Common.TyArg(v.value1));\n        };\n        if (Data_Boolean.otherwise) {\n            return new Language_CP_Syntax_Core.TmTApp(step(v.value0), v.value1);\n        };\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmFold) {\n        return new Language_CP_Syntax_Core.TmFold(v.value0, step(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmUnfold && Language_CP_Subtyping.isTopLike(v.value0)) {\n        return Language_CP_Syntax_Core.TmUnit.value;\n    };\n    var v1 = function (v2) {\n        var v3 = function (v4) {\n            if (v instanceof Language_CP_Syntax_Core.TmUnfold && Data_Boolean.otherwise) {\n                return new Language_CP_Syntax_Core.TmUnfold(v.value0, step(v.value1));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TmToString) {\n                if (isValue(v.value0)) {\n                    return Language_CP_Semantics_Common.toString(v.value0);\n                };\n                if (Data_Boolean.otherwise) {\n                    return new Language_CP_Syntax_Core.TmToString(step(v.value0));\n                };\n            };\n            return Partial_Unsafe.unsafeCrashWith(\"CP.Semantics.Subst.step: \" + (\"well-typed programs don't get stuck, but got \" + Data_Show.show(Language_CP_Syntax_Core.showTm)(v)));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TmUnfold) {\n            if (v.value1 instanceof Language_CP_Syntax_Core.TmMerge) {\n                return new Language_CP_Syntax_Core.TmUnfold(v.value0, new Language_CP_Syntax_Core.TmAnno(v.value1, v.value0));\n            };\n            return v3(true);\n        };\n        return v3(true);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TmUnfold) {\n        if (v.value1 instanceof Language_CP_Syntax_Core.TmFold) {\n            return new Language_CP_Syntax_Core.TmAnno(v.value1.value1, Language_CP_Syntax_Core.unfold(v.value0));\n        };\n        return v1(true);\n    };\n    return v1(true);\n};\nvar $$eval = function ($copy_e) {\n    var $tco_done = false;\n    var $tco_result;\n    function $tco_loop(e) {\n        if (isValue(e)) {\n            $tco_done = true;\n            return e;\n        };\n        if (Data_Boolean.otherwise) {\n            $copy_e = step(e);\n            return;\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Semantics.Subst (line 14, column 1 - line 14, column 17): \" + [ e.constructor.name ]);\n    };\n    while (!$tco_done) {\n        $tco_result = $tco_loop($copy_e);\n    };\n    return $tco_result;\n};\nmodule.exports = {\n    \"eval\": $$eval,\n    step: step,\n    typedReduce: typedReduce,\n    paraApp: paraApp,\n    isValue: isValue\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Semantics/Subst.purs?");

/***/ }),

/***/ "./src/CP/Subtyping.purs":
/*!*******************************!*\
  !*** ./src/CP/Subtyping.purs ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar split = function (v) {\n    if (v instanceof Language_CP_Syntax_Core.TyAnd) {\n        return Data_Maybe.Just.create(new Data_Tuple.Tuple(v.value0, v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Core.TyArrow) {\n        return Control_Bind.bind(Data_Maybe.bindMaybe)(split(v.value1))(function (v1) {\n            return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TyArrow(v.value0, v1.value0, v.value2), new Language_CP_Syntax_Core.TyArrow(v.value0, v1.value1, v.value2)));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Core.TyRcd && !v.value2) {\n        return Control_Bind.bind(Data_Maybe.bindMaybe)(split(v.value1))(function (v1) {\n            return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TyRcd(v.value0, v1.value0, false), new Language_CP_Syntax_Core.TyRcd(v.value0, v1.value1, false)));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Core.TyForall) {\n        return Control_Bind.bind(Data_Maybe.bindMaybe)(split(v.value2))(function (v1) {\n            return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TyForall(v.value0, v.value1, v1.value0), new Language_CP_Syntax_Core.TyForall(v.value0, v.value1, v1.value1)));\n        });\n    };\n    return Data_Maybe.Nothing.value;\n};\nvar isTopLike = function (v) {\n    if (v instanceof Language_CP_Syntax_Core.TyTop) {\n        return true;\n    };\n    if (v instanceof Language_CP_Syntax_Core.TyArrow) {\n        return isTopLike(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TyAnd) {\n        return isTopLike(v.value0) && isTopLike(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TyRcd) {\n        return isTopLike(v.value1);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TyForall) {\n        return isTopLike(v.value2);\n    };\n    if (v instanceof Language_CP_Syntax_Core.TyRec) {\n        return isTopLike(v.value1);\n    };\n    return false;\n};\nvar subtype = function (v) {\n    return function (v1) {\n        if (v instanceof Language_CP_Syntax_Core.TyBot) {\n            return true;\n        };\n        if (isTopLike(v1)) {\n            return true;\n        };\n        var v2 = function (v3) {\n            if (v instanceof Language_CP_Syntax_Core.TyArrow && v1 instanceof Language_CP_Syntax_Core.TyArrow) {\n                return subtype(v1.value0)(v.value0) && subtype(v.value1)(v1.value1);\n            };\n            if (v instanceof Language_CP_Syntax_Core.TyAnd) {\n                return subtype(v.value0)(v1) || subtype(v.value1)(v1);\n            };\n            if (v1 instanceof Language_CP_Syntax_Core.TyRcd && v1.value2) {\n                return true;\n            };\n            if (v instanceof Language_CP_Syntax_Core.TyRcd && (!v.value2 && (v1 instanceof Language_CP_Syntax_Core.TyRcd && !v1.value2))) {\n                return v.value0 === v1.value0 && subtype(v.value1)(v1.value1);\n            };\n            if (v instanceof Language_CP_Syntax_Core.TyForall && v1 instanceof Language_CP_Syntax_Core.TyForall) {\n                return subtype(v1.value1)(v.value1) && subtype(v.value2)(Language_CP_Syntax_Core.tySubst(v1.value0)(new Language_CP_Syntax_Core.TyVar(v.value0))(v1.value2));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TyRec && v1 instanceof Language_CP_Syntax_Core.TyRec) {\n                var t2$prime = Language_CP_Syntax_Core.tySubst(v1.value0)(new Language_CP_Syntax_Core.TyVar(v.value0))(v1.value1);\n                return subtype(Language_CP_Syntax_Core.tySubst(v.value0)(new Language_CP_Syntax_Core.TyRcd(v.value0, v.value1, false))(v.value1))(Language_CP_Syntax_Core.tySubst(v1.value0)(new Language_CP_Syntax_Core.TyRcd(v.value0, t2$prime, false))(v1.value1));\n            };\n            if (v instanceof Language_CP_Syntax_Core.TyArray && v1 instanceof Language_CP_Syntax_Core.TyArray) {\n                return subtype(v.value0)(v1.value0);\n            };\n            if (Data_Eq.eq(Language_CP_Syntax_Core.eqTy)(v)(v1)) {\n                return true;\n            };\n            if (Data_Boolean.otherwise) {\n                return false;\n            };\n            throw new Error(\"Failed pattern match at Language.CP.Subtyping (line 9, column 1 - line 9, column 31): \" + [ v.constructor.name, v1.constructor.name ]);\n        };\n        var $81 = split(v1);\n        if ($81 instanceof Data_Maybe.Just) {\n            return subtype(v)($81.value0.value0) && subtype(v)($81.value0.value1);\n        };\n        return v2(true);\n    };\n};\nvar supertype = Data_Function.flip(subtype);\nvar aeq = function (v) {\n    return function (v1) {\n        if (v instanceof Language_CP_Syntax_Core.TyArrow && v1 instanceof Language_CP_Syntax_Core.TyArrow) {\n            return aeq(v.value0)(v1.value0) && aeq(v.value1)(v1.value1);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyAnd && v1 instanceof Language_CP_Syntax_Core.TyAnd) {\n            return aeq(v.value0)(v1.value0) && aeq(v.value1)(v1.value1);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyRcd && v1 instanceof Language_CP_Syntax_Core.TyRcd) {\n            return v.value0 === v1.value0 && (aeq(v.value1)(v1.value1) && v.value2 === v1.value2);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyForall && v1 instanceof Language_CP_Syntax_Core.TyForall) {\n            return aeq(v.value1)(v1.value1) && aeq(v.value2)(Language_CP_Syntax_Core.tySubst(v1.value0)(new Language_CP_Syntax_Core.TyVar(v.value0))(v1.value2));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyRec && v1 instanceof Language_CP_Syntax_Core.TyRec) {\n            return aeq(v.value1)(Language_CP_Syntax_Core.tySubst(v1.value0)(new Language_CP_Syntax_Core.TyVar(v.value0))(v1.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyArray && v1 instanceof Language_CP_Syntax_Core.TyArray) {\n            return aeq(v.value0)(v1.value0);\n        };\n        if (Data_Eq.eq(Language_CP_Syntax_Core.eqTy)(v)(v1)) {\n            return true;\n        };\n        if (Data_Boolean.otherwise) {\n            return false;\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Subtyping (line 54, column 1 - line 54, column 27): \" + [ v.constructor.name, v1.constructor.name ]);\n    };\n};\nmodule.exports = {\n    subtype: subtype,\n    supertype: supertype,\n    isTopLike: isTopLike,\n    split: split,\n    aeq: aeq\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Subtyping.purs?");

/***/ }),

/***/ "./src/CP/Syntax/Common.purs":
/*!***********************************!*\
  !*** ./src/CP/Syntax/Common.purs ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Neg = (function () {\n    function Neg() {\n\n    };\n    Neg.value = new Neg();\n    return Neg;\n})();\nvar Not = (function () {\n    function Not() {\n\n    };\n    Not.value = new Not();\n    return Not;\n})();\nvar Len = (function () {\n    function Len() {\n\n    };\n    Len.value = new Len();\n    return Len;\n})();\nvar And = (function () {\n    function And() {\n\n    };\n    And.value = new And();\n    return And;\n})();\nvar Or = (function () {\n    function Or() {\n\n    };\n    Or.value = new Or();\n    return Or;\n})();\nvar KnStar = (function () {\n    function KnStar() {\n\n    };\n    KnStar.value = new KnStar();\n    return KnStar;\n})();\nvar KnArr = (function () {\n    function KnArr(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    KnArr.create = function (value0) {\n        return function (value1) {\n            return new KnArr(value0, value1);\n        };\n    };\n    return KnArr;\n})();\nvar Eql = (function () {\n    function Eql() {\n\n    };\n    Eql.value = new Eql();\n    return Eql;\n})();\nvar Neq = (function () {\n    function Neq() {\n\n    };\n    Neq.value = new Neq();\n    return Neq;\n})();\nvar Lt = (function () {\n    function Lt() {\n\n    };\n    Lt.value = new Lt();\n    return Lt;\n})();\nvar Le = (function () {\n    function Le() {\n\n    };\n    Le.value = new Le();\n    return Le;\n})();\nvar Gt = (function () {\n    function Gt() {\n\n    };\n    Gt.value = new Gt();\n    return Gt;\n})();\nvar Ge = (function () {\n    function Ge() {\n\n    };\n    Ge.value = new Ge();\n    return Ge;\n})();\nvar Add = (function () {\n    function Add() {\n\n    };\n    Add.value = new Add();\n    return Add;\n})();\nvar Sub = (function () {\n    function Sub() {\n\n    };\n    Sub.value = new Sub();\n    return Sub;\n})();\nvar Mul = (function () {\n    function Mul() {\n\n    };\n    Mul.value = new Mul();\n    return Mul;\n})();\nvar Div = (function () {\n    function Div() {\n\n    };\n    Div.value = new Div();\n    return Div;\n})();\nvar Mod = (function () {\n    function Mod() {\n\n    };\n    Mod.value = new Mod();\n    return Mod;\n})();\nvar Arith = (function () {\n    function Arith(value0) {\n        this.value0 = value0;\n    };\n    Arith.create = function (value0) {\n        return new Arith(value0);\n    };\n    return Arith;\n})();\nvar Comp = (function () {\n    function Comp(value0) {\n        this.value0 = value0;\n    };\n    Comp.create = function (value0) {\n        return new Comp(value0);\n    };\n    return Comp;\n})();\nvar Logic = (function () {\n    function Logic(value0) {\n        this.value0 = value0;\n    };\n    Logic.create = function (value0) {\n        return new Logic(value0);\n    };\n    return Logic;\n})();\nvar Append = (function () {\n    function Append() {\n\n    };\n    Append.value = new Append();\n    return Append;\n})();\nvar Index = (function () {\n    function Index() {\n\n    };\n    Index.value = new Index();\n    return Index;\n})();\nvar Coalesce = (function () {\n    function Coalesce() {\n\n    };\n    Coalesce.value = new Coalesce();\n    return Coalesce;\n})();\nvar showUnOp = {\n    show: function (v) {\n        if (v instanceof Neg) {\n            return \"-\";\n        };\n        if (v instanceof Not) {\n            return \"!\";\n        };\n        if (v instanceof Len) {\n            return \"#\";\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Common (line 23, column 1 - line 26, column 17): \" + [ v.constructor.name ]);\n    }\n};\nvar showLogicOp = {\n    show: function (v) {\n        if (v instanceof And) {\n            return \"&&\";\n        };\n        if (v instanceof Or) {\n            return \"||\";\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Common (line 62, column 1 - line 64, column 18): \" + [ v.constructor.name ]);\n    }\n};\nvar showKind = {\n    show: function (v) {\n        if (v instanceof KnStar) {\n            return \"*\";\n        };\n        if (v instanceof KnArr) {\n            return Data_Show.show(showKind)(v.value0) + (\" \\u2192 \" + Data_Show.show(showKind)(v.value1));\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Common (line 13, column 1 - line 15, column 51): \" + [ v.constructor.name ]);\n    }\n};\nvar showCompOp = {\n    show: function (v) {\n        if (v instanceof Eql) {\n            return \"==\";\n        };\n        if (v instanceof Neq) {\n            return \"!=\";\n        };\n        if (v instanceof Lt) {\n            return \"<\";\n        };\n        if (v instanceof Le) {\n            return \"<=\";\n        };\n        if (v instanceof Gt) {\n            return \">\";\n        };\n        if (v instanceof Ge) {\n            return \">=\";\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Common (line 54, column 1 - line 60, column 18): \" + [ v.constructor.name ]);\n    }\n};\nvar showArithOp = {\n    show: function (v) {\n        if (v instanceof Add) {\n            return \"+\";\n        };\n        if (v instanceof Sub) {\n            return \"-\";\n        };\n        if (v instanceof Mul) {\n            return \"*\";\n        };\n        if (v instanceof Div) {\n            return \"/\";\n        };\n        if (v instanceof Mod) {\n            return \"%\";\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Common (line 47, column 1 - line 52, column 17): \" + [ v.constructor.name ]);\n    }\n};\nvar showBinOp = {\n    show: function (v) {\n        if (v instanceof Arith) {\n            return Data_Show.show(showArithOp)(v.value0);\n        };\n        if (v instanceof Comp) {\n            return Data_Show.show(showCompOp)(v.value0);\n        };\n        if (v instanceof Logic) {\n            return Data_Show.show(showLogicOp)(v.value0);\n        };\n        if (v instanceof Append) {\n            return \"++\";\n        };\n        if (v instanceof Index) {\n            return \"!!\";\n        };\n        if (v instanceof Coalesce) {\n            return \"??\";\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Common (line 39, column 1 - line 45, column 23): \" + [ v.constructor.name ]);\n    }\n};\nvar eqKind = {\n    eq: function (x) {\n        return function (y) {\n            if (x instanceof KnStar && y instanceof KnStar) {\n                return true;\n            };\n            if (x instanceof KnArr && y instanceof KnArr) {\n                return Data_Eq.eq(eqKind)(x.value0)(y.value0) && Data_Eq.eq(eqKind)(x.value1)(y.value1);\n            };\n            return false;\n        };\n    }\n};\nvar parens = function (str) {\n    return \"(\" + (str + \")\");\n};\nvar brackets = function (str) {\n    return \"[\" + (str + \"]\");\n};\nvar braces = function (str) {\n    return \"{ \" + (str + \" }\");\n};\nvar angles = function (str) {\n    return \"<\" + (str + \">\");\n};\nmodule.exports = {\n    KnStar: KnStar,\n    KnArr: KnArr,\n    Neg: Neg,\n    Not: Not,\n    Len: Len,\n    Arith: Arith,\n    Comp: Comp,\n    Logic: Logic,\n    Append: Append,\n    Index: Index,\n    Coalesce: Coalesce,\n    Add: Add,\n    Sub: Sub,\n    Mul: Mul,\n    Div: Div,\n    Mod: Mod,\n    Eql: Eql,\n    Neq: Neq,\n    Lt: Lt,\n    Le: Le,\n    Gt: Gt,\n    Ge: Ge,\n    And: And,\n    Or: Or,\n    parens: parens,\n    braces: braces,\n    angles: angles,\n    brackets: brackets,\n    showKind: showKind,\n    eqKind: eqKind,\n    showUnOp: showUnOp,\n    showBinOp: showBinOp,\n    showArithOp: showArithOp,\n    showCompOp: showCompOp,\n    showLogicOp: showLogicOp\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Syntax/Common.purs?");

/***/ }),

/***/ "./src/CP/Syntax/Core.purs":
/*!*********************************!*\
  !*** ./src/CP/Syntax/Core.purs ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar $foreign = __webpack_require__(/*! ./src/CP/Syntax/Core.js */ \"./src/CP/Syntax/Core.js\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Map_Internal = __webpack_require__(/*! ./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs */ \"./.spago/ordered-collections/v2.0.1/src/Data/Map/Internal.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Language_CP_Syntax_Common = __webpack_require__(/*! ./src/CP/Syntax/Common.purs */ \"./src/CP/Syntax/Common.purs\");\nvar Language_CP_Util = __webpack_require__(/*! ./src/CP/Util.purs */ \"./src/CP/Util.purs\");\nvar TyInt = (function () {\n    function TyInt() {\n\n    };\n    TyInt.value = new TyInt();\n    return TyInt;\n})();\nvar TyDouble = (function () {\n    function TyDouble() {\n\n    };\n    TyDouble.value = new TyDouble();\n    return TyDouble;\n})();\nvar TyString = (function () {\n    function TyString() {\n\n    };\n    TyString.value = new TyString();\n    return TyString;\n})();\nvar TyBool = (function () {\n    function TyBool() {\n\n    };\n    TyBool.value = new TyBool();\n    return TyBool;\n})();\nvar TyTop = (function () {\n    function TyTop() {\n\n    };\n    TyTop.value = new TyTop();\n    return TyTop;\n})();\nvar TyBot = (function () {\n    function TyBot() {\n\n    };\n    TyBot.value = new TyBot();\n    return TyBot;\n})();\nvar TyArrow = (function () {\n    function TyArrow(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TyArrow.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TyArrow(value0, value1, value2);\n            };\n        };\n    };\n    return TyArrow;\n})();\nvar TyAnd = (function () {\n    function TyAnd(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TyAnd.create = function (value0) {\n        return function (value1) {\n            return new TyAnd(value0, value1);\n        };\n    };\n    return TyAnd;\n})();\nvar TyRcd = (function () {\n    function TyRcd(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TyRcd.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TyRcd(value0, value1, value2);\n            };\n        };\n    };\n    return TyRcd;\n})();\nvar TyVar = (function () {\n    function TyVar(value0) {\n        this.value0 = value0;\n    };\n    TyVar.create = function (value0) {\n        return new TyVar(value0);\n    };\n    return TyVar;\n})();\nvar TyForall = (function () {\n    function TyForall(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TyForall.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TyForall(value0, value1, value2);\n            };\n        };\n    };\n    return TyForall;\n})();\nvar TyRec = (function () {\n    function TyRec(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TyRec.create = function (value0) {\n        return function (value1) {\n            return new TyRec(value0, value1);\n        };\n    };\n    return TyRec;\n})();\nvar TyArray = (function () {\n    function TyArray(value0) {\n        this.value0 = value0;\n    };\n    TyArray.create = function (value0) {\n        return new TyArray(value0);\n    };\n    return TyArray;\n})();\nvar TmBind = (function () {\n    function TmBind(value0) {\n        this.value0 = value0;\n    };\n    TmBind.create = function (value0) {\n        return new TmBind(value0);\n    };\n    return TmBind;\n})();\nvar TyBind = (function () {\n    function TyBind(value0) {\n        this.value0 = value0;\n    };\n    TyBind.create = function (value0) {\n        return new TyBind(value0);\n    };\n    return TyBind;\n})();\nvar TmInt = (function () {\n    function TmInt(value0) {\n        this.value0 = value0;\n    };\n    TmInt.create = function (value0) {\n        return new TmInt(value0);\n    };\n    return TmInt;\n})();\nvar TmDouble = (function () {\n    function TmDouble(value0) {\n        this.value0 = value0;\n    };\n    TmDouble.create = function (value0) {\n        return new TmDouble(value0);\n    };\n    return TmDouble;\n})();\nvar TmString = (function () {\n    function TmString(value0) {\n        this.value0 = value0;\n    };\n    TmString.create = function (value0) {\n        return new TmString(value0);\n    };\n    return TmString;\n})();\nvar TmBool = (function () {\n    function TmBool(value0) {\n        this.value0 = value0;\n    };\n    TmBool.create = function (value0) {\n        return new TmBool(value0);\n    };\n    return TmBool;\n})();\nvar TmUnit = (function () {\n    function TmUnit() {\n\n    };\n    TmUnit.value = new TmUnit();\n    return TmUnit;\n})();\nvar TmUndefined = (function () {\n    function TmUndefined() {\n\n    };\n    TmUndefined.value = new TmUndefined();\n    return TmUndefined;\n})();\nvar TmUnary = (function () {\n    function TmUnary(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmUnary.create = function (value0) {\n        return function (value1) {\n            return new TmUnary(value0, value1);\n        };\n    };\n    return TmUnary;\n})();\nvar TmBinary = (function () {\n    function TmBinary(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TmBinary.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TmBinary(value0, value1, value2);\n            };\n        };\n    };\n    return TmBinary;\n})();\nvar TmIf = (function () {\n    function TmIf(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TmIf.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TmIf(value0, value1, value2);\n            };\n        };\n    };\n    return TmIf;\n})();\nvar TmVar = (function () {\n    function TmVar(value0) {\n        this.value0 = value0;\n    };\n    TmVar.create = function (value0) {\n        return new TmVar(value0);\n    };\n    return TmVar;\n})();\nvar TmApp = (function () {\n    function TmApp(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TmApp.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TmApp(value0, value1, value2);\n            };\n        };\n    };\n    return TmApp;\n})();\nvar TmAbs = (function () {\n    function TmAbs(value0, value1, value2, value3, value4) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n        this.value4 = value4;\n    };\n    TmAbs.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return function (value4) {\n                        return new TmAbs(value0, value1, value2, value3, value4);\n                    };\n                };\n            };\n        };\n    };\n    return TmAbs;\n})();\nvar TmFix = (function () {\n    function TmFix(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TmFix.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TmFix(value0, value1, value2);\n            };\n        };\n    };\n    return TmFix;\n})();\nvar TmAnno = (function () {\n    function TmAnno(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmAnno.create = function (value0) {\n        return function (value1) {\n            return new TmAnno(value0, value1);\n        };\n    };\n    return TmAnno;\n})();\nvar TmMerge = (function () {\n    function TmMerge(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmMerge.create = function (value0) {\n        return function (value1) {\n            return new TmMerge(value0, value1);\n        };\n    };\n    return TmMerge;\n})();\nvar TmRcd = (function () {\n    function TmRcd(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TmRcd.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TmRcd(value0, value1, value2);\n            };\n        };\n    };\n    return TmRcd;\n})();\nvar TmPrj = (function () {\n    function TmPrj(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmPrj.create = function (value0) {\n        return function (value1) {\n            return new TmPrj(value0, value1);\n        };\n    };\n    return TmPrj;\n})();\nvar TmTApp = (function () {\n    function TmTApp(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmTApp.create = function (value0) {\n        return function (value1) {\n            return new TmTApp(value0, value1);\n        };\n    };\n    return TmTApp;\n})();\nvar TmTAbs = (function () {\n    function TmTAbs(value0, value1, value2, value3) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n    };\n    TmTAbs.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return new TmTAbs(value0, value1, value2, value3);\n                };\n            };\n        };\n    };\n    return TmTAbs;\n})();\nvar TmFold = (function () {\n    function TmFold(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmFold.create = function (value0) {\n        return function (value1) {\n            return new TmFold(value0, value1);\n        };\n    };\n    return TmFold;\n})();\nvar TmUnfold = (function () {\n    function TmUnfold(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmUnfold.create = function (value0) {\n        return function (value1) {\n            return new TmUnfold(value0, value1);\n        };\n    };\n    return TmUnfold;\n})();\nvar TmToString = (function () {\n    function TmToString(value0) {\n        this.value0 = value0;\n    };\n    TmToString.create = function (value0) {\n        return new TmToString(value0);\n    };\n    return TmToString;\n})();\nvar TmArray = (function () {\n    function TmArray(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmArray.create = function (value0) {\n        return function (value1) {\n            return new TmArray(value0, value1);\n        };\n    };\n    return TmArray;\n})();\nvar TmRef = (function () {\n    function TmRef(value0) {\n        this.value0 = value0;\n    };\n    TmRef.create = function (value0) {\n        return new TmRef(value0);\n    };\n    return TmRef;\n})();\nvar TmClosure = (function () {\n    function TmClosure(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmClosure.create = function (value0) {\n        return function (value1) {\n            return new TmClosure(value0, value1);\n        };\n    };\n    return TmClosure;\n})();\nvar TmHAbs = (function () {\n    function TmHAbs(value0, value1, value2, value3) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n    };\n    TmHAbs.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return new TmHAbs(value0, value1, value2, value3);\n                };\n            };\n        };\n    };\n    return TmHAbs;\n})();\nvar TmHFix = (function () {\n    function TmHFix(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmHFix.create = function (value0) {\n        return function (value1) {\n            return new TmHFix(value0, value1);\n        };\n    };\n    return TmHFix;\n})();\nvar TmHTAbs = (function () {\n    function TmHTAbs(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TmHTAbs.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TmHTAbs(value0, value1, value2);\n            };\n        };\n    };\n    return TmHTAbs;\n})();\nvar showTy = {\n    show: function (v) {\n        if (v instanceof TyInt) {\n            return \"Int\";\n        };\n        if (v instanceof TyDouble) {\n            return \"Double\";\n        };\n        if (v instanceof TyString) {\n            return \"String\";\n        };\n        if (v instanceof TyBool) {\n            return \"Bool\";\n        };\n        if (v instanceof TyTop) {\n            return \"\\u22a4\";\n        };\n        if (v instanceof TyBot) {\n            return \"\\u22a5\";\n        };\n        if (v instanceof TyArrow && v.value2) {\n            return \"Trait\" + Language_CP_Syntax_Common.angles(Language_CP_Util.beside(Data_Show.show(showTy)(v.value0))(Language_CP_Util.beside(\"=>\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TyArrow && !v.value2) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTy)(v.value0))(Language_CP_Util.beside(\"\\u2192\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TyAnd) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTy)(v.value0))(Language_CP_Util.beside(\"&\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TyRcd) {\n            return Language_CP_Syntax_Common.braces(v.value0 + Language_CP_Util.beside((function () {\n                if (v.value2) {\n                    return \"?\";\n                };\n                return \"\";\n            })())(Language_CP_Util.beside(\":\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TyVar) {\n            return v.value0;\n        };\n        if (v instanceof TyForall) {\n            return Language_CP_Syntax_Common.parens(\"\\u2200\" + Language_CP_Util.beside(v.value0)(Language_CP_Util.beside(\"*\")(Data_Show.show(showTy)(v.value1) + Language_CP_Util.beside(\".\")(Data_Show.show(showTy)(v.value2)))));\n        };\n        if (v instanceof TyRec) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"\\u03bc\")(v.value0 + Language_CP_Util.beside(\".\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TyArray) {\n            return Language_CP_Syntax_Common.brackets(Data_Show.show(showTy)(v.value0));\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Core (line 34, column 1 - line 52, column 39): \" + [ v.constructor.name ]);\n    }\n};\nvar showTm = {\n    show: function (v) {\n        if (v instanceof TmInt) {\n            return Data_Show.show(Data_Show.showInt)(v.value0);\n        };\n        if (v instanceof TmDouble) {\n            return Data_Show.show(Data_Show.showNumber)(v.value0);\n        };\n        if (v instanceof TmString) {\n            return Data_Show.show(Data_Show.showString)(v.value0);\n        };\n        if (v instanceof TmBool) {\n            return Data_Show.show(Data_Show.showBoolean)(v.value0);\n        };\n        if (v instanceof TmUnit) {\n            return \"()\";\n        };\n        if (v instanceof TmUndefined) {\n            return \"undefined\";\n        };\n        if (v instanceof TmUnary) {\n            return Data_Show.show(Language_CP_Syntax_Common.showUnOp)(v.value0) + Data_Show.show(showTm)(v.value1);\n        };\n        if (v instanceof TmBinary) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value1))(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Common.showBinOp)(v.value0))(Data_Show.show(showTm)(v.value2))));\n        };\n        if (v instanceof TmIf) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"if\")(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Language_CP_Util.beside(\"then\")(Language_CP_Util.beside(Data_Show.show(showTm)(v.value1))(Language_CP_Util.beside(\"else\")(Data_Show.show(showTm)(v.value2)))))));\n        };\n        if (v instanceof TmVar) {\n            return v.value0;\n        };\n        if (v instanceof TmApp) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Data_Show.show(showTm)(v.value1)));\n        };\n        if (v instanceof TmAbs) {\n            return Language_CP_Syntax_Common.parens(\"\\u03bb\" + (v.value0 + Language_CP_Util.beside(\".\")(Language_CP_Util.beside(Data_Show.show(showTm)(v.value1))(Language_CP_Util.beside(\":\")(Language_CP_Util.beside(Data_Show.show(showTy)(v.value2))(Language_CP_Util.beside(\"\\u2192\")(Data_Show.show(showTy)(v.value3))))))));\n        };\n        if (v instanceof TmFix) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"fix\")(v.value0 + Language_CP_Util.beside(\".\")(Language_CP_Util.beside(Data_Show.show(showTm)(v.value1))(Language_CP_Util.beside(\":\")(Data_Show.show(showTy)(v.value2))))));\n        };\n        if (v instanceof TmAnno) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Language_CP_Util.beside(\":\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TmMerge) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Language_CP_Util.beside(\",\")(Data_Show.show(showTm)(v.value1))));\n        };\n        if (v instanceof TmRcd) {\n            return Language_CP_Syntax_Common.braces(Language_CP_Util.beside(v.value0)(Language_CP_Util.beside(\":\")(Language_CP_Util.beside(Data_Show.show(showTy)(v.value1))(Language_CP_Util.beside(\"=\")(Data_Show.show(showTm)(v.value2))))));\n        };\n        if (v instanceof TmPrj) {\n            return Data_Show.show(showTm)(v.value0) + (\".\" + v.value1);\n        };\n        if (v instanceof TmTApp) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(\"@\" + Data_Show.show(showTy)(v.value1)));\n        };\n        if (v instanceof TmTAbs) {\n            return Language_CP_Syntax_Common.parens(\"\\u039b\" + (v.value0 + Language_CP_Util.beside(\".\")(Language_CP_Util.beside(Data_Show.show(showTm)(v.value2))(Language_CP_Util.beside(\":\")(\"\\u2200\" + Language_CP_Util.beside(v.value0)(Language_CP_Util.beside(\"*\")(Data_Show.show(showTy)(v.value1) + Language_CP_Util.beside(\".\")(Data_Show.show(showTy)(v.value3)))))))));\n        };\n        if (v instanceof TmFold) {\n            return Language_CP_Syntax_Common.parens(\"fold @\" + Language_CP_Util.beside(Data_Show.show(showTy)(v.value0))(Data_Show.show(showTm)(v.value1)));\n        };\n        if (v instanceof TmUnfold) {\n            return Language_CP_Syntax_Common.parens(\"unfold @\" + Language_CP_Util.beside(Data_Show.show(showTy)(v.value0))(Data_Show.show(showTm)(v.value1)));\n        };\n        if (v instanceof TmToString) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"toString\")(Data_Show.show(showTm)(v.value0)));\n        };\n        if (v instanceof TmArray) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Language_CP_Syntax_Common.brackets(Data_Foldable.intercalate(Data_Foldable.foldableArray)(Data_Monoid.monoidString)(\"; \")(Data_Functor.map(Data_Functor.functorArray)(Data_Show.show(showTm))(v.value1))))(Language_CP_Util.beside(\":\")(Language_CP_Syntax_Common.brackets(Data_Show.show(showTy)(v.value0)))));\n        };\n        if (v instanceof TmRef) {\n            return Language_CP_Syntax_Common.angles(\"Ref\");\n        };\n        if (v instanceof TmClosure) {\n            return Language_CP_Syntax_Common.angles(Language_CP_Util.beside(\"Closure\")(Data_Show.show(showTm)(v.value1)));\n        };\n        if (v instanceof TmHAbs) {\n            return Language_CP_Syntax_Common.angles(Language_CP_Util.beside(\"HOAS\")(Language_CP_Util.beside(Data_Show.show(showTy)(v.value1))(Language_CP_Util.beside(\"\\u2192\")(Data_Show.show(showTy)(v.value2)))));\n        };\n        if (v instanceof TmHFix) {\n            return Language_CP_Syntax_Common.angles(Language_CP_Util.beside(\"HOAS fix\")(Data_Show.show(showTy)(v.value1)));\n        };\n        if (v instanceof TmHTAbs) {\n            return Language_CP_Syntax_Common.angles(Language_CP_Util.beside(\"HOAS \\u2200*\")(Data_Show.show(showTy)(v.value1)));\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Core (line 90, column 1 - line 123, column 63): \" + [ v.constructor.name ]);\n    }\n};\nvar showEvalBind = {\n    show: function (v) {\n        if (v instanceof TmBind) {\n            return Data_Show.show(showTm)(v.value0);\n        };\n        if (v instanceof TyBind && v.value0 instanceof Data_Maybe.Just) {\n            return Data_Show.show(showTy)(v.value0.value0);\n        };\n        if (v instanceof TyBind && v.value0 instanceof Data_Maybe.Nothing) {\n            return \"*\";\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Core (line 248, column 1 - line 251, column 30): \" + [ v.constructor.name ]);\n    }\n};\nvar eqTy = {\n    eq: function (x) {\n        return function (y) {\n            if (x instanceof TyInt && y instanceof TyInt) {\n                return true;\n            };\n            if (x instanceof TyDouble && y instanceof TyDouble) {\n                return true;\n            };\n            if (x instanceof TyString && y instanceof TyString) {\n                return true;\n            };\n            if (x instanceof TyBool && y instanceof TyBool) {\n                return true;\n            };\n            if (x instanceof TyTop && y instanceof TyTop) {\n                return true;\n            };\n            if (x instanceof TyBot && y instanceof TyBot) {\n                return true;\n            };\n            if (x instanceof TyArrow && y instanceof TyArrow) {\n                return Data_Eq.eq(eqTy)(x.value0)(y.value0) && Data_Eq.eq(eqTy)(x.value1)(y.value1) && x.value2 === y.value2;\n            };\n            if (x instanceof TyAnd && y instanceof TyAnd) {\n                return Data_Eq.eq(eqTy)(x.value0)(y.value0) && Data_Eq.eq(eqTy)(x.value1)(y.value1);\n            };\n            if (x instanceof TyRcd && y instanceof TyRcd) {\n                return x.value0 === y.value0 && Data_Eq.eq(eqTy)(x.value1)(y.value1) && x.value2 === y.value2;\n            };\n            if (x instanceof TyVar && y instanceof TyVar) {\n                return x.value0 === y.value0;\n            };\n            if (x instanceof TyForall && y instanceof TyForall) {\n                return x.value0 === y.value0 && Data_Eq.eq(eqTy)(x.value1)(y.value1) && Data_Eq.eq(eqTy)(x.value2)(y.value2);\n            };\n            if (x instanceof TyRec && y instanceof TyRec) {\n                return x.value0 === y.value0 && Data_Eq.eq(eqTy)(x.value1)(y.value1);\n            };\n            if (x instanceof TyArray && y instanceof TyArray) {\n                return Data_Eq.eq(eqTy)(x.value0)(y.value0);\n            };\n            return false;\n        };\n    }\n};\nvar tySubst = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2 instanceof TyArrow) {\n                return new TyArrow(tySubst(v)(v1)(v2.value0), tySubst(v)(v1)(v2.value1), v2.value2);\n            };\n            if (v2 instanceof TyAnd) {\n                return new TyAnd(tySubst(v)(v1)(v2.value0), tySubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TyRcd) {\n                return new TyRcd(v2.value0, tySubst(v)(v1)(v2.value1), v2.value2);\n            };\n            if (v2 instanceof TyVar) {\n                var $182 = v === v2.value0;\n                if ($182) {\n                    return v1;\n                };\n                return new TyVar(v2.value0);\n            };\n            if (v2 instanceof TyForall) {\n                return new TyForall(v2.value0, tySubst(v)(v1)(v2.value1), (function () {\n                    var $184 = v === v2.value0;\n                    if ($184) {\n                        return v2.value2;\n                    };\n                    return tySubst(v)(v1)(v2.value2);\n                })());\n            };\n            if (v2 instanceof TyRec) {\n                return new TyRec(v2.value0, (function () {\n                    var $188 = v === v2.value0;\n                    if ($188) {\n                        return v2.value1;\n                    };\n                    return tySubst(v)(v1)(v2.value1);\n                })());\n            };\n            if (v2 instanceof TyArray) {\n                return new TyArray(tySubst(v)(v1)(v2.value0));\n            };\n            return v2;\n        };\n    };\n};\nvar unfold = function (v) {\n    if (v instanceof TyRec) {\n        return tySubst(v.value0)(v)(v.value1);\n    };\n    return v;\n};\nvar tyConvert = function (v) {\n    return function (v1) {\n        if (v1 instanceof TyArrow) {\n            return new TyArrow(tyConvert(v)(v1.value0), tyConvert(v)(v1.value1), v1.value2);\n        };\n        if (v1 instanceof TyAnd) {\n            return new TyAnd(tyConvert(v)(v1.value0), tyConvert(v)(v1.value1));\n        };\n        if (v1 instanceof TyRcd) {\n            return new TyRcd(v1.value0, tyConvert(v)(v1.value1), v1.value2);\n        };\n        if (v1 instanceof TyVar) {\n            var v2 = Data_Map_Internal.lookup(Data_Ord.ordString)(v1.value0)(v);\n            if (v2 instanceof Data_Maybe.Just && v2.value0 instanceof Data_Either.Right) {\n                return v2.value0.value0;\n            };\n            return new TyVar(v1.value0);\n        };\n        if (v1 instanceof TyForall) {\n            return new TyForall(v1.value0, tyConvert(v)(v1.value1), tyConvert(v)(v1.value2));\n        };\n        if (v1 instanceof TyRec) {\n            return new TyRec(v1.value0, tyConvert(v)(v1.value1));\n        };\n        if (v1 instanceof TyArray) {\n            return new TyArray(tyConvert(v)(v1.value0));\n        };\n        return v1;\n    };\n};\nvar tyHoas$prime = function (env) {\n    return function (a) {\n        return function (t) {\n            return function (ty) {\n                return tyConvert(Data_Map_Internal.insert(Data_Ord.ordString)(a)(new Data_Either.Right(ty))(env))(t);\n            };\n        };\n    };\n};\nvar tyHoas = tyHoas$prime(Data_Map_Internal.empty);\nvar tmTSubst = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2 instanceof TmUnary) {\n                return new TmUnary(v2.value0, tmTSubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TmBinary) {\n                return new TmBinary(v2.value0, tmTSubst(v)(v1)(v2.value1), tmTSubst(v)(v1)(v2.value2));\n            };\n            if (v2 instanceof TmIf) {\n                return new TmIf(tmTSubst(v)(v1)(v2.value0), tmTSubst(v)(v1)(v2.value1), tmTSubst(v)(v1)(v2.value2));\n            };\n            if (v2 instanceof TmApp) {\n                return new TmApp(tmTSubst(v)(v1)(v2.value0), tmTSubst(v)(v1)(v2.value1), v2.value2);\n            };\n            if (v2 instanceof TmAbs) {\n                return new TmAbs(v2.value0, tmTSubst(v)(v1)(v2.value1), tySubst(v)(v1)(v2.value2), tySubst(v)(v1)(v2.value3), v2.value4);\n            };\n            if (v2 instanceof TmFix) {\n                return new TmFix(v2.value0, tmTSubst(v)(v1)(v2.value1), tySubst(v)(v1)(v2.value2));\n            };\n            if (v2 instanceof TmAnno) {\n                return new TmAnno(tmTSubst(v)(v1)(v2.value0), tySubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TmMerge) {\n                return new TmMerge(tmTSubst(v)(v1)(v2.value0), tmTSubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TmRcd) {\n                return new TmRcd(v2.value0, tySubst(v)(v1)(v2.value1), tmTSubst(v)(v1)(v2.value2));\n            };\n            if (v2 instanceof TmPrj) {\n                return new TmPrj(tmTSubst(v)(v1)(v2.value0), v2.value1);\n            };\n            if (v2 instanceof TmTApp) {\n                return new TmTApp(tmTSubst(v)(v1)(v2.value0), tySubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TmTAbs) {\n                return new TmTAbs(v2.value0, tySubst(v)(v1)(v2.value1), tmTSubst(v)(v1)(v2.value2), (function () {\n                    var $248 = v === v2.value0;\n                    if ($248) {\n                        return v2.value3;\n                    };\n                    return tySubst(v)(v1)(v2.value3);\n                })());\n            };\n            if (v2 instanceof TmFold) {\n                return new TmFold(tySubst(v)(v1)(v2.value0), tmTSubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TmUnfold) {\n                return new TmUnfold(tySubst(v)(v1)(v2.value0), tmTSubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TmToString) {\n                return new TmToString(tmTSubst(v)(v1)(v2.value0));\n            };\n            if (v2 instanceof TmArray) {\n                return new TmArray(tySubst(v)(v1)(v2.value0), Data_Functor.map(Data_Functor.functorArray)(tmTSubst(v)(v1))(v2.value1));\n            };\n            return v2;\n        };\n    };\n};\nvar tmSubst = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2 instanceof TmUnary) {\n                return new TmUnary(v2.value0, tmSubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TmBinary) {\n                return new TmBinary(v2.value0, tmSubst(v)(v1)(v2.value1), tmSubst(v)(v1)(v2.value2));\n            };\n            if (v2 instanceof TmIf) {\n                return new TmIf(tmSubst(v)(v1)(v2.value0), tmSubst(v)(v1)(v2.value1), tmSubst(v)(v1)(v2.value2));\n            };\n            if (v2 instanceof TmVar) {\n                var $271 = v === v2.value0;\n                if ($271) {\n                    return v1;\n                };\n                return new TmVar(v2.value0);\n            };\n            if (v2 instanceof TmApp) {\n                return new TmApp(tmSubst(v)(v1)(v2.value0), tmSubst(v)(v1)(v2.value1), v2.value2);\n            };\n            if (v2 instanceof TmAbs) {\n                return new TmAbs(v2.value0, (function () {\n                    var $276 = v === v2.value0;\n                    if ($276) {\n                        return v2.value1;\n                    };\n                    return tmSubst(v)(v1)(v2.value1);\n                })(), v2.value2, v2.value3, v2.value4);\n            };\n            if (v2 instanceof TmFix) {\n                return new TmFix(v2.value0, (function () {\n                    var $282 = v === v2.value0;\n                    if ($282) {\n                        return v2.value1;\n                    };\n                    return tmSubst(v)(v1)(v2.value1);\n                })(), v2.value2);\n            };\n            if (v2 instanceof TmAnno) {\n                return new TmAnno(tmSubst(v)(v1)(v2.value0), v2.value1);\n            };\n            if (v2 instanceof TmMerge) {\n                return new TmMerge(tmSubst(v)(v1)(v2.value0), tmSubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TmRcd) {\n                return new TmRcd(v2.value0, v2.value1, tmSubst(v)(v1)(v2.value2));\n            };\n            if (v2 instanceof TmPrj) {\n                return new TmPrj(tmSubst(v)(v1)(v2.value0), v2.value1);\n            };\n            if (v2 instanceof TmTApp) {\n                return new TmTApp(tmSubst(v)(v1)(v2.value0), v2.value1);\n            };\n            if (v2 instanceof TmTAbs) {\n                return new TmTAbs(v2.value0, v2.value1, tmSubst(v)(v1)(v2.value2), v2.value3);\n            };\n            if (v2 instanceof TmFold) {\n                return new TmFold(v2.value0, tmSubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TmUnfold) {\n                return new TmUnfold(v2.value0, tmSubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TmToString) {\n                return new TmToString(tmSubst(v)(v1)(v2.value0));\n            };\n            if (v2 instanceof TmArray) {\n                return new TmArray(v2.value0, Data_Functor.map(Data_Functor.functorArray)(tmSubst(v)(v1))(v2.value1));\n            };\n            return v2;\n        };\n    };\n};\nvar tmConvert = function (v) {\n    return function (v1) {\n        if (v1 instanceof TmUnary) {\n            return new TmUnary(v1.value0, tmConvert(v)(v1.value1));\n        };\n        if (v1 instanceof TmBinary) {\n            return new TmBinary(v1.value0, tmConvert(v)(v1.value1), tmConvert(v)(v1.value2));\n        };\n        if (v1 instanceof TmIf) {\n            return new TmIf(tmConvert(v)(v1.value0), tmConvert(v)(v1.value1), tmConvert(v)(v1.value2));\n        };\n        if (v1 instanceof TmVar) {\n            var v2 = Data_Map_Internal.lookup(Data_Ord.ordString)(v1.value0)(v);\n            if (v2 instanceof Data_Maybe.Just && v2.value0 instanceof Data_Either.Left) {\n                return v2.value0.value0;\n            };\n            return new TmVar(v1.value0);\n        };\n        if (v1 instanceof TmApp) {\n            return new TmApp(tmConvert(v)(v1.value0), tmConvert(v)(v1.value1), v1.value2);\n        };\n        if (v1 instanceof TmAbs) {\n            return new TmHAbs(function (tm) {\n                return tmConvert(Data_Map_Internal.insert(Data_Ord.ordString)(v1.value0)(new Data_Either.Left(tm))(v))(v1.value1);\n            }, tyConvert(v)(v1.value2), tyConvert(v)(v1.value3), v1.value4);\n        };\n        if (v1 instanceof TmFix) {\n            return new TmHFix(function (tm) {\n                return tmConvert(Data_Map_Internal.insert(Data_Ord.ordString)(v1.value0)(new Data_Either.Left(tm))(v))(v1.value1);\n            }, tyConvert(v)(v1.value2));\n        };\n        if (v1 instanceof TmAnno) {\n            return new TmAnno(tmConvert(v)(v1.value0), tyConvert(v)(v1.value1));\n        };\n        if (v1 instanceof TmMerge) {\n            return new TmMerge(tmConvert(v)(v1.value0), tmConvert(v)(v1.value1));\n        };\n        if (v1 instanceof TmRcd) {\n            return new TmRcd(v1.value0, tyConvert(v)(v1.value1), tmConvert(v)(v1.value2));\n        };\n        if (v1 instanceof TmPrj) {\n            return new TmPrj(tmConvert(v)(v1.value0), v1.value1);\n        };\n        if (v1 instanceof TmTApp) {\n            return new TmTApp(tmConvert(v)(v1.value0), tyConvert(v)(v1.value1));\n        };\n        if (v1 instanceof TmTAbs) {\n            return new TmHTAbs(function (ty) {\n                return tmConvert(Data_Map_Internal.insert(Data_Ord.ordString)(v1.value0)(new Data_Either.Right(ty))(v))(v1.value2);\n            }, tyConvert(v)(v1.value1), tyHoas$prime(v)(v1.value0)(v1.value3));\n        };\n        if (v1 instanceof TmFold) {\n            return new TmFold(tyConvert(v)(v1.value0), tmConvert(v)(v1.value1));\n        };\n        if (v1 instanceof TmUnfold) {\n            return new TmUnfold(tyConvert(v)(v1.value0), tmConvert(v)(v1.value1));\n        };\n        if (v1 instanceof TmToString) {\n            return new TmToString(tmConvert(v)(v1.value0));\n        };\n        if (v1 instanceof TmArray) {\n            return new TmArray(tyConvert(v)(v1.value0), Data_Functor.map(Data_Functor.functorArray)(tmConvert(v))(v1.value1));\n        };\n        return v1;\n    };\n};\nvar tmHoas = tmConvert(Data_Map_Internal.empty);\nmodule.exports = {\n    TyInt: TyInt,\n    TyDouble: TyDouble,\n    TyString: TyString,\n    TyBool: TyBool,\n    TyTop: TyTop,\n    TyBot: TyBot,\n    TyArrow: TyArrow,\n    TyAnd: TyAnd,\n    TyRcd: TyRcd,\n    TyVar: TyVar,\n    TyForall: TyForall,\n    TyRec: TyRec,\n    TyArray: TyArray,\n    TmInt: TmInt,\n    TmDouble: TmDouble,\n    TmString: TmString,\n    TmBool: TmBool,\n    TmUnit: TmUnit,\n    TmUndefined: TmUndefined,\n    TmUnary: TmUnary,\n    TmBinary: TmBinary,\n    TmIf: TmIf,\n    TmVar: TmVar,\n    TmApp: TmApp,\n    TmAbs: TmAbs,\n    TmFix: TmFix,\n    TmAnno: TmAnno,\n    TmMerge: TmMerge,\n    TmRcd: TmRcd,\n    TmPrj: TmPrj,\n    TmTApp: TmTApp,\n    TmTAbs: TmTAbs,\n    TmFold: TmFold,\n    TmUnfold: TmUnfold,\n    TmToString: TmToString,\n    TmArray: TmArray,\n    TmRef: TmRef,\n    TmClosure: TmClosure,\n    TmHAbs: TmHAbs,\n    TmHFix: TmHFix,\n    TmHTAbs: TmHTAbs,\n    tmHoas: tmHoas,\n    tyHoas: tyHoas,\n    \"tyHoas'\": tyHoas$prime,\n    tyConvert: tyConvert,\n    tmConvert: tmConvert,\n    tySubst: tySubst,\n    unfold: unfold,\n    tmSubst: tmSubst,\n    tmTSubst: tmTSubst,\n    TmBind: TmBind,\n    TyBind: TyBind,\n    showTy: showTy,\n    eqTy: eqTy,\n    showTm: showTm,\n    showEvalBind: showEvalBind,\n    \"new\": $foreign[\"new\"],\n    done: $foreign.done,\n    read: $foreign.read,\n    write: $foreign.write\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Syntax/Core.purs?");

/***/ }),

/***/ "./src/CP/Syntax/Source.purs":
/*!***********************************!*\
  !*** ./src/CP/Syntax/Source.purs ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_Bifunctor = __webpack_require__(/*! ./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs */ \"./.spago/bifunctors/v5.0.0/src/Data/Bifunctor.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_HeytingAlgebra = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs */ \"./.spago/prelude/v5.0.1/src/Data/HeytingAlgebra.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Monoid = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Monoid.purs */ \"./.spago/prelude/v5.0.1/src/Data/Monoid.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Language_CP_Syntax_Common = __webpack_require__(/*! ./src/CP/Syntax/Common.purs */ \"./src/CP/Syntax/Common.purs\");\nvar Language_CP_Util = __webpack_require__(/*! ./src/CP/Util.purs */ \"./src/CP/Util.purs\");\nvar RcdTy = (function () {\n    function RcdTy(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    RcdTy.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new RcdTy(value0, value1, value2);\n            };\n        };\n    };\n    return RcdTy;\n})();\nvar TyInt = (function () {\n    function TyInt() {\n\n    };\n    TyInt.value = new TyInt();\n    return TyInt;\n})();\nvar TyDouble = (function () {\n    function TyDouble() {\n\n    };\n    TyDouble.value = new TyDouble();\n    return TyDouble;\n})();\nvar TyString = (function () {\n    function TyString() {\n\n    };\n    TyString.value = new TyString();\n    return TyString;\n})();\nvar TyBool = (function () {\n    function TyBool() {\n\n    };\n    TyBool.value = new TyBool();\n    return TyBool;\n})();\nvar TyTop = (function () {\n    function TyTop() {\n\n    };\n    TyTop.value = new TyTop();\n    return TyTop;\n})();\nvar TyBot = (function () {\n    function TyBot() {\n\n    };\n    TyBot.value = new TyBot();\n    return TyBot;\n})();\nvar TyArrow = (function () {\n    function TyArrow(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TyArrow.create = function (value0) {\n        return function (value1) {\n            return new TyArrow(value0, value1);\n        };\n    };\n    return TyArrow;\n})();\nvar TyAnd = (function () {\n    function TyAnd(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TyAnd.create = function (value0) {\n        return function (value1) {\n            return new TyAnd(value0, value1);\n        };\n    };\n    return TyAnd;\n})();\nvar TyRcd = (function () {\n    function TyRcd(value0) {\n        this.value0 = value0;\n    };\n    TyRcd.create = function (value0) {\n        return new TyRcd(value0);\n    };\n    return TyRcd;\n})();\nvar TyVar = (function () {\n    function TyVar(value0) {\n        this.value0 = value0;\n    };\n    TyVar.create = function (value0) {\n        return new TyVar(value0);\n    };\n    return TyVar;\n})();\nvar TyForall = (function () {\n    function TyForall(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TyForall.create = function (value0) {\n        return function (value1) {\n            return new TyForall(value0, value1);\n        };\n    };\n    return TyForall;\n})();\nvar TyRec = (function () {\n    function TyRec(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TyRec.create = function (value0) {\n        return function (value1) {\n            return new TyRec(value0, value1);\n        };\n    };\n    return TyRec;\n})();\nvar TyApp = (function () {\n    function TyApp(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TyApp.create = function (value0) {\n        return function (value1) {\n            return new TyApp(value0, value1);\n        };\n    };\n    return TyApp;\n})();\nvar TyAbs = (function () {\n    function TyAbs(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TyAbs.create = function (value0) {\n        return function (value1) {\n            return new TyAbs(value0, value1);\n        };\n    };\n    return TyAbs;\n})();\nvar TyTrait = (function () {\n    function TyTrait(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TyTrait.create = function (value0) {\n        return function (value1) {\n            return new TyTrait(value0, value1);\n        };\n    };\n    return TyTrait;\n})();\nvar TySort = (function () {\n    function TySort(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TySort.create = function (value0) {\n        return function (value1) {\n            return new TySort(value0, value1);\n        };\n    };\n    return TySort;\n})();\nvar TySig = (function () {\n    function TySig(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TySig.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TySig(value0, value1, value2);\n            };\n        };\n    };\n    return TySig;\n})();\nvar TyArray = (function () {\n    function TyArray(value0) {\n        this.value0 = value0;\n    };\n    TyArray.create = function (value0) {\n        return new TyArray(value0);\n    };\n    return TyArray;\n})();\nvar TmInt = (function () {\n    function TmInt(value0) {\n        this.value0 = value0;\n    };\n    TmInt.create = function (value0) {\n        return new TmInt(value0);\n    };\n    return TmInt;\n})();\nvar TmDouble = (function () {\n    function TmDouble(value0) {\n        this.value0 = value0;\n    };\n    TmDouble.create = function (value0) {\n        return new TmDouble(value0);\n    };\n    return TmDouble;\n})();\nvar TmString = (function () {\n    function TmString(value0) {\n        this.value0 = value0;\n    };\n    TmString.create = function (value0) {\n        return new TmString(value0);\n    };\n    return TmString;\n})();\nvar TmBool = (function () {\n    function TmBool(value0) {\n        this.value0 = value0;\n    };\n    TmBool.create = function (value0) {\n        return new TmBool(value0);\n    };\n    return TmBool;\n})();\nvar TmUnit = (function () {\n    function TmUnit() {\n\n    };\n    TmUnit.value = new TmUnit();\n    return TmUnit;\n})();\nvar TmUndefined = (function () {\n    function TmUndefined() {\n\n    };\n    TmUndefined.value = new TmUndefined();\n    return TmUndefined;\n})();\nvar TmUnary = (function () {\n    function TmUnary(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmUnary.create = function (value0) {\n        return function (value1) {\n            return new TmUnary(value0, value1);\n        };\n    };\n    return TmUnary;\n})();\nvar TmBinary = (function () {\n    function TmBinary(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TmBinary.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TmBinary(value0, value1, value2);\n            };\n        };\n    };\n    return TmBinary;\n})();\nvar TmIf = (function () {\n    function TmIf(value0, value1, value2) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n    };\n    TmIf.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return new TmIf(value0, value1, value2);\n            };\n        };\n    };\n    return TmIf;\n})();\nvar TmVar = (function () {\n    function TmVar(value0) {\n        this.value0 = value0;\n    };\n    TmVar.create = function (value0) {\n        return new TmVar(value0);\n    };\n    return TmVar;\n})();\nvar TmApp = (function () {\n    function TmApp(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmApp.create = function (value0) {\n        return function (value1) {\n            return new TmApp(value0, value1);\n        };\n    };\n    return TmApp;\n})();\nvar TmAbs = (function () {\n    function TmAbs(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmAbs.create = function (value0) {\n        return function (value1) {\n            return new TmAbs(value0, value1);\n        };\n    };\n    return TmAbs;\n})();\nvar TmAnno = (function () {\n    function TmAnno(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmAnno.create = function (value0) {\n        return function (value1) {\n            return new TmAnno(value0, value1);\n        };\n    };\n    return TmAnno;\n})();\nvar TmMerge = (function () {\n    function TmMerge(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmMerge.create = function (value0) {\n        return function (value1) {\n            return new TmMerge(value0, value1);\n        };\n    };\n    return TmMerge;\n})();\nvar TmRcd = (function () {\n    function TmRcd(value0) {\n        this.value0 = value0;\n    };\n    TmRcd.create = function (value0) {\n        return new TmRcd(value0);\n    };\n    return TmRcd;\n})();\nvar TmPrj = (function () {\n    function TmPrj(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmPrj.create = function (value0) {\n        return function (value1) {\n            return new TmPrj(value0, value1);\n        };\n    };\n    return TmPrj;\n})();\nvar TmTApp = (function () {\n    function TmTApp(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmTApp.create = function (value0) {\n        return function (value1) {\n            return new TmTApp(value0, value1);\n        };\n    };\n    return TmTApp;\n})();\nvar TmTAbs = (function () {\n    function TmTAbs(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmTAbs.create = function (value0) {\n        return function (value1) {\n            return new TmTAbs(value0, value1);\n        };\n    };\n    return TmTAbs;\n})();\nvar TmLet = (function () {\n    function TmLet(value0, value1, value2, value3, value4) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n        this.value4 = value4;\n    };\n    TmLet.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return function (value4) {\n                        return new TmLet(value0, value1, value2, value3, value4);\n                    };\n                };\n            };\n        };\n    };\n    return TmLet;\n})();\nvar TmLetrec = (function () {\n    function TmLetrec(value0, value1, value2, value3, value4, value5) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n        this.value4 = value4;\n        this.value5 = value5;\n    };\n    TmLetrec.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return function (value4) {\n                        return function (value5) {\n                            return new TmLetrec(value0, value1, value2, value3, value4, value5);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    return TmLetrec;\n})();\nvar TmOpen = (function () {\n    function TmOpen(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmOpen.create = function (value0) {\n        return function (value1) {\n            return new TmOpen(value0, value1);\n        };\n    };\n    return TmOpen;\n})();\nvar TmUpdate = (function () {\n    function TmUpdate(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmUpdate.create = function (value0) {\n        return function (value1) {\n            return new TmUpdate(value0, value1);\n        };\n    };\n    return TmUpdate;\n})();\nvar TmTrait = (function () {\n    function TmTrait(value0, value1, value2, value3) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n    };\n    TmTrait.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return new TmTrait(value0, value1, value2, value3);\n                };\n            };\n        };\n    };\n    return TmTrait;\n})();\nvar TmNew = (function () {\n    function TmNew(value0) {\n        this.value0 = value0;\n    };\n    TmNew.create = function (value0) {\n        return new TmNew(value0);\n    };\n    return TmNew;\n})();\nvar TmForward = (function () {\n    function TmForward(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmForward.create = function (value0) {\n        return function (value1) {\n            return new TmForward(value0, value1);\n        };\n    };\n    return TmForward;\n})();\nvar TmExclude = (function () {\n    function TmExclude(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmExclude.create = function (value0) {\n        return function (value1) {\n            return new TmExclude(value0, value1);\n        };\n    };\n    return TmExclude;\n})();\nvar TmFold = (function () {\n    function TmFold(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmFold.create = function (value0) {\n        return function (value1) {\n            return new TmFold(value0, value1);\n        };\n    };\n    return TmFold;\n})();\nvar TmUnfold = (function () {\n    function TmUnfold(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmUnfold.create = function (value0) {\n        return function (value1) {\n            return new TmUnfold(value0, value1);\n        };\n    };\n    return TmUnfold;\n})();\nvar TmToString = (function () {\n    function TmToString(value0) {\n        this.value0 = value0;\n    };\n    TmToString.create = function (value0) {\n        return new TmToString(value0);\n    };\n    return TmToString;\n})();\nvar TmArray = (function () {\n    function TmArray(value0) {\n        this.value0 = value0;\n    };\n    TmArray.create = function (value0) {\n        return new TmArray(value0);\n    };\n    return TmArray;\n})();\nvar TmDoc = (function () {\n    function TmDoc(value0) {\n        this.value0 = value0;\n    };\n    TmDoc.create = function (value0) {\n        return new TmDoc(value0);\n    };\n    return TmDoc;\n})();\nvar TmPos = (function () {\n    function TmPos(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmPos.create = function (value0) {\n        return function (value1) {\n            return new TmPos(value0, value1);\n        };\n    };\n    return TmPos;\n})();\nvar TmType = (function () {\n    function TmType(value0, value1, value2, value3, value4) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n        this.value4 = value4;\n    };\n    TmType.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return function (value4) {\n                        return new TmType(value0, value1, value2, value3, value4);\n                    };\n                };\n            };\n        };\n    };\n    return TmType;\n})();\nvar TmDef = (function () {\n    function TmDef(value0, value1, value2, value3, value4, value5) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n        this.value4 = value4;\n        this.value5 = value5;\n    };\n    TmDef.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return function (value4) {\n                        return function (value5) {\n                            return new TmDef(value0, value1, value2, value3, value4, value5);\n                        };\n                    };\n                };\n            };\n        };\n    };\n    return TmDef;\n})();\nvar TmParam = (function () {\n    function TmParam(value0, value1) {\n        this.value0 = value0;\n        this.value1 = value1;\n    };\n    TmParam.create = function (value0) {\n        return function (value1) {\n            return new TmParam(value0, value1);\n        };\n    };\n    return TmParam;\n})();\nvar WildCard = (function () {\n    function WildCard(value0) {\n        this.value0 = value0;\n    };\n    WildCard.create = function (value0) {\n        return new WildCard(value0);\n    };\n    return WildCard;\n})();\nvar RcdField = (function () {\n    function RcdField(value0, value1, value2, value3) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n    };\n    RcdField.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return new RcdField(value0, value1, value2, value3);\n                };\n            };\n        };\n    };\n    return RcdField;\n})();\nvar DefaultPattern = (function () {\n    function DefaultPattern(value0) {\n        this.value0 = value0;\n    };\n    DefaultPattern.create = function (value0) {\n        return new DefaultPattern(value0);\n    };\n    return DefaultPattern;\n})();\nvar MethodPattern = (function () {\n    function MethodPattern(value0, value1, value2, value3) {\n        this.value0 = value0;\n        this.value1 = value1;\n        this.value2 = value2;\n        this.value3 = value3;\n    };\n    MethodPattern.create = function (value0) {\n        return function (value1) {\n            return function (value2) {\n                return function (value3) {\n                    return new MethodPattern(value0, value1, value2, value3);\n                };\n            };\n        };\n    };\n    return MethodPattern;\n})();\nvar eqTy = {\n    eq: function (x) {\n        return function (y) {\n            if (x instanceof TyInt && y instanceof TyInt) {\n                return true;\n            };\n            if (x instanceof TyDouble && y instanceof TyDouble) {\n                return true;\n            };\n            if (x instanceof TyString && y instanceof TyString) {\n                return true;\n            };\n            if (x instanceof TyBool && y instanceof TyBool) {\n                return true;\n            };\n            if (x instanceof TyTop && y instanceof TyTop) {\n                return true;\n            };\n            if (x instanceof TyBot && y instanceof TyBot) {\n                return true;\n            };\n            if (x instanceof TyArrow && y instanceof TyArrow) {\n                return Data_Eq.eq(eqTy)(x.value0)(y.value0) && Data_Eq.eq(eqTy)(x.value1)(y.value1);\n            };\n            if (x instanceof TyAnd && y instanceof TyAnd) {\n                return Data_Eq.eq(eqTy)(x.value0)(y.value0) && Data_Eq.eq(eqTy)(x.value1)(y.value1);\n            };\n            if (x instanceof TyRcd && y instanceof TyRcd) {\n                return Data_Eq.eq(Data_List_Types.eqList(eqRcdTy))(x.value0)(y.value0);\n            };\n            if (x instanceof TyVar && y instanceof TyVar) {\n                return x.value0 === y.value0;\n            };\n            if (x instanceof TyForall && y instanceof TyForall) {\n                return Data_Eq.eq(Data_List_Types.eqList(Data_Tuple.eqTuple(Data_Eq.eqString)(Data_Maybe.eqMaybe(eqTy))))(x.value0)(y.value0) && Data_Eq.eq(eqTy)(x.value1)(y.value1);\n            };\n            if (x instanceof TyRec && y instanceof TyRec) {\n                return x.value0 === y.value0 && Data_Eq.eq(eqTy)(x.value1)(y.value1);\n            };\n            if (x instanceof TyApp && y instanceof TyApp) {\n                return Data_Eq.eq(eqTy)(x.value0)(y.value0) && Data_Eq.eq(eqTy)(x.value1)(y.value1);\n            };\n            if (x instanceof TyAbs && y instanceof TyAbs) {\n                return x.value0 === y.value0 && Data_Eq.eq(eqTy)(x.value1)(y.value1);\n            };\n            if (x instanceof TyTrait && y instanceof TyTrait) {\n                return Data_Eq.eq(Data_Maybe.eqMaybe(eqTy))(x.value0)(y.value0) && Data_Eq.eq(eqTy)(x.value1)(y.value1);\n            };\n            if (x instanceof TySort && y instanceof TySort) {\n                return Data_Eq.eq(eqTy)(x.value0)(y.value0) && Data_Eq.eq(Data_Maybe.eqMaybe(eqTy))(x.value1)(y.value1);\n            };\n            if (x instanceof TySig && y instanceof TySig) {\n                return x.value0 === y.value0 && x.value1 === y.value1 && Data_Eq.eq(eqTy)(x.value2)(y.value2);\n            };\n            if (x instanceof TyArray && y instanceof TyArray) {\n                return Data_Eq.eq(eqTy)(x.value0)(y.value0);\n            };\n            return false;\n        };\n    }\n};\nvar eqRcdTy = {\n    eq: function (x) {\n        return function (y) {\n            return x.value0 === y.value0 && Data_Eq.eq(eqTy)(x.value1)(y.value1) && x.value2 === y.value2;\n        };\n    }\n};\nvar tySubst = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2 instanceof TyArrow) {\n                return new TyArrow(tySubst(v)(v1)(v2.value0), tySubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TyAnd) {\n                return new TyAnd(tySubst(v)(v1)(v2.value0), tySubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TyRcd) {\n                return new TyRcd(Data_Functor.mapFlipped(Data_List_Types.functorList)(v2.value0)(function (v3) {\n                    return new RcdTy(v3.value0, tySubst(v)(v1)(v3.value1), v3.value2);\n                }));\n            };\n            if (v2 instanceof TyVar) {\n                var $144 = v === v2.value0;\n                if ($144) {\n                    return v1;\n                };\n                return new TyVar(v2.value0);\n            };\n            if (v2 instanceof TyForall) {\n                return new TyForall(Data_Functor.map(Data_List_Types.functorList)(Data_Bifunctor.rmap(Data_Bifunctor.bifunctorTuple)(Data_Functor.map(Data_Maybe.functorMaybe)(tySubst(v)(v1))))(v2.value0), (function () {\n                    var $146 = Data_Foldable.any(Data_List_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(function ($336) {\n                        return (function (v3) {\n                            return v3 === v;\n                        })(Data_Tuple.fst($336));\n                    })(v2.value0);\n                    if ($146) {\n                        return v2.value1;\n                    };\n                    return tySubst(v)(v1)(v2.value1);\n                })());\n            };\n            if (v2 instanceof TyRec) {\n                return new TyRec(v2.value0, (function () {\n                    var $149 = v === v2.value0;\n                    if ($149) {\n                        return v2.value1;\n                    };\n                    return tySubst(v)(v1)(v2.value1);\n                })());\n            };\n            if (v2 instanceof TyApp) {\n                return new TyApp(tySubst(v)(v1)(v2.value0), tySubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TyAbs) {\n                return new TyAbs(v2.value0, (function () {\n                    var $154 = v === v2.value0;\n                    if ($154) {\n                        return v2.value1;\n                    };\n                    return tySubst(v)(v1)(v2.value1);\n                })());\n            };\n            if (v2 instanceof TyTrait) {\n                return new TyTrait(Data_Functor.map(Data_Maybe.functorMaybe)(tySubst(v)(v1))(v2.value0), tySubst(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof TySort) {\n                return new TySort(tySubst(v)(v1)(v2.value0), Data_Functor.map(Data_Maybe.functorMaybe)(tySubst(v)(v1))(v2.value1));\n            };\n            if (v2 instanceof TySig) {\n                return new TySig(v2.value0, v2.value1, (function () {\n                    var $161 = v === v2.value0 || v === v2.value1;\n                    if ($161) {\n                        return v2.value2;\n                    };\n                    return tySubst(v)(v1)(v2.value2);\n                })());\n            };\n            if (v2 instanceof TyArray) {\n                return new TyArray(tySubst(v)(v1)(v2.value0));\n            };\n            return v2;\n        };\n    };\n};\nvar showMaybe = function (dictShow) {\n    return function (l) {\n        return function (m) {\n            return function (r) {\n                return Data_Maybe.maybe(\"\")(function (x) {\n                    return l + (Data_Show.show(dictShow)(x) + r);\n                })(m);\n            };\n        };\n    };\n};\nvar intercalate$prime = function (dictFoldable) {\n    return function (dictMonoid) {\n        return function (sep) {\n            return function (xs) {\n                var $166 = Data_Foldable[\"null\"](dictFoldable)(xs);\n                if ($166) {\n                    return Data_Monoid.mempty(dictMonoid);\n                };\n                return Data_Semigroup.append(dictMonoid.Semigroup0())(Data_Foldable.intercalate(dictFoldable)(dictMonoid)(sep)(xs))(sep);\n            };\n        };\n    };\n};\nvar showTy = {\n    show: function (v) {\n        if (v instanceof TyInt) {\n            return \"Int\";\n        };\n        if (v instanceof TyDouble) {\n            return \"Double\";\n        };\n        if (v instanceof TyString) {\n            return \"String\";\n        };\n        if (v instanceof TyBool) {\n            return \"Bool\";\n        };\n        if (v instanceof TyTop) {\n            return \"Top\";\n        };\n        if (v instanceof TyBot) {\n            return \"Bot\";\n        };\n        if (v instanceof TyArrow) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTy)(v.value0))(Language_CP_Util.beside(\"->\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TyAnd) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTy)(v.value0))(Language_CP_Util.beside(\"&\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TyRcd) {\n            return Language_CP_Syntax_Common.braces(showRcdTy(v.value0));\n        };\n        if (v instanceof TyVar) {\n            return v.value0;\n        };\n        if (v instanceof TyForall) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"forall\")(showTyParams(v.value0) + Language_CP_Util.beside(\".\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TyRec) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"mu\")(v.value0 + Language_CP_Util.beside(\".\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TyApp) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTy)(v.value0))(Data_Show.show(showTy)(v.value1)));\n        };\n        if (v instanceof TyAbs) {\n            return Language_CP_Syntax_Common.parens(\"\\\\\" + Language_CP_Util.beside(v.value0)(Language_CP_Util.beside(\"->\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TyTrait) {\n            return \"Trait\" + Language_CP_Syntax_Common.angles(showMaybe(showTy)(\"\")(v.value0)(\" => \") + Data_Show.show(showTy)(v.value1));\n        };\n        if (v instanceof TySort) {\n            return Language_CP_Syntax_Common.angles(Data_Show.show(showTy)(v.value0) + showMaybe(showTy)(\" => \")(v.value1)(\"\"));\n        };\n        if (v instanceof TySig) {\n            return Language_CP_Syntax_Common.parens(\"\\\\\" + Language_CP_Util.beside(Language_CP_Syntax_Common.angles(v.value0 + Language_CP_Util.beside(\",\")(v.value1)))(Language_CP_Util.beside(\"->\")(Data_Show.show(showTy)(v.value2))));\n        };\n        if (v instanceof TyArray) {\n            return Language_CP_Syntax_Common.brackets(Data_Show.show(showTy)(v.value0));\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Source (line 36, column 1 - line 56, column 39): \" + [ v.constructor.name ]);\n    }\n};\nvar showTyParams = function (params) {\n    return intercalate$prime(Data_List_Types.foldableList)(Data_Monoid.monoidString)(\" \")(Data_Functor.mapFlipped(Data_List_Types.functorList)(params)(function (param) {\n        return Data_Maybe.maybe(Data_Tuple.fst(param))(function (t) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Tuple.fst(param))(Language_CP_Util.beside(\"*\")(Data_Show.show(showTy)(t))));\n        })(Data_Tuple.snd(param));\n    }));\n};\nvar showRcdTy = function (xs) {\n    return Data_Foldable.intercalate(Data_List_Types.foldableList)(Data_Monoid.monoidString)(\"; \")(Data_Functor.mapFlipped(Data_List_Types.functorList)(xs)(function (v) {\n        return v.value0 + Language_CP_Util.beside((function () {\n            if (v.value2) {\n                return \"?\";\n            };\n            return \"\";\n        })())(Language_CP_Util.beside(\":\")(Data_Show.show(showTy)(v.value1)));\n    }));\n};\nvar showSelfAnno = Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {\n    return Language_CP_Syntax_Common.brackets((function () {\n        if (v.value1 instanceof Data_Maybe.Just) {\n            return Language_CP_Util.beside(v.value0)(Language_CP_Util.beside(\":\")(Data_Show.show(showTy)(v.value1.value0)));\n        };\n        if (v.value1 instanceof Data_Maybe.Nothing) {\n            return v.value0;\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Source (line 242, column 48 - line 244, column 15): \" + [ v.value1.constructor.name ]);\n    })());\n});\nvar showTm = {\n    show: function (v) {\n        if (v instanceof TmInt) {\n            return Data_Show.show(Data_Show.showInt)(v.value0);\n        };\n        if (v instanceof TmDouble) {\n            return Data_Show.show(Data_Show.showNumber)(v.value0);\n        };\n        if (v instanceof TmString) {\n            return Data_Show.show(Data_Show.showString)(v.value0);\n        };\n        if (v instanceof TmBool) {\n            return Data_Show.show(Data_Show.showBoolean)(v.value0);\n        };\n        if (v instanceof TmUnit) {\n            return \"()\";\n        };\n        if (v instanceof TmUndefined) {\n            return \"undefined\";\n        };\n        if (v instanceof TmUnary) {\n            return Data_Show.show(Language_CP_Syntax_Common.showUnOp)(v.value0) + Data_Show.show(showTm)(v.value1);\n        };\n        if (v instanceof TmBinary) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value1))(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Common.showBinOp)(v.value0))(Data_Show.show(showTm)(v.value2))));\n        };\n        if (v instanceof TmIf) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"if\")(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Language_CP_Util.beside(\"then\")(Language_CP_Util.beside(Data_Show.show(showTm)(v.value1))(Language_CP_Util.beside(\"else\")(Data_Show.show(showTm)(v.value2)))))));\n        };\n        if (v instanceof TmVar) {\n            var $213 = Language_CP_Util.isCapitalized(v.value0);\n            if ($213) {\n                return \"$\" + v.value0;\n            };\n            return v.value0;\n        };\n        if (v instanceof TmApp) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Data_Show.show(showTm)(v.value1)));\n        };\n        if (v instanceof TmAbs) {\n            return Language_CP_Syntax_Common.parens(\"\\\\\" + (showTmParams(v.value0) + Language_CP_Util.beside(\"->\")(Data_Show.show(showTm)(v.value1))));\n        };\n        if (v instanceof TmAnno) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Language_CP_Util.beside(\":\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TmMerge) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Language_CP_Util.beside(\",\")(Data_Show.show(showTm)(v.value1))));\n        };\n        if (v instanceof TmRcd) {\n            return Language_CP_Syntax_Common.braces(showRcdTm(v.value0));\n        };\n        if (v instanceof TmPrj) {\n            return Data_Show.show(showTm)(v.value0) + (\".\" + v.value1);\n        };\n        if (v instanceof TmTApp) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(\"@\" + Data_Show.show(showTy)(v.value1)));\n        };\n        if (v instanceof TmTAbs) {\n            return Language_CP_Syntax_Common.parens(\"/\\\\\" + (showTyParams(v.value0) + Language_CP_Util.beside(\".\")(Data_Show.show(showTm)(v.value1))));\n        };\n        if (v instanceof TmLet) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"let\")(Language_CP_Util.beside(v.value0)(showTyParams(v.value1) + (showTmParams(v.value2) + Language_CP_Util.beside(\"=\")(Language_CP_Util.beside(Data_Show.show(showTm)(v.value3))(Language_CP_Util.beside(\"in\")(Data_Show.show(showTm)(v.value4))))))));\n        };\n        if (v instanceof TmLetrec) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"letrec\")(Language_CP_Util.beside(v.value0)(showTyParams(v.value1) + (showTmParams(v.value2) + Language_CP_Util.beside(\":\")(Language_CP_Util.beside(Data_Show.show(showTy)(v.value3))(Language_CP_Util.beside(\"=\")(Language_CP_Util.beside(Data_Show.show(showTm)(v.value4))(Language_CP_Util.beside(\"in\")(Data_Show.show(showTm)(v.value5))))))))));\n        };\n        if (v instanceof TmOpen) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"open\")(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Language_CP_Util.beside(\"in\")(Data_Show.show(showTm)(v.value1)))));\n        };\n        if (v instanceof TmUpdate) {\n            return Language_CP_Syntax_Common.braces(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Language_CP_Util.beside(\"|\")(Data_Foldable.intercalate(Data_List_Types.foldableList)(Data_Monoid.monoidString)(\"; \")(Data_Functor.mapFlipped(Data_List_Types.functorList)(v.value1)(function (v1) {\n                return Language_CP_Util.beside(v1.value0)(Language_CP_Util.beside(\"=\")(Data_Show.show(showTm)(v1.value1)));\n            })))));\n        };\n        if (v instanceof TmTrait) {\n            return Language_CP_Syntax_Common.parens(\"trait\" + Language_CP_Util.beside(Data_Maybe.maybe(\"\")(function (v1) {\n                return \" \" + v1;\n            })(showSelfAnno(v.value0)))(showMaybe(showTy)(\"implements \")(v.value1)(\" \") + (showMaybe(showTm)(\"inherits \")(v.value2)(\" \") + Language_CP_Util.beside(\"=>\")(Data_Show.show(showTm)(v.value3)))));\n        };\n        if (v instanceof TmNew) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"new\")(Data_Show.show(showTm)(v.value0)));\n        };\n        if (v instanceof TmForward) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Language_CP_Util.beside(\"^\")(Data_Show.show(showTm)(v.value1))));\n        };\n        if (v instanceof TmExclude) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(Data_Show.show(showTm)(v.value0))(Language_CP_Util.beside(\"\\\\\")(Data_Show.show(showTy)(v.value1))));\n        };\n        if (v instanceof TmFold) {\n            return Language_CP_Syntax_Common.parens(\"fold @\" + Language_CP_Util.beside(Data_Show.show(showTy)(v.value0))(Data_Show.show(showTm)(v.value1)));\n        };\n        if (v instanceof TmUnfold) {\n            return Language_CP_Syntax_Common.parens(\"unfold @\" + Language_CP_Util.beside(Data_Show.show(showTy)(v.value0))(Data_Show.show(showTm)(v.value1)));\n        };\n        if (v instanceof TmToString) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(\"toString\")(Data_Show.show(showTm)(v.value0)));\n        };\n        if (v instanceof TmArray) {\n            return Language_CP_Syntax_Common.brackets(Data_Foldable.intercalate(Data_Foldable.foldableArray)(Data_Monoid.monoidString)(\"; \")(Data_Functor.map(Data_Functor.functorArray)(Data_Show.show(showTm))(v.value0)));\n        };\n        if (v instanceof TmDoc) {\n            return Data_Show.show(showTm)(v.value0);\n        };\n        if (v instanceof TmPos) {\n            return Data_Show.show(showTm)(v.value1);\n        };\n        if (v instanceof TmType) {\n            return Language_CP_Util.beside(\"type\")(Language_CP_Util.beside(v.value0)(intercalate$prime(Data_List_Types.foldableList)(Data_Monoid.monoidString)(\" \")(Data_Functor.map(Data_List_Types.functorList)(Language_CP_Syntax_Common.angles)(v.value1)) + (intercalate$prime(Data_List_Types.foldableList)(Data_Monoid.monoidString)(\" \")(v.value2) + Language_CP_Util.beside(\"=\")(Data_Show.show(showTy)(v.value3) + Language_CP_Util.beside(\";\")(Data_Show.show(showTm)(v.value4))))));\n        };\n        if (v instanceof TmDef) {\n            return Language_CP_Util.beside(v.value0)(showTyParams(v.value1) + (showTmParams(v.value2) + (showMaybe(showTy)(\": \")(v.value3)(\" \") + Language_CP_Util.beside(\"=\")(Data_Show.show(showTm)(v.value4) + Language_CP_Util.beside(\";\")(Data_Show.show(showTm)(v.value5))))));\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Source (line 102, column 1 - line 152, column 63): \" + [ v.constructor.name ]);\n    }\n};\nvar showTmParams = function (params) {\n    var showFields = function (v) {\n        if (v instanceof Data_List_Types.Nil) {\n            return \"\";\n        };\n        if (v instanceof Data_List_Types.Cons) {\n            return Language_CP_Util.beside(v.value0.value0)(Language_CP_Util.beside(\"=\")(Data_Show.show(showTm)(v.value0.value1) + Language_CP_Util.beside(\";\")(showFields(v.value1))));\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Source (line 213, column 9 - line 213, column 46): \" + [ v.constructor.name ]);\n    };\n    return intercalate$prime(Data_List_Types.foldableList)(Data_Monoid.monoidString)(\" \")(Data_Functor.mapFlipped(Data_List_Types.functorList)(params)(function (v) {\n        if (v instanceof TmParam && v.value1 instanceof Data_Maybe.Just) {\n            return Language_CP_Syntax_Common.parens(Language_CP_Util.beside(v.value0)(Language_CP_Util.beside(\":\")(Data_Show.show(showTy)(v.value1.value0))));\n        };\n        if (v instanceof TmParam && v.value1 instanceof Data_Maybe.Nothing) {\n            return v.value0;\n        };\n        if (v instanceof WildCard) {\n            return Language_CP_Util.beside(\"{\")(showFields(v.value0) + \".. }\");\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Source (line 209, column 53 - line 212, column 61): \" + [ v.constructor.name ]);\n    }));\n};\nvar showRcdTm = function (xs) {\n    var showMethod = function (l) {\n        return function (p) {\n            return function (e) {\n                return \".\" + Language_CP_Util.beside(l)(showTmParams(p) + Language_CP_Util.beside(\"=\")(Data_Show.show(showTm)(e)));\n            };\n        };\n    };\n    var showField = function (l) {\n        return function (p) {\n            return function (v) {\n                if (v instanceof Data_Either.Left) {\n                    return Language_CP_Util.beside(l)(showTmParams(p) + Language_CP_Util.beside(\"=\")(Data_Show.show(showTm)(v.value0)));\n                };\n                if (v instanceof Data_Either.Right) {\n                    return Data_Maybe.maybe(\"\")(function (v1) {\n                        return v1 + \"@\";\n                    })(showSelfAnno(v.value0.value0)) + (Language_CP_Syntax_Common.parens(\" \" + Language_CP_Util.beside(l)(showTmParams(p))) + showMethod(v.value0.value1)(v.value0.value2)(v.value0.value3));\n                };\n                throw new Error(\"Failed pattern match at Language.CP.Syntax.Source (line 231, column 9 - line 231, column 79): \" + [ l.constructor.name, p.constructor.name, v.constructor.name ]);\n            };\n        };\n    };\n    return Data_Foldable.intercalate(Data_List_Types.foldableList)(Data_Monoid.monoidString)(\"; \")(Data_Functor.mapFlipped(Data_List_Types.functorList)(xs)(function (v) {\n        if (v instanceof RcdField) {\n            return (function () {\n                if (v.value0) {\n                    return \"override \";\n                };\n                return \"\";\n            })() + showField(v.value1)(v.value2)(v.value3);\n        };\n        if (v instanceof DefaultPattern) {\n            return Data_Maybe.fromMaybe(\"_\")(showSelfAnno(v.value0.value0)) + showMethod(v.value0.value1)(v.value0.value2)(v.value0.value3);\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Syntax.Source (line 227, column 42 - line 230, column 58): \" + [ v.constructor.name ]);\n    }));\n};\nvar showDoc = function (v) {\n    if (v instanceof TmDoc) {\n        return \"`\" + (showDoc(v.value0) + \"`\");\n    };\n    if (v instanceof TmPos && v.value1 instanceof TmDoc) {\n        return \"[\" + (showDoc(v.value1.value0) + \"]\");\n    };\n    if (v instanceof TmPos) {\n        return showDoc(v.value1);\n    };\n    if (v instanceof TmNew) {\n        return showDoc(v.value0);\n    };\n    if (v instanceof TmVar && v.value0 === \"Endl\") {\n        return \"\\\\\\\\\";\n    };\n    if (v instanceof TmApp && (v.value0 instanceof TmApp && (v.value0.value0 instanceof TmVar && v.value0.value0.value0 === \"Comp\"))) {\n        return showDoc(v.value0.value1) + showDoc(v.value1);\n    };\n    if (v instanceof TmApp && (v.value0 instanceof TmVar && (v.value0.value0 === \"Str\" && v.value1 instanceof TmString))) {\n        return v.value1.value0;\n    };\n    if (v instanceof TmApp && (v.value0 instanceof TmVar && (v.value0.value0 === \"Str\" && v.value1 instanceof TmToString))) {\n        return \"\\\\(\" + (Data_Show.show(showTm)(v.value1.value0) + \")\");\n    };\n    if (v instanceof TmApp && v.value0 instanceof TmVar) {\n        return \"\\\\\" + (v.value0.value0 + showDoc(v.value1));\n    };\n    if (v instanceof TmApp) {\n        return showDoc(v.value0) + showDoc(v.value1);\n    };\n    return \"(\" + (Data_Show.show(showTm)(v) + \")\");\n};\nmodule.exports = {\n    TyInt: TyInt,\n    TyDouble: TyDouble,\n    TyString: TyString,\n    TyBool: TyBool,\n    TyTop: TyTop,\n    TyBot: TyBot,\n    TyArrow: TyArrow,\n    TyAnd: TyAnd,\n    TyRcd: TyRcd,\n    TyVar: TyVar,\n    TyForall: TyForall,\n    TyRec: TyRec,\n    TyApp: TyApp,\n    TyAbs: TyAbs,\n    TyTrait: TyTrait,\n    TySort: TySort,\n    TySig: TySig,\n    TyArray: TyArray,\n    TmInt: TmInt,\n    TmDouble: TmDouble,\n    TmString: TmString,\n    TmBool: TmBool,\n    TmUnit: TmUnit,\n    TmUndefined: TmUndefined,\n    TmUnary: TmUnary,\n    TmBinary: TmBinary,\n    TmIf: TmIf,\n    TmVar: TmVar,\n    TmApp: TmApp,\n    TmAbs: TmAbs,\n    TmAnno: TmAnno,\n    TmMerge: TmMerge,\n    TmRcd: TmRcd,\n    TmPrj: TmPrj,\n    TmTApp: TmTApp,\n    TmTAbs: TmTAbs,\n    TmLet: TmLet,\n    TmLetrec: TmLetrec,\n    TmOpen: TmOpen,\n    TmUpdate: TmUpdate,\n    TmTrait: TmTrait,\n    TmNew: TmNew,\n    TmForward: TmForward,\n    TmExclude: TmExclude,\n    TmFold: TmFold,\n    TmUnfold: TmUnfold,\n    TmToString: TmToString,\n    TmArray: TmArray,\n    TmDoc: TmDoc,\n    TmPos: TmPos,\n    TmType: TmType,\n    TmDef: TmDef,\n    RcdField: RcdField,\n    DefaultPattern: DefaultPattern,\n    MethodPattern: MethodPattern,\n    showDoc: showDoc,\n    tySubst: tySubst,\n    \"intercalate'\": intercalate$prime,\n    showMaybe: showMaybe,\n    showTyParams: showTyParams,\n    TmParam: TmParam,\n    WildCard: WildCard,\n    showTmParams: showTmParams,\n    RcdTy: RcdTy,\n    showRcdTy: showRcdTy,\n    showRcdTm: showRcdTm,\n    showSelfAnno: showSelfAnno,\n    showTy: showTy,\n    eqTy: eqTy,\n    showTm: showTm,\n    eqRcdTy: eqRcdTy\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Syntax/Source.purs?");

/***/ }),

/***/ "./src/CP/Transform.purs":
/*!*******************************!*\
  !*** ./src/CP/Transform.purs ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Alt = __webpack_require__(/*! ./.spago/control/v5.0.0/src/Control/Alt.purs */ \"./.spago/control/v5.0.0/src/Control/Alt.purs\");\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_Except_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs\");\nvar Control_Monad_Reader_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs\");\nvar Data_Bitraversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Bitraversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Bitraversable.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Language_CP_Context = __webpack_require__(/*! ./src/CP/Context.purs */ \"./src/CP/Context.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar Language_CP_Syntax_Source = __webpack_require__(/*! ./src/CP/Syntax/Source.purs */ \"./src/CP/Syntax/Source.purs\");\nvar Language_CP_Util = __webpack_require__(/*! ./src/CP/Util.purs */ \"./src/CP/Util.purs\");\nvar translate = function (v) {\n    if (v instanceof Language_CP_Syntax_Source.TyRcd && v.value0 instanceof Data_List_Types.Nil) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Core.TyTop.value);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyRcd) {\n        return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Util.foldl1(Language_CP_Syntax_Core.TyAnd.create))(Data_Traversable[\"for\"](Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_List_Types.traversableList)(v.value0)(function (v1) {\n            return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Core.TyRcd.create(v1.value0))(translate(v1.value1)))(v1.value2);\n        }));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyForall) {\n        var disjointness = function (v1) {\n            if (v1 instanceof Data_Maybe.Just) {\n                return translate(v1.value0);\n            };\n            if (v1 instanceof Data_Maybe.Nothing) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Core.TyTop.value);\n            };\n            throw new Error(\"Failed pattern match at Language.CP.Transform (line 32, column 9 - line 32, column 50): \" + [ v1.constructor.name ]);\n        };\n        return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Data_Foldable.foldr(Data_List_Types.foldableList)(Data_Tuple.uncurry(Language_CP_Syntax_Core.TyForall.create)))(translate(v.value1)))(Data_Traversable.traverse(Data_List_Types.traversableList)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_Bitraversable.rtraverse(Data_Bitraversable.bitraversableTuple)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(disjointness))(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyInt) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Core.TyInt.value);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyDouble) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Core.TyDouble.value);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyString) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Core.TyString.value);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyBool) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Core.TyBool.value);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyTop) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Core.TyTop.value);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyBot) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Core.TyBot.value);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyAnd) {\n        return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Core.TyAnd.create)(translate(v.value0)))(translate(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyArrow) {\n        return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Core.TyArrow.create)(translate(v.value0)))(translate(v.value1)))(false);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyVar) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Core.TyVar(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyRec) {\n        return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Core.TyRec.create(v.value0))(translate(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyTrait && v.value0 instanceof Data_Maybe.Nothing) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(translate(v.value1))(function (to$prime) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Core.TyArrow(to$prime, to$prime, true));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyTrait && v.value0 instanceof Data_Maybe.Just) {\n        return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Core.TyArrow.create)(translate(v.value0.value0)))(translate(v.value1)))(true);\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyArray) {\n        return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Core.TyArray.create)(translate(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyAbs) {\n        return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected a proper type, but got\")(Data_Show.show(Language_CP_Syntax_Source.showTy)(v)));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TySig) {\n        return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected a proper type, but got\")(Data_Show.show(Language_CP_Syntax_Source.showTy)(v)));\n    };\n    return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected an expanded type, but got\")(Data_Show.show(Language_CP_Syntax_Source.showTy)(v)));\n};\nvar someTy = Language_CP_Syntax_Core.TyTop.value;\nvar expand = function (v) {\n    if (v instanceof Language_CP_Syntax_Source.TyArrow) {\n        return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyArrow.create)(expand(v.value0)))(expand(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyAnd) {\n        return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyAnd.create)(expand(v.value0)))(expand(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyRcd) {\n        return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyRcd.create)(Data_Traversable[\"for\"](Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_List_Types.traversableList)(v.value0)(function (v1) {\n            return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.RcdTy.create(v1.value0))(expand(v1.value1)))(v1.value2);\n        }));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyVar) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.lookupTyBind(v.value0))(function (mtd) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.lookupSort(v.value0))(function (ms) {\n                var v1 = Control_Alt.alt(Data_Maybe.altMaybe)(Data_Functor[\"void\"](Data_Maybe.functorMaybe)(mtd))(Data_Functor[\"void\"](Data_Maybe.functorMaybe)(ms));\n                if (v1 instanceof Data_Maybe.Just) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Source.TyVar(v.value0));\n                };\n                if (v1 instanceof Data_Maybe.Nothing) {\n                    return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.lookupTyAlias(v.value0))(function (mt) {\n                        if (mt instanceof Data_Maybe.Just) {\n                            return expand(mt.value0);\n                        };\n                        if (mt instanceof Data_Maybe.Nothing) {\n                            return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"type variable\")(Language_CP_Util.beside(Data_Show.show(Data_Show.showString)(v.value0))(\"is undefined\")));\n                        };\n                        throw new Error(\"Failed pattern match at Language.CP.Transform (line 72, column 7 - line 74, column 82): \" + [ mt.constructor.name ]);\n                    });\n                };\n                throw new Error(\"Failed pattern match at Language.CP.Transform (line 68, column 3 - line 74, column 82): \" + [ v1.constructor.name ]);\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyForall) {\n        return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyForall.create)(Data_Traversable.traverse(Data_List_Types.traversableList)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_Bitraversable.rtraverse(Data_Bitraversable.bitraversableTuple)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_Traversable.traverse(Data_Traversable.traversableMaybe)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(expand)))(v.value0)))(Data_Foldable.foldr(Data_List_Types.foldableList)(function (x) {\n            return function (s) {\n                return Language_CP_Context.addTyBind(Data_Tuple.fst(x))(someTy)(s);\n            };\n        })(expand(v.value1))(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyRec) {\n        return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyRec.create(v.value0))(Language_CP_Context.addTyBind(v.value0)(someTy)(expand(v.value1)));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyApp) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(expand(v.value0))(function (t1$prime) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(expand(v.value1))(function (t2$prime) {\n                if (t1$prime instanceof Language_CP_Syntax_Source.TyAbs) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Source.tySubst(t1$prime.value0)(t2$prime)(t1$prime.value1));\n                };\n                if (t1$prime instanceof Language_CP_Syntax_Source.TySig) {\n                    if (t2$prime instanceof Language_CP_Syntax_Source.TySort && t2$prime.value1 instanceof Data_Maybe.Just) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Source.tySubst(t1$prime.value1)(t2$prime.value1.value0)(Language_CP_Syntax_Source.tySubst(t1$prime.value0)(t2$prime.value0)(t1$prime.value2)));\n                    };\n                    return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"sig instantiation expected a sort, but got\")(Data_Show.show(Language_CP_Syntax_Source.showTy)(v.value1)));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected an applicable type, but got\")(Data_Show.show(Language_CP_Syntax_Source.showTy)(v.value0)));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyAbs) {\n        return Language_CP_Context.addTyBind(v.value0)(someTy)(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyAbs.create(v.value0))(expand(v.value1)));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyTrait) {\n        return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyTrait.create)(Data_Traversable.traverse(Data_Traversable.traversableMaybe)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(expand)(v.value0)))(expand(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TySort) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(expand(v.value0))(function (ti$prime) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Data_Traversable.traverse(Data_Traversable.traversableMaybe)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(expand)(v.value1))(function (mto) {\n                if (mto instanceof Data_Maybe.Just) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Source.TySort(new Language_CP_Syntax_Source.TyAnd(ti$prime, mto.value0), new Data_Maybe.Just(mto.value0)));\n                };\n                if (mto instanceof Data_Maybe.Nothing) {\n                    if (ti$prime instanceof Language_CP_Syntax_Source.TyVar) {\n                        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.lookupSort(ti$prime.value0))(function (mb) {\n                            if (mb instanceof Data_Maybe.Just) {\n                                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Source.TySort(ti$prime, new Data_Maybe.Just(new Language_CP_Syntax_Source.TyVar(mb.value0))));\n                            };\n                            if (mb instanceof Data_Maybe.Nothing) {\n                                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Source.TySort(ti$prime, new Data_Maybe.Just(ti$prime)));\n                            };\n                            throw new Error(\"Failed pattern match at Language.CP.Transform (line 102, column 9 - line 103, column 61): \" + [ mb.constructor.name ]);\n                        });\n                    };\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Source.TySort(ti$prime, new Data_Maybe.Just(ti$prime)));\n                };\n                throw new Error(\"Failed pattern match at Language.CP.Transform (line 97, column 3 - line 104, column 42): \" + [ mto.constructor.name ]);\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TyArray) {\n        return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyArray.create)(expand(v.value0));\n    };\n    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(v);\n};\nvar transform = Control_Bind.composeKleisli(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(expand)(translate);\nvar transform$prime = function (t) {\n    return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(expand(t))(function (t$prime) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(translate(t$prime))(function (t$prime$prime) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(t$prime$prime, t$prime));\n        });\n    });\n};\nvar distinguish = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v2 instanceof Language_CP_Syntax_Source.TyArrow) {\n                return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyArrow.create)(distinguish(v)(!v1)(v2.value0)))(distinguish(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof Language_CP_Syntax_Source.TyAnd) {\n                return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyAnd.create)(distinguish(v)(v1)(v2.value0)))(distinguish(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof Language_CP_Syntax_Source.TyRcd) {\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyRcd.create)(Data_Traversable[\"for\"](Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_List_Types.traversableList)(v2.value0)(function (v3) {\n                    return Data_Functor.flap(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.RcdTy.create(v3.value0))(distinguish(Language_CP_Util.isCapitalized(v3.value0))(v1)(v3.value1)))(v3.value2);\n                }));\n            };\n            if (v1 && v2 instanceof Language_CP_Syntax_Source.TyVar) {\n                return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.lookupSort(v2.value0))(function (mb) {\n                    if (mb instanceof Data_Maybe.Just) {\n                        if (v) {\n                            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Source.TyTrait(new Data_Maybe.Just(v2), new Language_CP_Syntax_Source.TyVar(mb.value0)));\n                        };\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Source.TyVar(mb.value0));\n                    };\n                    if (mb instanceof Data_Maybe.Nothing) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Source.TyVar(v2.value0));\n                    };\n                    throw new Error(\"Failed pattern match at Language.CP.Transform (line 122, column 3 - line 124, column 41): \" + [ mb.constructor.name ]);\n                });\n            };\n            if (v2 instanceof Language_CP_Syntax_Source.TyForall) {\n                return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyForall.create)(Data_Traversable.traverse(Data_List_Types.traversableList)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_Bitraversable.rtraverse(Data_Bitraversable.bitraversableTuple)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_Traversable.traverse(Data_Traversable.traversableMaybe)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(distinguish(v)(v1))))(v2.value0)))(distinguish(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof Language_CP_Syntax_Source.TyRec) {\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyRec.create(v2.value0))(distinguish(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof Language_CP_Syntax_Source.TyApp) {\n                return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyApp.create)(distinguish(v)(v1)(v2.value0)))(distinguish(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof Language_CP_Syntax_Source.TyAbs) {\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyAbs.create(v2.value0))(distinguish(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof Language_CP_Syntax_Source.TyTrait) {\n                return Control_Apply.apply(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyTrait.create)(Data_Traversable.traverse(Data_Traversable.traversableMaybe)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(distinguish(v)(!v1))(v2.value0)))(distinguish(v)(v1)(v2.value1));\n            };\n            if (v2 instanceof Language_CP_Syntax_Source.TyArray) {\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Language_CP_Syntax_Source.TyArray.create)(distinguish(v)(v1)(v2.value0));\n            };\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(v2);\n        };\n    };\n};\nvar transformTyDef = Control_Bind.composeKleisli(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(expand)(distinguish(false)(true));\nmodule.exports = {\n    transform: transform,\n    \"transform'\": transform$prime,\n    translate: translate,\n    someTy: someTy,\n    expand: expand,\n    transformTyDef: transformTyDef,\n    distinguish: distinguish\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Transform.purs?");

/***/ }),

/***/ "./src/CP/Typing.purs":
/*!****************************!*\
  !*** ./src/CP/Typing.purs ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Control_Applicative = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Applicative.purs */ \"./.spago/prelude/v5.0.1/src/Control/Applicative.purs\");\nvar Control_Apply = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Apply.purs */ \"./.spago/prelude/v5.0.1/src/Control/Apply.purs\");\nvar Control_Bind = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Control/Bind.purs */ \"./.spago/prelude/v5.0.1/src/Control/Bind.purs\");\nvar Control_Monad_Except_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Except/Trans.purs\");\nvar Control_Monad_Reader_Trans = __webpack_require__(/*! ./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs */ \"./.spago/transformers/v5.2.0/src/Control/Monad/Reader/Trans.purs\");\nvar Data_Array = __webpack_require__(/*! ./.spago/arrays/v6.0.1/src/Data/Array.purs */ \"./.spago/arrays/v6.0.1/src/Data/Array.purs\");\nvar Data_Boolean = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Boolean.purs */ \"./.spago/prelude/v5.0.1/src/Data/Boolean.purs\");\nvar Data_Either = __webpack_require__(/*! ./.spago/either/v5.0.0/src/Data/Either.purs */ \"./.spago/either/v5.0.0/src/Data/Either.purs\");\nvar Data_Eq = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Eq.purs */ \"./.spago/prelude/v5.0.1/src/Data/Eq.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_Function = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Function.purs */ \"./.spago/prelude/v5.0.1/src/Data/Function.purs\");\nvar Data_Functor = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Functor.purs */ \"./.spago/prelude/v5.0.1/src/Data/Functor.purs\");\nvar Data_Identity = __webpack_require__(/*! ./.spago/identity/v5.0.0/src/Data/Identity.purs */ \"./.spago/identity/v5.0.0/src/Data/Identity.purs\");\nvar Data_List = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List.purs */ \"./.spago/lists/v6.0.1/src/Data/List.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_Ord = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Ord.purs */ \"./.spago/prelude/v5.0.1/src/Data/Ord.purs\");\nvar Data_Semigroup = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Semigroup.purs */ \"./.spago/prelude/v5.0.1/src/Data/Semigroup.purs\");\nvar Data_Set = __webpack_require__(/*! ./.spago/ordered-collections/v2.0.1/src/Data/Set.purs */ \"./.spago/ordered-collections/v2.0.1/src/Data/Set.purs\");\nvar Data_Show = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Show.purs */ \"./.spago/prelude/v5.0.1/src/Data/Show.purs\");\nvar Data_Traversable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Traversable.purs\");\nvar Data_Tuple = __webpack_require__(/*! ./.spago/tuples/v6.0.1/src/Data/Tuple.purs */ \"./.spago/tuples/v6.0.1/src/Data/Tuple.purs\");\nvar Data_Unit = __webpack_require__(/*! ./.spago/prelude/v5.0.1/src/Data/Unit.purs */ \"./.spago/prelude/v5.0.1/src/Data/Unit.purs\");\nvar Language_CP_Context = __webpack_require__(/*! ./src/CP/Context.purs */ \"./src/CP/Context.purs\");\nvar Language_CP_Desugar = __webpack_require__(/*! ./src/CP/Desugar.purs */ \"./src/CP/Desugar.purs\");\nvar Language_CP_Subtyping = __webpack_require__(/*! ./src/CP/Subtyping.purs */ \"./src/CP/Subtyping.purs\");\nvar Language_CP_Syntax_Common = __webpack_require__(/*! ./src/CP/Syntax/Common.purs */ \"./src/CP/Syntax/Common.purs\");\nvar Language_CP_Syntax_Core = __webpack_require__(/*! ./src/CP/Syntax/Core.purs */ \"./src/CP/Syntax/Core.purs\");\nvar Language_CP_Syntax_Source = __webpack_require__(/*! ./src/CP/Syntax/Source.purs */ \"./src/CP/Syntax/Source.purs\");\nvar Language_CP_Transform = __webpack_require__(/*! ./src/CP/Transform.purs */ \"./src/CP/Transform.purs\");\nvar Language_CP_Util = __webpack_require__(/*! ./src/CP/Util.purs */ \"./src/CP/Util.purs\");\nvar transformTyRec = function (t) {\n    return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Transform.transform(t))(function (t$prime) {\n        if (t$prime instanceof Language_CP_Syntax_Core.TyRec) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(t$prime);\n        };\n        return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"fold/unfold expected a recursive type, but got\")(Data_Show.show(Language_CP_Syntax_Source.showTy)(t)));\n    });\n};\nvar trait = function (x) {\n    return function (e) {\n        return function (targ) {\n            return function (tret) {\n                return new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmAbs(x, e, targ, tret, false), new Language_CP_Syntax_Core.TyArrow(targ, tret, true));\n            };\n        };\n    };\n};\nvar selectLabel = function (v) {\n    return function (v1) {\n        return function (v2) {\n            if (v instanceof Language_CP_Syntax_Core.TyAnd) {\n                var v3 = selectLabel(v.value1)(v1)(v2);\n                var v4 = selectLabel(v.value0)(v1)(v2);\n                if (v4 instanceof Data_Maybe.Just && v3 instanceof Data_Maybe.Just) {\n                    return new Data_Maybe.Just(new Language_CP_Syntax_Core.TyAnd(v4.value0, v3.value0));\n                };\n                if (v4 instanceof Data_Maybe.Just && v3 instanceof Data_Maybe.Nothing) {\n                    return new Data_Maybe.Just(v4.value0);\n                };\n                if (v4 instanceof Data_Maybe.Nothing && v3 instanceof Data_Maybe.Just) {\n                    return new Data_Maybe.Just(v3.value0);\n                };\n                if (v4 instanceof Data_Maybe.Nothing && v3 instanceof Data_Maybe.Nothing) {\n                    return Data_Maybe.Nothing.value;\n                };\n                throw new Error(\"Failed pattern match at Language.CP.Typing (line 481, column 3 - line 485, column 34): \" + [ v4.constructor.name, v3.constructor.name ]);\n            };\n            if (v instanceof Language_CP_Syntax_Core.TyRcd && (v1 === v.value0 && v2 === v.value2)) {\n                return new Data_Maybe.Just(v.value1);\n            };\n            return Data_Maybe.Nothing.value;\n        };\n    };\n};\nvar letIn = function (x) {\n    return function (e1) {\n        return function (t1) {\n            return function (e2) {\n                return function (t2) {\n                    return new Language_CP_Syntax_Core.TmApp(new Language_CP_Syntax_Core.TmAbs(x, e2, t1, t2, false), e1, false);\n                };\n            };\n        };\n    };\n};\nvar disjointTyBind = function (a1) {\n    return function (t1) {\n        return function (a2) {\n            return function (t2) {\n                return function (td) {\n                    var freshName = a1 + (\" or \" + a2);\n                    var freshVar = new Language_CP_Syntax_Core.TyVar(freshName);\n                    return Language_CP_Context.addTyBind(freshName)(td)(disjoint(Language_CP_Syntax_Core.tySubst(a1)(freshVar)(t1))(Language_CP_Syntax_Core.tySubst(a2)(freshVar)(t2)));\n                };\n            };\n        };\n    };\n};\nvar disjoint = function (v) {\n    return function (v1) {\n        if (Language_CP_Subtyping.isTopLike(v)) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_Unit.unit);\n        };\n        if (Language_CP_Subtyping.isTopLike(v1)) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_Unit.unit);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyArrow && v1 instanceof Language_CP_Syntax_Core.TyArrow) {\n            return disjoint(v.value1)(v1.value1);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyAnd) {\n            return Control_Apply.applySecond(Control_Monad_Reader_Trans.applyReaderT(Control_Monad_Except_Trans.applyExceptT(Data_Identity.monadIdentity)))(disjoint(v.value0)(v1))(disjoint(v.value1)(v1));\n        };\n        if (v1 instanceof Language_CP_Syntax_Core.TyAnd) {\n            return disjoint(new Language_CP_Syntax_Core.TyAnd(v1.value0, v1.value1))(v);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyRcd && v1 instanceof Language_CP_Syntax_Core.TyRcd) {\n            if (v.value0 === v1.value0 && (!v.value2 && !v1.value2)) {\n                return disjoint(v.value1)(v1.value1);\n            };\n            if (Data_Boolean.otherwise) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_Unit.unit);\n            };\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyVar) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.lookupTyBind(v.value0))(function (mt$prime) {\n                if (mt$prime instanceof Data_Maybe.Just) {\n                    var $127 = Language_CP_Subtyping.subtype(mt$prime.value0)(v1);\n                    if ($127) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_Unit.unit);\n                    };\n                    return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"type variable\")(Language_CP_Util.beside(Data_Show.show(Data_Show.showString)(v.value0))(Language_CP_Util.beside(\"is not disjoint from\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1)))));\n                };\n                if (mt$prime instanceof Data_Maybe.Nothing) {\n                    return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"type variable\")(Language_CP_Util.beside(Data_Show.show(Data_Show.showString)(v.value0))(\"is undefined\")));\n                };\n                throw new Error(\"Failed pattern match at Language.CP.Typing (line 433, column 3 - line 436, column 78): \" + [ mt$prime.constructor.name ]);\n            });\n        };\n        if (v1 instanceof Language_CP_Syntax_Core.TyVar) {\n            return disjoint(new Language_CP_Syntax_Core.TyVar(v1.value0))(v);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyForall && v1 instanceof Language_CP_Syntax_Core.TyForall) {\n            return disjointTyBind(v.value0)(v.value2)(v1.value0)(v1.value2)(new Language_CP_Syntax_Core.TyAnd(v.value1, v1.value1));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyRec && v1 instanceof Language_CP_Syntax_Core.TyRec) {\n            return disjointTyBind(v.value0)(v.value1)(v1.value0)(v1.value1)(Language_CP_Syntax_Core.TyBot.value);\n        };\n        if (Data_Eq.notEq(Language_CP_Syntax_Core.eqTy)(v)(v1)) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_Unit.unit);\n        };\n        if (Data_Boolean.otherwise) {\n            return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected two disjoint types, but got\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v))(Language_CP_Util.beside(\"and\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1)))));\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Typing (line 422, column 1 - line 422, column 40): \" + [ v.constructor.name, v1.constructor.name ]);\n    };\n};\nvar distApp = function (v) {\n    return function (v1) {\n        if (v instanceof Language_CP_Syntax_Core.TyTop) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Language_CP_Syntax_Core.TyTop.value);\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyArrow && v1 instanceof Data_Either.Left) {\n            if (Language_CP_Subtyping.subtype(v1.value0)(v.value0)) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(v.value1);\n            };\n            if (Data_Boolean.otherwise) {\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected the argument type to be a subtype of the parameter type, but got\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value0))(Language_CP_Util.beside(\"and\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v.value0)))));\n            };\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyForall && v1 instanceof Data_Either.Right) {\n            return Data_Functor.voidLeft(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(disjoint(v1.value0)(v.value1))(Language_CP_Syntax_Core.tySubst(v.value0)(v1.value0)(v.value2));\n        };\n        if (v instanceof Language_CP_Syntax_Core.TyAnd) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(distApp(v.value0)(v1))(function (t1$prime) {\n                return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(distApp(v.value1)(v1))(function (t2$prime) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Core.TyAnd(t1$prime, t2$prime));\n                });\n            });\n        };\n        return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected an applicable type, but got\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v)));\n    };\n};\nvar diffRcdTy = function (x) {\n    return function (y) {\n        var toArray = function (v) {\n            if (v instanceof Language_CP_Syntax_Core.TyAnd) {\n                return Data_Semigroup.append(Data_Semigroup.semigroupArray)(toArray(v.value0))(toArray(v.value1));\n            };\n            return [ v ];\n        };\n        var fromArray = Data_Foldable.foldr(Data_Foldable.foldableArray)(Language_CP_Syntax_Core.TyAnd.create)(Language_CP_Syntax_Core.TyTop.value);\n        return fromArray(Data_Array.difference(Language_CP_Syntax_Core.eqTy)(toArray(x))(toArray(y)));\n    };\n};\nvar collectLabels = function (v) {\n    if (v instanceof Language_CP_Syntax_Core.TyAnd) {\n        return Data_Set.union(Data_Ord.ordString)(collectLabels(v.value0))(collectLabels(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Core.TyRcd && !v.value2) {\n        return Data_Set.singleton(v.value0);\n    };\n    return Data_Set.empty;\n};\nvar infer = function (v) {\n    if (v instanceof Language_CP_Syntax_Source.TmInt) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmInt(v.value0), Language_CP_Syntax_Core.TyInt.value));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmDouble) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmDouble(v.value0), Language_CP_Syntax_Core.TyDouble.value));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmString) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmString(v.value0), Language_CP_Syntax_Core.TyString.value));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmBool) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmBool(v.value0), Language_CP_Syntax_Core.TyBool.value));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmUnit) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(Language_CP_Syntax_Core.TmUnit.value, Language_CP_Syntax_Core.TyTop.value));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmUndefined) {\n        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(Language_CP_Syntax_Core.TmUndefined.value, Language_CP_Syntax_Core.TyBot.value));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmUnary && v.value0 instanceof Language_CP_Syntax_Common.Neg) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v1) {\n            var core = function (ty) {\n                return new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmUnary(Language_CP_Syntax_Common.Neg.value, new Language_CP_Syntax_Core.TmAnno(v1.value0, ty)), ty);\n            };\n            var $168 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyInt.value);\n            if ($168) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(Language_CP_Syntax_Core.TyInt.value));\n            };\n            var $169 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyDouble.value);\n            if ($169) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(Language_CP_Syntax_Core.TyDouble.value));\n            };\n            return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"Neg is not defined for\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1)));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmUnary && v.value0 instanceof Language_CP_Syntax_Common.Not) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v1) {\n            var core = new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmUnary(Language_CP_Syntax_Common.Not.value, new Language_CP_Syntax_Core.TmAnno(v1.value0, Language_CP_Syntax_Core.TyBool.value)), Language_CP_Syntax_Core.TyBool.value);\n            var $175 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyBool.value);\n            if ($175) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core);\n            };\n            return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"Not is not defined for\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1)));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmUnary && v.value0 instanceof Language_CP_Syntax_Common.Len) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v1) {\n            var core = new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmUnary(Language_CP_Syntax_Common.Len.value, v1.value0), Language_CP_Syntax_Core.TyInt.value);\n            if (v1.value1 instanceof Language_CP_Syntax_Core.TyArray) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core);\n            };\n            return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"Len is not defined for\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1)));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmBinary && v.value0 instanceof Language_CP_Syntax_Common.Arith) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value2))(function (v2) {\n                var core = function (ty) {\n                    return new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmBinary(new Language_CP_Syntax_Common.Arith(v.value0.value0), new Language_CP_Syntax_Core.TmAnno(v1.value0, ty), new Language_CP_Syntax_Core.TmAnno(v2.value0, ty)), ty);\n                };\n                var $189 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyInt.value) && Language_CP_Subtyping.subtype(v2.value1)(Language_CP_Syntax_Core.TyInt.value);\n                if ($189) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(Language_CP_Syntax_Core.TyInt.value));\n                };\n                var $190 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyDouble.value) && Language_CP_Subtyping.subtype(v2.value1)(Language_CP_Syntax_Core.TyDouble.value);\n                if ($190) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(Language_CP_Syntax_Core.TyDouble.value));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"ArithOp is not defined between\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1))(Language_CP_Util.beside(\"and\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v2.value1)))));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmBinary && v.value0 instanceof Language_CP_Syntax_Common.Comp) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value2))(function (v2) {\n                var core = function (ty) {\n                    return new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmBinary(new Language_CP_Syntax_Common.Comp(v.value0.value0), new Language_CP_Syntax_Core.TmAnno(v1.value0, ty), new Language_CP_Syntax_Core.TmAnno(v2.value0, ty)), Language_CP_Syntax_Core.TyBool.value);\n                };\n                var $201 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyInt.value) && Language_CP_Subtyping.subtype(v2.value1)(Language_CP_Syntax_Core.TyInt.value);\n                if ($201) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(Language_CP_Syntax_Core.TyInt.value));\n                };\n                var $202 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyDouble.value) && Language_CP_Subtyping.subtype(v2.value1)(Language_CP_Syntax_Core.TyDouble.value);\n                if ($202) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(Language_CP_Syntax_Core.TyDouble.value));\n                };\n                var $203 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyString.value) && Language_CP_Subtyping.subtype(v2.value1)(Language_CP_Syntax_Core.TyString.value);\n                if ($203) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(Language_CP_Syntax_Core.TyString.value));\n                };\n                var $204 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyBool.value) && Language_CP_Subtyping.subtype(v2.value1)(Language_CP_Syntax_Core.TyBool.value);\n                if ($204) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(Language_CP_Syntax_Core.TyBool.value));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"CompOp is not defined between\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1))(Language_CP_Util.beside(\"and\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v2.value1)))));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmBinary && v.value0 instanceof Language_CP_Syntax_Common.Logic) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value2))(function (v2) {\n                var core = new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmBinary(new Language_CP_Syntax_Common.Logic(v.value0.value0), new Language_CP_Syntax_Core.TmAnno(v1.value0, Language_CP_Syntax_Core.TyBool.value), new Language_CP_Syntax_Core.TmAnno(v2.value0, Language_CP_Syntax_Core.TyBool.value)), Language_CP_Syntax_Core.TyBool.value);\n                var $215 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyBool.value) && Language_CP_Subtyping.subtype(v2.value1)(Language_CP_Syntax_Core.TyBool.value);\n                if ($215) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core);\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"LogicOp is not defined between\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1))(Language_CP_Util.beside(\"and\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v2.value1)))));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmBinary && v.value0 instanceof Language_CP_Syntax_Common.Append) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value2))(function (v2) {\n                var $226 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyString.value) && Language_CP_Subtyping.subtype(v2.value1)(Language_CP_Syntax_Core.TyString.value);\n                if ($226) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmBinary(Language_CP_Syntax_Common.Append.value, new Language_CP_Syntax_Core.TmAnno(v1.value0, Language_CP_Syntax_Core.TyString.value), new Language_CP_Syntax_Core.TmAnno(v2.value0, Language_CP_Syntax_Core.TyString.value)), Language_CP_Syntax_Core.TyString.value));\n                };\n                if (v1.value1 instanceof Language_CP_Syntax_Core.TyArray && v2.value1 instanceof Language_CP_Syntax_Core.TyArray) {\n                    var core = function (el) {\n                        return function (er) {\n                            return function (ty) {\n                                return new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmBinary(Language_CP_Syntax_Common.Append.value, el, er), ty);\n                            };\n                        };\n                    };\n                    var $229 = Language_CP_Subtyping.aeq(v1.value1.value0)(v2.value1.value0);\n                    if ($229) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(v1.value0)(v2.value0)(v1.value1));\n                    };\n                    var $230 = Language_CP_Subtyping.subtype(v2.value1.value0)(v1.value1.value0);\n                    if ($230) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(v1.value0)(new Language_CP_Syntax_Core.TmAnno(v2.value0, v1.value1))(v1.value1));\n                    };\n                    var $231 = Language_CP_Subtyping.subtype(v1.value1.value0)(v2.value1.value0);\n                    if ($231) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(new Language_CP_Syntax_Core.TmAnno(v1.value0, v2.value1))(v2.value0)(v2.value1));\n                    };\n                    return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"Append expected two arrays of equivalent types or subtypes,\")(Language_CP_Util.beside(\"but got\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1.value0))(Language_CP_Util.beside(\"and\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v2.value1.value0))))));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"Append is not defined between\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1))(Language_CP_Util.beside(\"and\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v2.value1)))));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmBinary && v.value0 instanceof Language_CP_Syntax_Common.Index) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value2))(function (v2) {\n                if (v1.value1 instanceof Language_CP_Syntax_Core.TyArray && Language_CP_Subtyping.subtype(v2.value1)(Language_CP_Syntax_Core.TyInt.value)) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmBinary(Language_CP_Syntax_Common.Index.value, v1.value0, new Language_CP_Syntax_Core.TmAnno(v2.value0, Language_CP_Syntax_Core.TyInt.value)), v1.value1.value0));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"Index is not defined between\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1))(Language_CP_Util.beside(\"and\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v2.value1)))));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmBinary && (v.value0 instanceof Language_CP_Syntax_Common.Coalesce && v.value1 instanceof Language_CP_Syntax_Source.TmPrj)) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1.value0))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value2))(function (v2) {\n                var v3 = selectLabel(v1.value1)(v.value1.value1)(true);\n                if (v3 instanceof Data_Maybe.Just && Language_CP_Subtyping.subtype(v2.value1)(v3.value0)) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmBinary(Language_CP_Syntax_Common.Coalesce.value, new Language_CP_Syntax_Core.TmPrj(v1.value0, v.value1.value1), new Language_CP_Syntax_Core.TmAnno(v2.value0, v3.value0)), v3.value0));\n                };\n                return Language_CP_Context.throwTypeError(v.value1.value1 + \"'s default value does not match its interface\");\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmIf) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            var $266 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.TyBool.value);\n            if ($266) {\n                return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v2) {\n                    return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value2))(function (v3) {\n                        var core = function (et) {\n                            return function (ef) {\n                                return function (ty) {\n                                    return new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmIf(new Language_CP_Syntax_Core.TmAnno(v1.value0, Language_CP_Syntax_Core.TyBool.value), et, ef), ty);\n                                };\n                            };\n                        };\n                        var $269 = Language_CP_Subtyping.aeq(v2.value1)(v3.value1);\n                        if ($269) {\n                            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(v2.value0)(v3.value0)(v2.value1));\n                        };\n                        var $270 = Language_CP_Subtyping.subtype(v3.value1)(v2.value1);\n                        if ($270) {\n                            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(v2.value0)(new Language_CP_Syntax_Core.TmAnno(v3.value0, v2.value1))(v2.value1));\n                        };\n                        var $271 = Language_CP_Subtyping.subtype(v2.value1)(v3.value1);\n                        if ($271) {\n                            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(core(new Language_CP_Syntax_Core.TmAnno(v2.value0, v3.value1))(v3.value0)(v3.value1));\n                        };\n                        return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"if-branches expected two equivalent types or subtypes, but got\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v2.value1))(Language_CP_Util.beside(\"and\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v3.value1)))));\n                    });\n                });\n            };\n            return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"if-condition expected Bool, but got\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1)));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmVar) {\n        return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Data_Tuple.Tuple.create(new Language_CP_Syntax_Core.TmVar(v.value0)))(Language_CP_Context.lookupTmBind(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmApp) {\n        var app = function (v1) {\n            return function (v2) {\n                if (v1 instanceof Language_CP_Syntax_Core.TyArrow && Language_CP_Subtyping.aeq(v2)(v1.value0)) {\n                    return new Data_Maybe.Just(v1.value1);\n                };\n                return Data_Maybe.Nothing.value;\n            };\n        };\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v2) {\n                var v3 = app(v1.value1)(v2.value1);\n                if (v3 instanceof Data_Maybe.Just) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmApp(v1.value0, v2.value0, false), v3.value0));\n                };\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Data_Tuple.Tuple.create(new Language_CP_Syntax_Core.TmApp(v1.value0, v2.value0, true)))(distApp(v1.value1)(new Data_Either.Left(v2.value1)));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmAbs && (v.value0 instanceof Data_List_Types.Cons && (v.value0.value0 instanceof Language_CP_Syntax_Source.TmParam && (v.value0.value0.value1 instanceof Data_Maybe.Just && v.value0.value1 instanceof Data_List_Types.Nil)))) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Transform.transform(v.value0.value0.value1.value0))(function (targ$prime) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.addTmBind(v.value0.value0.value0)(targ$prime)(infer(v.value1)))(function (v1) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmAbs(v.value0.value0.value0, v1.value0, targ$prime, v1.value1, false), new Language_CP_Syntax_Core.TyArrow(targ$prime, v1.value1, false)));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmAbs && (v.value0 instanceof Data_List_Types.Cons && (v.value0.value0 instanceof Language_CP_Syntax_Source.TmParam && (v.value0.value0.value1 instanceof Data_Maybe.Nothing && v.value0.value1 instanceof Data_List_Types.Nil)))) {\n        return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"lambda parameter\")(Language_CP_Util.beside(Data_Show.show(Data_Show.showString)(v.value0.value0.value0))(\"should be annotated with a type\")));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmAbs && (v.value0 instanceof Data_List_Types.Cons && (v.value0.value0 instanceof Language_CP_Syntax_Source.WildCard && v.value0.value1 instanceof Data_List_Types.Nil))) {\n        return Language_CP_Context.throwTypeError(\"record wildcards should only occur in traits with interfaces implemented\");\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmAnno) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Transform.transform(v.value1))(function (ta$prime) {\n                var $319 = Language_CP_Subtyping.subtype(v1.value1)(ta$prime);\n                if ($319) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmAnno(v1.value0, ta$prime), ta$prime));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"annotated\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Source.showTy)(v.value1))(Language_CP_Util.beside(\"is not a supertype of inferred\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1)))));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmMerge) {\n        var appToSelf = function (e) {\n            return new Language_CP_Syntax_Core.TmApp(e, new Language_CP_Syntax_Core.TmVar(\"#self\"), true);\n        };\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v2) {\n                if (v1.value1 instanceof Language_CP_Syntax_Core.TyArrow && (v1.value1.value2 && (v2.value1 instanceof Language_CP_Syntax_Core.TyArrow && v2.value1.value2))) {\n                    return Control_Bind.discard(Control_Bind.discardUnit)(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(disjoint(v1.value1.value1)(v2.value1.value1))(function () {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(trait(\"#self\")(new Language_CP_Syntax_Core.TmMerge(appToSelf(v1.value0), appToSelf(v2.value0)))(new Language_CP_Syntax_Core.TyAnd(v1.value1.value0, v2.value1.value0))(new Language_CP_Syntax_Core.TyAnd(v1.value1.value1, v2.value1.value1)));\n                    });\n                };\n                return Control_Bind.discard(Control_Bind.discardUnit)(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(disjoint(v1.value1)(v2.value1))(function () {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmMerge(v1.value0, v2.value0), new Language_CP_Syntax_Core.TyAnd(v1.value1, v2.value1)));\n                });\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmRcd && (v.value0 instanceof Data_List_Types.Cons && (v.value0.value0 instanceof Language_CP_Syntax_Source.RcdField && (v.value0.value0.value2 instanceof Data_List_Types.Nil && (v.value0.value0.value3 instanceof Data_Either.Left && v.value0.value1 instanceof Data_List_Types.Nil))))) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0.value0.value3.value0))(function (v1) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmRcd(v.value0.value0.value1, v1.value1, v1.value0), new Language_CP_Syntax_Core.TyRcd(v.value0.value0.value1, v1.value1, false)));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmPrj) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            var v2 = selectLabel(v1.value1)(v.value1)(false);\n            if (v2 instanceof Data_Maybe.Just) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmPrj(v1.value0, v.value1), v2.value0));\n            };\n            return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"label\")(Language_CP_Util.beside(Data_Show.show(Data_Show.showString)(v.value1))(Language_CP_Util.beside(\"is absent in\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1)))));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmTApp) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Transform.transform(v.value1))(function (ta$prime) {\n                return Data_Functor.map(Control_Monad_Reader_Trans.functorReaderT(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity)))(Data_Tuple.Tuple.create(new Language_CP_Syntax_Core.TmTApp(v1.value0, ta$prime)))(distApp(v1.value1)(new Data_Either.Right(ta$prime)));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmTAbs && (v.value0 instanceof Data_List_Types.Cons && (v.value0.value0.value1 instanceof Data_Maybe.Just && v.value0.value1 instanceof Data_List_Types.Nil))) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Transform.transform(v.value0.value0.value1.value0))(function (td$prime) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.addTyBind(v.value0.value0.value0)(td$prime)(infer(v.value1)))(function (v1) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmTAbs(v.value0.value0.value0, td$prime, v1.value0, v1.value1), new Language_CP_Syntax_Core.TyForall(v.value0.value0.value0, td$prime, v1.value1)));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmLet && (v.value1 instanceof Data_List_Types.Nil && v.value2 instanceof Data_List_Types.Nil)) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value3))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.addTmBind(v.value0)(v1.value1)(infer(v.value4)))(function (v2) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(letIn(v.value0)(v1.value0)(v1.value1)(v2.value0)(v2.value1), v2.value1));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmLetrec && (v.value1 instanceof Data_List_Types.Nil && v.value2 instanceof Data_List_Types.Nil)) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Transform.transform(v.value3))(function (t$prime) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.addTmBind(v.value0)(t$prime)(infer(v.value4)))(function (v1) {\n                var $385 = Language_CP_Subtyping.subtype(v1.value1)(t$prime);\n                if ($385) {\n                    var e1$prime$prime = (function () {\n                        var $386 = Language_CP_Subtyping.aeq(v1.value1)(t$prime);\n                        if ($386) {\n                            return v1.value0;\n                        };\n                        return new Language_CP_Syntax_Core.TmAnno(v1.value0, t$prime);\n                    })();\n                    return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.addTmBind(v.value0)(t$prime)(infer(v.value5)))(function (v2) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(letIn(v.value0)(new Language_CP_Syntax_Core.TmFix(v.value0, e1$prime$prime, t$prime))(t$prime)(v2.value0)(v2.value1), v2.value1));\n                    });\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"annotated\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Source.showTy)(v.value3))(Language_CP_Util.beside(\"is not a supertype of inferred\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1)))));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmOpen) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            var b = Data_Foldable.foldr(Data_Set.foldableSet)(function (l) {\n                return function (s) {\n                    return new Data_List_Types.Cons(new Data_Tuple.Tuple(l, Language_CP_Util.unsafeFromJust(selectLabel(v1.value1)(l)(false))), s);\n                };\n            })(Data_List_Types.Nil.value)(collectLabels(v1.value1));\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Data_Foldable.foldr(Data_List_Types.foldableList)(Data_Tuple.uncurry(Language_CP_Context.addTmBind))(infer(v.value1))(b))(function (v2) {\n                var open = function (v3) {\n                    return function (e) {\n                        return letIn(v3.value0)(new Language_CP_Syntax_Core.TmPrj(new Language_CP_Syntax_Core.TmVar(\"#opened\"), v3.value0))(v3.value1)(e)(v2.value1);\n                    };\n                };\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(letIn(\"#opened\")(v1.value0)(v1.value1)(Data_Foldable.foldr(Data_List_Types.foldableList)(open)(v2.value0)(b))(v2.value1), v2.value1));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmUpdate) {\n        var rcdTy = function (v1) {\n            return function (s) {\n                if (v1 instanceof Language_CP_Syntax_Core.TmRcd) {\n                    return new Language_CP_Syntax_Core.TyAnd(new Language_CP_Syntax_Core.TyRcd(v1.value0, v1.value1, false), s);\n                };\n                return s;\n            };\n        };\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Data_Traversable[\"for\"](Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(Data_List_Types.traversableList)(v.value1)(function (v2) {\n                return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v2.value1))(function (v3) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Language_CP_Syntax_Core.TmRcd(v2.value0, v3.value1, v3.value0));\n                });\n            }))(function (fields$prime) {\n                var t$prime = Data_Foldable.foldr(Data_List_Types.foldableList)(rcdTy)(Language_CP_Syntax_Core.TyTop.value)(fields$prime);\n                var $422 = Language_CP_Subtyping.subtype(v1.value1)(t$prime);\n                if ($422) {\n                    var outdate = new Language_CP_Syntax_Core.TmAnno(v1.value0, diffRcdTy(v1.value1)(t$prime));\n                    var update = Data_Foldable.foldr(Data_List_Types.foldableList)(Language_CP_Syntax_Core.TmMerge.create)(Language_CP_Syntax_Core.TmUnit.value)(fields$prime);\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmMerge(outdate, update), v1.value1));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"cannot safely update the record\")(Data_Show.show(Language_CP_Syntax_Source.showTm)(v.value0)));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmTrait && (v.value0 instanceof Data_Maybe.Just && (v.value0.value0.value1 instanceof Data_Maybe.Just && v.value1 instanceof Data_Maybe.Just))) {\n        var override = function (ty) {\n            return function (e) {\n                var selectOverride = function (v1) {\n                    if (v1 instanceof Language_CP_Syntax_Source.TmPos) {\n                        return selectOverride(v1.value1);\n                    };\n                    if (v1 instanceof Language_CP_Syntax_Source.TmOpen) {\n                        return selectOverride(v1.value1);\n                    };\n                    if (v1 instanceof Language_CP_Syntax_Source.TmMerge) {\n                        return Data_Semigroup.append(Data_Semigroup.semigroupArray)(selectOverride(v1.value0))(selectOverride(v1.value1));\n                    };\n                    if (v1 instanceof Language_CP_Syntax_Source.TmRcd && (v1.value0 instanceof Data_List_Types.Cons && (v1.value0.value0 instanceof Language_CP_Syntax_Source.RcdField && (v1.value0.value0.value0 && v1.value0.value1 instanceof Data_List_Types.Nil)))) {\n                        return [ v1.value0.value0.value1 ];\n                    };\n                    return [  ];\n                };\n                var removeOverride = function (v1) {\n                    return function (v2) {\n                        if (v1 instanceof Language_CP_Syntax_Core.TyAnd) {\n                            var t2$prime = removeOverride(v1.value1)(v2);\n                            var t1$prime = removeOverride(v1.value0)(v2);\n                            if (t1$prime instanceof Language_CP_Syntax_Core.TyTop && t2$prime instanceof Language_CP_Syntax_Core.TyTop) {\n                                return Language_CP_Syntax_Core.TyTop.value;\n                            };\n                            if (t1$prime instanceof Language_CP_Syntax_Core.TyTop) {\n                                return t2$prime;\n                            };\n                            if (t2$prime instanceof Language_CP_Syntax_Core.TyTop) {\n                                return t1$prime;\n                            };\n                            return new Language_CP_Syntax_Core.TyAnd(t1$prime, t2$prime);\n                        };\n                        if (v1 instanceof Language_CP_Syntax_Core.TyRcd && Data_Array.elem(Data_Eq.eqString)(v1.value0)(v2)) {\n                            return Language_CP_Syntax_Core.TyTop.value;\n                        };\n                        return v1;\n                    };\n                };\n                var ls = selectOverride(e);\n                var $450 = Data_Array[\"null\"](ls);\n                if ($450) {\n                    return ty;\n                };\n                return removeOverride(ty)(ls);\n            };\n        };\n        var filterRcd = function (f) {\n            return Data_List.filter(function (v1) {\n                return f(v1.value0);\n            });\n        };\n        var combineRcd = function (v1) {\n            if (v1 instanceof Language_CP_Syntax_Source.TyAnd && (v1.value0 instanceof Language_CP_Syntax_Source.TyRcd && v1.value1 instanceof Language_CP_Syntax_Source.TyRcd)) {\n                return Data_Semigroup.append(Data_List_Types.semigroupList)(v1.value0.value0)(v1.value1.value0);\n            };\n            if (v1 instanceof Language_CP_Syntax_Source.TyAnd && v1.value1 instanceof Language_CP_Syntax_Source.TyRcd) {\n                return Data_Semigroup.append(Data_List_Types.semigroupList)(combineRcd(v1.value0))(v1.value1.value0);\n            };\n            if (v1 instanceof Language_CP_Syntax_Source.TyAnd && v1.value0 instanceof Language_CP_Syntax_Source.TyRcd) {\n                return Data_Semigroup.append(Data_List_Types.semigroupList)(v1.value0.value0)(combineRcd(v1.value1));\n            };\n            if (v1 instanceof Language_CP_Syntax_Source.TyAnd) {\n                return Data_Semigroup.append(Data_List_Types.semigroupList)(combineRcd(v1.value0))(combineRcd(v1.value1));\n            };\n            if (v1 instanceof Language_CP_Syntax_Source.TyRcd) {\n                return v1.value0;\n            };\n            return Data_List_Types.Nil.value;\n        };\n        var matchOptional = function (def) {\n            return function (ty) {\n                var labels$prime = Data_Foldable.foldr(Data_List_Types.foldableList)(function (v1) {\n                    return function (s) {\n                        if (v1.value2) {\n                            return new Data_List_Types.Cons(v1.value0, s);\n                        };\n                        return s;\n                    };\n                })(Data_List_Types.Nil.value)(combineRcd(ty));\n                var labels = Data_Functor.map(Data_List_Types.functorList)(Data_Tuple.fst)(def);\n                return Data_Eq.eq(Data_List_Types.eqList(Data_Eq.eqString))(Data_List.sort(Data_Ord.ordString)(labels))(Data_List.sort(Data_Ord.ordString)(labels$prime));\n            };\n        };\n        var inferFromSig = function (v1) {\n            return function (v2) {\n                if (v1 instanceof Language_CP_Syntax_Source.TyAnd) {\n                    return inferFromSig(Language_CP_Syntax_Source.TyRcd.create(combineRcd(v1)))(v2);\n                };\n                if (v2 instanceof Language_CP_Syntax_Source.TmPos) {\n                    return new Language_CP_Syntax_Source.TmPos(v2.value0, inferFromSig(v1)(v2.value1));\n                };\n                if (v2 instanceof Language_CP_Syntax_Source.TmOpen) {\n                    return new Language_CP_Syntax_Source.TmOpen(v2.value0, inferFromSig(v1)(v2.value1));\n                };\n                if (v2 instanceof Language_CP_Syntax_Source.TmMerge) {\n                    return new Language_CP_Syntax_Source.TmMerge(inferFromSig(v1)(v2.value0), inferFromSig(v1)(v2.value1));\n                };\n                if (v1 instanceof Language_CP_Syntax_Source.TyRcd && (v2 instanceof Language_CP_Syntax_Source.TmRcd && (v2.value0 instanceof Data_List_Types.Cons && (v2.value0.value0 instanceof Language_CP_Syntax_Source.RcdField && (v2.value0.value0.value2 instanceof Data_List_Types.Nil && (v2.value0.value0.value3 instanceof Data_Either.Left && v2.value0.value1 instanceof Data_List_Types.Nil)))))) {\n                    var v3 = Data_List.last(filterRcd(function (v4) {\n                        return v4 === v2.value0.value0.value1;\n                    })(v1.value0));\n                    if (v3 instanceof Data_Maybe.Just) {\n                        return new Language_CP_Syntax_Source.TmRcd(Data_List.singleton(new Language_CP_Syntax_Source.RcdField(v2.value0.value0.value0, v2.value0.value0.value1, Data_List_Types.Nil.value, new Data_Either.Left(inferFromSig(v3.value0.value1)(v2.value0.value0.value3.value0)))));\n                    };\n                    return v2;\n                };\n                if (v1 instanceof Language_CP_Syntax_Source.TyRcd && (v2 instanceof Language_CP_Syntax_Source.TmRcd && (v2.value0 instanceof Data_List_Types.Cons && (v2.value0.value0 instanceof Language_CP_Syntax_Source.DefaultPattern && v2.value0.value1 instanceof Data_List_Types.Nil)))) {\n                    var paramsAndInnerTy = function (v3) {\n                        if (v3 instanceof Language_CP_Syntax_Source.TyArrow) {\n                            var v4 = paramsAndInnerTy(v3.value1);\n                            return new Data_Tuple.Tuple(new Data_List_Types.Cons(new Language_CP_Syntax_Source.TmParam(\"_\", new Data_Maybe.Just(v3.value0)), v4.value0), v4.value1);\n                        };\n                        return new Data_Tuple.Tuple(Data_List_Types.Nil.value, v3);\n                    };\n                    var innerLabel = function ($copy_v3) {\n                        var $tco_done = false;\n                        var $tco_result;\n                        function $tco_loop(v3) {\n                            if (v3 instanceof Language_CP_Syntax_Source.TmPos) {\n                                $copy_v3 = v3.value1;\n                                return;\n                            };\n                            if (v3 instanceof Language_CP_Syntax_Source.TmOpen) {\n                                $copy_v3 = v3.value1;\n                                return;\n                            };\n                            if (v3 instanceof Language_CP_Syntax_Source.TmAbs) {\n                                $copy_v3 = v3.value1;\n                                return;\n                            };\n                            if (v3 instanceof Language_CP_Syntax_Source.TmTrait) {\n                                $copy_v3 = v3.value3;\n                                return;\n                            };\n                            if (v3 instanceof Language_CP_Syntax_Source.TmRcd && (v3.value0 instanceof Data_List_Types.Cons && (v3.value0.value0 instanceof Language_CP_Syntax_Source.RcdField && v3.value0.value1 instanceof Data_List_Types.Nil))) {\n                                $tco_done = true;\n                                return v3.value0.value0.value1;\n                            };\n                            $tco_done = true;\n                            return \"#nothing\";\n                        };\n                        while (!$tco_done) {\n                            $tco_result = $tco_loop($copy_v3);\n                        };\n                        return $tco_result;\n                    };\n                    var patternsFromRcd = function (v3) {\n                        return function (v4) {\n                            if (v3 instanceof Language_CP_Syntax_Source.TmPos) {\n                                return patternsFromRcd(v3.value1)(v4);\n                            };\n                            if (v3 instanceof Language_CP_Syntax_Source.TmOpen) {\n                                return patternsFromRcd(v3.value1)(v4);\n                            };\n                            if (v3 instanceof Language_CP_Syntax_Source.TmMerge) {\n                                return Data_Semigroup.append(Data_Semigroup.semigroupArray)(patternsFromRcd(v3.value0)(v4))(patternsFromRcd(v3.value1)(v4));\n                            };\n                            if (v3 instanceof Language_CP_Syntax_Source.TmRcd && (v3.value0 instanceof Data_List_Types.Cons && (v3.value0.value0 instanceof Language_CP_Syntax_Source.RcdField && (v3.value0.value0.value3 instanceof Data_Either.Left && v3.value0.value1 instanceof Data_List_Types.Nil)))) {\n                                var $530 = innerLabel(v3.value0.value0.value3.value0) === v4;\n                                if ($530) {\n                                    return [ v3.value0.value0.value1 ];\n                                };\n                                return [  ];\n                            };\n                            return [  ];\n                        };\n                    };\n                    var patterns = function (l) {\n                        return patternsFromRcd(new Language_CP_Syntax_Source.TmMerge(Data_Maybe.fromMaybe(Language_CP_Syntax_Source.TmUnit.value)(v.value2), v.value3))(l);\n                    };\n                    return Language_CP_Desugar.desugar(Language_CP_Syntax_Source.TmRcd.create(Data_Functor.mapFlipped(Data_List_Types.functorList)(filterRcd(function (v3) {\n                        return Data_Array.notElem(Data_Eq.eqString)(v3)(patterns(v2.value0.value0.value0.value1));\n                    })(v1.value0))(function (v3) {\n                        var v4 = paramsAndInnerTy(v3.value1);\n                        var e = inferFromSig(v4.value1)(Language_CP_Desugar.desugarMethodPattern(v2.value0.value0.value0));\n                        return new Language_CP_Syntax_Source.RcdField(false, v3.value0, v4.value0, new Data_Either.Left(e));\n                    })));\n                };\n                if (v1 instanceof Language_CP_Syntax_Source.TyArrow && (v2 instanceof Language_CP_Syntax_Source.TmAbs && (v2.value0 instanceof Data_List_Types.Cons && (v2.value0.value0 instanceof Language_CP_Syntax_Source.TmParam && (v2.value0.value0.value1 instanceof Data_Maybe.Nothing && v2.value0.value1 instanceof Data_List_Types.Nil))))) {\n                    return new Language_CP_Syntax_Source.TmAbs(Data_List.singleton(new Language_CP_Syntax_Source.TmParam(v2.value0.value0.value0, new Data_Maybe.Just(v1.value0))), inferFromSig(v1.value1)(v2.value1));\n                };\n                if (v1 instanceof Language_CP_Syntax_Source.TyArrow && (v2 instanceof Language_CP_Syntax_Source.TmAbs && (v2.value0 instanceof Data_List_Types.Cons && (v2.value0.value0 instanceof Language_CP_Syntax_Source.TmParam && (v2.value0.value0.value1 instanceof Data_Maybe.Just && v2.value0.value1 instanceof Data_List_Types.Nil))))) {\n                    return new Language_CP_Syntax_Source.TmAbs(v2.value0, inferFromSig(v1.value1)(v2.value1));\n                };\n                if (v1 instanceof Language_CP_Syntax_Source.TyArrow && (v2 instanceof Language_CP_Syntax_Source.TmAbs && (v2.value0 instanceof Data_List_Types.Cons && (v2.value0.value0 instanceof Language_CP_Syntax_Source.WildCard && (v2.value0.value1 instanceof Data_List_Types.Nil && matchOptional(v2.value0.value0.value0)(v1.value0)))))) {\n                    var wildcardVar = new Language_CP_Syntax_Source.TmVar(\"#wildcard\");\n                    var letFieldIn = function (v3) {\n                        return function (e2) {\n                            return new Language_CP_Syntax_Source.TmLet(v3.value0, Data_List_Types.Nil.value, Data_List_Types.Nil.value, new Language_CP_Syntax_Source.TmBinary(Language_CP_Syntax_Common.Coalesce.value, new Language_CP_Syntax_Source.TmPrj(wildcardVar, v3.value0), v3.value1), e2);\n                        };\n                    };\n                    var open = function (fields) {\n                        return function (body) {\n                            return Data_Foldable.foldr(Data_List_Types.foldableList)(letFieldIn)(body)(fields);\n                        };\n                    };\n                    return new Language_CP_Syntax_Source.TmAbs(Data_List.singleton(new Language_CP_Syntax_Source.TmParam(\"#wildcard\", new Data_Maybe.Just(v1.value0))), open(v2.value0.value0.value0)(new Language_CP_Syntax_Source.TmOpen(wildcardVar, inferFromSig(v1.value1)(v2.value1))));\n                };\n                if (v1 instanceof Language_CP_Syntax_Source.TyTrait && (v2 instanceof Language_CP_Syntax_Source.TmTrait && v2.value0 instanceof Data_Maybe.Just)) {\n                    var t$prime = Data_Maybe.fromMaybe(Data_Maybe.fromMaybe(Language_CP_Syntax_Source.TyTop.value)(v1.value0))(v2.value0.value0.value1);\n                    return new Language_CP_Syntax_Source.TmTrait(new Data_Maybe.Just(new Data_Tuple.Tuple(v2.value0.value0.value0, new Data_Maybe.Just(t$prime))), v2.value1, Data_Functor.map(Data_Maybe.functorMaybe)(inferFromSig(v1.value1))(v2.value2), inferFromSig(v1.value1)(v2.value3));\n                };\n                return v2;\n            };\n        };\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Transform.transform(v.value0.value0.value1.value0))(function (t$prime) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Transform[\"transform'\"](v.value1.value0))(function (v1) {\n                var e2 = inferFromSig(v1.value1)(v.value3);\n                return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))((function () {\n                    if (v.value2 instanceof Data_Maybe.Just) {\n                        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.addTmBind(v.value0.value0.value0)(t$prime)(infer(v.value2.value0)))(function (v2) {\n                            if (v2.value1 instanceof Language_CP_Syntax_Core.TyArrow && v2.value1.value2) {\n                                var $596 = Language_CP_Subtyping.subtype(t$prime)(v2.value1.value0);\n                                if ($596) {\n                                    return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.addTmBind(v.value0.value0.value0)(t$prime)(Language_CP_Context.addTmBind(\"super\")(v2.value1.value1)(infer(e2))))(function (v3) {\n                                        var to$prime = override(v2.value1.value1)(e2);\n                                        return Control_Bind.discard(Control_Bind.discardUnit)(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(disjoint(to$prime)(v3.value1))(function () {\n                                            var tret = new Language_CP_Syntax_Core.TyAnd(to$prime, v3.value1);\n                                            var ret = letIn(\"super\")(new Language_CP_Syntax_Core.TmApp(v2.value0, new Language_CP_Syntax_Core.TmVar(v.value0.value0.value0), true))(v2.value1.value1)(new Language_CP_Syntax_Core.TmMerge(new Language_CP_Syntax_Core.TmAnno(new Language_CP_Syntax_Core.TmVar(\"super\"), to$prime), v3.value0))(tret);\n                                            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(ret, tret));\n                                        });\n                                    });\n                                };\n                                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"self-type\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Source.showTy)(v.value0.value0.value1.value0))(Language_CP_Util.beside(\"is not a subtype of inherited self-type\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v2.value1.value1)))));\n                            };\n                            return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected to inherit a trait, but got\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v2.value1)));\n                        });\n                    };\n                    if (v.value2 instanceof Data_Maybe.Nothing) {\n                        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Context.addTmBind(v.value0.value0.value0)(t$prime)(infer(e2)))(function (v2) {\n                            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(v2.value0, v2.value1));\n                        });\n                    };\n                    throw new Error(\"Failed pattern match at Language.CP.Typing (line 211, column 21 - line 232, column 26): \" + [ v.value2.constructor.name ]);\n                })())(function (v2) {\n                    var $610 = Language_CP_Subtyping.subtype(v2.value1)(v1.value0);\n                    if ($610) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(trait(v.value0.value0.value0)(v2.value0)(t$prime)(v2.value1));\n                    };\n                    return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"the trait does not implement\")(Data_Show.show(Language_CP_Syntax_Source.showTy)(v.value1.value0)));\n                });\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmTrait && (v.value0 instanceof Data_Maybe.Just && v.value0.value0.value1 instanceof Data_Maybe.Nothing)) {\n        return infer(new Language_CP_Syntax_Source.TmTrait(new Data_Maybe.Just(new Data_Tuple.Tuple(v.value0.value0.value0, new Data_Maybe.Just(Language_CP_Syntax_Source.TyTop.value))), v.value1, v.value2, v.value3));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmNew) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            if (v1.value1 instanceof Language_CP_Syntax_Core.TyArrow && v1.value1.value2) {\n                var $633 = Language_CP_Subtyping.subtype(v1.value1.value1)(v1.value1.value0);\n                if ($633) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmFix(\"#self\", new Language_CP_Syntax_Core.TmApp(v1.value0, new Language_CP_Syntax_Core.TmVar(\"#self\"), true), v1.value1.value1), v1.value1.value1));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"input type is not a supertype of output type in\")(Language_CP_Util.beside(\"Trait<\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1.value0))(Language_CP_Util.beside(\"=>\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1.value1))(\">\"))))));\n            };\n            return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"new expected a trait, but got\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1)));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmForward) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v2) {\n                if (v1.value1 instanceof Language_CP_Syntax_Core.TyArrow && v1.value1.value2) {\n                    var $643 = Language_CP_Subtyping.subtype(v2.value1)(v1.value1.value0);\n                    if ($643) {\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmApp(v1.value0, v2.value0, true), v1.value1.value1));\n                    };\n                    return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected to forward to a subtype of\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1.value0) + Language_CP_Util.beside(\", but got\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v2.value1))));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected to forward from a trait, but got\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1)));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmExclude) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Language_CP_Transform.transform(v.value1))(function (te$prime) {\n                if (v1.value1 instanceof Language_CP_Syntax_Core.TyArrow && v1.value1.value2) {\n                    var $655 = Language_CP_Subtyping.subtype(v1.value1.value1)(te$prime);\n                    if ($655) {\n                        var t$prime = new Language_CP_Syntax_Core.TyArrow(v1.value1.value0, diffRcdTy(v1.value1.value1)(te$prime), true);\n                        return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmAnno(v1.value0, t$prime), t$prime));\n                    };\n                    return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected to exclude supertype from\")(Data_Show.show(Language_CP_Syntax_Source.showTm)(v.value0) + Language_CP_Util.beside(\", but got\")(Data_Show.show(Language_CP_Syntax_Source.showTy)(v.value1))));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected to exclude from a trait, but got\")(Data_Show.show(Language_CP_Syntax_Source.showTm)(v.value0)));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmFold) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(transformTyRec(v.value0))(function (t$prime) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v1) {\n                var $664 = Language_CP_Subtyping.subtype(v1.value1)(Language_CP_Syntax_Core.unfold(t$prime));\n                if ($664) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmFold(t$prime, v1.value0), t$prime));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"cannot fold\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Source.showTm)(v.value1))(Language_CP_Util.beside(\"to\")(Data_Show.show(Language_CP_Syntax_Source.showTy)(v.value0)))));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmUnfold) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(transformTyRec(v.value0))(function (t$prime) {\n            return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value1))(function (v1) {\n                var $670 = Language_CP_Subtyping.subtype(v1.value1)(t$prime);\n                if ($670) {\n                    return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmUnfold(t$prime, v1.value0), Language_CP_Syntax_Core.unfold(t$prime)));\n                };\n                return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"cannot unfold\")(Language_CP_Util.beside(Data_Show.show(Language_CP_Syntax_Source.showTm)(v.value1))(Language_CP_Util.beside(\"to\")(Data_Show.show(Language_CP_Syntax_Source.showTy)(v.value0)))));\n            });\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmToString) {\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(infer(v.value0))(function (v1) {\n            var $676 = Data_Eq.eq(Language_CP_Syntax_Core.eqTy)(v1.value1)(Language_CP_Syntax_Core.TyInt.value) || (Data_Eq.eq(Language_CP_Syntax_Core.eqTy)(v1.value1)(Language_CP_Syntax_Core.TyDouble.value) || (Data_Eq.eq(Language_CP_Syntax_Core.eqTy)(v1.value1)(Language_CP_Syntax_Core.TyString.value) || Data_Eq.eq(Language_CP_Syntax_Core.eqTy)(v1.value1)(Language_CP_Syntax_Core.TyBool.value)));\n            if ($676) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmToString(v1.value0), Language_CP_Syntax_Core.TyString.value));\n            };\n            return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"cannot show\")(Data_Show.show(Language_CP_Syntax_Core.showTy)(v1.value1)));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmArray) {\n        var $680 = Data_Array[\"null\"](v.value0);\n        if ($680) {\n            return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmArray(Language_CP_Syntax_Core.TyBot.value, [  ]), new Language_CP_Syntax_Core.TyArray(Language_CP_Syntax_Core.TyBot.value)));\n        };\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(Data_Traversable.traverse(Data_Traversable.traversableArray)(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(infer)(v.value0))(function (ets) {\n            var v1 = Data_Array.unzip(ets);\n            var t = Language_CP_Util.unsafeFromJust(Data_Array.head(v1.value1));\n            var $682 = Data_Array.all(function (v2) {\n                return Language_CP_Subtyping.aeq(v2)(t);\n            })(v1.value1);\n            if ($682) {\n                return Control_Applicative.pure(Control_Monad_Reader_Trans.applicativeReaderT(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)))(new Data_Tuple.Tuple(new Language_CP_Syntax_Core.TmArray(t, v1.value0), new Language_CP_Syntax_Core.TyArray(t)));\n            };\n            return Language_CP_Context.throwTypeError(\"elements of an array should all have the same type\" + Language_CP_Util.beside(\", but got\")(Data_Show.show(Language_CP_Syntax_Source.showTm)(new Language_CP_Syntax_Source.TmArray(v.value0))));\n        });\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmDoc) {\n        var f = function (v1) {\n            if (v1 instanceof Language_CP_Context.Pos) {\n                return new Language_CP_Context.Pos(v1.value0, v1.value1, true);\n            };\n            if (v1 instanceof Language_CP_Context.UnknownPos) {\n                return Language_CP_Context.UnknownPos.value;\n            };\n            throw new Error(\"Failed pattern match at Language.CP.Typing (line 389, column 9 - line 389, column 37): \" + [ v1.constructor.name ]);\n        };\n        return Language_CP_Context.localPos(f)(infer(v.value0));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmPos) {\n        var f = function (v1) {\n            if (v1 instanceof Language_CP_Context.Pos) {\n                return new Language_CP_Context.Pos(v.value0, v.value1, v1.value2);\n            };\n            if (v1 instanceof Language_CP_Context.UnknownPos) {\n                return new Language_CP_Context.Pos(v.value0, v.value1, false);\n            };\n            throw new Error(\"Failed pattern match at Language.CP.Typing (line 393, column 9 - line 393, column 42): \" + [ v1.constructor.name ]);\n        };\n        return Language_CP_Context.localPos(f)(infer(v.value1));\n    };\n    if (v instanceof Language_CP_Syntax_Source.TmType) {\n        var dualSorts = Data_Functor.mapFlipped(Data_List_Types.functorList)(v.value1)(function (sort) {\n            return new Data_Tuple.Tuple(sort, \"#\" + sort);\n        });\n        var sig = function (t$prime) {\n            return Data_Foldable.foldr(Data_List_Types.foldableList)(Data_Tuple.uncurry(Language_CP_Syntax_Source.TySig.create))(Data_Foldable.foldr(Data_List_Types.foldableList)(Language_CP_Syntax_Source.TyAbs.create)(t$prime)(v.value2))(dualSorts);\n        };\n        var addTyBinds = function (typing) {\n            return Data_Foldable.foldr(Data_List_Types.foldableList)(Data_Function.flip(Language_CP_Context.addTyBind)(Language_CP_Syntax_Core.TyTop.value))(typing)(v.value2);\n        };\n        var addSorts = function (typing) {\n            return Data_Foldable.foldr(Data_List_Types.foldableList)(Data_Tuple.uncurry(Language_CP_Context.addSort))(typing)(dualSorts);\n        };\n        return Control_Bind.bind(Control_Monad_Reader_Trans.bindReaderT(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity)))(addSorts(addTyBinds(Language_CP_Transform.transformTyDef(v.value3))))(function (t$prime) {\n            return Language_CP_Context.addTyAlias(v.value0)(sig(t$prime))(infer(v.value4));\n        });\n    };\n    return Language_CP_Context.throwTypeError(Language_CP_Util.beside(\"expected a desugared term, but got\")(Data_Show.show(Language_CP_Syntax_Source.showTm)(v)));\n};\nmodule.exports = {\n    infer: infer,\n    distApp: distApp,\n    disjoint: disjoint,\n    disjointTyBind: disjointTyBind,\n    letIn: letIn,\n    trait: trait,\n    transformTyRec: transformTyRec,\n    diffRcdTy: diffRcdTy,\n    collectLabels: collectLabels,\n    selectLabel: selectLabel\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Typing.purs?");

/***/ }),

/***/ "./src/CP/Util.purs":
/*!**************************!*\
  !*** ./src/CP/Util.purs ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Generated by purs version 0.14.4\n\nvar Data_CodePoint_Unicode = __webpack_require__(/*! ./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs */ \"./.spago/unicode/v5.0.0/src/Data/CodePoint/Unicode.purs\");\nvar Data_Foldable = __webpack_require__(/*! ./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs */ \"./.spago/foldable-traversable/v5.0.1/src/Data/Foldable.purs\");\nvar Data_List_Types = __webpack_require__(/*! ./.spago/lists/v6.0.1/src/Data/List/Types.purs */ \"./.spago/lists/v6.0.1/src/Data/List/Types.purs\");\nvar Data_Maybe = __webpack_require__(/*! ./.spago/maybe/v5.0.0/src/Data/Maybe.purs */ \"./.spago/maybe/v5.0.0/src/Data/Maybe.purs\");\nvar Data_String_CodePoints = __webpack_require__(/*! ./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs */ \"./.spago/strings/v5.0.0/src/Data/String/CodePoints.purs\");\nvar Partial_Unsafe = __webpack_require__(/*! ./.spago/partial/v3.0.0/src/Partial/Unsafe.purs */ \"./.spago/partial/v3.0.0/src/Partial/Unsafe.purs\");\nvar unsafeFromJust = function (v) {\n    if (v instanceof Data_Maybe.Nothing) {\n        return Partial_Unsafe.unsafeCrashWith(\"unsafeFromJust: unexpected Nothing\");\n    };\n    if (v instanceof Data_Maybe.Just) {\n        return v.value0;\n    };\n    throw new Error(\"Failed pattern match at Language.CP.Util (line 25, column 1 - line 25, column 41): \" + [ v.constructor.name ]);\n};\nvar isCapitalized = (function () {\n    var $17 = Data_String_CodePoints.codePointAt(0);\n    return function ($18) {\n        return Data_CodePoint_Unicode.isUpper(unsafeFromJust($17($18)));\n    };\n})();\nvar foldr1 = function (v) {\n    return function (v1) {\n        if (v1 instanceof Data_List_Types.Nil) {\n            return Partial_Unsafe.unsafeCrashWith(\"foldr1: empty list\");\n        };\n        if (v1 instanceof Data_List_Types.Cons && v1.value1 instanceof Data_List_Types.Nil) {\n            return v1.value0;\n        };\n        if (v1 instanceof Data_List_Types.Cons) {\n            return v(v1.value0)(foldr1(v)(v1.value1));\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Util (line 20, column 1 - line 20, column 49): \" + [ v.constructor.name, v1.constructor.name ]);\n    };\n};\nvar foldl1 = function (v) {\n    return function (v1) {\n        if (v1 instanceof Data_List_Types.Nil) {\n            return Partial_Unsafe.unsafeCrashWith(\"foldl1: empty list\");\n        };\n        if (v1 instanceof Data_List_Types.Cons) {\n            return Data_Foldable.foldl(Data_List_Types.foldableList)(v)(v1.value0)(v1.value1);\n        };\n        throw new Error(\"Failed pattern match at Language.CP.Util (line 16, column 1 - line 16, column 49): \" + [ v.constructor.name, v1.constructor.name ]);\n    };\n};\nvar beside = function (s1) {\n    return function (s2) {\n        return s1 + (\" \" + s2);\n    };\n};\nmodule.exports = {\n    beside: beside,\n    foldl1: foldl1,\n    foldr1: foldr1,\n    unsafeFromJust: unsafeFromJust,\n    isCapitalized: isCapitalized\n};\n\n\n\n//# sourceURL=webpack://bundle/./src/CP/Util.purs?");

/***/ }),

/***/ "./src/CP/Syntax/Core.js":
/*!*******************************!*\
  !*** ./src/CP/Syntax/Core.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports[\"new\"] = function (e) {\n  return { term: e, done: false };\n};\n\nexports.done = function (ref) {\n  return ref.done;\n};\n\nexports.read = function (ref) {\n  return ref.term;\n};\n\nexports.write = function (v) {\n  return function (ref) {\n    ref.term = v;\n    ref.done = true;\n    return v;\n  };\n};\n\n\n//# sourceURL=webpack://bundle/./src/CP/Syntax/Core.js?");

/***/ }),

/***/ "?1ac6":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://bundle/fs_(ignored)?");

/***/ }),

/***/ "./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CompletionContext\": () => (/* binding */ CompletionContext),\n/* harmony export */   \"acceptCompletion\": () => (/* binding */ acceptCompletion),\n/* harmony export */   \"autocompletion\": () => (/* binding */ autocompletion),\n/* harmony export */   \"clearSnippet\": () => (/* binding */ clearSnippet),\n/* harmony export */   \"closeCompletion\": () => (/* binding */ closeCompletion),\n/* harmony export */   \"completeAnyWord\": () => (/* binding */ completeAnyWord),\n/* harmony export */   \"completeFromList\": () => (/* binding */ completeFromList),\n/* harmony export */   \"completionKeymap\": () => (/* binding */ completionKeymap),\n/* harmony export */   \"completionStatus\": () => (/* binding */ completionStatus),\n/* harmony export */   \"currentCompletions\": () => (/* binding */ currentCompletions),\n/* harmony export */   \"ifIn\": () => (/* binding */ ifIn),\n/* harmony export */   \"ifNotIn\": () => (/* binding */ ifNotIn),\n/* harmony export */   \"moveCompletionSelection\": () => (/* binding */ moveCompletionSelection),\n/* harmony export */   \"nextSnippetField\": () => (/* binding */ nextSnippetField),\n/* harmony export */   \"prevSnippetField\": () => (/* binding */ prevSnippetField),\n/* harmony export */   \"snippet\": () => (/* binding */ snippet),\n/* harmony export */   \"snippetCompletion\": () => (/* binding */ snippetCompletion),\n/* harmony export */   \"snippetKeymap\": () => (/* binding */ snippetKeymap),\n/* harmony export */   \"startCompletion\": () => (/* binding */ startCompletion)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_tooltip__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/tooltip */ \"./node_modules/@codemirror/tooltip/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n\n\n\n\n\n\n/**\nAn instance of this is passed to completion source functions.\n*/\nclass CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sourcesin the editor, the extension will create\n    these for you.)\n    */\n    constructor(\n    /**\n    The editor state that the completion happens in.\n    */\n    state, \n    /**\n    The position at which the completion is happening.\n    */\n    pos, \n    /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */\n    explicit) {\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        /**\n        @internal\n        */\n        this.abortListeners = [];\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */\n    tokenBefore(types) {\n        let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\n        while (token && types.indexOf(token.name) < 0)\n            token = token.parent;\n        return token ? { from: token.from, to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */\n    matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */\n    get aborted() { return this.abortListeners == null; }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    */\n    addEventListener(type, listener) {\n        if (type == \"abort\" && this.abortListeners)\n            this.abortListeners.push(listener);\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words)\n        flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options) {\n        first[label[0]] = true;\n        for (let i = 1; i < label.length; i++)\n            rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\nfunction completeFromList(list) {\n    let options = list.map(o => typeof o == \"string\" ? { label: o } : o);\n    let [span, match] = options.every(o => /^\\w+$/.test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\n    return (context) => {\n        let token = context.matchBefore(match);\n        return token || context.explicit ? { from: token ? token.from : context.pos, options, span } : null;\n    };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifIn(nodes, source) {\n    return (context) => {\n        for (let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)\n            if (nodes.indexOf(pos.name) > -1)\n                return source(context);\n        return null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifNotIn(nodes, source) {\n    return (context) => {\n        for (let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)\n            if (nodes.indexOf(pos.name) > -1)\n                return null;\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match) {\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n    }\n}\nfunction cur(state) { return state.selection.main.head; }\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd)\n        return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? \"i\" : \"\"));\n}\nfunction applyCompletion(view, option) {\n    let apply = option.completion.apply || option.completion.label;\n    let result = option.source;\n    if (typeof apply == \"string\") {\n        view.dispatch({\n            changes: { from: result.from, to: result.to, insert: apply },\n            selection: { anchor: result.from + apply.length },\n            userEvent: \"input.complete\"\n        });\n    }\n    else {\n        apply(view, option.completion, result.from, result.to);\n    }\n}\nconst SourceCache = /*@__PURE__*/new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source))\n        return source;\n    let known = SourceCache.get(source);\n    if (!known)\n        SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\n\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern) {\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        for (let p = 0; p < pattern.length;) {\n            let char = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p), size = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push((0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return null for no match, and otherwise an array that starts\n    // with the match score, followed by any number of `from, to` pairs\n    // indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0)\n            return [0];\n        if (word.length < this.pattern.length)\n            return null;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0);\n            return first == chars[0] ? [0, 0, (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first)]\n                : first == folded[0] ? [-200 /* CaseFold */, 0, (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first)] : null;\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0)\n            return [0, 0, this.pattern.length];\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n                let next = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo])\n                    any[anyTo++] = i;\n                i += (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len)\n                return null;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word);\n        // Go over the option's text, scanning for the various kinds of matches\n        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* NonWord */; i < e && byWordTo < len;) {\n            let next = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo])\n                    precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0)\n                            adjacentStart = i;\n                        adjacentEnd = i;\n                        adjacentTo++;\n                    }\n                    else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff\n                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Lower */ : next >= 65 && next <= 90 ? 1 /* Upper */ : 0 /* NonWord */)\n                : ((ch = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 /* Upper */ : ch != ch.toUpperCase() ? 2 /* Lower */ : 0 /* NonWord */);\n            if ((type == 1 /* Upper */ && hasLower || prevType == 0 /* NonWord */ && type != 0 /* NonWord */) &&\n                (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true))))\n                byWord[byWordTo++] = i;\n            prevType = type;\n            i += (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n        }\n        if (byWordTo == len && byWord[0] == 0)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0)\n            return [-200 /* CaseFold */, 0, adjacentEnd];\n        if (direct > -1)\n            return [-700 /* NotStart */, direct, direct + this.pattern.length];\n        if (adjacentTo == len)\n            return [-200 /* CaseFold */ + -700 /* NotStart */, adjacentStart, adjacentEnd];\n        if (byWordTo == len)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0) + -700 /* NotStart */, byWord, word);\n        return chars.length == 2 ? null : this.result((any[0] ? -700 /* NotStart */ : 0) + -200 /* CaseFold */ + -1100 /* Gap */, any, word);\n    }\n    result(score, positions, word) {\n        let result = [score], i = 1;\n        for (let pos of positions) {\n            let to = pos + (this.astral ? (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);\n            if (i > 1 && result[i - 1] == pos)\n                result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return result;\n    }\n}\n\nconst completionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            activateOnTyping: true,\n            override: null,\n            maxRenderedOptions: 100,\n            defaultKeymap: true,\n            optionClass: () => \"\",\n            icons: true,\n            addToOptions: []\n        }, {\n            defaultKeymap: (a, b) => a && b,\n            icons: (a, b) => a && b,\n            optionClass: (a, b) => c => joinClass(a(c), b(c)),\n            addToOptions: (a, b) => a.concat(b)\n        });\n    }\n});\nfunction joinClass(a, b) {\n    return a ? b ? a + \" \" + b : a : b;\n}\n\nconst MaxInfoWidth = 300;\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            maxHeight: \"10em\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li\": {\n                cursor: \"pointer\",\n                padding: \"1px 1em 1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li[aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            }\n        }\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: MaxInfoWidth + \"px\",\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": { right: \"100%\" },\n    \".cm-completionInfo.cm-completionInfo-right\": { left: \"100%\" },\n    \"&light .cm-snippetField\": { backgroundColor: \"#00000022\" },\n    \"&dark .cm-snippetField\": { backgroundColor: \"#ffffff22\" },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": { content: \"'\\uFE0E'\" } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": { content: \"''\" }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": { content: \"'abc'\", fontSize: \"50%\", verticalAlign: \"middle\" }\n    }\n});\n\nfunction optionContent(config) {\n    let content = config.addToOptions.slice();\n    if (config.icons)\n        content.push({\n            render(completion) {\n                let icon = document.createElement(\"div\");\n                icon.classList.add(\"cm-completionIcon\");\n                if (completion.type)\n                    icon.classList.add(...completion.type.split(/\\s+/g).map(cls => \"cm-completionIcon-\" + cls));\n                icon.setAttribute(\"aria-hidden\", \"true\");\n                return icon;\n            },\n            position: 20\n        });\n    content.push({\n        render(completion, _s, match) {\n            let labelElt = document.createElement(\"span\");\n            labelElt.className = \"cm-completionLabel\";\n            let { label } = completion, off = 0;\n            for (let j = 1; j < match.length;) {\n                let from = match[j++], to = match[j++];\n                if (from > off)\n                    labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n                let span = labelElt.appendChild(document.createElement(\"span\"));\n                span.appendChild(document.createTextNode(label.slice(from, to)));\n                span.className = \"cm-completionMatchedText\";\n                off = to;\n            }\n            if (off < label.length)\n                labelElt.appendChild(document.createTextNode(label.slice(off)));\n            return labelElt;\n        },\n        position: 50\n    }, {\n        render(completion) {\n            if (!completion.detail)\n                return null;\n            let detailElt = document.createElement(\"span\");\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = completion.detail;\n            return detailElt;\n        },\n        position: 80\n    });\n    return content.sort((a, b) => a.position - b.position).map(a => a.render);\n}\nfunction createInfoDialog(option, view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-tooltip cm-completionInfo\";\n    let { info } = option.completion;\n    if (typeof info == \"string\") {\n        dom.textContent = info;\n    }\n    else {\n        let content = info(option.completion);\n        if (content.then)\n            content.then(node => dom.appendChild(node), e => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.logException)(view.state, e, \"completion info\"));\n        else\n            dom.appendChild(content);\n    }\n    return dom;\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max)\n        return { from: 0, to: total };\n    if (selected <= (total >> 1)) {\n        let off = Math.floor(selected / max);\n        return { from: off * max, to: (off + 1) * max };\n    }\n    let off = Math.floor((total - selected) / max);\n    return { from: total - (off + 1) * max, to: total - off * max };\n}\nclass CompletionTooltip {\n    constructor(view, stateField) {\n        this.view = view;\n        this.stateField = stateField;\n        this.info = null;\n        this.placeInfo = {\n            read: () => this.measureInfo(),\n            write: (pos) => this.positionInfo(pos),\n            key: this\n        };\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.optionContent = optionContent(config);\n        this.optionClass = config.optionClass;\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.dom.addEventListener(\"mousedown\", (e) => {\n            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));\n        this.list.addEventListener(\"scroll\", () => {\n            if (this.info)\n                this.view.requestMeasure(this.placeInfo);\n        });\n    }\n    mount() { this.updateSel(); }\n    update(update) {\n        if (update.state.field(this.stateField) != update.startState.field(this.stateField))\n            this.updateSel();\n    }\n    positioned() {\n        if (this.info)\n            this.view.requestMeasure(this.placeInfo);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.list.remove();\n            this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));\n            this.list.addEventListener(\"scroll\", () => {\n                if (this.info)\n                    this.view.requestMeasure(this.placeInfo);\n            });\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            if (this.info) {\n                this.info.remove();\n                this.info = null;\n            }\n            let option = open.options[open.selected];\n            if (option.completion.info) {\n                this.info = this.dom.appendChild(createInfoDialog(option, this.view));\n                this.view.requestMeasure(this.placeInfo);\n            }\n        }\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n            if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            }\n            else {\n                if (opt.hasAttribute(\"aria-selected\"))\n                    opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set)\n            scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel)\n            return null;\n        let rect = this.dom.getBoundingClientRect();\n        let top = sel.getBoundingClientRect().top - rect.top;\n        if (top < 0 || top > this.list.clientHeight - 10)\n            return null;\n        let left = this.view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Direction.RTL;\n        let spaceLeft = rect.left, spaceRight = innerWidth - rect.right;\n        if (left && spaceLeft < Math.min(MaxInfoWidth, spaceRight))\n            left = false;\n        else if (!left && spaceRight < Math.min(MaxInfoWidth, spaceLeft))\n            left = true;\n        return { top, left };\n    }\n    positionInfo(pos) {\n        if (this.info && pos) {\n            this.info.style.top = pos.top + \"px\";\n            this.info.classList.toggle(\"cm-completionInfo-left\", pos.left);\n            this.info.classList.toggle(\"cm-completionInfo-right\", !pos.left);\n        }\n    }\n    createListBox(options, id, range) {\n        const ul = document.createElement(\"ul\");\n        ul.id = id;\n        ul.setAttribute(\"role\", \"listbox\");\n        for (let i = range.from; i < range.to; i++) {\n            let { completion, match } = options[i];\n            const li = ul.appendChild(document.createElement(\"li\"));\n            li.id = id + \"-\" + i;\n            li.setAttribute(\"role\", \"option\");\n            let cls = this.optionClass(completion);\n            if (cls)\n                li.className = cls;\n            for (let source of this.optionContent) {\n                let node = source(completion, this.view.state, match);\n                if (node)\n                    li.appendChild(node);\n            }\n        }\n        if (range.from)\n            ul.classList.add(\"cm-completionListIncompleteTop\");\n        if (range.to < options.length)\n            ul.classList.add(\"cm-completionListIncompleteBottom\");\n        return ul;\n    }\n}\n// We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\nfunction completionTooltip(stateField) {\n    return (view) => new CompletionTooltip(view, stateField);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    if (self.top < parent.top)\n        container.scrollTop -= parent.top - self.top;\n    else if (self.bottom > parent.bottom)\n        container.scrollTop += self.bottom - parent.bottom;\n}\n\nconst MaxOptions = 300;\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +\n        (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [], i = 0;\n    for (let a of active)\n        if (a.hasResult()) {\n            if (a.result.filter === false) {\n                for (let option of a.result.options)\n                    options.push(new Option(option, a, [1e9 - i++]));\n            }\n            else {\n                let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;\n                for (let option of a.result.options)\n                    if (match = matcher.match(option.label)) {\n                        if (option.boost != null)\n                            match[0] += option.boost;\n                        options.push(new Option(option, a, match));\n                    }\n            }\n        }\n    options.sort(cmpOption);\n    let result = [], prev = null;\n    for (let opt of options.sort(cmpOption)) {\n        if (result.length == MaxOptions)\n            break;\n        if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail)\n            result.push(opt);\n        else if (score(opt.completion) > score(prev))\n            result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected) {\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this\n            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);\n    }\n    static build(active, state, id, prev) {\n        let options = sortOptions(active, state);\n        if (!options.length)\n            return null;\n        let selected = 0;\n        if (prev && prev.selected) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for (let i = 0; i < options.length && !selected; i++) {\n                if (options[i].completion == selectedValue)\n                    selected = i;\n            }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: completionTooltip(completionState)\n        }, prev ? prev.timestamp : Date.now(), selected);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open) {\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override ||\n            state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map(source => {\n            let value = this.active.find(s => s.source == source) ||\n                new ActiveSource(source, this.active.some(a => a.state != 0 /* Inactive */) ? 1 /* Pending */ : 0 /* Inactive */);\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))\n            active = this.active;\n        let open = tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||\n            !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open)\n            : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;\n        if (!open && active.every(a => a.state != 1 /* Pending */) && active.some(a => a.hasResult()))\n            active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* Inactive */) : a);\n        for (let effect of tr.effects)\n            if (effect.is(setSelectedEffect))\n                open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() { return this.open ? this.open.tooltip : null; }\n    get attrs() { return this.open ? this.open.attrs : baseAttrs; }\n}\nfunction sameResults(a, b) {\n    if (a == b)\n        return true;\n    for (let iA = 0, iB = 0;;) {\n        while (iA < a.length && !a[iA].hasResult)\n            iA++;\n        while (iB < b.length && !b[iB].hasResult)\n            iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB)\n            return endA == endB;\n        if (a[iA++].result != b[iB++].result)\n            return false;\n    }\n}\nconst baseAttrs = {\n    \"aria-autocomplete\": \"list\",\n    \"aria-expanded\": \"false\"\n};\nfunction makeAttrs(id, selected) {\n    return {\n        \"aria-autocomplete\": \"list\",\n        \"aria-expanded\": \"true\",\n        \"aria-activedescendant\": id + \"-\" + selected,\n        \"aria-controls\": id\n    };\n}\nconst none = [];\nfunction cmpOption(a, b) {\n    let dScore = b.match[0] - a.match[0];\n    if (dScore)\n        return dScore;\n    return a.completion.label.localeCompare(b.completion.label);\n}\nfunction getUserEvent(tr) {\n    return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\nclass ActiveSource {\n    constructor(source, state, explicitPos = -1) {\n        this.source = source;\n        this.state = state;\n        this.explicitPos = explicitPos;\n    }\n    hasResult() { return false; }\n    update(tr, conf) {\n        let event = getUserEvent(tr), value = this;\n        if (event)\n            value = value.handleUserEvent(tr, event, conf);\n        else if (tr.docChanged)\n            value = value.handleChange(tr);\n        else if (tr.selection && value.state != 0 /* Inactive */)\n            value = new ActiveSource(value.source, 0 /* Inactive */);\n        for (let effect of tr.effects) {\n            if (effect.is(startCompletionEffect))\n                value = new ActiveSource(value.source, 1 /* Pending */, effect.value ? cur(tr.state) : -1);\n            else if (effect.is(closeCompletionEffect))\n                value = new ActiveSource(value.source, 0 /* Inactive */);\n            else if (effect.is(setActiveEffect))\n                for (let active of effect.value)\n                    if (active.source == value.source)\n                        value = active;\n        }\n        return value;\n    }\n    handleUserEvent(tr, type, conf) {\n        return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* Pending */);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* Inactive */) : this.map(tr.changes);\n    }\n    map(changes) {\n        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicitPos, result, from, to, span) {\n        super(source, 2 /* Result */, explicitPos);\n        this.result = result;\n        this.from = from;\n        this.to = to;\n        this.span = span;\n    }\n    hasResult() { return true; }\n    handleUserEvent(tr, type, conf) {\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if ((this.explicitPos > -1 ? pos < from : pos <= from) || pos > to)\n            return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* Pending */ : 0 /* Inactive */);\n        let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos);\n        if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to))))\n            return new ActiveResult(this.source, explicitPos, this.result, from, to, this.span);\n        return new ActiveSource(this.source, 1 /* Pending */, explicitPos);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* Inactive */) : this.map(tr.changes);\n    }\n    map(mapping) {\n        return mapping.empty ? this :\n            new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);\n    }\n}\nconst startCompletionEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst setActiveEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map(sources, mapping) { return sources.map(s => s.map(mapping)); }\n});\nconst setSelectedEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst completionState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() { return CompletionState.start(); },\n    update(value, tr) { return value.update(tr); },\n    provide: f => [\n        _codemirror_tooltip__WEBPACK_IMPORTED_MODULE_4__.showTooltip.from(f, val => val.tooltip),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.contentAttributes.from(f, state => state.attrs)\n    ]\n});\n\nconst CompletionInteractMargin = 75;\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\nfunction moveCompletionSelection(forward, by = \"option\") {\n    return (view) => {\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)\n            return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = view.dom.querySelector(\".cm-tooltip-autocomplete\")))\n            step = Math.max(2, Math.floor(tooltip.offsetHeight / tooltip.firstChild.offsetHeight));\n        let selected = cState.open.selected + step * (forward ? 1 : -1), { length } = cState.open.options;\n        if (selected < 0)\n            selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length)\n            selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({ effects: setSelectedEffect.of(selected) });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/\nconst acceptCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)\n        return false;\n    applyCompletion(view, cState.open.options[cState.open.selected]);\n    return true;\n};\n/**\nExplicitly start autocompletion.\n*/\nconst startCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState)\n        return false;\n    view.dispatch({ effects: startCompletionEffect.of(true) });\n    return true;\n};\n/**\nClose the currently active completion.\n*/\nconst closeCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some(a => a.state != 0 /* Inactive */))\n        return false;\n    view.dispatch({ effects: closeCompletionEffect.of(null) });\n    return true;\n};\nclass RunningQuery {\n    constructor(active, context) {\n        this.active = active;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.composing = 0 /* None */;\n        for (let active of view.state.field(completionState).active)\n            if (active.state == 1 /* Pending */)\n                this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)\n            return;\n        let doesReset = update.transactions.some(tr => {\n            return (tr.selection || tr.docChanged) && !getUserEvent(tr);\n        });\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (doesReset ||\n                query.updates.length + update.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {\n                for (let handler of query.context.abortListeners) {\n                    try {\n                        handler();\n                    }\n                    catch (e) {\n                        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.logException)(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            }\n            else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1)\n            clearTimeout(this.debounceUpdate);\n        this.debounceUpdate = cState.active.some(a => a.state == 1 /* Pending */ && !this.running.some(q => q.active.source == a.source))\n            ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;\n        if (this.composing != 0 /* None */)\n            for (let tr of update.transactions) {\n                if (getUserEvent(tr) == \"input\")\n                    this.composing = 2 /* Changed */;\n                else if (this.composing == 2 /* Changed */ && tr.selection)\n                    this.composing = 3 /* ChangedAndMoved */;\n            }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active) {\n            if (active.state == 1 /* Pending */ && !this.running.some(r => r.active.source == active.source))\n                this.startQuery(active);\n        }\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicitPos == pos);\n        let pending = new RunningQuery(active, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then(result => {\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, err => {\n            this.view.dispatch({ effects: closeCompletionEffect.of(null) });\n            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.logException)(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every(q => q.done !== undefined))\n            this.accept();\n        else if (this.debounceAccept < 0)\n            this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1)\n            clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig);\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (query.done === undefined)\n                continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span && query.done.filter !== false ? ensureAnchor(query.done.span, true) : null);\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)\n                    active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);\n            if (current && current.state == 1 /* Pending */) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.active.source, 0 /* Inactive */);\n                    for (let tr of query.updates)\n                        active = active.update(tr, conf);\n                    if (active.state != 1 /* Pending */)\n                        updated.push(active);\n                }\n                else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length)\n            this.view.dispatch({ effects: setActiveEffect.of(updated) });\n    }\n}, {\n    eventHandlers: {\n        compositionstart() {\n            this.composing = 1 /* Started */;\n        },\n        compositionend() {\n            if (this.composing == 3 /* ChangedAndMoved */) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);\n            }\n            this.composing = 0 /* None */;\n        }\n    }\n});\n\nclass FieldPos {\n    constructor(field, line, from, to) {\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to) {\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions) {\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [pos];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines) {\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for (let i = 0; i < tabs; i++)\n                    indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return { text, ranges };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)) {\n            while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n                let seq = m[1] ? +m[1] : null, name = m[2] || m[3], found = -1;\n                for (let i = 0; i < fields.length; i++) {\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)\n                        found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))\n                        i++;\n                    fields.splice(i, 0, { seq, name: name || null });\n                    found = i;\n                    for (let pos of positions)\n                        if (pos.field >= found)\n                            pos.field++;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n            }\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.widget({ widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() { return false; }\n    } });\nlet fieldRange = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.mark({ class: \"cm-snippetField\" });\nclass ActiveSnippet {\n    constructor(ranges, active) {\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        return new ActiveSnippet(this.ranges.map(r => r.map(changes)), this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map(value, changes) { return value && value.map(changes); }\n});\nconst moveToField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst snippetState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() { return null; },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setActive))\n                return effect.value;\n            if (effect.is(moveToField) && value)\n                return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged)\n            value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection))\n            value = null;\n        return value;\n    },\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.decorations.from(f, val => val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.filter(r => r.field == field).map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can apply it.\nSnippets are written using syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n*/\nfunction snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, _completion, from, to) => {\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let spec = { changes: { from, to, insert: _codemirror_text__WEBPACK_IMPORTED_MODULE_1__.Text.of(text) } };\n        if (ranges.length)\n            spec.selection = fieldSelection(ranges, 0);\n        if (ranges.length > 1) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [setActive.of(active)];\n            if (editor.state.field(snippetState, false) === undefined)\n                effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of([snippetState.init(() => active), addSnippetKeymap,\n                    snippetPointerHandler, baseTheme]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch }) => {\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0)\n            return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/\nconst clearSnippet = ({ state, dispatch }) => {\n    let active = state.field(snippetState, false);\n    if (!active)\n        return false;\n    dispatch(state.update({ effects: setActive.of(null) }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\nconst nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\nconst prevSnippetField = /*@__PURE__*/moveField(-1);\nconst defaultSnippetKeymap = [\n    { key: \"Tab\", run: nextSnippetField, shift: prevSnippetField },\n    { key: \"Escape\", run: clearSnippet }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\nconst snippetKeymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }\n});\nconst addSnippetKeymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.override(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\nfunction snippetCompletion(template, completion) {\n    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });\n}\nconst snippetPointerHandler = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.domEventHandlers({\n    mousedown(event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)\n            return false;\n        let match = active.ranges.find(r => r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active)\n            return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)\n        });\n        return true;\n    }\n});\n\nfunction wordRE(wordChars) {\n    let escaped = wordChars.replace(/[\\\\[.+*?(){|^$]/g, \"\\\\$&\");\n    try {\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n    }\n    catch (_a) {\n        return new RegExp(`[\\w${escaped}]`, \"g\");\n    }\n}\nfunction mapRE(re, f) {\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/Object.create(null);\nfunction wordCache(wordChars) {\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n    for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {\n        let { value } = lines, m;\n        wordRE.lastIndex = 0;\n        while (m = wordRE.exec(value)) {\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\n                result.push({ type: \"text\", label: m[0] });\n                seen[m[0]] = true;\n                if (result.length >= 2000 /* MaxList */)\n                    return;\n            }\n        }\n        pos += value.length + 1;\n    }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n    let big = doc.length >= 1000 /* MinCacheLen */;\n    let cached = big && cache.get(doc);\n    if (cached)\n        return cached;\n    let result = [], seen = Object.create(null);\n    if (doc.children) {\n        let pos = 0;\n        for (let ch of doc.children) {\n            if (ch.length >= 1000 /* MinCacheLen */) {\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {\n                    if (!seen[c.label]) {\n                        seen[c.label] = true;\n                        result.push(c);\n                    }\n                }\n            }\n            else {\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n            }\n            pos += ch.length + 1;\n        }\n    }\n    else {\n        storeWords(doc, wordRE, result, seen, ignoreAt);\n    }\n    if (big && result.length < 2000 /* MaxList */)\n        cache.set(doc, result);\n    return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\nconst completeAnyWord = context => {\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n    let re = wordRE(wordChars);\n    let token = context.matchBefore(mapRE(re, s => s + \"$\"));\n    if (!token && !context.explicit)\n        return null;\n    let from = token ? token.from : context.pos;\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* Range */, from);\n    return { from, options, span: mapRE(re, s => \"^\" + s) };\n};\n\n/**\nReturns an extension that enables autocompletion.\n*/\nfunction autocompletion(config = {}) {\n    return [\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\nconst completionKeymap = [\n    { key: \"Ctrl-Space\", run: startCompletion },\n    { key: \"Escape\", run: closeCompletion },\n    { key: \"ArrowDown\", run: /*@__PURE__*/moveCompletionSelection(true) },\n    { key: \"ArrowUp\", run: /*@__PURE__*/moveCompletionSelection(false) },\n    { key: \"PageDown\", run: /*@__PURE__*/moveCompletionSelection(true, \"page\") },\n    { key: \"PageUp\", run: /*@__PURE__*/moveCompletionSelection(false, \"page\") },\n    { key: \"Enter\", run: acceptCompletion }\n];\nconst completionKeymapExt = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.override(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\nfunction completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some(a => a.state == 1 /* Pending */) ? \"pending\"\n        : cState && cState.active.some(a => a.state != 0 /* Inactive */) ? \"active\" : null;\n}\n/**\nReturns the available completions as an array.\n*/\nfunction currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open ? open.options.map(o => o.completion) : [];\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/autocomplete/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/basic-setup/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@codemirror/basic-setup/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditorView\": () => (/* reexport safe */ _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView),\n/* harmony export */   \"EditorState\": () => (/* reexport safe */ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState),\n/* harmony export */   \"basicSetup\": () => (/* binding */ basicSetup)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/history */ \"./node_modules/@codemirror/history/dist/index.js\");\n/* harmony import */ var _codemirror_fold__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/fold */ \"./node_modules/@codemirror/fold/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_gutter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/gutter */ \"./node_modules/@codemirror/gutter/dist/index.js\");\n/* harmony import */ var _codemirror_commands__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @codemirror/commands */ \"./node_modules/@codemirror/commands/dist/index.js\");\n/* harmony import */ var _codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @codemirror/matchbrackets */ \"./node_modules/@codemirror/matchbrackets/dist/index.js\");\n/* harmony import */ var _codemirror_closebrackets__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @codemirror/closebrackets */ \"./node_modules/@codemirror/closebrackets/dist/index.js\");\n/* harmony import */ var _codemirror_search__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @codemirror/search */ \"./node_modules/@codemirror/search/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @codemirror/autocomplete */ \"./node_modules/@codemirror/autocomplete/dist/index.js\");\n/* harmony import */ var _codemirror_comment__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @codemirror/comment */ \"./node_modules/@codemirror/comment/dist/index.js\");\n/* harmony import */ var _codemirror_rectangular_selection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @codemirror/rectangular-selection */ \"./node_modules/@codemirror/rectangular-selection/dist/index.js\");\n/* harmony import */ var _codemirror_highlight__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/highlight */ \"./node_modules/@codemirror/highlight/dist/index.js\");\n/* harmony import */ var _codemirror_lint__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @codemirror/lint */ \"./node_modules/@codemirror/lint/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\nThis is an extension value that just pulls together a whole lot of\nextensions that you might want in a basic editor. It is meant as a\nconvenient helper to quickly set up CodeMirror without installing\nand importing a lot of packages.\n\nSpecifically, it includes...\n\n - [the default command bindings](https://codemirror.net/6/docs/ref/#commands.defaultKeymap)\n - [line numbers](https://codemirror.net/6/docs/ref/#gutter.lineNumbers)\n - [special character highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars)\n - [the undo history](https://codemirror.net/6/docs/ref/#history.history)\n - [a fold gutter](https://codemirror.net/6/docs/ref/#fold.foldGutter)\n - [custom selection drawing](https://codemirror.net/6/docs/ref/#view.drawSelection)\n - [multiple selections](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\n - [reindentation on input](https://codemirror.net/6/docs/ref/#language.indentOnInput)\n - [the default highlight style](https://codemirror.net/6/docs/ref/#highlight.defaultHighlightStyle) (as fallback)\n - [bracket matching](https://codemirror.net/6/docs/ref/#matchbrackets.bracketMatching)\n - [bracket closing](https://codemirror.net/6/docs/ref/#closebrackets.closeBrackets)\n - [autocompletion](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion)\n - [rectangular selection](https://codemirror.net/6/docs/ref/#rectangular-selection.rectangularSelection)\n - [active line highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLine)\n - [active line gutter highlighting](https://codemirror.net/6/docs/ref/#gutter.highlightActiveLineGutter)\n - [selection match highlighting](https://codemirror.net/6/docs/ref/#search.highlightSelectionMatches)\n - [search](https://codemirror.net/6/docs/ref/#search.searchKeymap)\n - [commenting](https://codemirror.net/6/docs/ref/#comment.commentKeymap)\n - [linting](https://codemirror.net/6/docs/ref/#lint.lintKeymap)\n\n(You'll probably want to add some language package to your setup\ntoo.)\n\nThis package does not allow customization. The idea is that, once\nyou decide you want to configure your editor more precisely, you\ntake this package's source (which is just a bunch of imports and\nan array literal), copy it into your own code, and adjust it as\ndesired.\n*/\nconst basicSetup = [\n    /*@__PURE__*/(0,_codemirror_gutter__WEBPACK_IMPORTED_MODULE_2__.lineNumbers)(),\n    /*@__PURE__*/(0,_codemirror_gutter__WEBPACK_IMPORTED_MODULE_2__.highlightActiveLineGutter)(),\n    /*@__PURE__*/(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.highlightSpecialChars)(),\n    /*@__PURE__*/(0,_codemirror_history__WEBPACK_IMPORTED_MODULE_3__.history)(),\n    /*@__PURE__*/(0,_codemirror_fold__WEBPACK_IMPORTED_MODULE_4__.foldGutter)(),\n    /*@__PURE__*/(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.drawSelection)(),\n    /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.allowMultipleSelections.of(true),\n    /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_5__.indentOnInput)(),\n    _codemirror_highlight__WEBPACK_IMPORTED_MODULE_6__.defaultHighlightStyle.fallback,\n    /*@__PURE__*/(0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_7__.bracketMatching)(),\n    /*@__PURE__*/(0,_codemirror_closebrackets__WEBPACK_IMPORTED_MODULE_8__.closeBrackets)(),\n    /*@__PURE__*/(0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_9__.autocompletion)(),\n    /*@__PURE__*/(0,_codemirror_rectangular_selection__WEBPACK_IMPORTED_MODULE_10__.rectangularSelection)(),\n    /*@__PURE__*/(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.highlightActiveLine)(),\n    /*@__PURE__*/(0,_codemirror_search__WEBPACK_IMPORTED_MODULE_11__.highlightSelectionMatches)(),\n    /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.keymap.of([\n        ..._codemirror_closebrackets__WEBPACK_IMPORTED_MODULE_8__.closeBracketsKeymap,\n        ..._codemirror_commands__WEBPACK_IMPORTED_MODULE_12__.defaultKeymap,\n        ..._codemirror_search__WEBPACK_IMPORTED_MODULE_11__.searchKeymap,\n        ..._codemirror_history__WEBPACK_IMPORTED_MODULE_3__.historyKeymap,\n        ..._codemirror_fold__WEBPACK_IMPORTED_MODULE_4__.foldKeymap,\n        ..._codemirror_comment__WEBPACK_IMPORTED_MODULE_13__.commentKeymap,\n        ..._codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_9__.completionKeymap,\n        ..._codemirror_lint__WEBPACK_IMPORTED_MODULE_14__.lintKeymap\n    ])\n];\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/basic-setup/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/closebrackets/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/closebrackets/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"closeBrackets\": () => (/* binding */ closeBrackets),\n/* harmony export */   \"closeBracketsKeymap\": () => (/* binding */ closeBracketsKeymap),\n/* harmony export */   \"deleteBracketPair\": () => (/* binding */ deleteBracketPair),\n/* harmony export */   \"insertBracket\": () => (/* binding */ insertBracket)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/rangeset */ \"./node_modules/@codemirror/rangeset/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n\n\n\n\n\n\nconst defaults = {\n    brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n    before: \")]}'\\\":;>\"\n};\nconst closeBracketEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({\n    map(value, mapping) {\n        let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst skipBracketEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({\n    map(value, mapping) { return mapping.mapPos(value); }\n});\nconst closedBracket = /*@__PURE__*/new class extends _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({\n    create() { return _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty; },\n    update(value, tr) {\n        if (tr.selection) {\n            let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;\n            let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;\n            if (lineStart != tr.changes.mapPos(prevLineStart, -1))\n                value = _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n        }\n        value = value.map(tr.changes);\n        for (let effect of tr.effects) {\n            if (effect.is(closeBracketEffect))\n                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });\n            else if (effect.is(skipBracketEffect))\n                value = value.update({ filter: from => from != effect.value });\n        }\n        return value;\n    }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/\nfunction closeBrackets() {\n    return [_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of(handleInput), bracketState];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for (let i = 0; i < definedClosing.length; i += 2)\n        if (definedClosing.charCodeAt(i) == ch)\n            return definedClosing.charAt(i + 1);\n    return (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.fromCodePoint)(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nfunction handleInput(view, from, to, insert) {\n    if (view.composing)\n        return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.codePointSize)((0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(insert, 0)) == 1 ||\n        from != sel.from || to != sel.to)\n        return false;\n    let tr = insertBracket(view.state, insert);\n    if (!tr)\n        return false;\n    view.dispatch(tr);\n    return true;\n}\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/\nconst deleteBracketPair = ({ state, dispatch }) => {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange(range => {\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens) {\n                if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(token, 0)))\n                    return { changes: { from: range.head - token.length, to: range.head + token.length },\n                        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(range.head - token.length),\n                        userEvent: \"delete.backward\" };\n            }\n        }\n        return { range: dont = range };\n    });\n    if (!dont)\n        dispatch(state.update(changes, { scrollIntoView: true }));\n    return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#closebrackets.deleteBracketPair).\n*/\nconst closeBracketsKeymap = [\n    { key: \"Backspace\", run: deleteBracketPair }\n];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert bracketsthe\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#closebrackets.closeBrackets) extension will\ntake care of running this for user input.)\n*/\nfunction insertBracket(state, bracket) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens) {\n        let closed = closing((0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(tok, 0));\n        if (bracket == tok)\n            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1)\n                : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from))\n            return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, from => {\n        if (from == pos)\n            found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.codePointSize)((0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.codePointSize)((0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],\n                effects: closeBracketEffect.of(range.to + open.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(range.anchor + open.length, range.head + open.length) };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1)\n            return { changes: { insert: open + close, from: range.head },\n                effects: closeBracketEffect.of(range.head + open.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(range.head + open.length) };\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, moved = state.selection.ranges.map(range => {\n        if (range.empty && nextChar(state.doc, range.head) == close)\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(range.head + close.length);\n        return dont = range;\n    });\n    return dont ? null : state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.create(moved, state.selection.mainIndex),\n        scrollIntoView: true,\n        effects: state.selection.ranges.map(({ from }) => skipBracketEffect.of(from))\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],\n                effects: closeBracketEffect.of(range.to + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(range.anchor + token.length, range.head + token.length) };\n        let pos = range.head, next = nextChar(state.doc, pos);\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos + token.length) };\n            }\n            else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),\n                    effects: skipBracketEffect.of(pos) };\n            }\n        }\n        else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token &&\n            nodeStart(state, pos - 2 * token.length)) {\n            return { changes: { insert: token + token + token + token, from: pos },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos + token.length) };\n        }\n        else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.CharCategory.Word) {\n            let prev = state.sliceDoc(pos - 1, pos);\n            if (prev != token && state.charCategorizer(pos)(prev) != _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.CharCategory.Word)\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.cursor(pos + token.length) };\n        }\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_4__.syntaxTree)(state).resolveInner(pos + 1);\n    return tree.parent && tree.from == pos;\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/closebrackets/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"copyLineDown\": () => (/* binding */ copyLineDown),\n/* harmony export */   \"copyLineUp\": () => (/* binding */ copyLineUp),\n/* harmony export */   \"cursorCharBackward\": () => (/* binding */ cursorCharBackward),\n/* harmony export */   \"cursorCharForward\": () => (/* binding */ cursorCharForward),\n/* harmony export */   \"cursorCharLeft\": () => (/* binding */ cursorCharLeft),\n/* harmony export */   \"cursorCharRight\": () => (/* binding */ cursorCharRight),\n/* harmony export */   \"cursorDocEnd\": () => (/* binding */ cursorDocEnd),\n/* harmony export */   \"cursorDocStart\": () => (/* binding */ cursorDocStart),\n/* harmony export */   \"cursorGroupBackward\": () => (/* binding */ cursorGroupBackward),\n/* harmony export */   \"cursorGroupForward\": () => (/* binding */ cursorGroupForward),\n/* harmony export */   \"cursorGroupLeft\": () => (/* binding */ cursorGroupLeft),\n/* harmony export */   \"cursorGroupRight\": () => (/* binding */ cursorGroupRight),\n/* harmony export */   \"cursorLineBoundaryBackward\": () => (/* binding */ cursorLineBoundaryBackward),\n/* harmony export */   \"cursorLineBoundaryForward\": () => (/* binding */ cursorLineBoundaryForward),\n/* harmony export */   \"cursorLineDown\": () => (/* binding */ cursorLineDown),\n/* harmony export */   \"cursorLineEnd\": () => (/* binding */ cursorLineEnd),\n/* harmony export */   \"cursorLineStart\": () => (/* binding */ cursorLineStart),\n/* harmony export */   \"cursorLineUp\": () => (/* binding */ cursorLineUp),\n/* harmony export */   \"cursorMatchingBracket\": () => (/* binding */ cursorMatchingBracket),\n/* harmony export */   \"cursorPageDown\": () => (/* binding */ cursorPageDown),\n/* harmony export */   \"cursorPageUp\": () => (/* binding */ cursorPageUp),\n/* harmony export */   \"cursorSubwordBackward\": () => (/* binding */ cursorSubwordBackward),\n/* harmony export */   \"cursorSubwordForward\": () => (/* binding */ cursorSubwordForward),\n/* harmony export */   \"cursorSyntaxLeft\": () => (/* binding */ cursorSyntaxLeft),\n/* harmony export */   \"cursorSyntaxRight\": () => (/* binding */ cursorSyntaxRight),\n/* harmony export */   \"defaultKeymap\": () => (/* binding */ defaultKeymap),\n/* harmony export */   \"deleteCharBackward\": () => (/* binding */ deleteCharBackward),\n/* harmony export */   \"deleteCharForward\": () => (/* binding */ deleteCharForward),\n/* harmony export */   \"deleteGroupBackward\": () => (/* binding */ deleteGroupBackward),\n/* harmony export */   \"deleteGroupForward\": () => (/* binding */ deleteGroupForward),\n/* harmony export */   \"deleteLine\": () => (/* binding */ deleteLine),\n/* harmony export */   \"deleteToLineEnd\": () => (/* binding */ deleteToLineEnd),\n/* harmony export */   \"deleteToLineStart\": () => (/* binding */ deleteToLineStart),\n/* harmony export */   \"deleteTrailingWhitespace\": () => (/* binding */ deleteTrailingWhitespace),\n/* harmony export */   \"emacsStyleKeymap\": () => (/* binding */ emacsStyleKeymap),\n/* harmony export */   \"indentLess\": () => (/* binding */ indentLess),\n/* harmony export */   \"indentMore\": () => (/* binding */ indentMore),\n/* harmony export */   \"indentSelection\": () => (/* binding */ indentSelection),\n/* harmony export */   \"indentWithTab\": () => (/* binding */ indentWithTab),\n/* harmony export */   \"insertBlankLine\": () => (/* binding */ insertBlankLine),\n/* harmony export */   \"insertNewline\": () => (/* binding */ insertNewline),\n/* harmony export */   \"insertNewlineAndIndent\": () => (/* binding */ insertNewlineAndIndent),\n/* harmony export */   \"insertTab\": () => (/* binding */ insertTab),\n/* harmony export */   \"moveLineDown\": () => (/* binding */ moveLineDown),\n/* harmony export */   \"moveLineUp\": () => (/* binding */ moveLineUp),\n/* harmony export */   \"selectAll\": () => (/* binding */ selectAll),\n/* harmony export */   \"selectCharBackward\": () => (/* binding */ selectCharBackward),\n/* harmony export */   \"selectCharForward\": () => (/* binding */ selectCharForward),\n/* harmony export */   \"selectCharLeft\": () => (/* binding */ selectCharLeft),\n/* harmony export */   \"selectCharRight\": () => (/* binding */ selectCharRight),\n/* harmony export */   \"selectDocEnd\": () => (/* binding */ selectDocEnd),\n/* harmony export */   \"selectDocStart\": () => (/* binding */ selectDocStart),\n/* harmony export */   \"selectGroupBackward\": () => (/* binding */ selectGroupBackward),\n/* harmony export */   \"selectGroupForward\": () => (/* binding */ selectGroupForward),\n/* harmony export */   \"selectGroupLeft\": () => (/* binding */ selectGroupLeft),\n/* harmony export */   \"selectGroupRight\": () => (/* binding */ selectGroupRight),\n/* harmony export */   \"selectLine\": () => (/* binding */ selectLine),\n/* harmony export */   \"selectLineBoundaryBackward\": () => (/* binding */ selectLineBoundaryBackward),\n/* harmony export */   \"selectLineBoundaryForward\": () => (/* binding */ selectLineBoundaryForward),\n/* harmony export */   \"selectLineDown\": () => (/* binding */ selectLineDown),\n/* harmony export */   \"selectLineEnd\": () => (/* binding */ selectLineEnd),\n/* harmony export */   \"selectLineStart\": () => (/* binding */ selectLineStart),\n/* harmony export */   \"selectLineUp\": () => (/* binding */ selectLineUp),\n/* harmony export */   \"selectMatchingBracket\": () => (/* binding */ selectMatchingBracket),\n/* harmony export */   \"selectPageDown\": () => (/* binding */ selectPageDown),\n/* harmony export */   \"selectPageUp\": () => (/* binding */ selectPageUp),\n/* harmony export */   \"selectParentSyntax\": () => (/* binding */ selectParentSyntax),\n/* harmony export */   \"selectSubwordBackward\": () => (/* binding */ selectSubwordBackward),\n/* harmony export */   \"selectSubwordForward\": () => (/* binding */ selectSubwordForward),\n/* harmony export */   \"selectSyntaxLeft\": () => (/* binding */ selectSyntaxLeft),\n/* harmony export */   \"selectSyntaxRight\": () => (/* binding */ selectSyntaxRight),\n/* harmony export */   \"simplifySelection\": () => (/* binding */ simplifySelection),\n/* harmony export */   \"splitLine\": () => (/* binding */ splitLine),\n/* harmony export */   \"standardKeymap\": () => (/* binding */ standardKeymap),\n/* harmony export */   \"transposeChars\": () => (/* binding */ transposeChars)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/matchbrackets */ \"./node_modules/@codemirror/matchbrackets/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\n\n\nfunction updateSel(sel, by) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({ selection, scrollIntoView: true, userEvent: \"select\" });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection))\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\nconst cursorCharLeft = view => cursorByChar(view, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n/**\nMove the selection one character to the right.\n*/\nconst cursorCharRight = view => cursorByChar(view, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n/**\nMove the selection one character forward.\n*/\nconst cursorCharForward = view => cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/\nconst cursorCharBackward = view => cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\nconst cursorGroupLeft = view => cursorByGroup(view, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n/**\nMove the selection one group to the right.\n*/\nconst cursorGroupRight = view => cursorByGroup(view, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n/**\nMove the selection one group forward.\n*/\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/\nconst cursorGroupBackward = view => cursorByGroup(view, false);\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    return view.moveByChar(range, forward, start => {\n        let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space, pos = range.from;\n        let done = false, sawUpper = false, sawLower = false;\n        let step = (next) => {\n            if (done)\n                return false;\n            pos += forward ? next.length : -next.length;\n            let nextCat = categorize(next), ahead;\n            if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space)\n                cat = nextCat;\n            if (cat != nextCat)\n                return false;\n            if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n                if (next.toLowerCase() == next) {\n                    if (!forward && sawUpper)\n                        return false;\n                    sawLower = true;\n                }\n                else if (sawLower) {\n                    if (forward)\n                        return false;\n                    done = true;\n                }\n                else {\n                    if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word &&\n                        ahead.toLowerCase() == ahead)\n                        return false;\n                    sawUpper = true;\n                }\n            }\n            return true;\n        };\n        step(start);\n        return step;\n    });\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\nconst cursorSubwordForward = view => cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/\nconst cursorSubwordBackward = view => cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp))\n        return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n    let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for (let at = start.head;;) {\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next)\n            break;\n        if (interestingNode(state, next, bracketProp))\n            pos = next;\n        else\n            at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, pos.to, -1)) && match.matched)\n        newPos = forward ? match.end.to : match.end.from;\n    else\n        newPos = forward ? pos.to : pos.from;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR));\n/**\nMove the cursor over the next syntactic element to the right.\n*/\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, range => {\n        if (!range.empty)\n            return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/\nconst cursorLineUp = view => cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/\nconst cursorLineDown = view => cursorByLine(view, true);\nfunction cursorByPage(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveVertically(range, forward, view.dom.clientHeight) : rangeEnd(range, forward));\n}\n/**\nMove the selection one page up.\n*/\nconst cursorPageUp = view => cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/\nconst cursorPageDown = view => cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.visualLineAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))\n        moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space)\n            moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection to the start of the line.\n*/\nconst cursorLineStart = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.visualLineAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/\nconst cursorLineEnd = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.visualLineAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, range => {\n        let matching = (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, range.head, -1)\n            || (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, range.head, 1)\n            || (range.head > 0 && (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, range.head - 1, 1))\n            || (range.head < state.doc.length && (0,_codemirror_matchbrackets__WEBPACK_IMPORTED_MODULE_4__.matchBrackets)(state, range.head + 1, -1));\n        if (!matching || !matching.end)\n            return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n    });\n    if (!found)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\nconst cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\nconst selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n    let selection = updateSel(view.state.selection, range => {\n        let head = how(range);\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn);\n    });\n    if (selection.eq(view.state.selection))\n        return false;\n    view.dispatch(setSel(view.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, range => view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\nconst selectCharLeft = view => selectByChar(view, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n/**\nMove the selection head one character to the right.\n*/\nconst selectCharRight = view => selectByChar(view, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n/**\nMove the selection head one character forward.\n*/\nconst selectCharForward = view => selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/\nconst selectCharBackward = view => selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n    return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\nconst selectGroupLeft = view => selectByGroup(view, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n/**\nMove the selection head one group to the right.\n*/\nconst selectGroupRight = view => selectByGroup(view, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR);\n/**\nMove the selection head one group forward.\n*/\nconst selectGroupForward = view => selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/\nconst selectGroupBackward = view => selectByGroup(view, false);\nfunction selectBySubword(view, forward) {\n    return extendSel(view, range => moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\nconst selectSubwordForward = view => selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/\nconst selectSubwordBackward = view => selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR));\n/**\nMove the selection head over the next syntactic element to the right.\n*/\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR));\nfunction selectByLine(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/\nconst selectLineUp = view => selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/\nconst selectLineDown = view => selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward, view.dom.clientHeight));\n}\n/**\nMove the selection head one page up.\n*/\nconst selectPageUp = view => selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/\nconst selectPageDown = view => selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection head to the start of the line.\n*/\nconst selectLineStart = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.visualLineAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/\nconst selectLineEnd = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.visualLineAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/\nconst cursorDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: 0 }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/\nconst cursorDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.doc.length }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\nconst selectDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\nconst selectDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));\n    return true;\n};\n/**\nSelect the entire document.\n*/\nconst selectAll = ({ state, dispatch }) => {\n    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: \"select\" }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\nconst selectLine = ({ state, dispatch }) => {\n    let ranges = selectedLineBlocks(state).map(({ from, to }) => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({ selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges), userEvent: \"select\" }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\nconst selectParentSyntax = ({ state, dispatch }) => {\n    let selection = updateSel(state.selection, range => {\n        var _a;\n        let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(range.head, 1);\n        while (!((context.from < range.from && context.to >= range.to) ||\n            (context.to > range.to && context.from <= range.from) ||\n            !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))\n            context = context.parent;\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(context.to, context.from);\n    });\n    dispatch(setSel(state, selection));\n    return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\nconst simplifySelection = ({ state, dispatch }) => {\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1)\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([cur.main]);\n    else if (!cur.main.empty)\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)]);\n    if (!selection)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy({ state, dispatch }, by) {\n    if (state.readOnly)\n        return false;\n    let event = \"delete.selection\";\n    let changes = state.changeByRange(range => {\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(from);\n            if (towards < from)\n                event = \"delete.backward\";\n            else if (towards > from)\n                event = \"delete.forward\";\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        }\n        return from == to ? { range } : { changes: { from, to }, range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from) };\n    });\n    if (changes.changes.empty)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: event }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView)\n        for (let ranges of target.pluginField(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.PluginField.atomicRanges))\n            ranges.between(pos, pos, (from, to) => {\n                if (from < pos && to > pos)\n                    pos = forward ? to : from;\n            });\n    return pos;\n}\nconst deleteByChar = (target, forward) => deleteBy(target, pos => {\n    let { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n    if (!forward && pos > line.from && pos < line.from + 200 &&\n        !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n        if (before[before.length - 1] == \"\\t\")\n            return pos - 1;\n        let col = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.countColumn)(before, state.tabSize), drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n        for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)\n            pos--;\n        targetPos = pos;\n    }\n    else {\n        targetPos = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))\n            targetPos += forward ? 1 : -1;\n    }\n    return skipAtomic(target, targetPos, forward);\n});\n/**\nDelete the selection, or, for cursor selections, the character\nbefore the cursor.\n*/\nconst deleteCharBackward = view => deleteByChar(view, false);\n/**\nDelete the selection or the character after the cursor.\n*/\nconst deleteCharForward = view => deleteByChar(view, true);\nconst deleteByGroup = (target, forward) => deleteBy(target, start => {\n    let pos = start, { state } = target, line = state.doc.lineAt(pos);\n    let categorize = state.charCategorizer(pos);\n    for (let cat = null;;) {\n        if (pos == (forward ? line.to : line.from)) {\n            if (pos == start && line.number != (forward ? state.doc.lines : 1))\n                pos += forward ? 1 : -1;\n            break;\n        }\n        let next = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n        let nextCat = categorize(nextChar);\n        if (cat != null && nextCat != cat)\n            break;\n        if (nextChar != \" \" || pos != start)\n            cat = nextCat;\n        pos = next;\n    }\n    return skipAtomic(target, pos, forward);\n});\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\nconst deleteGroupBackward = target => deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/\nconst deleteGroupForward = target => deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\nconst deleteToLineEnd = view => deleteBy(view, pos => {\n    let lineEnd = view.visualLineAt(pos).to;\n    return skipAtomic(view, pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1), true);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\nconst deleteToLineStart = view => deleteBy(view, pos => {\n    let lineStart = view.visualLineAt(pos).from;\n    return skipAtomic(view, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);\n});\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\nconst deleteTrailingWhitespace = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = [];\n    for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1)\n                changes.push({ from: pos - (prev.length - trailing), to: pos });\n            if (iter.done)\n                break;\n            prev = \"\";\n        }\n        else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({ changes, userEvent: \"delete\" }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\nconst splitLine = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = state.changeByRange(range => {\n        return { changes: { from: range.from, to: range.to, insert: _codemirror_text__WEBPACK_IMPORTED_MODULE_5__.Text.of([\"\", \"\"]) },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from) };\n    });\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\nconst transposeChars = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = state.changeByRange(range => {\n        if (!range.empty || range.from == 0 || range.from == state.doc.length)\n            return { range };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to) };\n    });\n    if (changes.changes.empty)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"move.character\" }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges) {\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from)\n            endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        }\n        else {\n            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly)\n        return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward ? block.to == state.doc.length : block.from == 0)\n            continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });\n            for (let r of block.ranges)\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        }\n        else {\n            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });\n            for (let r of block.ranges)\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/\nconst moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/\nconst moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly)\n        return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward)\n            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });\n        else\n            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });\n    }\n    dispatch(state.update({ changes, scrollIntoView: true, userEvent: \"input.copyline\" }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\nconst copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\nconst copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/\nconst deleteLine = view => {\n    if (view.state.readOnly)\n        return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {\n        if (from > 0)\n            from--;\n        else if (to < state.doc.length)\n            to++;\n        return { from, to };\n    }));\n    let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);\n    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: \"delete.line\" });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/\nconst insertNewline = ({ state, dispatch }) => {\n    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1)))\n        return { from: pos, to: pos };\n    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos &&\n        (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&\n        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)\n        return { from: before.to, to: after.from };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\nconst insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\nconst insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch }) => {\n        if (state.readOnly)\n            return false;\n        let changes = state.changeByRange(range => {\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof)\n                from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });\n            let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n            if (indent == null)\n                indent = /^\\s*/.exec(state.doc.lineAt(from).text)[0].length;\n            while (to < line.to && /\\s/.test(line.text[to - line.from]))\n                to++;\n            if (explode)\n                ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from)))\n                from = line.from;\n            let insert = [\"\", (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)];\n            if (explode)\n                insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n            return { changes: { from, to, insert: _codemirror_text__WEBPACK_IMPORTED_MODULE_5__.Text.of(insert) },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length) };\n        });\n        dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange(range => {\n        let changes = [];\n        for (let pos = range.from; pos <= range.to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return { changes,\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\nconst indentSelection = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let updated = Object.create(null);\n    let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, { overrideIndentation: start => {\n            let found = updated[start];\n            return found == null ? -1 : found;\n        } });\n    let changes = changeBySelectedLine(state, (line, changes, range) => {\n        let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n        if (indent == null)\n            return;\n        if (!/\\S/.test(line.text))\n            indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n    });\n    if (!changes.changes.empty)\n        dispatch(state.update(changes, { userEvent: \"indent\" }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\nconst indentMore = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        changes.push({ from: line.from, insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit) });\n    }), { userEvent: \"input.indent\" }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\nconst indentLess = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space)\n            return;\n        let col = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_5__.countColumn)(space, state.tabSize), keep = 0;\n        let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))\n            keep++;\n        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });\n    }), { userEvent: \"delete.dedent\" }));\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\nconst insertTab = ({ state, dispatch }) => {\n    if (state.selection.ranges.some(r => !r.empty))\n        return indentMore({ state, dispatch });\n    dispatch(state.update(state.replaceSelection(\"\\t\"), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Alt-<: [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart)\n - Alt->: [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\nconst emacsStyleKeymap = [\n    { key: \"Ctrl-b\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\n    { key: \"Ctrl-f\", run: cursorCharRight, shift: selectCharRight },\n    { key: \"Ctrl-p\", run: cursorLineUp, shift: selectLineUp },\n    { key: \"Ctrl-n\", run: cursorLineDown, shift: selectLineDown },\n    { key: \"Ctrl-a\", run: cursorLineStart, shift: selectLineStart },\n    { key: \"Ctrl-e\", run: cursorLineEnd, shift: selectLineEnd },\n    { key: \"Ctrl-d\", run: deleteCharForward },\n    { key: \"Ctrl-h\", run: deleteCharBackward },\n    { key: \"Ctrl-k\", run: deleteToLineEnd },\n    { key: \"Ctrl-Alt-h\", run: deleteGroupBackward },\n    { key: \"Ctrl-o\", run: splitLine },\n    { key: \"Ctrl-t\", run: transposeChars },\n    { key: \"Alt-<\", run: cursorDocStart },\n    { key: \"Alt->\", run: cursorDocEnd },\n    { key: \"Ctrl-v\", run: cursorPageDown },\n    { key: \"Alt-v\", run: cursorPageUp },\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).\n - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).\n*/\nconst standardKeymap = /*@__PURE__*/[\n    { key: \"ArrowLeft\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\n    { key: \"Mod-ArrowLeft\", mac: \"Alt-ArrowLeft\", run: cursorGroupLeft, shift: selectGroupLeft },\n    { mac: \"Cmd-ArrowLeft\", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward },\n    { key: \"ArrowRight\", run: cursorCharRight, shift: selectCharRight, preventDefault: true },\n    { key: \"Mod-ArrowRight\", mac: \"Alt-ArrowRight\", run: cursorGroupRight, shift: selectGroupRight },\n    { mac: \"Cmd-ArrowRight\", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward },\n    { key: \"ArrowUp\", run: cursorLineUp, shift: selectLineUp, preventDefault: true },\n    { mac: \"Cmd-ArrowUp\", run: cursorDocStart, shift: selectDocStart },\n    { mac: \"Ctrl-ArrowUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"ArrowDown\", run: cursorLineDown, shift: selectLineDown, preventDefault: true },\n    { mac: \"Cmd-ArrowDown\", run: cursorDocEnd, shift: selectDocEnd },\n    { mac: \"Ctrl-ArrowDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"PageUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"PageDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"Home\", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward },\n    { key: \"Mod-Home\", run: cursorDocStart, shift: selectDocStart },\n    { key: \"End\", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward },\n    { key: \"Mod-End\", run: cursorDocEnd, shift: selectDocEnd },\n    { key: \"Enter\", run: insertNewlineAndIndent },\n    { key: \"Mod-a\", run: selectAll },\n    { key: \"Backspace\", run: deleteCharBackward, shift: deleteCharBackward },\n    { key: \"Delete\", run: deleteCharForward, shift: deleteCharForward },\n    { key: \"Mod-Backspace\", mac: \"Alt-Backspace\", run: deleteGroupBackward },\n    { key: \"Mod-Delete\", mac: \"Alt-Delete\", run: deleteGroupForward },\n    { mac: \"Mod-Backspace\", run: deleteToLineStart },\n    { mac: \"Mod-Delete\", run: deleteToLineEnd }\n].concat(/*@__PURE__*/emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Comd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n*/\nconst defaultKeymap = /*@__PURE__*/[\n    { key: \"Alt-ArrowLeft\", mac: \"Ctrl-ArrowLeft\", run: cursorSyntaxLeft, shift: selectSyntaxLeft },\n    { key: \"Alt-ArrowRight\", mac: \"Ctrl-ArrowRight\", run: cursorSyntaxRight, shift: selectSyntaxRight },\n    { key: \"Alt-ArrowUp\", run: moveLineUp },\n    { key: \"Shift-Alt-ArrowUp\", run: copyLineUp },\n    { key: \"Alt-ArrowDown\", run: moveLineDown },\n    { key: \"Shift-Alt-ArrowDown\", run: copyLineDown },\n    { key: \"Escape\", run: simplifySelection },\n    { key: \"Mod-Enter\", run: insertBlankLine },\n    { key: \"Alt-l\", mac: \"Ctrl-l\", run: selectLine },\n    { key: \"Mod-i\", run: selectParentSyntax, preventDefault: true },\n    { key: \"Mod-[\", run: indentLess },\n    { key: \"Mod-]\", run: indentMore },\n    { key: \"Mod-Alt-\\\\\", run: indentSelection },\n    { key: \"Shift-Mod-k\", run: deleteLine },\n    { key: \"Shift-Mod-\\\\\", run: cursorMatchingBracket }\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\nconst indentWithTab = { key: \"Tab\", run: indentMore, shift: indentLess };\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/commands/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/comment/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@codemirror/comment/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"blockComment\": () => (/* binding */ blockComment),\n/* harmony export */   \"blockUncomment\": () => (/* binding */ blockUncomment),\n/* harmony export */   \"commentKeymap\": () => (/* binding */ commentKeymap),\n/* harmony export */   \"lineComment\": () => (/* binding */ lineComment),\n/* harmony export */   \"lineUncomment\": () => (/* binding */ lineUncomment),\n/* harmony export */   \"toggleBlockComment\": () => (/* binding */ toggleBlockComment),\n/* harmony export */   \"toggleComment\": () => (/* binding */ toggleComment),\n/* harmony export */   \"toggleLineComment\": () => (/* binding */ toggleLineComment)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\nconst toggleComment = target => {\n    let config = getConfig(target.state);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockComment(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch }) => {\n        let tr = f(option, state.selection.ranges, state);\n        if (!tr)\n            return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#comment.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* Toggle */);\n/**\nComment the current selection using line comments.\n*/\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1 /* Comment */);\n/**\nUncomment the current selection using line comments.\n*/\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2 /* Uncomment */);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#comment.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* Toggle */);\n/**\nComment the current selection using block comments.\n*/\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1 /* Comment */);\n/**\nUncomment the current selection using block comments.\n*/\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2 /* Uncomment */);\n/**\nDefault key bindings for this package.\n\n - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#comment.toggleComment).\n - Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#comment.toggleBlockComment).\n*/\nconst commentKeymap = [\n    { key: \"Mod-/\", run: toggleComment },\n    { key: \"Alt-A\", run: toggleBlockComment }\n];\nfunction getConfig(state, pos = state.selection.main.head) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\nfunction findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&\n        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },\n            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    }\n    else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open &&\n        endText.slice(endOff, endOff + close.length) == close) {\n        return { open: { pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },\n            close: { pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, ranges, state) {\n    let tokens = ranges.map(r => getConfig(state, r.from).block);\n    if (!tokens.every(c => c))\n        return null;\n    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* Uncomment */ && !comments.every(c => c)) {\n        let index = 0;\n        return state.changeByRange(range => {\n            let { open, close } = tokens[index++];\n            if (comments[index])\n                return { range };\n            let shift = open.length + 1;\n            return {\n                changes: [{ from: range.from, insert: open + \" \" }, { from: range.to, insert: \" \" + close }],\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(range.anchor + shift, range.head + shift)\n            };\n        });\n    }\n    else if (option != 1 /* Comment */ && comments.some(c => c)) {\n        let changes = [];\n        for (let i = 0, comment; i < comments.length; i++)\n            if (comment = comments[i]) {\n                let token = tokens[i], { open, close } = comment;\n                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });\n            }\n        return { changes };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, ranges, state) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges) {\n        let startI = lines.length, minIndent = 1e9;\n        for (let pos = from; pos <= to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let token = getConfig(state, pos).line;\n                if (!token)\n                    continue;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent)\n                    minIndent = indent;\n                lines.push({ line, comment, token, indent, empty, single: false });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9)\n            for (let i = startI; i < lines.length; i++)\n                if (lines[i].indent < lines[i].line.text.length)\n                    lines[i].indent = minIndent;\n        if (lines.length == startI + 1)\n            lines[startI].single = true;\n    }\n    if (option != 2 /* Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)\n            if (single || !empty)\n                changes.push({ from: line.from + indent, insert: token + \" \" });\n        let changeSet = state.changes(changes);\n        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };\n    }\n    else if (option != 1 /* Comment */ && lines.some(l => l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)\n            if (comment >= 0) {\n                let from = line.from + comment, to = from + token.length;\n                if (line.text[to - line.from] == \" \")\n                    to++;\n                changes.push({ from, to });\n            }\n        return { changes };\n    }\n    return null;\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/comment/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/fold/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/fold/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"codeFolding\": () => (/* binding */ codeFolding),\n/* harmony export */   \"foldAll\": () => (/* binding */ foldAll),\n/* harmony export */   \"foldCode\": () => (/* binding */ foldCode),\n/* harmony export */   \"foldEffect\": () => (/* binding */ foldEffect),\n/* harmony export */   \"foldGutter\": () => (/* binding */ foldGutter),\n/* harmony export */   \"foldKeymap\": () => (/* binding */ foldKeymap),\n/* harmony export */   \"foldedRanges\": () => (/* binding */ foldedRanges),\n/* harmony export */   \"unfoldAll\": () => (/* binding */ unfoldAll),\n/* harmony export */   \"unfoldCode\": () => (/* binding */ unfoldCode),\n/* harmony export */   \"unfoldEffect\": () => (/* binding */ unfoldEffect)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_gutter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/gutter */ \"./node_modules/@codemirror/gutter/dist/index.js\");\n/* harmony import */ var _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/rangeset */ \"./node_modules/@codemirror/rangeset/dist/index.js\");\n\n\n\n\n\n\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : { from, to };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstancesusually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#fold.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#fold.foldGutter) create the transactions.)\n*/\nconst foldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({ map: mapRange });\n/**\nState effect that unfolds the given range (if it was folded).\n*/\nconst unfoldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define({ map: mapRange });\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges) {\n        if (lines.some(l => l.from <= head && l.to >= head))\n            continue;\n        lines.push(view.visualLineAt(head));\n    }\n    return lines;\n}\nconst foldState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({\n    create() {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none;\n    },\n    update(folded, tr) {\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects) {\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))\n                folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });\n            else if (e.is(unfoldEffect))\n                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from, filterTo: e.value.to });\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) {\n            let onSelection = false, { head } = tr.selection.main;\n            folded.between(head, head, (a, b) => { if (a < head && b > head)\n                onSelection = true; });\n            if (onSelection)\n                folded = folded.update({\n                    filterFrom: head,\n                    filterTo: head,\n                    filter: (a, b) => b <= head || a >= head\n                });\n        }\n        return folded;\n    },\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(f)\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) containing the folded ranges\nin the given state.\n*/\nfunction foldedRanges(state) {\n    return state.field(foldState, false) || _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\n}\nfunction foldInside(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n        if (!found || found.from > from)\n            found = { from, to };\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b) => { if (a == from && b == to)\n        found = true; });\n    return found;\n}\nfunction maybeEnable(state, other) {\n    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/\nconst foldCode = view => {\n    for (let line of selectedLines(view)) {\n        let range = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldable)(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });\n            return true;\n        }\n    }\n    return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/\nconst unfoldCode = view => {\n    if (!view.state.field(foldState, false))\n        return false;\n    let effects = [];\n    for (let line of selectedLines(view)) {\n        let folded = foldInside(view.state, line.from, line.to);\n        if (folded)\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    }\n    if (effects.length)\n        view.dispatch({ effects });\n    return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges.\n*/\nconst foldAll = view => {\n    let { state } = view, effects = [];\n    for (let pos = 0; pos < state.doc.length;) {\n        let line = view.visualLineAt(pos), range = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldable)(state, line.from, line.to);\n        if (range)\n            effects.push(foldEffect.of(range));\n        pos = (range ? view.visualLineAt(range.to) : line).to + 1;\n    }\n    if (effects.length)\n        view.dispatch({ effects: maybeEnable(view.state, effects) });\n    return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/\nconst unfoldAll = view => {\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size)\n        return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });\n    view.dispatch({ effects });\n    return true;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#fold.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#fold.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#fold.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#fold.unfoldAll).\n*/\nconst foldKeymap = [\n    { key: \"Ctrl-Shift-[\", mac: \"Cmd-Alt-[\", run: foldCode },\n    { key: \"Ctrl-Shift-]\", mac: \"Cmd-Alt-]\", run: unfoldCode },\n    { key: \"Ctrl-Alt-[\", run: foldAll },\n    { key: \"Ctrl-Alt-]\", run: unfoldAll }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    placeholderText: \"\"\n};\nconst foldConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n    combine(values) { return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.combineConfig)(values, defaultConfig); }\n});\n/**\nCreate an extension that configures code folding.\n*/\nfunction codeFolding(config) {\n    let result = [foldState, baseTheme];\n    if (config)\n        result.push(foldConfig.of(config));\n    return result;\n}\nconst foldWidget = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.replace({ widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.WidgetType {\n        ignoreEvents() { return false; }\n        toDOM(view) {\n            let { state } = view, conf = state.facet(foldConfig);\n            if (conf.placeholderDOM)\n                return conf.placeholderDOM();\n            let element = document.createElement(\"span\");\n            element.textContent = conf.placeholderText;\n            element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n            element.title = state.phrase(\"unfold\");\n            element.className = \"cm-foldPlaceholder\";\n            element.onclick = event => {\n                let line = view.visualLineAt(view.posAtDOM(event.target));\n                let folded = foldInside(view.state, line.from, line.to);\n                if (folded)\n                    view.dispatch({ effects: unfoldEffect.of(folded) });\n                event.preventDefault();\n            };\n            return element;\n        }\n    } });\nconst foldGutterDefaults = {\n    openText: \"\",\n    closedText: \"\",\n    markerDOM: null,\n};\nclass FoldMarker extends _codemirror_gutter__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n    constructor(config, open) {\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) { return this.config == other.config && this.open == other.open; }\n    toDOM(view) {\n        if (this.config.markerDOM)\n            return this.config.markerDOM(this.open);\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/\nfunction foldGutter(config = {}) {\n    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.from = view.viewport.from;\n            this.markers = this.buildMarkers(view);\n        }\n        update(update) {\n            if (update.docChanged || update.viewportChanged ||\n                update.startState.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.language) != update.state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.language) ||\n                update.startState.field(foldState, false) != update.state.field(foldState, false))\n                this.markers = this.buildMarkers(update.view);\n        }\n        buildMarkers(view) {\n            let builder = new _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_2__.RangeSetBuilder();\n            view.viewportLines(line => {\n                let mark = foldInside(view.state, line.from, line.to) ? canUnfold\n                    : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldable)(view.state, line.from, line.to) ? canFold : null;\n                if (mark)\n                    builder.add(line.from, line.from, mark);\n            });\n            return builder.finish();\n        }\n    });\n    return [\n        markers,\n        (0,_codemirror_gutter__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n            class: \"cm-foldGutter\",\n            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty; },\n            initialSpacer() {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: {\n                click: (view, line) => {\n                    let folded = foldInside(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({ effects: unfoldEffect.of(folded) });\n                        return true;\n                    }\n                    let range = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldable)(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({ effects: foldEffect.of(range) });\n                        return true;\n                    }\n                    return false;\n                }\n            }\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \".cm-foldGutter .cm-gutterElement\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/fold/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/gutter/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/gutter/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GutterMarker\": () => (/* binding */ GutterMarker),\n/* harmony export */   \"gutter\": () => (/* binding */ gutter),\n/* harmony export */   \"gutterLineClass\": () => (/* binding */ gutterLineClass),\n/* harmony export */   \"gutters\": () => (/* binding */ gutters),\n/* harmony export */   \"highlightActiveLineGutter\": () => (/* binding */ highlightActiveLineGutter),\n/* harmony export */   \"lineNumberMarkers\": () => (/* binding */ lineNumberMarkers),\n/* harmony export */   \"lineNumbers\": () => (/* binding */ lineNumbers)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/rangeset */ \"./node_modules/@codemirror/rangeset/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n\n\n\n\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/\nclass GutterMarker extends _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeValue {\n    /**\n    @internal\n    */\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    Compare this marker to another marker of the same type.\n    */\n    eq(other) { return false; }\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/\nconst gutterLineClass = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst defaults = {\n    class: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: () => _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.empty,\n    lineMarker: () => null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/\nfunction gutter(config) {\n    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-gutters\": {\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        left: 0,\n        zIndex: 200\n    },\n    \"&light .cm-gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#999\",\n        borderRight: \"1px solid #ddd\"\n    },\n    \"&dark .cm-gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    \".cm-gutter\": {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        overflow: \"hidden\"\n    },\n    \".cm-gutterElement\": {\n        boxSizing: \"border-box\"\n    },\n    \".cm-lineNumbers .cm-gutterElement\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    },\n    \"&light .cm-activeLineGutter\": {\n        backgroundColor: \"#e2f2ff\"\n    },\n    \"&dark .cm-activeLineGutter\": {\n        backgroundColor: \"#222227\"\n    }\n});\nconst unfixGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine: values => values.some(x => x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/\nfunction gutters(config) {\n    let result = [\n        gutterView,\n        baseTheme\n    ];\n    if (config && config.fixed === false)\n        result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutters\";\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)\n            this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n        this.syncGutters();\n    }\n    update(update) {\n        if (this.updateGutters(update))\n            this.syncGutters();\n    }\n    syncGutters() {\n        let lineClasses = _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n        let classSet = [];\n        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport));\n        this.view.viewportLines(line => {\n            let text;\n            if (Array.isArray(line.type)) {\n                for (let b of line.type)\n                    if (b.type == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.BlockType.Text) {\n                        text = b;\n                        break;\n                    }\n            }\n            else {\n                text = line.type == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.BlockType.Text ? line : undefined;\n            }\n            if (!text)\n                return;\n            if (classSet.length)\n                classSet = [];\n            advanceCursor(lineClasses, classSet, line.from);\n            for (let cx of contexts)\n                cx.line(this.view, text, classSet);\n        }, 0);\n        for (let cx of contexts)\n            cx.finish();\n        this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        if (this.view.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n    }\n    updateGutters(update) {\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged ||\n            !_codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n        if (prev == cur) {\n            for (let gutter of this.gutters)\n                if (gutter.update(update))\n                    change = true;\n        }\n        else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur) {\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                }\n                else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters)\n                g.dom.remove();\n            for (let g of gutters)\n                this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        this.dom.remove();\n    }\n}, {\n    provide: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.PluginField.scrollMargins.from(value => {\n        if (value.gutters.length == 0 || !value.fixed)\n            return null;\n        return value.view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };\n    })\n});\nfunction asArray(val) { return (Array.isArray(val) ? val : [val]); }\nfunction advanceCursor(cursor, collect, pos) {\n    while (cursor.value && cursor.from <= pos) {\n        if (cursor.from == pos)\n            collect.push(cursor.value);\n        cursor.next();\n    }\n}\nclass UpdateContext {\n    constructor(gutter, viewport) {\n        this.gutter = gutter;\n        this.localMarkers = [];\n        this.i = 0;\n        this.height = 0;\n        this.cursor = _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.iter(gutter.markers, viewport.from);\n    }\n    line(view, line, extraMarkers) {\n        if (this.localMarkers.length)\n            this.localMarkers = [];\n        advanceCursor(this.cursor, this.localMarkers, line.from);\n        let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;\n        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n        if (forLine)\n            localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)\n            return;\n        let above = line.top - this.height;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, line.height, above, localMarkers);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        }\n        else {\n            let elt = gutter.elements[this.i];\n            if (sameMarkers(localMarkers, elt.markers))\n                localMarkers = elt.markers;\n            elt.update(view, line.height, above, localMarkers);\n        }\n        this.height = line.bottom;\n        this.i++;\n    }\n    finish() {\n        let gutter = this.gutter;\n        while (gutter.elements.length > this.i)\n            gutter.dom.removeChild(gutter.elements.pop().dom);\n    }\n}\nclass SingleGutterView {\n    constructor(view, config) {\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n        for (let prop in config.domEventHandlers) {\n            this.dom.addEventListener(prop, (event) => {\n                let line = view.visualLineAtHeight(event.clientY, view.contentDOM.getBoundingClientRect().top);\n                if (config.domEventHandlers[prop](view, line, event))\n                    event.preventDefault();\n            });\n        }\n        this.markers = asArray(config.markers(view));\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = asArray(this.config.markers(update.view));\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0])\n                this.spacer.update(update.view, 0, 0, [updated]);\n        }\n        let vp = update.view.viewport;\n        return !_codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to);\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers) {\n        this.height = -1;\n        this.above = 0;\n        this.dom = document.createElement(\"div\");\n        this.update(view, height, above, markers);\n    }\n    update(view, height, above, markers) {\n        if (this.height != height)\n            this.dom.style.height = (this.height = height) + \"px\";\n        if (this.above != above)\n            this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (this.markers != markers) {\n            this.markers = markers;\n            for (let ch; ch = this.dom.lastChild;)\n                ch.remove();\n            let cls = \"cm-gutterElement\";\n            for (let m of markers) {\n                if (m.toDOM)\n                    this.dom.appendChild(m.toDOM(view));\n                let c = m.elementClass;\n                if (c)\n                    cls += \" \" + c;\n            }\n            this.dom.className = cls;\n        }\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].compare(b[i]))\n            return false;\n    return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/\nconst lineNumberMarkers = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst lineNumberConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine(values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(values, { formatNumber: String, domEventHandlers: {} }, {\n            domEventHandlers(a, b) {\n                let result = Object.assign({}, a);\n                for (let event in b) {\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number) {\n        super();\n        this.number = number;\n    }\n    eq(other) { return this.number == other.number; }\n    toDOM(_view) { return document.createTextNode(this.number); }\n}\nfunction formatNumber(view, number) {\n    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({\n    class: \"cm-lineNumbers\",\n    renderEmptyElements: false,\n    markers(view) { return view.state.facet(lineNumberMarkers); },\n    lineMarker(view, line, others) {\n        if (others.some(m => m.toDOM))\n            return null;\n        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n    },\n    initialSpacer(view) {\n        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n    },\n    updateSpacer(spacer, update) {\n        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n        return max == spacer.number ? spacer : new NumberMarker(max);\n    },\n    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n}));\n/**\nCreate a line number gutter extension.\n*/\nfunction lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        gutters(),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while (last < lines)\n        last = last * 10 + 9;\n    return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {\n    constructor() {\n        super(...arguments);\n        this.elementClass = \"cm-activeLineGutter\";\n    }\n};\nconst activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute([\"selection\"], state => {\n    let marks = [], last = -1;\n    for (let range of state.selection.ranges)\n        if (range.empty) {\n            let linePos = state.doc.lineAt(range.head).from;\n            if (linePos > last) {\n                last = linePos;\n                marks.push(activeLineGutterMarker.range(linePos));\n            }\n        }\n    return _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_0__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/\nfunction highlightActiveLineGutter() {\n    return activeLineGutterHighlighter;\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/gutter/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/highlight/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@codemirror/highlight/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HighlightStyle\": () => (/* binding */ HighlightStyle),\n/* harmony export */   \"Tag\": () => (/* binding */ Tag),\n/* harmony export */   \"classHighlightStyle\": () => (/* binding */ classHighlightStyle),\n/* harmony export */   \"defaultHighlightStyle\": () => (/* binding */ defaultHighlightStyle),\n/* harmony export */   \"highlightTree\": () => (/* binding */ highlightTree),\n/* harmony export */   \"styleTags\": () => (/* binding */ styleTags),\n/* harmony export */   \"tags\": () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/rangeset */ \"./node_modules/@codemirror/rangeset/dist/index.js\");\n\n\n\n\n\n\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](https://codemirror.net/6/docs/ref/#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlight style](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](https://codemirror.net/6/docs/ref/#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](https://codemirror.net/6/docs/ref/#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/\nclass Tag {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The set of tags that match this tag, starting with this one\n    itself, sorted in order of decreasing specificity. @internal\n    */\n    set, \n    /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */\n    base, \n    /**\n    The modifiers applied to this.base @internal\n    */\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */\n        this.id = nextTagID++;\n    }\n    /**\n    Define a new tag. If `parent` is given, the tag is treated as a\n    sub-tag of that parent, and [highlight\n    styles](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle) that don't mention this tag\n    will try to fall back to the parent tag (or grandparent tag,\n    etc).\n    */\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = permute(mods);\n        for (let parent of base.set)\n            for (let config of configs)\n                set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction permute(array) {\n    let result = [array];\n    for (let i = 0; i < array.length; i++) {\n        for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))\n            result.push(a);\n    }\n    return result;\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia\n[`LRParser.configure`](https://lezer.codemirror.net/docs/ref#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](https://codemirror.net/6/docs/ref/#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node\nname](https://lezer.codemirror.net/docs/ref#common.NodeType.name),\nor multiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single levelwildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? null : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nconst highlightStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(stylings) { return stylings.length ? HighlightStyle.combinedMatch(stylings) : null; }\n});\nconst fallbackHighlightStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(values) { return values.length ? values[0].match : null; }\n});\nfunction getHighlightStyle(state) {\n    return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle);\n}\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://codemirror.net/6/docs/ref/#highlight.Tag).\n*/\nclass HighlightStyle {\n    constructor(spec, options) {\n        this.map = Object.create(null);\n        let modSpec;\n        function def(spec) {\n            let cls = style_mod__WEBPACK_IMPORTED_MODULE_1__.StyleModule.newName();\n            (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n            return cls;\n        }\n        this.all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : null;\n        for (let style of spec) {\n            let cls = (style.class || def(Object.assign({}, style, { tag: null }))) +\n                (this.all ? \" \" + this.all : \"\");\n            let tags = style.tag;\n            if (!Array.isArray(tags))\n                this.map[tags.id] = cls;\n            else\n                for (let tag of tags)\n                    this.map[tag.id] = cls;\n        }\n        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_1__.StyleModule(modSpec) : null;\n        this.scope = options.scope || null;\n        this.match = this.match.bind(this);\n        let ext = [treeHighlighter];\n        if (this.module)\n            ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.EditorView.styleModule.of(this.module));\n        this.extension = ext.concat(highlightStyle.of(this));\n        this.fallback = ext.concat(fallbackHighlightStyle.of(this));\n    }\n    /**\n    Returns the CSS class associated with the given tag, if any.\n    This method is bound to the instance by the constructor.\n    */\n    match(tag, scope) {\n        if (this.scope && scope != this.scope)\n            return null;\n        for (let t of tag.set) {\n            let match = this.map[t.id];\n            if (match !== undefined) {\n                if (t != tag)\n                    this.map[tag.id] = match;\n                return match;\n            }\n        }\n        return this.map[tag.id] = this.all;\n    }\n    /**\n    Combines an array of highlight styles into a single match\n    function that returns all of the classes assigned by the styles\n    for a given tag.\n    */\n    static combinedMatch(styles) {\n        if (styles.length == 1)\n            return styles[0].match;\n        let cache = styles.some(s => s.scope) ? undefined : Object.create(null);\n        return (tag, scope) => {\n            let cached = cache && cache[tag.id];\n            if (cached !== undefined)\n                return cached;\n            let result = null;\n            for (let style of styles) {\n                let value = style.match(tag, scope);\n                if (value)\n                    result = result ? result + \" \" + value : value;\n            }\n            if (cache)\n                cache[tag.id] = result;\n            return result;\n        };\n    }\n    /**\n    Create a highlighter style that associates the given styles to\n    the given tags. The spec must be objects that hold a style tag\n    or array of tags in their `tag` property, and either a single\n    `class` property providing a static CSS class (for highlighters\n    like [`classHighlightStyle`](https://codemirror.net/6/docs/ref/#highlight.classHighlightStyle)\n    that rely on external styling), or a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    set of CSS properties (which define the styling for those tags).\n    \n    The CSS rules created for a highlighter will be emitted in the\n    order of the spec's properties. That means that for elements that\n    have multiple tags associated with them, styles defined further\n    down in the list will have a higher CSS precedence than styles\n    defined earlier.\n    */\n    static define(specs, options) {\n        return new HighlightStyle(specs, options || {});\n    }\n    /**\n    Returns the CSS classes (if any) that the highlight styles\n    active in the given state would assign to the given a style\n    [tag](https://codemirror.net/6/docs/ref/#highlight.Tag) and (optional) language\n    [scope](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle^define^options.scope).\n    */\n    static get(state, tag, scope) {\n        let style = getHighlightStyle(state);\n        return style && style(tag, scope || _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none);\n    }\n}\n/**\nRun the tree highlighter over the given tree.\n*/\nfunction highlightTree(tree, \n/**\nGet the CSS classes used to style a given [tag](https://codemirror.net/6/docs/ref/#highlight.Tag),\nor `null` if it isn't styled. (You'll often want to pass a\nhighlight style's [`match`](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle.match)\nmethod here.)\n*/\ngetStyle, \n/**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/\nputStyle, \n/**\nThe start of the range to highlight.\n*/\nfrom = 0, \n/**\nThe end of the range.\n*/\nto = tree.length) {\n    highlightTreeRange(tree, from, to, getStyle, putStyle);\n}\nclass TreeHighlighter {\n    constructor(view) {\n        this.markCache = Object.create(null);\n        this.tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_4__.syntaxTree)(view.state);\n        this.decorations = this.buildDeco(view, getHighlightStyle(view.state));\n    }\n    update(update) {\n        let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_4__.syntaxTree)(update.state), style = getHighlightStyle(update.state);\n        let styleChange = style != update.startState.facet(highlightStyle);\n        if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {\n            this.decorations = this.decorations.map(update.changes);\n        }\n        else if (tree != this.tree || update.viewportChanged || styleChange) {\n            this.tree = tree;\n            this.decorations = this.buildDeco(update.view, style);\n        }\n    }\n    buildDeco(view, match) {\n        if (!match || !this.tree.length)\n            return _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.none;\n        let builder = new _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_5__.RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges) {\n            highlightTreeRange(this.tree, from, to, match, (from, to, style) => {\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.mark({ class: style })));\n            });\n        }\n        return builder.finish();\n    }\n}\n// This extension installs a highlighter that highlights based on the\n// syntax tree and highlight style.\nconst treeHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.extend(/*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_3__.ViewPlugin.fromClass(TreeHighlighter, {\n    decorations: v => v.decorations\n}));\nconst nodeStack = [\"\"];\nclass HighlightBuilder {\n    constructor(at, style, span) {\n        this.at = at;\n        this.style = style;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, depth, scope) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        nodeStack[depth] = type.name;\n        if (type.isTop)\n            scope = type;\n        let cls = inheritedClass;\n        let rule = type.prop(ruleNodeProp), opaque = false;\n        while (rule) {\n            if (!rule.context || matchContext(rule.context, nodeStack, depth)) {\n                for (let tag of rule.tags) {\n                    let st = this.style(tag, scope);\n                    if (st) {\n                        if (cls)\n                            cls += \" \";\n                        cls += st;\n                        if (rule.mode == 1 /* Inherit */)\n                            inheritedClass += (inheritedClass ? \" \" : \"\") + st;\n                        else if (rule.mode == 0 /* Opaque */)\n                            opaque = true;\n                    }\n                }\n                break;\n            }\n            rule = rule.next;\n        }\n        this.startSpan(cursor.from, cls);\n        if (opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, depth + 1, scope);\n                        this.startSpan(Math.min(to, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor, Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, depth, mounted.tree.type);\n                    this.startSpan(pos, cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, depth + 1, scope);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\nfunction highlightTreeRange(tree, from, to, style, span) {\n    let builder = new HighlightBuilder(from, style, span);\n    builder.highlightRange(tree.cursor(), from, to, \"\", 0, tree.type);\n    builder.flush(to);\n}\nfunction matchContext(context, stack, depth) {\n    if (context.length > depth - 1)\n        return false;\n    for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {\n        let check = context[i];\n        if (check && check != stack[d])\n            return false;\n    }\n    return true;\n}\nconst t = Tag.define;\nconst comment = /*@__PURE__*/t(), name = /*@__PURE__*/t(), typeName = /*@__PURE__*/t(name), propertyName = /*@__PURE__*/t(name), literal = /*@__PURE__*/t(), string = /*@__PURE__*/t(literal), number = /*@__PURE__*/t(literal), content = /*@__PURE__*/t(), heading = /*@__PURE__*/t(content), keyword = /*@__PURE__*/t(), operator = /*@__PURE__*/t(), punctuation = /*@__PURE__*/t(), bracket = /*@__PURE__*/t(punctuation), meta = /*@__PURE__*/t();\n/**\nThe default set of highlighting [tags](https://codemirror.net/6/docs/ref/#highlight.Tag^define) used\nby regular language packages and themes.\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](https://codemirror.net/6/docs/ref/#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an elementif your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/\nconst tags = {\n    /**\n    A comment.\n    */\n    comment,\n    /**\n    A line [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).\n    */\n    lineComment: /*@__PURE__*/t(comment),\n    /**\n    A block [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).\n    */\n    blockComment: /*@__PURE__*/t(comment),\n    /**\n    A documentation [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).\n    */\n    docComment: /*@__PURE__*/t(comment),\n    /**\n    Any kind of identifier.\n    */\n    name,\n    /**\n    The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a variable.\n    */\n    variableName: /*@__PURE__*/t(name),\n    /**\n    A type [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n    */\n    typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](https://codemirror.net/6/docs/ref/#highlight.tags.typeName)).\n    */\n    tagName: /*@__PURE__*/t(typeName),\n    /**\n    A property or field [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n    */\n    propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)).\n    */\n    attributeName: /*@__PURE__*/t(propertyName),\n    /**\n    The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a class.\n    */\n    className: /*@__PURE__*/t(name),\n    /**\n    A label [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n    */\n    labelName: /*@__PURE__*/t(name),\n    /**\n    A namespace [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).\n    */\n    namespace: /*@__PURE__*/t(name),\n    /**\n    The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a macro.\n    */\n    macroName: /*@__PURE__*/t(name),\n    /**\n    A literal value.\n    */\n    literal,\n    /**\n    A string [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n    */\n    string,\n    /**\n    A documentation [string](https://codemirror.net/6/docs/ref/#highlight.tags.string).\n    */\n    docString: /*@__PURE__*/t(string),\n    /**\n    A character literal (subtag of [string](https://codemirror.net/6/docs/ref/#highlight.tags.string)).\n    */\n    character: /*@__PURE__*/t(string),\n    /**\n    An attribute value (subtag of [string](https://codemirror.net/6/docs/ref/#highlight.tags.string)).\n    */\n    attributeValue: /*@__PURE__*/t(string),\n    /**\n    A number [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n    */\n    number,\n    /**\n    An integer [number](https://codemirror.net/6/docs/ref/#highlight.tags.number) literal.\n    */\n    integer: /*@__PURE__*/t(number),\n    /**\n    A floating-point [number](https://codemirror.net/6/docs/ref/#highlight.tags.number) literal.\n    */\n    float: /*@__PURE__*/t(number),\n    /**\n    A boolean [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n    */\n    bool: /*@__PURE__*/t(literal),\n    /**\n    Regular expression [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n    */\n    regexp: /*@__PURE__*/t(literal),\n    /**\n    An escape [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */\n    escape: /*@__PURE__*/t(literal),\n    /**\n    A color [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n    */\n    color: /*@__PURE__*/t(literal),\n    /**\n    A URL [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).\n    */\n    url: /*@__PURE__*/t(literal),\n    /**\n    A language keyword.\n    */\n    keyword,\n    /**\n    The [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) for the self or this\n    object.\n    */\n    self: /*@__PURE__*/t(keyword),\n    /**\n    The [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) for null.\n    */\n    null: /*@__PURE__*/t(keyword),\n    /**\n    A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) denoting some atomic value.\n    */\n    atom: /*@__PURE__*/t(keyword),\n    /**\n    A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that represents a unit.\n    */\n    unit: /*@__PURE__*/t(keyword),\n    /**\n    A modifier [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword).\n    */\n    modifier: /*@__PURE__*/t(keyword),\n    /**\n    A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that acts as an operator.\n    */\n    operatorKeyword: /*@__PURE__*/t(keyword),\n    /**\n    A control-flow related [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword).\n    */\n    controlKeyword: /*@__PURE__*/t(keyword),\n    /**\n    A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that defines something.\n    */\n    definitionKeyword: /*@__PURE__*/t(keyword),\n    /**\n    An operator.\n    */\n    operator,\n    /**\n    An [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that defines something.\n    */\n    derefOperator: /*@__PURE__*/t(operator),\n    /**\n    Arithmetic-related [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n    */\n    arithmeticOperator: /*@__PURE__*/t(operator),\n    /**\n    Logical [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n    */\n    logicOperator: /*@__PURE__*/t(operator),\n    /**\n    Bit [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n    */\n    bitwiseOperator: /*@__PURE__*/t(operator),\n    /**\n    Comparison [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n    */\n    compareOperator: /*@__PURE__*/t(operator),\n    /**\n    [Operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that updates its operand.\n    */\n    updateOperator: /*@__PURE__*/t(operator),\n    /**\n    [Operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that defines something.\n    */\n    definitionOperator: /*@__PURE__*/t(operator),\n    /**\n    Type-related [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n    */\n    typeOperator: /*@__PURE__*/t(operator),\n    /**\n    Control-flow [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).\n    */\n    controlOperator: /*@__PURE__*/t(operator),\n    /**\n    Program or markup punctuation.\n    */\n    punctuation,\n    /**\n    [Punctuation](https://codemirror.net/6/docs/ref/#highlight.tags.punctuation) that separates\n    things.\n    */\n    separator: /*@__PURE__*/t(punctuation),\n    /**\n    Bracket-style [punctuation](https://codemirror.net/6/docs/ref/#highlight.tags.punctuation).\n    */\n    bracket,\n    /**\n    Angle [brackets](https://codemirror.net/6/docs/ref/#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */\n    angleBracket: /*@__PURE__*/t(bracket),\n    /**\n    Square [brackets](https://codemirror.net/6/docs/ref/#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */\n    squareBracket: /*@__PURE__*/t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](https://codemirror.net/6/docs/ref/#highlight.tags.bracket).\n    */\n    paren: /*@__PURE__*/t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](https://codemirror.net/6/docs/ref/#highlight.tags.bracket).\n    */\n    brace: /*@__PURE__*/t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */\n    content,\n    /**\n    [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a heading.\n    */\n    heading,\n    /**\n    A level 1 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n    */\n    heading1: /*@__PURE__*/t(heading),\n    /**\n    A level 2 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n    */\n    heading2: /*@__PURE__*/t(heading),\n    /**\n    A level 3 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n    */\n    heading3: /*@__PURE__*/t(heading),\n    /**\n    A level 4 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n    */\n    heading4: /*@__PURE__*/t(heading),\n    /**\n    A level 5 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n    */\n    heading5: /*@__PURE__*/t(heading),\n    /**\n    A level 6 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).\n    */\n    heading6: /*@__PURE__*/t(heading),\n    /**\n    A prose separator (such as a horizontal rule).\n    */\n    contentSeparator: /*@__PURE__*/t(content),\n    /**\n    [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a list.\n    */\n    list: /*@__PURE__*/t(content),\n    /**\n    [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a quote.\n    */\n    quote: /*@__PURE__*/t(content),\n    /**\n    [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is emphasized.\n    */\n    emphasis: /*@__PURE__*/t(content),\n    /**\n    [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is styled strong.\n    */\n    strong: /*@__PURE__*/t(content),\n    /**\n    [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is part of a link.\n    */\n    link: /*@__PURE__*/t(content),\n    /**\n    [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is styled as code or\n    monospace.\n    */\n    monospace: /*@__PURE__*/t(content),\n    /**\n    [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that has a strike-through\n    style.\n    */\n    strikethrough: /*@__PURE__*/t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */\n    inserted: /*@__PURE__*/t(),\n    /**\n    Deleted text.\n    */\n    deleted: /*@__PURE__*/t(),\n    /**\n    Changed text.\n    */\n    changed: /*@__PURE__*/t(),\n    /**\n    An invalid or unsyntactic element.\n    */\n    invalid: /*@__PURE__*/t(),\n    /**\n    Metadata or meta-instruction.\n    */\n    meta,\n    /**\n    [Metadata](https://codemirror.net/6/docs/ref/#highlight.tags.meta) that applies to the entire\n    document.\n    */\n    documentMeta: /*@__PURE__*/t(meta),\n    /**\n    [Metadata](https://codemirror.net/6/docs/ref/#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */\n    annotation: /*@__PURE__*/t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](https://codemirror.net/6/docs/ref/#highlight.tags.meta).\n    */\n    processingInstruction: /*@__PURE__*/t(meta),\n    /**\n    [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) tags.\n    */\n    definition: /*@__PURE__*/Tag.defineModifier(),\n    /**\n    [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](https://codemirror.net/6/docs/ref/#highlight.tags.variableName).\n    */\n    constant: /*@__PURE__*/Tag.defineModifier(),\n    /**\n    [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) used to indicate that\n    a [variable](https://codemirror.net/6/docs/ref/#highlight.tags.variableName) or [property\n    name](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */\n    function: /*@__PURE__*/Tag.defineModifier(),\n    /**\n    [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that can be applied to\n    [names](https://codemirror.net/6/docs/ref/#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */\n    standard: /*@__PURE__*/Tag.defineModifier(),\n    /**\n    [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates a given\n    [names](https://codemirror.net/6/docs/ref/#highlight.tags.name) is local to some scope.\n    */\n    local: /*@__PURE__*/Tag.defineModifier(),\n    /**\n    A generic variant [modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](https://codemirror.net/6/docs/ref/#highlight.tags.string) and\n    [variable name](https://codemirror.net/6/docs/ref/#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */\n    special: /*@__PURE__*/Tag.defineModifier()\n};\n/**\nA default highlight style (works well with light themes).\n*/\nconst defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([\n    { tag: tags.link,\n        textDecoration: \"underline\" },\n    { tag: tags.heading,\n        textDecoration: \"underline\",\n        fontWeight: \"bold\" },\n    { tag: tags.emphasis,\n        fontStyle: \"italic\" },\n    { tag: tags.strong,\n        fontWeight: \"bold\" },\n    { tag: tags.strikethrough,\n        textDecoration: \"line-through\" },\n    { tag: tags.keyword,\n        color: \"#708\" },\n    { tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],\n        color: \"#219\" },\n    { tag: [tags.literal, tags.inserted],\n        color: \"#164\" },\n    { tag: [tags.string, tags.deleted],\n        color: \"#a11\" },\n    { tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)],\n        color: \"#e40\" },\n    { tag: /*@__PURE__*/tags.definition(tags.variableName),\n        color: \"#00f\" },\n    { tag: /*@__PURE__*/tags.local(tags.variableName),\n        color: \"#30a\" },\n    { tag: [tags.typeName, tags.namespace],\n        color: \"#085\" },\n    { tag: tags.className,\n        color: \"#167\" },\n    { tag: [/*@__PURE__*/tags.special(tags.variableName), tags.macroName],\n        color: \"#256\" },\n    { tag: /*@__PURE__*/tags.definition(tags.propertyName),\n        color: \"#00c\" },\n    { tag: tags.comment,\n        color: \"#940\" },\n    { tag: tags.meta,\n        color: \"#7a757a\" },\n    { tag: tags.invalid,\n        color: \"#f00\" }\n]);\n/**\nThis is a highlight style that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThese tags are mapped to their name prefixed with `\"cmt-\"` (for\nexample `\"cmt-comment\"`):\n\n* [`link`](https://codemirror.net/6/docs/ref/#highlight.tags.link)\n* [`heading`](https://codemirror.net/6/docs/ref/#highlight.tags.heading)\n* [`emphasis`](https://codemirror.net/6/docs/ref/#highlight.tags.emphasis)\n* [`strong`](https://codemirror.net/6/docs/ref/#highlight.tags.strong)\n* [`keyword`](https://codemirror.net/6/docs/ref/#highlight.tags.keyword)\n* [`atom`](https://codemirror.net/6/docs/ref/#highlight.tags.atom) [`bool`](https://codemirror.net/6/docs/ref/#highlight.tags.bool)\n* [`url`](https://codemirror.net/6/docs/ref/#highlight.tags.url)\n* [`labelName`](https://codemirror.net/6/docs/ref/#highlight.tags.labelName)\n* [`inserted`](https://codemirror.net/6/docs/ref/#highlight.tags.inserted)\n* [`deleted`](https://codemirror.net/6/docs/ref/#highlight.tags.deleted)\n* [`literal`](https://codemirror.net/6/docs/ref/#highlight.tags.literal)\n* [`string`](https://codemirror.net/6/docs/ref/#highlight.tags.string)\n* [`number`](https://codemirror.net/6/docs/ref/#highlight.tags.number)\n* [`variableName`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n* [`typeName`](https://codemirror.net/6/docs/ref/#highlight.tags.typeName)\n* [`namespace`](https://codemirror.net/6/docs/ref/#highlight.tags.namespace)\n* [`macroName`](https://codemirror.net/6/docs/ref/#highlight.tags.macroName)\n* [`propertyName`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)\n* [`operator`](https://codemirror.net/6/docs/ref/#highlight.tags.operator)\n* [`comment`](https://codemirror.net/6/docs/ref/#highlight.tags.comment)\n* [`meta`](https://codemirror.net/6/docs/ref/#highlight.tags.meta)\n* [`punctuation`](https://codemirror.net/6/docs/ref/#highlight.tags.puncutation)\n* [`invalid`](https://codemirror.net/6/docs/ref/#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](https://codemirror.net/6/docs/ref/#highlight.tags.regexp),\n  [`escape`](https://codemirror.net/6/docs/ref/#highlight.tags.escape), and\n  [`special`](https://codemirror.net/6/docs/ref/#highlight.tags.special)[`(string)`](https://codemirror.net/6/docs/ref/#highlight.tags.string)\n  are mapped to `\"cmt-string2\"`\n* [`special`](https://codemirror.net/6/docs/ref/#highlight.tags.special)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n  to `\"cmt-variableName2\"`\n* [`local`](https://codemirror.net/6/docs/ref/#highlight.tags.local)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n  to `\"cmt-variableName cmt-local\"`\n* [`definition`](https://codemirror.net/6/docs/ref/#highlight.tags.definition)[`(variableName)`](https://codemirror.net/6/docs/ref/#highlight.tags.variableName)\n  to `\"cmt-variableName cmt-definition\"`\n*/\nconst classHighlightStyle = /*@__PURE__*/HighlightStyle.define([\n    { tag: tags.link, class: \"cmt-link\" },\n    { tag: tags.heading, class: \"cmt-heading\" },\n    { tag: tags.emphasis, class: \"cmt-emphasis\" },\n    { tag: tags.strong, class: \"cmt-strong\" },\n    { tag: tags.keyword, class: \"cmt-keyword\" },\n    { tag: tags.atom, class: \"cmt-atom\" },\n    { tag: tags.bool, class: \"cmt-bool\" },\n    { tag: tags.url, class: \"cmt-url\" },\n    { tag: tags.labelName, class: \"cmt-labelName\" },\n    { tag: tags.inserted, class: \"cmt-inserted\" },\n    { tag: tags.deleted, class: \"cmt-deleted\" },\n    { tag: tags.literal, class: \"cmt-literal\" },\n    { tag: tags.string, class: \"cmt-string\" },\n    { tag: tags.number, class: \"cmt-number\" },\n    { tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)], class: \"cmt-string2\" },\n    { tag: tags.variableName, class: \"cmt-variableName\" },\n    { tag: /*@__PURE__*/tags.local(tags.variableName), class: \"cmt-variableName cmt-local\" },\n    { tag: /*@__PURE__*/tags.definition(tags.variableName), class: \"cmt-variableName cmt-definition\" },\n    { tag: /*@__PURE__*/tags.special(tags.variableName), class: \"cmt-variableName2\" },\n    { tag: tags.typeName, class: \"cmt-typeName\" },\n    { tag: tags.namespace, class: \"cmt-namespace\" },\n    { tag: tags.macroName, class: \"cmt-macroName\" },\n    { tag: tags.propertyName, class: \"cmt-propertyName\" },\n    { tag: tags.operator, class: \"cmt-operator\" },\n    { tag: tags.comment, class: \"cmt-comment\" },\n    { tag: tags.meta, class: \"cmt-meta\" },\n    { tag: tags.invalid, class: \"cmt-invalid\" },\n    { tag: tags.punctuation, class: \"cmt-punctuation\" }\n]);\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/highlight/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/history/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@codemirror/history/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"history\": () => (/* binding */ history),\n/* harmony export */   \"historyField\": () => (/* binding */ historyField),\n/* harmony export */   \"historyKeymap\": () => (/* binding */ historyKeymap),\n/* harmony export */   \"invertedEffects\": () => (/* binding */ invertedEffects),\n/* harmony export */   \"isolateHistory\": () => (/* binding */ isolateHistory),\n/* harmony export */   \"redo\": () => (/* binding */ redo),\n/* harmony export */   \"redoDepth\": () => (/* binding */ redoDepth),\n/* harmony export */   \"redoSelection\": () => (/* binding */ redoSelection),\n/* harmony export */   \"undo\": () => (/* binding */ undo),\n/* harmony export */   \"undoDepth\": () => (/* binding */ undoDepth),\n/* harmony export */   \"undoSelection\": () => (/* binding */ undoSelection)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n\n\n\nconst fromHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\nconst isolateHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\nconst invertedEffects = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();\nconst historyConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n    combine(configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.combineConfig)(configs, {\n            minDepth: 100,\n            newGroupDelay: 500\n        }, { minDepth: Math.max, newGroupDelay: Math.min });\n    }\n});\nconst historyField_ = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({\n    create() {\n        return HistoryState.empty;\n    },\n    update(state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr), from = fromHist.side;\n            let other = from == 0 /* Done */ ? state.undone : state.done;\n            if (item)\n                other = updateBranch(other, other.length, config.minDepth, item);\n            else\n                other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* Done */ ? fromHist.rest : other, from == 0 /* Done */ ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\")\n            state = state.isolate();\n        if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction.addToHistory) === false)\n            return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction.time), userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction.userEvent);\n        if (event)\n            state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);\n        else if (tr.selection)\n            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\")\n            state = state.isolate();\n        return state;\n    },\n    toJSON(value) {\n        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };\n    },\n    fromJSON(json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/\nfunction history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.domEventHandlers({\n            beforeinput(e, view) {\n                if (e.inputType == \"historyUndo\")\n                    return undo(view);\n                if (e.inputType == \"historyRedo\")\n                    return redo(view);\n                return false;\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\nconst historyField = historyField_;\nfunction cmd(side, selection) {\n    return function ({ state, dispatch }) {\n        let historyState = state.field(historyField_, false);\n        if (!historyState)\n            return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr)\n            return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\nconst undo = /*@__PURE__*/cmd(0 /* Done */, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\nconst redo = /*@__PURE__*/cmd(1 /* Undone */, false);\n/**\nUndo a selection change.\n*/\nconst undoSelection = /*@__PURE__*/cmd(0 /* Done */, true);\n/**\nRedo a selection change.\n*/\nconst redoSelection = /*@__PURE__*/cmd(1 /* Undone */, true);\nfunction depth(side) {\n    return function (state) {\n        let histState = state.field(historyField_, false);\n        if (!histState)\n            return 0;\n        let branch = side == 0 /* Done */ ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\nconst undoDepth = /*@__PURE__*/depth(0 /* Done */);\n/**\nThe amount of redoable change events available in a given state.\n*/\nconst redoDepth = /*@__PURE__*/depth(1 /* Undone */);\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(\n    // The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, \n    // The effects associated with this event\n    effects, mapped, \n    // The selection before this event\n    startSelection, \n    // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter) {\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)) {\n            let result = invert(tr);\n            if (result.length)\n                effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty)\n            return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t) => ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t) => {\n        for (let i = 0; i < ranges.length;) {\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to)\n                isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length &&\n        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [HistEvent.selection([selection])];\n    }\n    else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection))\n            return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length)\n        return branch;\n    let length = branch.length, selections = none;\n    while (length) {\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        }\n        else { // Drop this event, since there's no changes or effects left\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [HistEvent.selection(selections)] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes)\n        return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, newGroupDelay, maxLen) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&\n            ((!lastEvent.selectionsAfter.length &&\n                time - this.prevTime < newGroupDelay &&\n                isAdjacent(lastEvent.changes, event.changes)) ||\n                // For compose (but not compose.start) events, always join with previous event\n                userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        }\n        else {\n            done = updateBranch(done, done.length, maxLen, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 &&\n            time - this.prevTime < newGroupDelay &&\n            userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) &&\n            eqSelectionShape(last[last.length - 1], selection))\n            return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, selection) {\n        let branch = side == 0 /* Done */ ? this.done : this.undone;\n        if (branch.length == 0)\n            return null;\n        let event = branch[branch.length - 1];\n        if (selection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({ side, rest: popSelection(branch) }),\n                userEvent: side == 0 /* Done */ ? \"select.undo\" : \"select.redo\"\n            });\n        }\n        else if (!event.changes) {\n            return null;\n        }\n        else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped)\n                rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({ side, rest }),\n                filter: false,\n                userEvent: side == 0 /* Done */ ? \"undo\" : \"redo\"\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#history.undo).\n- Mod-y (Mod-Shift-z on macOS): [`redo`](https://codemirror.net/6/docs/ref/#history.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#history.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#history.redoSelection).\n*/\nconst historyKeymap = [\n    { key: \"Mod-z\", run: undo, preventDefault: true },\n    { key: \"Mod-y\", mac: \"Mod-Shift-z\", run: redo, preventDefault: true },\n    { key: \"Mod-u\", run: undoSelection, preventDefault: true },\n    { key: \"Alt-u\", mac: \"Mod-Shift-u\", run: redoSelection, preventDefault: true }\n];\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/history/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IndentContext\": () => (/* binding */ IndentContext),\n/* harmony export */   \"LRLanguage\": () => (/* binding */ LRLanguage),\n/* harmony export */   \"Language\": () => (/* binding */ Language),\n/* harmony export */   \"LanguageDescription\": () => (/* binding */ LanguageDescription),\n/* harmony export */   \"LanguageSupport\": () => (/* binding */ LanguageSupport),\n/* harmony export */   \"ParseContext\": () => (/* binding */ ParseContext),\n/* harmony export */   \"TreeIndentContext\": () => (/* binding */ TreeIndentContext),\n/* harmony export */   \"continuedIndent\": () => (/* binding */ continuedIndent),\n/* harmony export */   \"defineLanguageFacet\": () => (/* binding */ defineLanguageFacet),\n/* harmony export */   \"delimitedIndent\": () => (/* binding */ delimitedIndent),\n/* harmony export */   \"ensureSyntaxTree\": () => (/* binding */ ensureSyntaxTree),\n/* harmony export */   \"flatIndent\": () => (/* binding */ flatIndent),\n/* harmony export */   \"foldInside\": () => (/* binding */ foldInside),\n/* harmony export */   \"foldNodeProp\": () => (/* binding */ foldNodeProp),\n/* harmony export */   \"foldService\": () => (/* binding */ foldService),\n/* harmony export */   \"foldable\": () => (/* binding */ foldable),\n/* harmony export */   \"getIndentUnit\": () => (/* binding */ getIndentUnit),\n/* harmony export */   \"getIndentation\": () => (/* binding */ getIndentation),\n/* harmony export */   \"indentNodeProp\": () => (/* binding */ indentNodeProp),\n/* harmony export */   \"indentOnInput\": () => (/* binding */ indentOnInput),\n/* harmony export */   \"indentService\": () => (/* binding */ indentService),\n/* harmony export */   \"indentString\": () => (/* binding */ indentString),\n/* harmony export */   \"indentUnit\": () => (/* binding */ indentUnit),\n/* harmony export */   \"language\": () => (/* binding */ language),\n/* harmony export */   \"languageDataProp\": () => (/* binding */ languageDataProp),\n/* harmony export */   \"syntaxTree\": () => (/* binding */ syntaxTree)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n\n\n\n\n\n/**\nNode prop stored in a grammar's top syntax node to provide the\nfacet that stores language data for that language.\n*/\nconst languageDataProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/\nfunction defineLanguageFacet(baseData) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n        combine: baseData ? values => values.concat(baseData) : undefined\n    });\n}\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. You'll\nwant to subclass this class for custom parsers, or use the\n[`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage) or\n[`StreamLanguage`](https://codemirror.net/6/docs/ref/#stream-parser.StreamLanguage) abstractions for\n[Lezer](https://lezer.codemirror.net/) or stream parsers.\n*/\nclass Language {\n    /**\n    Construct a language object. You usually don't need to invoke\n    this directly. But when you do, make sure you use\n    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet) to create\n    the first argument.\n    */\n    constructor(\n    /**\n    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) data\n    facet used for this language.\n    */\n    data, parser, \n    /**\n    The node type of the top node of trees produced by this parser.\n    */\n    topNode, extraExtensions = []) {\n        this.data = data;\n        this.topNode = topNode;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.prototype.hasOwnProperty(\"tree\"))\n            Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.prototype, \"tree\", { get() { return syntaxTree(this); } });\n        this.parser = parser;\n        this.extension = [\n            language.of(this),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))\n        ].concat(extraExtensions);\n    }\n    /**\n    Query whether this language is active at the given position.\n    */\n    isActiveAt(state, pos, side = -1) {\n        return languageDataFacetAt(state, pos, side) == this.data;\n    }\n    /**\n    Find the document regions that were parsed using this language.\n    The returned regions will _include_ any nested languages rooted\n    in this language, when those exist.\n    */\n    findRegions(state) {\n        let lang = state.facet(language);\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)\n            return [{ from: 0, to: state.doc.length }];\n        if (!lang || !lang.allowsNesting)\n            return [];\n        let result = [];\n        let explore = (tree, from) => {\n            if (tree.prop(languageDataProp) == this.data) {\n                result.push({ from, to: from + tree.length });\n                return;\n            }\n            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n            if (mount) {\n                if (mount.tree.prop(languageDataProp) == this.data) {\n                    if (mount.overlay)\n                        for (let r of mount.overlay)\n                            result.push({ from: r.from + from, to: r.to + from });\n                    else\n                        result.push({ from: from, to: from + tree.length });\n                    return;\n                }\n                else if (mount.overlay) {\n                    let size = result.length;\n                    explore(mount.tree, mount.overlay[0].from + from);\n                    if (result.length > size)\n                        return;\n                }\n            }\n            for (let i = 0; i < tree.children.length; i++) {\n                let ch = tree.children[i];\n                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree)\n                    explore(ch, tree.positions[i] + from);\n            }\n        };\n        explore(syntaxTree(state), 0);\n        return result;\n    }\n    /**\n    Indicates whether this language allows nested languages. The\n    default implementation returns true.\n    */\n    get allowsNesting() { return true; }\n}\n/**\n@internal\n*/\nLanguage.setState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nfunction languageDataFacetAt(state, pos, side) {\n    let topLang = state.facet(language);\n    if (!topLang)\n        return null;\n    let facet = topLang.data;\n    if (topLang.allowsNesting) {\n        for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, true, false))\n            facet = node.type.prop(languageDataProp) || facet;\n    }\n    return facet;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/\nclass LRLanguage extends Language {\n    constructor(data, parser) {\n        super(data, parser, parser.topNode);\n        this.parser = parser;\n    }\n    /**\n    Define a language from a parser.\n    */\n    static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LRLanguage(data, spec.parser.configure({\n            props: [languageDataProp.add(type => type.isTop ? data : undefined)]\n        }));\n    }\n    /**\n    Create a new instance of this language with a reconfigured\n    version of its parser.\n    */\n    configure(options) {\n        return new LRLanguage(this.data, this.parser.configure(options));\n    }\n    get allowsNesting() { return this.parser.wrappers.length > 0; } // FIXME\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of active [language](https://codemirror.net/6/docs/ref/#language.Language),\nor the empty tree if there is no language available.\n*/\nfunction syntaxTree(state) {\n    let field = state.field(Language.state, false);\n    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/\nfunction ensureSyntaxTree(state, upto, timeout = 50) {\n    var _a;\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n    return !parse ? null : parse.treeLen >= upto || parse.work(timeout, upto) ? parse.tree : null;\n}\n// Lezer-style Input object for a Text document.\nclass DocInput {\n    constructor(doc, length = doc.length) {\n        this.doc = doc;\n        this.length = length;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    syncTo(pos) {\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    chunk(pos) {\n        this.syncTo(pos);\n        return this.string;\n    }\n    get lineChunks() { return true; }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos)\n            return this.doc.sliceString(from, to);\n        else\n            return this.string.slice(from - stringStart, to - stringStart);\n    }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/\nclass ParseContext {\n    /**\n    @internal\n    */\n    constructor(parser, \n    /**\n    The current editor state.\n    */\n    state, \n    /**\n    Tree fragments that can be reused by incremental re-parses.\n    */\n    fragments = [], \n    /**\n    @internal\n    */\n    tree, treeLen, \n    /**\n    The current editor viewport (or some overapproximation\n    thereof). Intended to be used for opportunistically avoiding\n    work (in which case\n    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n    should be called to make sure the parser is restarted when the\n    skipped region becomes visible).\n    */\n    viewport, \n    /**\n    @internal\n    */\n    skipped, \n    /**\n    This is where skipping parsers can register a promise that,\n    when resolved, will schedule a new parse. It is cleared when\n    the parse worker picks up the promise. @internal\n    */\n    scheduleOn) {\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.treeLen = treeLen;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.scheduleOn = scheduleOn;\n        this.parse = null;\n        /**\n        @internal\n        */\n        this.tempSkipped = [];\n    }\n    startParse() {\n        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n    }\n    /**\n    @internal\n    */\n    work(time, upto) {\n        if (upto != null && upto >= this.state.doc.length)\n            upto = undefined;\n        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n            this.takeTree();\n            return true;\n        }\n        return this.withContext(() => {\n            var _a;\n            if (!this.parse)\n                this.parse = this.startParse();\n            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&\n                upto < this.state.doc.length)\n                this.parse.stopAt(upto);\n            let endTime = Date.now() + time;\n            for (;;) {\n                let done = this.parse.advance();\n                if (done) {\n                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n                    this.tree = done;\n                    this.parse = null;\n                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))\n                        this.parse = this.startParse();\n                    else\n                        return true;\n                }\n                if (Date.now() > endTime)\n                    return false;\n            }\n        });\n    }\n    /**\n    @internal\n    */\n    takeTree() {\n        let pos, tree;\n        if (this.parse && (pos = this.parse.parsedPos) > this.treeLen) {\n            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)\n                this.parse.stopAt(pos);\n            this.withContext(() => { while (!(tree = this.parse.advance())) { } });\n            this.tree = tree;\n            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n            this.parse = null;\n        }\n    }\n    withContext(f) {\n        let prev = currentContext;\n        currentContext = this;\n        try {\n            return f();\n        }\n        finally {\n            currentContext = prev;\n        }\n    }\n    withoutTempSkipped(fragments) {\n        for (let r; r = this.tempSkipped.pop();)\n            fragments = cutFragments(fragments, r.from, r.to);\n        return fragments;\n    }\n    /**\n    @internal\n    */\n    changes(changes, newState) {\n        let { fragments, tree, treeLen, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));\n            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n            treeLen = 0;\n            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped) {\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to)\n                        skipped.push({ from, to });\n                }\n            }\n        }\n        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n    }\n    /**\n    @internal\n    */\n    updateViewport(viewport) {\n        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)\n            return false;\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for (let i = 0; i < this.skipped.length; i++) {\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.fragments = cutFragments(this.fragments, from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        if (this.skipped.length >= startLen)\n            return false;\n        this.reset();\n        return true;\n    }\n    /**\n    @internal\n    */\n    reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    /**\n    Notify the parse scheduler that the given region was skipped\n    because it wasn't in view, and the parse should be restarted\n    when it comes into view.\n    */\n    skipUntilInView(from, to) {\n        this.skipped.push({ from, to });\n    }\n    /**\n    Returns a parser intended to be used as placeholder when\n    asynchronously loading a nested parser. It'll skip its input and\n    mark it as not-really-parsed, so that the next update will parse\n    it again.\n    \n    When `until` is given, a reparse will be scheduled when that\n    promise resolves.\n    */\n    static getSkippingParser(until) {\n        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                let from = ranges[0].from, to = ranges[ranges.length - 1].to;\n                let parser = {\n                    parsedPos: from,\n                    advance() {\n                        let cx = currentContext;\n                        if (cx) {\n                            for (let r of ranges)\n                                cx.tempSkipped.push(r);\n                            if (until)\n                                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;\n                        }\n                        this.parsedPos = to;\n                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n                    },\n                    stoppedAt: null,\n                    stopAt() { }\n                };\n                return parser;\n            }\n        };\n    }\n    /**\n    @internal\n    */\n    movedPast(pos) {\n        return this.treeLen < pos && this.parse && this.parse.parsedPos >= pos;\n    }\n    /**\n    @internal\n    */\n    isDone(upto) {\n        let frags = this.fragments;\n        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n    }\n    /**\n    Get the context for the current parse, or `null` if no editor\n    parse is in progress.\n    */\n    static get() { return currentContext; }\n}\nfunction cutFragments(fragments, from, to) {\n    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);\n}\nclass LanguageState {\n    constructor(\n    // A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context) {\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged)\n            return this;\n        let newCx = this.context.changes(tr.changes, tr.state);\n        // If the previous parse wasn't done, go forward only up to its\n        // end position or the end of the viewport, to avoid slowing down\n        // state updates with parse work beyond the viewport.\n        let upto = this.context.treeLen == tr.startState.doc.length ? undefined\n            : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n        if (!newCx.work(25 /* Apply */, upto))\n            newCx.takeTree();\n        return new LanguageState(newCx);\n    }\n    static init(state) {\n        let parseState = new ParseContext(state.facet(language).parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, { from: 0, to: state.doc.length }, [], null);\n        if (!parseState.work(25 /* Apply */))\n            parseState.takeTree();\n        return new LanguageState(parseState);\n    }\n}\nLanguage.state = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create: LanguageState.init,\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(Language.setState))\n                return e.value;\n        if (tr.startState.facet(language) != tr.state.facet(language))\n            return LanguageState.init(tr.state);\n        return value.apply(tr);\n    }\n});\nlet requestIdle = typeof window != \"undefined\" && window.requestIdleCallback ||\n    ((callback, { timeout }) => setTimeout(callback, timeout));\nlet cancelIdle = typeof window != \"undefined\" && window.cancelIdleCallback || clearTimeout;\nconst parseWorker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class ParseWorker {\n    constructor(view) {\n        this.view = view;\n        this.working = -1;\n        // End of the current time chunk\n        this.chunkEnd = -1;\n        // Milliseconds of budget left for this chunk\n        this.chunkBudget = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        let cx = this.view.state.field(Language.state).context;\n        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)\n            this.scheduleWork();\n        if (update.docChanged) {\n            if (this.view.hasFocus)\n                this.chunkBudget += 50 /* ChangeBonus */;\n            this.scheduleWork();\n        }\n        this.checkAsyncSchedule(cx);\n    }\n    scheduleWork() {\n        if (this.working > -1)\n            return;\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))\n            this.working = requestIdle(this.work, { timeout: 500 /* Pause */ });\n    }\n    work(deadline) {\n        this.working = -1;\n        let now = Date.now();\n        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) { // Start a new chunk\n            this.chunkEnd = now + 30000 /* ChunkTime */;\n            this.chunkBudget = 3000 /* ChunkBudget */;\n        }\n        if (this.chunkBudget <= 0)\n            return; // No more budget\n        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);\n        if (field.tree == field.context.tree && field.context.treeLen >= vpTo + 1000000 /* MaxParseAhead */)\n            return;\n        let time = Math.min(this.chunkBudget, deadline ? Math.max(25 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */);\n        let done = field.context.work(time, vpTo + 1000000 /* MaxParseAhead */);\n        this.chunkBudget -= Date.now() - now;\n        if (done || this.chunkBudget <= 0 || field.context.movedPast(vpTo)) {\n            field.context.takeTree();\n            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });\n        }\n        if (!done && this.chunkBudget > 0)\n            this.scheduleWork();\n        this.checkAsyncSchedule(field.context);\n    }\n    checkAsyncSchedule(cx) {\n        if (cx.scheduleOn) {\n            cx.scheduleOn.then(() => this.scheduleWork());\n            cx.scheduleOn = null;\n        }\n    }\n    destroy() {\n        if (this.working >= 0)\n            cancelIdle(this.working);\n    }\n}, {\n    eventHandlers: { focus() { this.scheduleWork(); } }\n});\n/**\nThe facet used to associate a language with an editor state.\n*/\nconst language = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine(languages) { return languages.length ? languages[0] : null; },\n    enables: [Language.state, parseWorker]\n});\n/**\nThis class bundles a [language object](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/\nclass LanguageSupport {\n    /**\n    Create a support object.\n    */\n    constructor(\n    /**\n    The language object.\n    */\n    language, \n    /**\n    An optional set of supporting extensions. When nesting a\n    language in another language, the outer language is encouraged\n    to include the supporting extensions for its inner languages\n    in its own set of support extensions.\n    */\n    support = []) {\n        this.language = language;\n        this.support = support;\n        this.extension = [language, support];\n    }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/\nclass LanguageDescription {\n    constructor(\n    /**\n    The name of this language.\n    */\n    name, \n    /**\n    Alternative names for the mode (lowercased, includes `this.name`).\n    */\n    alias, \n    /**\n    File extensions associated with this language.\n    */\n    extensions, \n    /**\n    Optional filename pattern that should be associated with this\n    language.\n    */\n    filename, loadFunc) {\n        this.name = name;\n        this.alias = alias;\n        this.extensions = extensions;\n        this.filename = filename;\n        this.loadFunc = loadFunc;\n        /**\n        If the language has been loaded, this will hold its value.\n        */\n        this.support = undefined;\n        this.loading = null;\n    }\n    /**\n    Start loading the the language. Will return a promise that\n    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n    object when the language successfully loads.\n    */\n    load() {\n        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));\n    }\n    /**\n    Create a language description.\n    */\n    static of(spec) {\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, spec.load);\n    }\n    /**\n    Look for a language in the given array of descriptions that\n    matches the filename. Will first match\n    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n    and return the first language that matches.\n    */\n    static matchFilename(descs, filename) {\n        for (let d of descs)\n            if (d.filename && d.filename.test(filename))\n                return d;\n        let ext = /\\.([^.]+)$/.exec(filename);\n        if (ext)\n            for (let d of descs)\n                if (d.extensions.indexOf(ext[1]) > -1)\n                    return d;\n        return null;\n    }\n    /**\n    Look for a language whose name or alias matches the the given\n    name (case-insensitively). If `fuzzy` is true, and no direct\n    matchs is found, this'll also search for a language whose name\n    or alias occurs in the string (for names shorter than three\n    characters, only when surrounded by non-word characters).\n    */\n    static matchLanguageName(descs, name, fuzzy = true) {\n        name = name.toLowerCase();\n        for (let d of descs)\n            if (d.alias.some(a => a == name))\n                return d;\n        if (fuzzy)\n            for (let d of descs)\n                for (let a of d.alias) {\n                    let found = name.indexOf(a);\n                    if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length])))\n                        return d;\n                }\n        return null;\n    }\n}\n\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth at the start of a given line, or\n`null` to indicate no appropriate indentation could be determined.\n*/\nconst indentService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens.\nShould be a string consisting either entirely of spaces or\nentirely of tabs. When not set, this defaults to 2 spaces.\n*/\nconst indentUnit = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine: values => {\n        if (!values.length)\n            return \"  \";\n        if (!/^(?: +|\\t+)$/.test(values[0]))\n            throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return values[0];\n    }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/\nfunction getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/\nfunction indentString(state, cols) {\n    let result = \"\", ts = state.tabSize;\n    if (state.facet(indentUnit).charCodeAt(0) == 9)\n        while (cols >= ts) {\n            result += \"\\t\";\n            cols -= ts;\n        }\n    for (let i = 0; i < cols; i++)\n        result += \" \";\n    return result;\n}\n/**\nGet the indentation at the given position. Will first consult any\n[indent services](https://codemirror.net/6/docs/ref/#language.indentService) that are registered,\nand if none of those return an indentation, this will check the\nsyntax tree for the [indent node prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp)\nand use that if found. Returns a number when an indentation could\nbe determined, and null otherwise.\n*/\nfunction getIndentation(context, pos) {\n    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState)\n        context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)) {\n        let result = service(context, pos);\n        if (result != null)\n            return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/\nclass IndentContext {\n    /**\n    Create an indent context.\n    */\n    constructor(\n    /**\n    The editor state.\n    */\n    state, \n    /**\n    @internal\n    */\n    options = {}) {\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /**\n    Get a description of the line at the given position, taking\n    [simulated line\n    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    into account. If there is such a break at `pos`, the `bias`\n    argument determines whether the part of the line line before or\n    after the break is used.\n    */\n    lineAt(pos, bias = 1) {\n        let line = this.state.doc.lineAt(pos);\n        let { simulateBreak } = this.options;\n        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n            if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)\n                return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };\n            else\n                return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };\n        }\n        return line;\n    }\n    /**\n    Get the text directly after `pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */\n    textAfterPos(pos, bias = 1) {\n        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)\n            return \"\";\n        let { text, from } = this.lineAt(pos, bias);\n        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n    }\n    /**\n    Find the column for the given position.\n    */\n    column(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let result = this.countColumn(text, pos - from);\n        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n        if (override > -1)\n            result += override - this.countColumn(text, text.search(/\\S|$/));\n        return result;\n    }\n    /**\n    Find the column position (taking tabs into account) of the given\n    position in the given string.\n    */\n    countColumn(line, pos = line.length) {\n        return (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n    }\n    /**\n    Find the indentation column of the line at the given point.\n    */\n    lineIndent(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let override = this.options.overrideIndentation;\n        if (override) {\n            let overriden = override(from);\n            if (overriden > -1)\n                return overriden;\n        }\n        return this.countColumn(text, text.search(/\\S|$/));\n    }\n    /**\n    Returns the [simulated line\n    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    for this context, if any.\n    */\n    get simulatedBreak() {\n        return this.options.simulateBreak || null;\n    }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number or null, where null indicates that no\ndefinitive indentation can be determined.\n*/\nconst indentNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);\n}\nfunction ignoreClosed(cx) {\n    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy)\n        return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction indentFrom(node, pos, base) {\n    for (; node; node = node.parent) {\n        let strategy = indentStrategy(node);\n        if (strategy)\n            return strategy(new TreeIndentContext(base, pos, node));\n    }\n    return null;\n}\nfunction topIndent() { return 0; }\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions.\n*/\nclass TreeIndentContext extends IndentContext {\n    /**\n    @internal\n    */\n    constructor(base, \n    /**\n    The position at which indentation is being computed.\n    */\n    pos, \n    /**\n    The syntax tree node to which the indentation strategy\n    applies.\n    */\n    node) {\n        super(base.state, base.options);\n        this.base = base;\n        this.pos = pos;\n        this.node = node;\n    }\n    /**\n    Get the text directly after `this.pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */\n    get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /**\n    Get the indentation at the reference line for `this.node`, which\n    is the line on which it starts, unless there is a node that is\n    _not_ a parent of this node covering the start of that line. If\n    so, the line at the start of that node is tried, again skipping\n    on if it is covered by another such node.\n    */\n    get baseIndent() {\n        let line = this.state.doc.lineAt(this.node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for (;;) {\n            let atBreak = this.node.resolve(line.from);\n            while (atBreak.parent && atBreak.parent.from == atBreak.from)\n                atBreak = atBreak.parent;\n            if (isParent(atBreak, this.node))\n                break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line.from);\n    }\n    /**\n    Continue looking for indentations in the node's parent nodes,\n    and return the result of that.\n    */\n    continue() {\n        let parent = this.node.parent;\n        return parent ? indentFrom(parent, this.pos, this.base) : 0;\n    }\n}\nfunction isParent(parent, of) {\n    for (let cur = of; cur; cur = cur.parent)\n        if (parent == cur)\n            return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken)\n        return null;\n    let sim = context.options.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for (let pos = openToken.to;;) {\n        let next = tree.childAfter(pos);\n        if (!next || next == last)\n            return null;\n        if (!next.type.isSkipped)\n            return next.from < lineEnd ? openToken : null;\n        pos = next.to;\n    }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/\nfunction delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context) => delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned)\n        return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/\nconst flatIndent = (context) => context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/\nfunction continuedIndent({ except, units = 1 } = {}) {\n    return (context) => {\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/\nfunction indentOnInput() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.transactionFilter.of(tr => {\n        if (!tr.docChanged || !tr.isUserEvent(\"input.type\"))\n            return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n        if (!rules.length)\n            return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond)\n            return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some(r => r.test(lineStart)))\n            return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges) {\n            let line = state.doc.lineAt(head);\n            if (line.from == last)\n                continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null)\n                continue;\n            let cur = /^\\s*/.exec(line.text)[0];\n            let norm = indentString(state, indent);\n            if (cur != norm)\n                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n        return changes.length ? [tr, { changes, sequential: true }] : tr;\n    });\n}\n\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/\nconst foldService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/\nconst foldNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/\nfunction foldInside(node) {\n    let first = node.firstChild, last = node.lastChild;\n    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;\n}\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length == 0)\n        return null;\n    let inner = tree.resolveInner(end);\n    let found = null;\n    for (let cur = inner; cur; cur = cur.parent) {\n        if (cur.to <= end || cur.from > end)\n            continue;\n        if (found && cur.from < start)\n            break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end)\n                found = value;\n        }\n    }\n    return found;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/\nfunction foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)) {\n        let result = service(state, lineStart, lineEnd);\n        if (result)\n            return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/language/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/lint/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/lint/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"closeLintPanel\": () => (/* binding */ closeLintPanel),\n/* harmony export */   \"diagnosticCount\": () => (/* binding */ diagnosticCount),\n/* harmony export */   \"forceLinting\": () => (/* binding */ forceLinting),\n/* harmony export */   \"lintKeymap\": () => (/* binding */ lintKeymap),\n/* harmony export */   \"linter\": () => (/* binding */ linter),\n/* harmony export */   \"nextDiagnostic\": () => (/* binding */ nextDiagnostic),\n/* harmony export */   \"openLintPanel\": () => (/* binding */ openLintPanel),\n/* harmony export */   \"setDiagnostics\": () => (/* binding */ setDiagnostics)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_tooltip__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/tooltip */ \"./node_modules/@codemirror/tooltip/dist/index.js\");\n/* harmony import */ var _codemirror_panel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/panel */ \"./node_modules/@codemirror/panel/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"./node_modules/crelt/index.es.js\");\n\n\n\n\n\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic) {\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected) {\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n    static init(diagnostics, panel, state) {\n        let ranges = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set(diagnostics.map((d) => {\n            // For zero-length ranges or ranges covering only a line break, create a widget\n            return d.from == d.to || (d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)\n                ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.widget({\n                    widget: new DiagnosticWidget(d),\n                    diagnostic: d\n                }).range(d.from)\n                : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\n                    attributes: { class: \"cm-lintRange cm-lintRange-\" + d.severity },\n                    diagnostic: d\n                }).range(d.from, d.to);\n        }), true);\n        return new LintState(ranges, panel, findDiagnostic(ranges));\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, 1e9, (from, to, { spec }) => {\n        if (diagnostic && spec.diagnostic != diagnostic)\n            return;\n        found = new SelectedDiagnostic(from, to, spec.diagnostic);\n        return false;\n    });\n    return found;\n}\nfunction maybeEnableLint(state, effects, getState) {\n    return state.field(lintState, false) ? effects : effects.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of([\n        lintState.init(getState),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.compute([lintState], state => {\n            let { selected, panel } = state.field(lintState);\n            return !selected || !panel || selected.from == selected.to ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set([\n                activeMark.range(selected.from, selected.to)\n            ]);\n        }),\n        (0,_codemirror_tooltip__WEBPACK_IMPORTED_MODULE_3__.hoverTooltip)(lintTooltip),\n        baseTheme\n    ]));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics.\n*/\nfunction setDiagnostics(state, diagnostics) {\n    return {\n        effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)], () => LintState.init(diagnostics, null, state))\n    };\n}\nconst setDiagnosticsEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst movePanelSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst lintState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() {\n        return new LintState(_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none, null, null);\n    },\n    update(value, tr) {\n        if (tr.docChanged) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            value = new LintState(mapped, value.panel, selected);\n        }\n        for (let effect of tr.effects) {\n            if (effect.is(setDiagnosticsEffect)) {\n                value = LintState.init(effect.value, value.panel, tr.state);\n            }\n            else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            }\n            else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: f => [_codemirror_panel__WEBPACK_IMPORTED_MODULE_4__.showPanel.from(f, val => val.panel),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(f, s => s.diagnostics)]\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/\nfunction diagnosticCount(state) {\n    let lint = state.field(lintState, false);\n    return lint ? lint.diagnostics.size : 0;\n}\nconst activeMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({ class: \"cm-lintRange cm-lintRange-active\" });\nfunction lintTooltip(view, pos, side) {\n    let { diagnostics } = view.state.field(lintState);\n    let found = [], stackStart = 2e8, stackEnd = 0;\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {\n        if (pos >= from && pos <= to &&\n            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {\n            found.push(spec.diagnostic);\n            stackStart = Math.min(from, stackStart);\n            stackEnd = Math.max(to, stackEnd);\n        }\n    });\n    if (!found.length)\n        return null;\n    return {\n        pos: stackStart,\n        end: stackEnd,\n        above: view.state.doc.lineAt(stackStart).to < stackEnd,\n        create() {\n            return { dom: (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", { class: \"cm-tooltip-lint\" }, found.map(d => renderDiagnostic(view, d, false))) };\n        }\n    };\n}\n/**\nCommand to open and focus the lint panel.\n*/\nconst openLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)], () => LintState.init([], LintPanel.open, view.state)) });\n    let panel = (0,_codemirror_panel__WEBPACK_IMPORTED_MODULE_4__.getPanel)(view, LintPanel.open);\n    if (panel)\n        panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/\nconst closeLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        return false;\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/\nconst nextDiagnostic = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field)\n        return false;\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to)\n            return false;\n    }\n    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });\n    return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/\nconst lintKeymap = [\n    { key: \"Mod-Shift-m\", run: openLintPanel },\n    { key: \"F8\", run: nextDiagnostic }\n];\nconst lintPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.timeout = -1;\n        this.set = true;\n        let { delay } = view.state.facet(lintSource);\n        this.lintTime = Date.now() + delay;\n        this.run = this.run.bind(this);\n        this.timeout = setTimeout(this.run, delay);\n    }\n    run() {\n        let now = Date.now();\n        if (now < this.lintTime - 10) {\n            setTimeout(this.run, this.lintTime - now);\n        }\n        else {\n            this.set = false;\n            let { state } = this.view, { sources } = state.facet(lintSource);\n            Promise.all(sources.map(source => Promise.resolve(source(this.view)))).then(annotations => {\n                var _a, _b;\n                let all = annotations.reduce((a, b) => a.concat(b));\n                if (this.view.state.doc == state.doc &&\n                    (all.length || ((_b = (_a = this.view.state.field(lintState, false)) === null || _a === void 0 ? void 0 : _a.diagnostics) === null || _b === void 0 ? void 0 : _b.size)))\n                    this.view.dispatch(setDiagnostics(this.view.state, all));\n            }, error => { (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.logException)(this.view.state, error); });\n        }\n    }\n    update(update) {\n        let source = update.state.facet(lintSource);\n        if (update.docChanged || source != update.startState.facet(lintSource)) {\n            this.lintTime = Date.now() + source.delay;\n            if (!this.set) {\n                this.set = true;\n                this.timeout = setTimeout(this.run, source.delay);\n            }\n        }\n    }\n    force() {\n        if (this.set) {\n            this.lintTime = Date.now();\n            this.run();\n        }\n    }\n    destroy() {\n        clearTimeout(this.timeout);\n    }\n});\nconst lintSource = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(input) {\n        return { sources: input.map(i => i.source), delay: input.length ? Math.max(...input.map(i => i.delay)) : 750 };\n    },\n    enables: lintPlugin\n});\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed).\n*/\nfunction linter(source, config = {}) {\n    var _a;\n    return lintSource.of({ source, delay: (_a = config.delay) !== null && _a !== void 0 ? _a : 750 });\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/\nfunction forceLinting(view) {\n    let plugin = view.plugin(lintPlugin);\n    if (plugin)\n        plugin.force();\n}\nfunction assignKeys(actions) {\n    let assigned = [];\n    if (actions)\n        actions: for (let { name } of actions) {\n            for (let i = 0; i < name.length; i++) {\n                let ch = name[i];\n                if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {\n                    assigned.push(ch);\n                    continue actions;\n                }\n            }\n            assigned.push(\"\");\n        }\n    return assigned;\n}\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n    var _a;\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"li\", { class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", { class: \"cm-diagnosticText\" }, diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {\n        let click = (e) => {\n            e.preventDefault();\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n            if (found)\n                action.apply(view, found.from, found.to);\n        };\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n        let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"u\", name.slice(keyIndex, keyIndex + 1)),\n            name.slice(keyIndex + 1)];\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            class: \"cm-diagnosticAction\",\n            onclick: click,\n            onmousedown: click,\n            \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\n        }, nameElt);\n    }), diagnostic.source && (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", { class: \"cm-diagnosticSource\" }, diagnostic.source));\n}\nclass DiagnosticWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.WidgetType {\n    constructor(diagnostic) {\n        super();\n        this.diagnostic = diagnostic;\n    }\n    eq(other) { return other.diagnostic == this.diagnostic; }\n    toDOM() {\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", { class: \"cm-lintPoint cm-lintPoint-\" + this.diagnostic.severity });\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic) {\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic, true);\n        this.dom.id = this.id;\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view) {\n        this.view = view;\n        this.items = [];\n        let onkeydown = (event) => {\n            if (event.keyCode == 27) { // Escape\n                closeLintPanel(this.view);\n                this.view.focus();\n            }\n            else if (event.keyCode == 38 || event.keyCode == 33) { // ArrowUp, PageUp\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            }\n            else if (event.keyCode == 40 || event.keyCode == 34) { // ArrowDown, PageDown\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            }\n            else if (event.keyCode == 36) { // Home\n                this.moveSelection(0);\n            }\n            else if (event.keyCode == 35) { // End\n                this.moveSelection(this.items.length - 1);\n            }\n            else if (event.keyCode == 13) { // Enter\n                this.view.focus();\n            }\n            else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) { // A-Z\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\n                for (let i = 0; i < keys.length; i++)\n                    if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n                        let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n                        if (found)\n                            diagnostic.actions[i].apply(view, found.from, found.to);\n                    }\n            }\n            else {\n                return;\n            }\n            event.preventDefault();\n        };\n        let onclick = (event) => {\n            for (let i = 0; i < this.items.length; i++) {\n                if (this.items[i].dom.contains(event.target))\n                    this.moveSelection(i);\n            }\n        };\n        this.list = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n            tabIndex: 0,\n            role: \"listbox\",\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n            onkeydown,\n            onclick\n        });\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", { class: \"cm-panel-lint\" }, this.list, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            name: \"close\",\n            \"aria-label\": this.view.state.phrase(\"close\"),\n            onclick: () => closeLintPanel(this.view)\n        }, \"\"));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected)\n            return -1;\n        for (let i = 0; i < this.items.length; i++)\n            if (this.items[i].diagnostic == selected.diagnostic)\n                return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {\n            let found = -1, item;\n            for (let j = i; j < this.items.length; j++)\n                if (this.items[j].diagnostic == spec.diagnostic) {\n                    found = j;\n                    break;\n                }\n            if (found < 0) {\n                item = new PanelItem(this.view, spec.diagnostic);\n                this.items.splice(i, 0, item);\n                needsSync = true;\n            }\n            else {\n                item = this.items[found];\n                if (found > i) {\n                    this.items.splice(i, found - i);\n                    needsSync = true;\n                }\n            }\n            if (selected && item.diagnostic == selected.diagnostic) {\n                if (!item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.setAttribute(\"aria-selected\", \"true\");\n                    newSelectedItem = item;\n                }\n            }\n            else if (item.dom.hasAttribute(\"aria-selected\")) {\n                item.dom.removeAttribute(\"aria-selected\");\n            }\n            i++;\n        });\n        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1, to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),\n                write: ({ sel, panel }) => {\n                    if (sel.top < panel.top)\n                        this.list.scrollTop -= panel.top - sel.top;\n                    else if (sel.bottom > panel.bottom)\n                        this.list.scrollTop += sel.bottom - panel.bottom;\n                }\n            });\n        }\n        else if (this.selectedIndex < 0) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync)\n            this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items) {\n            if (item.dom.parentNode == this.list) {\n                while (domPos != item.dom)\n                    rm();\n                domPos = item.dom.nextSibling;\n            }\n            else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while (domPos)\n            rm();\n    }\n    moveSelection(selectedIndex) {\n        if (this.selectedIndex < 0)\n            return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection)\n            return;\n        this.view.dispatch({\n            selection: { anchor: selection.from, head: selection.to },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    static open(view) { return new LintPanel(view); }\n}\nfunction underline(color) {\n    if (typeof btoa != \"function\")\n        return \"none\";\n    let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"6\" height=\"3\">\n    <path d=\"m0 3 l2 -2 l1 0 l2 2 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>\n  </svg>`;\n    return `url('data:image/svg+xml;base64,${btoa(svg)}')`;\n}\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-diagnostic\": {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\",\n        whiteSpace: \"pre-wrap\"\n    },\n    \".cm-diagnostic-error\": { borderLeft: \"5px solid #d11\" },\n    \".cm-diagnostic-warning\": { borderLeft: \"5px solid orange\" },\n    \".cm-diagnostic-info\": { borderLeft: \"5px solid #999\" },\n    \".cm-diagnosticAction\": {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\"\n    },\n    \".cm-diagnosticSource\": {\n        fontSize: \"70%\",\n        opacity: .7\n    },\n    \".cm-lintRange\": {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\"\n    },\n    \".cm-lintRange-error\": { backgroundImage: /*@__PURE__*/underline(\"#d11\") },\n    \".cm-lintRange-warning\": { backgroundImage: /*@__PURE__*/underline(\"orange\") },\n    \".cm-lintRange-info\": { backgroundImage: /*@__PURE__*/underline(\"#999\") },\n    \".cm-lintRange-active\": { backgroundColor: \"#ffdd9980\" },\n    \".cm-tooltip-lint\": {\n        padding: 0,\n        margin: 0\n    },\n    \".cm-lintPoint\": {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \".cm-lintPoint-warning\": {\n        \"&:after\": { borderBottomColor: \"orange\" }\n    },\n    \".cm-lintPoint-info\": {\n        \"&:after\": { borderBottomColor: \"#999\" }\n    },\n    \".cm-panel.cm-panel-lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\",\n                \"& u\": { textDecoration: \"underline\" }\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            \"& u\": { textDecoration: \"none\" },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    }\n});\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/lint/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/matchbrackets/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/matchbrackets/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bracketMatching\": () => (/* binding */ bracketMatching),\n/* harmony export */   \"matchBrackets\": () => (/* binding */ matchBrackets)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-matchingBracket\": { backgroundColor: \"#328c8252\" },\n    \".cm-nonmatchingBracket\": { backgroundColor: \"#bb555544\" }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist\n        });\n    }\n});\nconst matchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({ class: \"cm-matchingBracket\" }), nonmatchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({ class: \"cm-nonmatchingBracket\" });\nconst bracketMatchingState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() { return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none; },\n    update(deco, tr) {\n        if (!tr.docChanged && !tr.selection)\n            return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges) {\n            if (!range.empty)\n                continue;\n            let match = matchBrackets(tr.state, range.head, -1, config)\n                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))\n                || (config.afterCursor &&\n                    (matchBrackets(tr.state, range.head, 1, config) ||\n                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));\n            if (!match)\n                continue;\n            let mark = match.matched ? matchingMark : nonmatchingMark;\n            decorations.push(mark.range(match.start.from, match.start.to));\n            if (match.end)\n                decorations.push(mark.range(match.end.from, match.end.to));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set(decorations, true);\n    },\n    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state), node = tree.resolveInner(pos, dir);\n    for (let cur = node; cur; cur = cur.parent) {\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to)\n            return matchMarkedBrackets(state, pos, dir, cur, matches, brackets);\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n    let parent = token.parent, firstToken = { from: token.from, to: token.to };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))\n        do {\n            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };\n                }\n                else if (matchingNodes(cursor.type, dir, brackets)) {\n                    depth++;\n                }\n                else if (matchingNodes(cursor.type, -dir, brackets)) {\n                    depth--;\n                    if (depth == 0)\n                        return {\n                            start: firstToken,\n                            end: cursor.from == cursor.to ? undefined : { from: cursor.from, to: cursor.to },\n                            matched: false\n                        };\n                }\n            }\n        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/matchbrackets/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/panel/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/panel/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getPanel\": () => (/* binding */ getPanel),\n/* harmony export */   \"panels\": () => (/* binding */ panels),\n/* harmony export */   \"showPanel\": () => (/* binding */ showPanel)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n\n\n\nconst panelConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n    combine(configs) {\n        let topContainer, bottomContainer;\n        for (let c of configs) {\n            topContainer = topContainer || c.topContainer;\n            bottomContainer = bottomContainer || c.bottomContainer;\n        }\n        return { topContainer, bottomContainer };\n    }\n});\n/**\nConfigures the panel-managing extension.\n*/\nfunction panels(config) {\n    return config ? [panelConfig.of(config)] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/\nfunction getPanel(view, panel) {\n    let plugin = view.plugin(panelPlugin);\n    let index = plugin ? plugin.specs.indexOf(panel) : -1;\n    return index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.input = view.state.facet(showPanel);\n        this.specs = this.input.filter(s => s);\n        this.panels = this.specs.map(spec => spec(view));\n        let conf = view.state.facet(panelConfig);\n        this.top = new PanelGroup(view, true, conf.topContainer);\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n        this.top.sync(this.panels.filter(p => p.top));\n        this.bottom.sync(this.panels.filter(p => !p.top));\n        for (let p of this.panels) {\n            p.dom.classList.add(\"cm-panel\");\n            if (p.mount)\n                p.mount();\n        }\n    }\n    update(update) {\n        let conf = update.state.facet(panelConfig);\n        if (this.top.container != conf.topContainer) {\n            this.top.sync([]);\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\n        }\n        if (this.bottom.container != conf.bottomContainer) {\n            this.bottom.sync([]);\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n        }\n        this.top.syncClasses();\n        this.bottom.syncClasses();\n        let input = update.state.facet(showPanel);\n        if (input != this.input) {\n            let specs = input.filter(x => x);\n            let panels = [], top = [], bottom = [], mount = [];\n            for (let spec of specs) {\n                let known = this.specs.indexOf(spec), panel;\n                if (known < 0) {\n                    panel = spec(update.view);\n                    mount.push(panel);\n                }\n                else {\n                    panel = this.panels[known];\n                    if (panel.update)\n                        panel.update(update);\n                }\n                panels.push(panel);\n                (panel.top ? top : bottom).push(panel);\n            }\n            this.specs = specs;\n            this.panels = panels;\n            this.top.sync(top);\n            this.bottom.sync(bottom);\n            for (let p of mount) {\n                p.dom.classList.add(\"cm-panel\");\n                if (p.mount)\n                    p.mount();\n            }\n        }\n        else {\n            for (let p of this.panels)\n                if (p.update)\n                    p.update(update);\n        }\n    }\n    destroy() {\n        this.top.sync([]);\n        this.bottom.sync([]);\n    }\n}, {\n    provide: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.PluginField.scrollMargins.from(value => ({ top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() }))\n});\nclass PanelGroup {\n    constructor(view, top, container) {\n        this.view = view;\n        this.top = top;\n        this.container = container;\n        this.dom = undefined;\n        this.classes = \"\";\n        this.panels = [];\n        this.syncClasses();\n    }\n    sync(panels) {\n        this.panels = panels;\n        this.syncDOM();\n    }\n    syncDOM() {\n        if (this.panels.length == 0) {\n            if (this.dom) {\n                this.dom.remove();\n                this.dom = undefined;\n            }\n            return;\n        }\n        if (!this.dom) {\n            this.dom = document.createElement(\"div\");\n            this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n            let parent = this.container || this.view.dom;\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n        }\n        let curDOM = this.dom.firstChild;\n        for (let panel of this.panels) {\n            if (panel.dom.parentNode == this.dom) {\n                while (curDOM != panel.dom)\n                    curDOM = rm(curDOM);\n                curDOM = curDOM.nextSibling;\n            }\n            else {\n                this.dom.insertBefore(panel.dom, curDOM);\n            }\n        }\n        while (curDOM)\n            curDOM = rm(curDOM);\n    }\n    scrollMargin() {\n        return !this.dom || this.container ? 0\n            : Math.max(0, this.top ?\n                this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :\n                Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n    }\n    syncClasses() {\n        if (!this.container || this.classes == this.view.themeClasses)\n            return;\n        for (let cls of this.classes.split(\" \"))\n            if (cls)\n                this.container.classList.remove(cls);\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))\n            if (cls)\n                this.container.classList.add(cls);\n    }\n}\nfunction rm(node) {\n    let next = node.nextSibling;\n    node.remove();\n    return next;\n}\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-panels\": {\n        boxSizing: \"border-box\",\n        position: \"sticky\",\n        left: 0,\n        right: 0\n    },\n    \"&light .cm-panels\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"black\"\n    },\n    \"&light .cm-panels-top\": {\n        borderBottom: \"1px solid #ddd\"\n    },\n    \"&light .cm-panels-bottom\": {\n        borderTop: \"1px solid #ddd\"\n    },\n    \"&dark .cm-panels\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    }\n});\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/\nconst showPanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n    enables: [panelPlugin, baseTheme]\n});\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/panel/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/rangeset/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/rangeset/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Range\": () => (/* binding */ Range),\n/* harmony export */   \"RangeSet\": () => (/* binding */ RangeSet),\n/* harmony export */   \"RangeSetBuilder\": () => (/* binding */ RangeSetBuilder),\n/* harmony export */   \"RangeValue\": () => (/* binding */ RangeValue)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. The default\n    implementation compares by identity.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n    */\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1000000000 /* Far */, true), e = this.findIndex(to, 1000000000 /* Far */, false, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer = RangeSet.empty, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this.isEmpty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (The extra type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this.isEmpty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.length == 0 || this.isEmpty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this.isEmpty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    @internal\n    */\n    get isEmpty() { return this.nextLayer == this; }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration. `from` and\n    `to` are coordinates in the _new_ space, after these changes.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            !set.isEmpty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            !set.isEmpty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */\n    static eq(oldSets, newSets, from = 0, to) {\n        if (to == null)\n            to = 1000000000 /* Far */;\n        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length)\n            return false;\n        if (!a.length)\n            return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for (;;) {\n            if (sideA.to != sideB.to ||\n                !sameValues(sideA.active, sideB.active) ||\n                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))\n                return false;\n            if (sideA.to >= to)\n                return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let open = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, open);\n                open = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n        return open;\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1)\n        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n            let cur = ranges[i];\n            if (cmpRange(prev, cur) > 0)\n                return ranges.slice().sort(cmpRange);\n            prev = cur;\n        }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\nclass RangeSetBuilder {\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* Far */;\n        this.lastTo = -1000000000 /* Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint < 500 /* BigPointSize */)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (inA.get(set.chunk[i]) == set.chunkPos[i])\n                shared.add(set.chunk[i]);\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex)\n                this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                    this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        }\n        else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* Far */;\n        this.endSide = 0;\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    if (this.cursor.from < from)\n                        trackExtra = 1;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            let openStart = 0;\n            while (openStart < trackOpen.length && trackOpen[openStart] < from)\n                openStart++;\n            this.openStart = openStart + trackExtra;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = this.active.length - 1; i >= 0; i--) {\n            if (this.activeRank[i] < this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&\n                sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/rangeset/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/rectangular-selection/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@codemirror/rectangular-selection/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"rectangularSelection\": () => (/* binding */ rectangularSelection)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n\n\n\n\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i);\n            if (line.length <= endOff)\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    }\n    else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i);\n            let start = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.findColumn)(line.text, startCol, state.tabSize, true);\n            if (start > -1) {\n                let end = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.findColumn)(line.text, endCol, state.tabSize);\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.range(line.from + start, line.from + end));\n            }\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1\n        : off == line.length ? absoluteColumn(view, event.clientX)\n            : (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n    return { line: line.number, col, off };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start)\n        return null;\n    return {\n        update(update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get(event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur)\n                return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length)\n                return startSel;\n            if (multiple)\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.create(ranges.concat(startSel.ranges));\n            else\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.create(ranges);\n        }\n    };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/\nfunction rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/rectangular-selection/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RegExpCursor\": () => (/* binding */ RegExpCursor),\n/* harmony export */   \"SearchCursor\": () => (/* binding */ SearchCursor),\n/* harmony export */   \"closeSearchPanel\": () => (/* binding */ closeSearchPanel),\n/* harmony export */   \"findNext\": () => (/* binding */ findNext),\n/* harmony export */   \"findPrevious\": () => (/* binding */ findPrevious),\n/* harmony export */   \"gotoLine\": () => (/* binding */ gotoLine),\n/* harmony export */   \"highlightSelectionMatches\": () => (/* binding */ highlightSelectionMatches),\n/* harmony export */   \"openSearchPanel\": () => (/* binding */ openSearchPanel),\n/* harmony export */   \"replaceAll\": () => (/* binding */ replaceAll),\n/* harmony export */   \"replaceNext\": () => (/* binding */ replaceNext),\n/* harmony export */   \"searchConfig\": () => (/* binding */ searchConfig),\n/* harmony export */   \"searchKeymap\": () => (/* binding */ searchKeymap),\n/* harmony export */   \"selectMatches\": () => (/* binding */ selectMatches),\n/* harmony export */   \"selectNextOccurrence\": () => (/* binding */ selectNextOccurrence),\n/* harmony export */   \"selectSelectionMatches\": () => (/* binding */ selectSelectionMatches)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_panel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/panel */ \"./node_modules/@codemirror/panel/dist/index.js\");\n/* harmony import */ var _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/rangeset */ \"./node_modules/@codemirror/rangeset/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"./node_modules/crelt/index.es.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n\n\n\n\n\n\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize) {\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (match) {\n                    this.value = match;\n                    return this;\n                }\n                if (i == norm.length - 1)\n                    break;\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: pos + 1 };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: pos + 1 };\n            else\n                this.matches.push(1, pos);\n        }\n        return match;\n    }\n}\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = from;\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = to + (from == to ? 1 : 0);\n                if (from == this.curLine.length)\n                    this.nextLine();\n                if (from < to || from > this.value.to) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = from;\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            // If a match goes almost to the end of a noncomplete chunk, try\n            // again, since it'll likely be able to match more\n            if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)\n                match = null;\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                this.value = { from, to, match };\n                this.matchPos = to + (from == to ? 1 : 0);\n                return this;\n            }\n            else {\n                if (this.flat.to == this.to) {\n                    this.done = true;\n                    return this;\n                }\n                // Grow the flattened doc\n                this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n            }\n        }\n    }\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\nfunction createLineDialog(view) {\n    let input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", { class: \"cm-textfield\", name: \"line\" });\n    let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        view.dispatch({\n            effects: dialogEffect.of(false),\n            selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n            scrollIntoView: true\n        });\n        view.focus();\n    }\n    return { dom, pos: -10 };\n}\nconst dialogEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst dialogField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => _codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\nconst gotoLine = view => {\n    let panel = (0,_codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.getPanel)(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = (0,_codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.getPanel)(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").focus();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100\n};\nconst highlightConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(options) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\nconst matchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n            query = state.sliceDoc(range.from, range.to).trim();\n            if (!query)\n                return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || ((from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Word) &&\n                    (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Word))) {\n                    if (check && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n                }\n            }\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection.\nExpand selection to the word when selection range is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(range.from, range.to), false),\n        scrollIntoView: true\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine(configs) {\n        let matchCase = configs.some(c => c.matchCase);\n        return {\n            top: configs.some(c => c.top),\n            matchCase: matchCase === undefined ? true : matchCase,\n        };\n    }\n});\n/**\nConfigure the behavior of the search extension.\n*/\nfunction searchConfig(config) {\n    return searchConfigFacet.of(config);\n}\nclass Query {\n    constructor(search, replace, caseInsensitive) {\n        this.search = search;\n        this.replace = replace;\n        this.caseInsensitive = caseInsensitive;\n    }\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseInsensitive == other.caseInsensitive && this.constructor == other.constructor;\n    }\n}\nclass StringQuery extends Query {\n    constructor(search, replace, caseInsensitive) {\n        super(search, replace, caseInsensitive);\n        this.unquoted = search.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    cursor(doc, from = 0, to = doc.length) {\n        return new SearchCursor(doc, this.unquoted, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);\n    }\n    nextMatch(doc, curFrom, curTo) {\n        let cursor = this.cursor(doc, curTo).nextOverlapping();\n        if (cursor.done)\n            cursor = this.cursor(doc, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(doc, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* ChunkSize */ - this.unquoted.length);\n            let cursor = this.cursor(doc, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* ChunkSize */;\n        }\n    }\n    prevMatch(doc, curFrom, curTo) {\n        return this.prevMatchInRange(doc, 0, curFrom) ||\n            this.prevMatchInRange(doc, curTo, doc.length);\n    }\n    getReplacement(_result) { return this.replace; }\n    matchAll(doc, limit) {\n        let cursor = this.cursor(doc), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(doc, from, to, add) {\n        let cursor = this.cursor(doc, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n    get valid() { return !!this.search; }\n}\nclass RegExpQuery extends Query {\n    constructor(search, replace, caseInsensitive) {\n        super(search, replace, caseInsensitive);\n        this.valid = !!search && validRegExp(search);\n    }\n    cursor(doc, from = 0, to = doc.length) {\n        return new RegExpCursor(doc, this.search, this.caseInsensitive ? { ignoreCase: true } : undefined, from, to);\n    }\n    nextMatch(doc, curFrom, curTo) {\n        let cursor = this.cursor(doc, curTo).next();\n        if (cursor.done)\n            cursor = this.cursor(doc, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(doc, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* ChunkSize */);\n            let cursor = this.cursor(doc, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(doc, curFrom, curTo) {\n        return this.prevMatchInRange(doc, 0, curFrom) ||\n            this.prevMatchInRange(doc, curTo, doc.length);\n    }\n    getReplacement(result) {\n        return this.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m);\n    }\n    matchAll(doc, limit) {\n        let cursor = this.cursor(doc), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(doc, from, to, add) {\n        let cursor = this.cursor(doc, Math.max(0, from - 250 /* HighlightMargin */), Math.min(to + 250 /* HighlightMargin */, doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nconst setQuery = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst searchState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state), createSearchPanel);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setQuery))\n                value = new SearchState(effect.value, value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => _codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.showPanel.from(f, val => val.panel)\n});\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.valid)\n            return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        let { view } = this;\n        let builder = new _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_5__.RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state.doc, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { from, to } = view.state.selection.main;\n    let next = query.nextMatch(view.state.doc, from, to);\n    if (!next || next.from == from && next.to == to)\n        return false;\n    view.dispatch({\n        selection: { anchor: next.from, head: next.to },\n        scrollIntoView: true,\n        effects: announceMatch(view, next)\n    });\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    let range = query.prevMatch(state.doc, from, to);\n    if (!range)\n        return false;\n    view.dispatch({\n        selection: { anchor: range.from, head: range.to },\n        scrollIntoView: true,\n        effects: announceMatch(view, range)\n    });\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state.doc, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(r.from, r.to)))\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({ selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges, main) }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let next = query.nextMatch(state.doc, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state.doc, next.from, next.to);\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = { anchor: next.from - off, head: next.to - off };\n    }\n    view.dispatch({\n        changes, selection,\n        scrollIntoView: !!selection,\n        effects: next ? announceMatch(view, next) : undefined\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state.doc, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    view.dispatch({ changes });\n    return true;\n});\nfunction createSearchPanel(view) {\n    let { query } = view.state.field(searchState);\n    return {\n        dom: buildPanel({\n            view,\n            query,\n            updateQuery(q) {\n                if (!query.eq(q)) {\n                    query = q;\n                    view.dispatch({ effects: setQuery.of(query) });\n                }\n            }\n        }),\n        mount() {\n            this.dom.querySelector(\"[name=search]\").select();\n        },\n        pos: 80,\n        top: view.state.facet(searchConfigFacet).top\n    };\n}\nfunction defaultQuery(state, fallback) {\n    var _a;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    let caseInsensitive = (_a = fallback === null || fallback === void 0 ? void 0 : fallback.caseInsensitive) !== null && _a !== void 0 ? _a : !state.facet(searchConfigFacet).matchCase;\n    return fallback && !selText ? fallback : new StringQuery(selText.replace(/\\n/g, \"\\\\n\"), \"\", caseInsensitive);\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let panel = (0,_codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.getPanel)(view, createSearchPanel);\n        if (!panel)\n            return false;\n        let searchInput = panel.dom.querySelector(\"[name=search]\");\n        searchInput.focus();\n        searchInput.select();\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setQuery.of(defaultQuery(view.state, state.query)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = (0,_codemirror_panel__WEBPACK_IMPORTED_MODULE_3__.getPanel)(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nfunction buildPanel(conf) {\n    function phrase(phrase) { return conf.view.state.phrase(phrase); }\n    let searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n        value: conf.query.search,\n        placeholder: phrase(\"Find\"),\n        \"aria-label\": phrase(\"Find\"),\n        class: \"cm-textfield\",\n        name: \"search\",\n        onchange: update,\n        onkeyup: update\n    });\n    let replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n        value: conf.query.replace,\n        placeholder: phrase(\"Replace\"),\n        \"aria-label\": phrase(\"Replace\"),\n        class: \"cm-textfield\",\n        name: \"replace\",\n        onchange: update,\n        onkeyup: update\n    });\n    let caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n        type: \"checkbox\",\n        name: \"case\",\n        checked: !conf.query.caseInsensitive,\n        onchange: update\n    });\n    let reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n        type: \"checkbox\",\n        name: \"re\",\n        checked: conf.query instanceof RegExpQuery,\n        onchange: update\n    });\n    function update() {\n        conf.updateQuery(new (reField.checked ? RegExpQuery : StringQuery)(searchField.value, replaceField.value, !caseField.checked));\n    }\n    function keydown(e) {\n        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.runScopeHandlers)(conf.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(conf.view);\n        }\n        else if (e.keyCode == 13 && e.target == replaceField) {\n            e.preventDefault();\n            replaceNext(conf.view);\n        }\n    }\n    function button(name, onclick, content) {\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n    }\n    let panel = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", { onkeydown: keydown, class: \"cm-search\" }, [\n        searchField,\n        button(\"next\", () => findNext(conf.view), [phrase(\"next\")]),\n        button(\"prev\", () => findPrevious(conf.view), [phrase(\"previous\")]),\n        button(\"select\", () => selectMatches(conf.view), [phrase(\"all\")]),\n        (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [caseField, phrase(\"match case\")]),\n        (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [reField, phrase(\"regexp\")]),\n        (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"),\n        replaceField,\n        button(\"replace\", () => replaceNext(conf.view), [phrase(\"replace\")]),\n        button(\"replaceAll\", () => replaceAll(conf.view), [phrase(\"replace all\")]),\n        (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", { name: \"close\", onclick: () => closeSearchPanel(conf.view), \"aria-label\": phrase(\"close\"), type: \"button\" }, [\"\"])\n    ]);\n    return panel;\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let lineStart = view.state.doc.lineAt(from).from, lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != lineStart) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${view.state.doc.lineAt(from).number}`);\n}\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.fallback(searchHighlighter),\n    baseTheme\n];\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/search/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Text\": () => (/* reexport safe */ _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text),\n/* harmony export */   \"Annotation\": () => (/* binding */ Annotation),\n/* harmony export */   \"AnnotationType\": () => (/* binding */ AnnotationType),\n/* harmony export */   \"ChangeDesc\": () => (/* binding */ ChangeDesc),\n/* harmony export */   \"ChangeSet\": () => (/* binding */ ChangeSet),\n/* harmony export */   \"CharCategory\": () => (/* binding */ CharCategory),\n/* harmony export */   \"Compartment\": () => (/* binding */ Compartment),\n/* harmony export */   \"EditorSelection\": () => (/* binding */ EditorSelection),\n/* harmony export */   \"EditorState\": () => (/* binding */ EditorState),\n/* harmony export */   \"Facet\": () => (/* binding */ Facet),\n/* harmony export */   \"MapMode\": () => (/* binding */ MapMode),\n/* harmony export */   \"Prec\": () => (/* binding */ Prec),\n/* harmony export */   \"SelectionRange\": () => (/* binding */ SelectionRange),\n/* harmony export */   \"StateEffect\": () => (/* binding */ StateEffect),\n/* harmony export */   \"StateEffectType\": () => (/* binding */ StateEffectType),\n/* harmony export */   \"StateField\": () => (/* binding */ StateField),\n/* harmony export */   \"Transaction\": () => (/* binding */ Transaction),\n/* harmony export */   \"combineConfig\": () => (/* binding */ combineConfig)\n/* harmony export */ });\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n\n\n\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/\nvar MapMode = /*@__PURE__*/(function (MapMode) {\n    /**\n    Map a position to a valid new position, even when its context\n    was deleted.\n    */\n    MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /**\n    Return null if deletion happens across the position.\n    */\n    MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /**\n    Return null if the character _before_ the position is deleted.\n    */\n    MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /**\n    Return null if the character _after_ the position is deleted.\n    */\n    MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\nreturn MapMode})(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/\nclass ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    sections) {\n        this.sections = sections;\n    }\n    /**\n    The length of the document before the change.\n    */\n    get length() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2)\n            result += this.sections[i];\n        return result;\n    }\n    /**\n    The length of the document after the change.\n    */\n    get newLength() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /**\n    False when there are actual changes in this set.\n    */\n    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }\n    /**\n    Iterate over the unchanged parts left by these changes.\n    */\n    iterGaps(f) {\n        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            }\n            else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /**\n    Iterate over the ranges changed by these changes. (See\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n    variant that also provides you with the inserted text.)\n    \n    When `individual` is true, adjacent changes (which are kept\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n    reported separately.\n    */\n    iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a description of the inverted form of these changes.\n    */\n    get invertedDesc() {\n        let sections = [];\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0)\n                sections.push(len, ins);\n            else\n                sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /**\n    Compute the combined effect of applying another set of changes\n    after this one. The length of the document after this set should\n    match the length before `other`.\n    */\n    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }\n    /**\n    Map this description, which should start with the same document\n    as `other`, over another set of changes, so that it can be\n    applied after it. When `before` is true, map as if the changes\n    in `other` happened before the ones in `this`.\n    */\n    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos)\n                    return posB + (pos - posA);\n                posB += len;\n            }\n            else {\n                if (mode != MapMode.Simple && endA >= pos &&\n                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||\n                        mode == MapMode.TrackBefore && posA < pos ||\n                        mode == MapMode.TrackAfter && endA > pos))\n                    return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len)\n                    return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA)\n            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /**\n    Check whether these changes touch a given range. When one of the\n    changes entirely covers the range, the string `\"cover\"` is\n    returned.\n    */\n    touchesRange(from, to = from) {\n        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from)\n                return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let result = \"\";\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n    /**\n    Serialize this change desc to a JSON-representable value.\n    */\n    toJSON() { return this.sections; }\n    /**\n    Create a change desc from its JSON representation (as produced\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n    */\n    static fromJSON(json) {\n        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != \"number\"))\n            throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n        return new ChangeDesc(json);\n    }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/\nclass ChangeSet extends ChangeDesc {\n    /**\n    @internal\n    */\n    constructor(sections, \n    /**\n    @internal\n    */\n    inserted) {\n        super(sections);\n        this.inserted = inserted;\n    }\n    /**\n    Apply the changes to a document, returning the modified\n    document.\n    */\n    apply(doc) {\n        if (this.length != doc.length)\n            throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    mapDesc(other, before = false) { return mapSet(this, other, before, true); }\n    /**\n    Given the document as it existed _before_ the changes, return a\n    change set that represents the inverse of this set, which could\n    be used to go from the document created by the changes back to\n    the document as it existed before the changes.\n    */\n    invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for (let i = 0, pos = 0; i < sections.length; i += 2) {\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while (inserted.length < index)\n                    inserted.push(_codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    Combine two subsequent change sets into a single set. `other`\n    must start in the document produced by `this`. If `this` goes\n    `docA`  `docB` and `other` represents `docB`  `docC`, the\n    returned value will represent the change `docA`  `docC`.\n    */\n    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }\n    /**\n    Given another change set starting in the same document, maps this\n    change set over the other, producing a new change set that can be\n    applied to the document produced by applying `other`. When\n    `before` is `true`, order changes as if `this` comes before\n    `other`, otherwise (the default) treat `other` as coming first.\n    \n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    `B.compose(A.map(B, true))` will produce the same document. This\n    provides a basic form of [operational\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    and can be used for collaborative editing.\n    */\n    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }\n    /**\n    Iterate over the changed ranges in the document, calling `f` for\n    each.\n    \n    When `individual` is true, adjacent changes are reported\n    separately.\n    */\n    iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n    set.\n    */\n    get desc() { return new ChangeDesc(this.sections); }\n    /**\n    @internal\n    */\n    filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for (let i = 0, pos = 0;;) {\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while (pos < next || pos == next && iter.len == 0) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0)\n                    addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while (pos < end) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return { changes: new ChangeSet(resultSections, resultInserted),\n            filtered: new ChangeDesc(filteredSections) };\n    }\n    /**\n    Serialize this change set to a JSON-representable value.\n    */\n    toJSON() {\n        let parts = [];\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0)\n                parts.push(len);\n            else if (ins == 0)\n                parts.push([len]);\n            else\n                parts.push([len].concat(this.inserted[i >> 1].toJSON()));\n        }\n        return parts;\n    }\n    /**\n    Create a change set for the given changes, for a document of the\n    given length, using `lineSep` as line separator.\n    */\n    static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length)\n                return;\n            if (pos < length)\n                addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)\n                    process(sub);\n            }\n            else if (spec instanceof ChangeSet) {\n                if (spec.length != length)\n                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            }\n            else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length)\n                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty : typeof insert == \"string\" ? _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0)\n                    return;\n                if (from < pos)\n                    flush();\n                if (from > pos)\n                    addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /**\n    Create an empty changeset of the given length.\n    */\n    static empty(length) {\n        return new ChangeSet(length ? [length, -1] : [], []);\n    }\n    /**\n    Create a changeset from its JSON representation (as produced by\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n    */\n    static fromJSON(json) {\n        if (!Array.isArray(json))\n            throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        let sections = [], inserted = [];\n        for (let i = 0; i < json.length; i++) {\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            }\n            else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i) => i && typeof e != \"string\")) {\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n            }\n            else if (part.length == 1) {\n                sections.push(part[0], 0);\n            }\n            else {\n                while (inserted.length < i)\n                    inserted.push(_codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty);\n                inserted[i] = _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.of(part.slice(1));\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0)\n        return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1])\n        sections[last] += len;\n    else if (len == 0 && sections[last] == 0)\n        sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    }\n    else\n        sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0)\n        return;\n    let index = (sections.length - 2) >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    }\n    else {\n        while (values.length < index)\n            values.push(_codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        }\n        else {\n            let endA = posA, endB = posB, text = _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty;\n            for (;;) {\n                endA += len;\n                endB += ins;\n                if (ins && inserted)\n                    text = text.append(inserted[(i - 2) >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)\n                    break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for (let posA = 0, posB = 0;;) {\n        if (a.ins == -1) {\n            posA += a.len;\n            a.next();\n        }\n        else if (b.ins == -1 && posB < posA) {\n            let skip = Math.min(b.len, posA - posB);\n            b.forward(skip);\n            addSection(sections, skip, -1);\n            posB += skip;\n        }\n        else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {\n            addSection(sections, b.ins, -1);\n            while (posA > posB && !a.done && posA + a.len < posB + b.len) {\n                posA += a.len;\n                a.next();\n            }\n            posB += b.len;\n            b.next();\n        }\n        else if (a.ins >= 0) {\n            let len = 0, end = posA + a.len;\n            for (;;) {\n                if (b.ins >= 0 && posB > posA && posB + b.len < end) {\n                    len += b.ins;\n                    posB += b.len;\n                    b.next();\n                }\n                else if (b.ins == -1 && posB < end) {\n                    let skip = Math.min(b.len, end - posB);\n                    len += skip;\n                    b.forward(skip);\n                    posB += skip;\n                }\n                else {\n                    break;\n                }\n            }\n            addSection(sections, len, a.ins);\n            if (insert)\n                addInsert(insert, sections, a.text);\n            posA = end;\n            a.next();\n        }\n        else if (a.done && b.done) {\n            return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);\n        }\n        else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for (let open = false;;) {\n        if (a.done && b.done) {\n            return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);\n        }\n        else if (a.ins == 0) { // Deletion in A\n            addSection(sections, a.len, 0, open);\n            a.next();\n        }\n        else if (b.len == 0 && !b.done) { // Insertion in B\n            addSection(sections, 0, b.ins, open);\n            if (insert)\n                addInsert(insert, sections, b.text);\n            b.next();\n        }\n        else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n        else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB)\n                    addInsert(insert, sections, b.text);\n            }\n            else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert)\n                    addInsert(insert, sections, a.textBit(len));\n            }\n            else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off)\n                    addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set) {\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        }\n        else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() { return this.ins == -2; }\n    get len2() { return this.ins < 0 ? this.len : this.ins; }\n    get text() {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length ? _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length && !len ? _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty\n            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len)\n            this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1)\n            this.forward(len);\n        else if (len == this.ins)\n            this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/\nclass SelectionRange {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The lower boundary of the range.\n    */\n    from, \n    /**\n    The upper boundary of the range.\n    */\n    to, flags) {\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /**\n    The anchor of the rangethe side that doesn't move when you\n    extend it.\n    */\n    get anchor() { return this.flags & 16 /* Inverted */ ? this.to : this.from; }\n    /**\n    The head of the range, which is moved when the range is\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n    */\n    get head() { return this.flags & 16 /* Inverted */ ? this.from : this.to; }\n    /**\n    True when `anchor` and `head` are at the same position.\n    */\n    get empty() { return this.from == this.to; }\n    /**\n    If this is a cursor that is explicitly associated with the\n    character on one of its sides, this returns the side. -1 means\n    the character before its position, 1 the character after, and 0\n    means no association.\n    */\n    get assoc() { return this.flags & 4 /* AssocBefore */ ? -1 : this.flags & 8 /* AssocAfter */ ? 1 : 0; }\n    /**\n    The bidirectional text level associated with this cursor, if\n    any.\n    */\n    get bidiLevel() {\n        let level = this.flags & 3 /* BidiLevelMask */;\n        return level == 3 ? null : level;\n    }\n    /**\n    The goal column (stored vertical offset) associated with a\n    cursor. This is used to preserve the vertical position when\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n    lines of different length.\n    */\n    get goalColumn() {\n        let value = this.flags >> 5 /* GoalColumnOffset */;\n        return value == 33554431 /* NoGoalColumn */ ? undefined : value;\n    }\n    /**\n    Map this range through a change, producing a valid range in the\n    updated document.\n    */\n    map(change, assoc = -1) {\n        let from = change.mapPos(this.from, assoc), to = change.mapPos(this.to, assoc);\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /**\n    Extend this range to cover at least `from` to `to`.\n    */\n    extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor)\n            return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /**\n    Compare this range to another range.\n    */\n    eq(other) {\n        return this.anchor == other.anchor && this.head == other.head;\n    }\n    /**\n    Return a JSON-serializable object representing the range.\n    */\n    toJSON() { return { anchor: this.anchor, head: this.head }; }\n    /**\n    Convert a JSON representation of a range to a `SelectionRange`\n    instance.\n    */\n    static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/\nclass EditorSelection {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The ranges in the selection, sorted by position. Ranges cannot\n    overlap (but they may touch, if they aren't empty).\n    */\n    ranges, \n    /**\n    The index of the _main_ range in the selection (which is\n    usually the range that was added last).\n    */\n    mainIndex = 0) {\n        this.ranges = ranges;\n        this.mainIndex = mainIndex;\n    }\n    /**\n    Map a selection through a change. Used to adjust the selection\n    position for changes.\n    */\n    map(change, assoc = -1) {\n        if (change.empty)\n            return this;\n        return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);\n    }\n    /**\n    Compare this selection to another selection.\n    */\n    eq(other) {\n        if (this.ranges.length != other.ranges.length ||\n            this.mainIndex != other.mainIndex)\n            return false;\n        for (let i = 0; i < this.ranges.length; i++)\n            if (!this.ranges[i].eq(other.ranges[i]))\n                return false;\n        return true;\n    }\n    /**\n    Get the primary selection range. Usually, you should make sure\n    your code applies to _all_ ranges, by using methods like\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n    */\n    get main() { return this.ranges[this.mainIndex]; }\n    /**\n    Make sure the selection only has one range. Returns a selection\n    holding only the main range from this selection.\n    */\n    asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([this.main]);\n    }\n    /**\n    Extend this selection with an extra range.\n    */\n    addRange(range, main = true) {\n        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /**\n    Replace a given range with another range, and then normalize the\n    selection to merge and sort ranges if necessary.\n    */\n    replaceRange(range, which = this.mainIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /**\n    Convert this selection to an object that can be serialized to\n    JSON.\n    */\n    toJSON() {\n        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };\n    }\n    /**\n    Create a selection from a JSON representation.\n    */\n    static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length)\n            throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);\n    }\n    /**\n    Create a selection holding a single range.\n    */\n    static single(anchor, head = anchor) {\n        return new EditorSelection([EditorSelection.range(anchor, head)], 0);\n    }\n    /**\n    Sort and merge the given set of ranges, creating a valid\n    selection.\n    */\n    static create(ranges, mainIndex = 0) {\n        if (ranges.length == 0)\n            throw new RangeError(\"A selection needs at least one range\");\n        for (let pos = 0, i = 0; i < ranges.length; i++) {\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos)\n                return normalized(ranges.slice(), mainIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n    /**\n    Create a cursor selection range at the given position. You can\n    safely ignore the optional arguments in most situations.\n    */\n    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 /* AssocBefore */ : 8 /* AssocAfter */) |\n            (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) |\n            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* NoGoalColumn */) << 5 /* GoalColumnOffset */));\n    }\n    /**\n    Create a selection range.\n    */\n    static range(anchor, head, goalColumn) {\n        let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* NoGoalColumn */) << 5 /* GoalColumnOffset */;\n        return head < anchor ? new SelectionRange(head, anchor, 16 /* Inverted */ | goal) : new SelectionRange(anchor, head, goal);\n    }\n}\nfunction normalized(ranges, mainIndex = 0) {\n    let main = ranges[mainIndex];\n    ranges.sort((a, b) => a.from - b.from);\n    mainIndex = ranges.indexOf(main);\n    for (let i = 1; i < ranges.length; i++) {\n        let range = ranges[i], prev = ranges[i - 1];\n        if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n            let from = prev.from, to = Math.max(range.to, prev.to);\n            if (i <= mainIndex)\n                mainIndex--;\n            ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n        }\n    }\n    return new EditorSelection(ranges, mainIndex);\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)\n        if (range.to > docLength)\n            throw new RangeError(\"Selection points outside of document\");\n}\n\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of facets are the [theme](https://codemirror.net/6/docs/ref/#view.EditorView^theme) styles\nassociated with an editor or the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) (which is reduced to a single\nvalue, using the input with the hightest precedence).\n*/\nclass Facet {\n    constructor(\n    /**\n    @internal\n    */\n    combine, \n    /**\n    @internal\n    */\n    compareInput, \n    /**\n    @internal\n    */\n    compare, isStatic, \n    /**\n    @internal\n    */\n    extensions) {\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        this.extensions = extensions;\n        /**\n        @internal\n        */\n        this.id = nextID++;\n        this.default = combine([]);\n    }\n    /**\n    Define a new facet.\n    */\n    static define(config = {}) {\n        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);\n    }\n    /**\n    Returns an extension that adds the given value for this facet.\n    */\n    of(value) {\n        return new FacetProvider([], this, 0 /* Static */, value);\n    }\n    /**\n    Create an extension that computes a value for the facet from a\n    state. You must take care to declare the parts of the state that\n    this value depends on, since your function is only called again\n    for a new state when one of those parts changed.\n    \n    In most cases, you'll want to use the\n    [`provide`](https://codemirror.net/6/docs/ref/#state.StateField^define^config.provide) option when\n    defining a field instead.\n    */\n    compute(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Single */, get);\n    }\n    /**\n    Create an extension that computes zero or more values for this\n    facet from a state.\n    */\n    computeN(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Multi */, get);\n    }\n    from(field, get) {\n        if (!get)\n            get = x => x;\n        return this.compute([field], state => get(state.field(field)));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value) {\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let idx = addresses[this.id] >> 1, multi = this.type == 2 /* Multi */;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies) {\n            if (dep == \"doc\")\n                depDoc = true;\n            else if (dep == \"selection\")\n                depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)\n                depAddrs.push(addresses[dep.id]);\n        }\n        return (state, tr) => {\n            if (!tr || tr.reconfigured) {\n                state.values[idx] = getter(state);\n                return 1 /* Changed */;\n            }\n            else {\n                let depChanged = (depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) ||\n                    depAddrs.some(addr => (ensureAddr(state, addr) & 1 /* Changed */) > 0);\n                if (!depChanged)\n                    return 0;\n                let newVal = getter(state), oldVal = tr.startState.values[idx];\n                if (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal))\n                    return 0;\n                state.values[idx] = newVal;\n                return 1 /* Changed */;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!compare(a[i], b[i]))\n            return false;\n    return true;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map(p => addresses[p.id]);\n    let providerTypes = providers.map(p => p.type);\n    let dynamic = providerAddrs.filter(p => !(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    return (state, tr) => {\n        let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1;\n        let changed = oldAddr == null;\n        for (let dynAddr of dynamic) {\n            if (ensureAddr(state, dynAddr) & 1 /* Changed */)\n                changed = true;\n        }\n        if (!changed)\n            return 0;\n        let values = [];\n        for (let i = 0; i < providerAddrs.length; i++) {\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Multi */)\n                for (let val of value)\n                    values.push(val);\n            else\n                values.push(value);\n        }\n        let newVal = facet.combine(values);\n        if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr)))\n            return 0;\n        state.values[idx] = newVal;\n        return 1 /* Changed */;\n    };\n}\nfunction maybeIndex(state, id) {\n    let found = state.config.address[id];\n    return found == null ? null : found >> 1;\n}\nconst initField = /*@__PURE__*/Facet.define({ static: true });\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/\nclass StateField {\n    constructor(\n    /**\n    @internal\n    */\n    id, createF, updateF, compareF, \n    /**\n    @internal\n    */\n    spec) {\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.spec = spec;\n        /**\n        @internal\n        */\n        this.provides = undefined;\n    }\n    /**\n    Define a state field.\n    */\n    static define(config) {\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);\n        if (config.provide)\n            field.provides = config.provide(field);\n        return field;\n    }\n    create(state) {\n        let init = state.facet(initField).find(i => i.field == this);\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /**\n    @internal\n    */\n    slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return (state, tr) => {\n            if (!tr || (tr.reconfigured && maybeIndex(tr.startState, this.id) == null)) {\n                state.values[idx] = this.create(state);\n                return 1 /* Changed */;\n            }\n            let oldVal, changed = 0;\n            if (tr.reconfigured) {\n                oldVal = tr.startState.values[maybeIndex(tr.startState, this.id)];\n                changed = 1 /* Changed */;\n            }\n            else {\n                oldVal = tr.startState.values[idx];\n            }\n            let value = this.updateF(oldVal, tr);\n            if (!changed && !this.compareF(oldVal, value))\n                changed = 1 /* Changed */;\n            if (changed)\n                state.values[idx] = value;\n            return changed;\n        };\n    }\n    /**\n    Returns an extension that enables this field and overrides the\n    way it is initialized. Can be useful when you need to provide a\n    non-default starting value for the field.\n    */\n    init(create) {\n        return [this, initField.of({ field: this, create })];\n    }\n    /**\n    State field instances can be used as\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n    given state.\n    */\n    get extension() { return this; }\n}\nconst Prec_ = { fallback: 3, default: 2, extend: 1, override: 0 };\nfunction prec(value) {\n    return (ext) => new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/\nconst Prec = {\n    /**\n    A precedence below the default precedence, which will cause\n    default-precedence extensions to override it even if they are\n    specified later in the extension ordering.\n    */\n    fallback: /*@__PURE__*/prec(Prec_.fallback),\n    /**\n    The regular default precedence.\n    */\n    default: /*@__PURE__*/prec(Prec_.default),\n    /**\n    A higher-than-default precedence.\n    */\n    extend: /*@__PURE__*/prec(Prec_.extend),\n    /**\n    Precedence above the `default` and `extend` precedences.\n    */\n    override: /*@__PURE__*/prec(Prec_.override)\n};\nclass PrecExtension {\n    constructor(inner, prec) {\n        this.inner = inner;\n        this.prec = prec;\n    }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/\nclass Compartment {\n    /**\n    Create an instance of this compartment to add to your [state\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n    */\n    of(ext) { return new CompartmentInstance(this, ext); }\n    /**\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n    reconfigures this compartment.\n    */\n    reconfigure(content) {\n        return Compartment.reconfigure.of({ compartment: this, extension: content });\n    }\n    /**\n    Get the current content of the compartment in the state, or\n    `undefined` if it isn't present.\n    */\n    get(state) {\n        return state.config.compartments.get(this);\n    }\n}\nclass CompartmentInstance {\n    constructor(compartment, inner) {\n        this.compartment = compartment;\n        this.inner = inner;\n    }\n}\nclass Configuration {\n    constructor(base, compartments, dynamicSlots, address, staticValues) {\n        this.base = base;\n        this.compartments = compartments;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.statusTemplate = [];\n        while (this.statusTemplate.length < dynamicSlots.length)\n            this.statusTemplate.push(0 /* Uninitialized */);\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(base, compartments, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        let newCompartments = new Map();\n        for (let ext of flatten(base, compartments, newCompartments)) {\n            if (ext instanceof StateField)\n                fields.push(ext);\n            else\n                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields) {\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => field.slot(a));\n        }\n        for (let id in facets) {\n            let providers = facets[id], facet = providers[0].facet;\n            if (providers.every(p => p.type == 0 /* Static */)) {\n                address[facet.id] = (staticValues.length << 1) | 1;\n                let value = facet.combine(providers.map(p => p.value));\n                let oldAddr = oldState ? oldState.config.address[facet.id] : null;\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (facet.compare(value, oldVal))\n                        value = oldVal;\n                }\n                staticValues.push(value);\n            }\n            else {\n                for (let p of providers) {\n                    if (p.type == 0 /* Static */) {\n                        address[p.id] = (staticValues.length << 1) | 1;\n                        staticValues.push(p.value);\n                    }\n                    else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push(a => p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        return new Configuration(base, newCompartments, dynamicSlots.map(f => f(address)), address, staticValues);\n    }\n}\nfunction flatten(extension, compartments, newCompartments) {\n    let result = [[], [], [], []];\n    let seen = new Map();\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known >= prec)\n                return;\n            let found = result[known].indexOf(ext);\n            if (found > -1)\n                result[known].splice(found, 1);\n            if (ext instanceof CompartmentInstance)\n                newCompartments.delete(ext.compartment);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)\n                inner(e, prec);\n        }\n        else if (ext instanceof CompartmentInstance) {\n            if (newCompartments.has(ext.compartment))\n                throw new RangeError(`Duplicate use of compartment in extensions`);\n            let content = compartments.get(ext.compartment) || ext.inner;\n            newCompartments.set(ext.compartment, content);\n            inner(content, prec);\n        }\n        else if (ext instanceof PrecExtension) {\n            inner(ext.inner, ext.prec);\n        }\n        else if (ext instanceof StateField) {\n            result[prec].push(ext);\n            if (ext.provides)\n                inner(ext.provides, prec);\n        }\n        else if (ext instanceof FacetProvider) {\n            result[prec].push(ext);\n            if (ext.facet.extensions)\n                inner(ext.facet.extensions, prec);\n        }\n        else {\n            let content = ext.extension;\n            if (!content)\n                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n            inner(content, prec);\n        }\n    }\n    inner(extension, Prec_.default);\n    return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1)\n        return 2 /* Computed */;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* Computing */)\n        throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* Computed */)\n        return status;\n    state.status[idx] = 4 /* Computing */;\n    let changed = state.config.dynamicSlots[idx](state, state.applying);\n    return state.status[idx] = 2 /* Computed */ | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\n\nconst languageData = /*@__PURE__*/Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/Facet.define({\n    combine: values => values.some(v => v),\n    static: true\n});\nconst lineSeparator = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = /*@__PURE__*/Facet.define();\nconst transactionFilter = /*@__PURE__*/Facet.define();\nconst transactionExtender = /*@__PURE__*/Facet.define();\nconst readOnly = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : false\n});\n\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/\nclass Annotation {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The annotation type.\n    */\n    type, \n    /**\n    The value of this annotation.\n    */\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Define a new type of annotation.\n    */\n    static define() { return new AnnotationType(); }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/\nclass AnnotationType {\n    /**\n    Create an instance of this annotation.\n    */\n    of(value) { return new Annotation(this, value); }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/\nclass StateEffectType {\n    /**\n    @internal\n    */\n    constructor(\n    // The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /**\n    @internal\n    */\n    map) {\n        this.map = map;\n    }\n    /**\n    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n    type.\n    */\n    of(value) { return new StateEffect(this, value); }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/\nclass StateEffect {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    type, \n    /**\n    The value of this effect.\n    */\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Map this effect through a position mapping. Will return\n    `undefined` when that ends up deleting the effect.\n    */\n    map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /**\n    Tells you whether this effect object is of a given\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n    */\n    is(type) { return this.type == type; }\n    /**\n    Define a new effect type. The type parameter indicates the type\n    of values that his effect holds.\n    */\n    static define(spec = {}) {\n        return new StateEffectType(spec.map || (v => v));\n    }\n    /**\n    Map an array of effects through a change set.\n    */\n    static mapEffects(effects, mapping) {\n        if (!effects.length)\n            return effects;\n        let result = [];\n        for (let effect of effects) {\n            let mapped = effect.map(mapping);\n            if (mapped)\n                result.push(mapped);\n        }\n        return result;\n    }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/\nStateEffect.reconfigure = /*@__PURE__*/StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/\nStateEffect.appendConfig = /*@__PURE__*/StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n*/\nclass Transaction {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The state from which the transaction starts.\n    */\n    startState, \n    /**\n    The document changes made by this transaction.\n    */\n    changes, \n    /**\n    The selection set by this transaction, or undefined if it\n    doesn't explicitly set a selection.\n    */\n    selection, \n    /**\n    The effects added to the transaction.\n    */\n    effects, \n    /**\n    @internal\n    */\n    annotations, \n    /**\n    Whether the selection should be scrolled into view after this\n    transaction is dispatched.\n    */\n    scrollIntoView) {\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.scrollIntoView = scrollIntoView;\n        /**\n        @internal\n        */\n        this._doc = null;\n        /**\n        @internal\n        */\n        this._state = null;\n        if (selection)\n            checkSelection(selection, changes.newLength);\n        if (!annotations.some((a) => a.type == Transaction.time))\n            this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /**\n    The new document produced by the transaction. Contrary to\n    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n    force the entire new state to be computed right away, so it is\n    recommended that [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n    when they need to look at the new document.\n    */\n    get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /**\n    The new selection produced by the transaction. If\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n    current selection through the changes made by the transaction.\n    */\n    get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /**\n    The new state created by the transaction. Computed on demand\n    (but retained for subsequent access), so itis recommended not to\n    access it in [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n    */\n    get state() {\n        if (!this._state)\n            this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /**\n    Get the value of the given annotation type, if any.\n    */\n    annotation(type) {\n        for (let ann of this.annotations)\n            if (ann.type == type)\n                return ann.value;\n        return undefined;\n    }\n    /**\n    Indicates whether the transaction changed the document.\n    */\n    get docChanged() { return !this.changes.empty; }\n    /**\n    Indicates whether this transaction reconfigures the state\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n    with a top-level configuration\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n    */\n    get reconfigured() { return this.startState.config != this.state.config; }\n    /**\n    Returns true if the transaction has a [user\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n    or more specific than `event`. For example, if the transaction\n    has `\"select.pointer\"` as user event, `\"select\"` and\n    `\"select.pointer\"` will match it.\n    */\n    isUserEvent(event) {\n        let e = this.annotation(Transaction.userEvent);\n        return e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\");\n    }\n}\n/**\nAnnotation used to store transaction timestamps.\n*/\nTransaction.time = /*@__PURE__*/Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/\nTransaction.userEvent = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/\nTransaction.addToHistory = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/\nTransaction.remote = /*@__PURE__*/Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for (let iA = 0, iB = 0;;) {\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        }\n        else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        }\n        else\n            return result;\n        if (!result.length || result[result.length - 1] < from)\n            result.push(from, to);\n        else if (result[result.length - 1] < to)\n            result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    }\n    else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let sel = spec.selection, annotations = asArray(spec.annotations);\n    if (spec.userEvent)\n        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes\n            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations,\n        scrollIntoView: !!spec.scrollIntoView\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false)\n        filter = false;\n    for (let i = 1; i < specs.length; i++) {\n        if (specs[i].filter === false)\n            filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = new Transaction(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)) {\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value))\n            result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        }\n        else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.invertedDesc;\n        }\n        tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for (let i = filters.length - 1; i >= 0; i--) {\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction)\n            tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)\n            tr = filtered[0];\n        else\n            tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for (let i = extenders.length - 1; i >= 0; i--) {\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length)\n            spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [value];\n}\n\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/\nvar CharCategory = /*@__PURE__*/(function (CharCategory) {\n    /**\n    Word characters.\n    */\n    CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    /**\n    Whitespace.\n    */\n    CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    /**\n    Anything else.\n    */\n    CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\nreturn CharCategory})(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) { }\nfunction hasWordChar(str) {\n    if (wordChar)\n        return wordChar.test(str);\n    for (let i = 0; i < str.length; i++) {\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))\n            return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char) => {\n        if (!/\\S/.test(char))\n            return CharCategory.Space;\n        if (hasWordChar(char))\n            return CharCategory.Word;\n        for (let i = 0; i < wordChars.length; i++)\n            if (char.indexOf(wordChars[i]) > -1)\n                return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/\nclass EditorState {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    config, \n    /**\n    The current document.\n    */\n    doc, \n    /**\n    The current selection.\n    */\n    selection, tr = null) {\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        /**\n        @internal\n        */\n        this.applying = null;\n        this.status = config.statusTemplate.slice();\n        if (tr && tr.startState.config == config) {\n            this.values = tr.startState.values.slice();\n        }\n        else {\n            this.values = config.dynamicSlots.map(_ => null);\n            // Copy over old values for shared facets/fields if this is a reconfigure\n            if (tr)\n                for (let id in config.address) {\n                    let cur = config.address[id], prev = tr.startState.config.address[id];\n                    if (prev != null && (cur & 1) == 0)\n                        this.values[cur >> 1] = getAddr(tr.startState, prev);\n                }\n        }\n        this.applying = tr;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr)\n            tr._state = this;\n        for (let i = 0; i < this.config.dynamicSlots.length; i++)\n            ensureAddr(this, i << 1);\n        this.applying = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require)\n                throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n    can be passed. Unless\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n    are assumed to start in the _current_ document (not the document\n    produced by previous specs), and its\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n    to the document created by its _own_ changes. The resulting\n    transaction contains the combined effect of all the different\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n    specs take precedence over earlier ones.\n    */\n    update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /**\n    @internal\n    */\n    applyTransaction(tr) {\n        let conf = this.config, { base, compartments } = conf;\n        for (let effect of tr.effects) {\n            if (effect.is(Compartment.reconfigure)) {\n                if (conf) {\n                    compartments = new Map;\n                    conf.compartments.forEach((val, key) => compartments.set(key, val));\n                    conf = null;\n                }\n                compartments.set(effect.value.compartment, effect.value.extension);\n            }\n            else if (effect.is(StateEffect.reconfigure)) {\n                conf = null;\n                base = effect.value;\n            }\n            else if (effect.is(StateEffect.appendConfig)) {\n                conf = null;\n                base = asArray(base).concat(effect.value);\n            }\n        }\n        new EditorState(conf || Configuration.resolve(base, compartments, this), tr.newDoc, tr.newSelection, tr);\n    }\n    /**\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n    replaces every selection range with the given content.\n    */\n    replaceSelection(text) {\n        if (typeof text == \"string\")\n            text = this.toText(text);\n        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },\n            range: EditorSelection.cursor(range.from + text.length) }));\n    }\n    /**\n    Create a set of changes and a new selection by running the given\n    function for each range in the active selection. The function\n    can return an optional set of changes (in the coordinate space\n    of the start document), plus an updated range (in the coordinate\n    space of the document produced by the call's own changes). This\n    method will merge all the changes and ranges into a single\n    changeset and selection, and return it as a [transaction\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n    */\n    changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [result1.range];\n        let effects = asArray(result1.effects);\n        for (let i = 1; i < sel.ranges.length; i++) {\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for (let j = 0; j < i; j++)\n                ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.mainIndex),\n            effects\n        };\n    }\n    /**\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n    description, taking the state's document length and line\n    separator into account.\n    */\n    changes(spec = []) {\n        if (spec instanceof ChangeSet)\n            return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /**\n    Using the state's [line\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n    [`Text`](https://codemirror.net/6/docs/ref/#text.Text) instance from the given string.\n    */\n    toText(string) {\n        return _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /**\n    Return the given range of the document as a string.\n    */\n    sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /**\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n    */\n    facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null)\n            return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Convert this state to a JSON-serializable object. When custom\n    fields should be serialized, you can pass them in as an object\n    mapping property names (in the resulting object, which should\n    not use `doc` or `selection`) to fields.\n    */\n    toJSON(fields) {\n        let result = {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n        if (fields)\n            for (let prop in fields) {\n                let value = fields[prop];\n                if (value instanceof StateField)\n                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n            }\n        return result;\n    }\n    /**\n    Deserialize a state from its JSON representation. When custom\n    fields should be deserialized, pass the same object you passed\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n    third argument.\n    */\n    static fromJSON(json, config = {}, fields) {\n        if (!json || typeof json.doc != \"string\")\n            throw new RangeError(\"Invalid JSON representation for EditorState\");\n        let fieldInit = [];\n        if (fields)\n            for (let prop in fields) {\n                let field = fields[prop], value = json[prop];\n                fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));\n            }\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit\n        });\n    }\n    /**\n    Create a new state. You'll usually only need this when\n    initializing an editorupdated states are created by applying\n    transactions.\n    */\n    static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || [], new Map);\n        let doc = config.doc instanceof _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text ? config.doc\n            : _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0)\n            : config.selection instanceof EditorSelection ? config.selection\n                : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections))\n            selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection);\n    }\n    /**\n    The size (in columns) of a tab in the document, determined by\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n    */\n    get tabSize() { return this.facet(EditorState.tabSize); }\n    /**\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n    string for this state.\n    */\n    get lineBreak() { return this.facet(EditorState.lineSeparator) || \"\\n\"; }\n    /**\n    Returns true when the editor is\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n    */\n    get readOnly() { return this.facet(readOnly); }\n    /**\n    Look up a translation for the given phrase (via the\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n    original string if no translation is found.\n    */\n    phrase(phrase) {\n        for (let map of this.facet(EditorState.phrases))\n            if (Object.prototype.hasOwnProperty.call(map, phrase))\n                return map[phrase];\n        return phrase;\n    }\n    /**\n    Find the values for a given language data field, provided by the\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n    */\n    languageDataAt(name, pos, side = -1) {\n        let values = [];\n        for (let provider of this.facet(languageData)) {\n            for (let result of provider(this, pos, side)) {\n                if (Object.prototype.hasOwnProperty.call(result, name))\n                    values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /**\n    Return a function that can categorize strings (expected to\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#text.findClusterBreak))\n    into one of:\n    \n     - Word (contains an alphanumeric character or a character\n       explicitly listed in the local language's `\"wordChars\"`\n       language data, which should be a string)\n     - Space (contains only whitespace)\n     - Other (anything else)\n    */\n    charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n    /**\n    Find the word at the given position, meaning the range\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n    around it. If no word characters are adjacent to the position,\n    this returns null.\n    */\n    wordAt(pos) {\n        let { text, from, length } = this.doc.lineAt(pos);\n        let cat = this.charCategorizer(pos);\n        let start = pos - from, end = pos - from;\n        while (start > 0) {\n            let prev = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(text, start, false);\n            if (cat(text.slice(prev, start)) != CharCategory.Word)\n                break;\n            start = prev;\n        }\n        while (end < length) {\n            let next = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(text, end);\n            if (cat(text.slice(end, next)) != CharCategory.Word)\n                break;\n            end = next;\n        }\n        return start == end ? null : EditorSelection.range(start + from, end + from);\n    }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/\nEditorState.tabSize = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/\nEditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/\nEditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/\nEditorState.phrases = /*@__PURE__*/Facet.define();\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/\nEditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two number indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/\nEditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/\nEditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are applied.\n*/\nEditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/StateEffect.define();\n\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. Will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/\nfunction combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n    let result = {};\n    for (let config of configs)\n        for (let key of Object.keys(config)) {\n            let value = config[key], current = result[key];\n            if (current === undefined)\n                result[key] = value;\n            else if (current === value || value === undefined) ; // No conflict\n            else if (Object.hasOwnProperty.call(combine, key))\n                result[key] = combine[key](current, value);\n            else\n                throw new Error(\"Config merge conflict for field \" + key);\n        }\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/state/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/text/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/text/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Line\": () => (/* binding */ Line),\n/* harmony export */   \"Text\": () => (/* binding */ Text),\n/* harmony export */   \"codePointAt\": () => (/* binding */ codePointAt),\n/* harmony export */   \"codePointSize\": () => (/* binding */ codePointSize),\n/* harmony export */   \"countColumn\": () => (/* binding */ countColumn),\n/* harmony export */   \"findClusterBreak\": () => (/* binding */ findClusterBreak),\n/* harmony export */   \"findColumn\": () => (/* binding */ findColumn),\n/* harmony export */   \"fromCodePoint\": () => (/* binding */ fromCodePoint)\n/* harmony export */ });\n// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = /*@__PURE__*/\"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(s => s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor (let i = 1; i < extend.length; i++)\n    extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n    for (let i = 1; i < extend.length; i += 2)\n        if (extend[i] > code)\n            return extend[i - 1] <= code;\n    return false;\n}\nfunction isRegionalIndicator(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters, characters\njoined with zero-width joiners, and flag emoji.\n*/\nfunction findClusterBreak(str, pos, forward = true) {\n    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);\n}\nfunction nextClusterBreak(str, pos) {\n    if (pos == str.length)\n        return pos;\n    // If pos is in the middle of a surrogate pair, move to its start\n    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))\n        pos--;\n    let prev = codePointAt(str, pos);\n    pos += codePointSize(prev);\n    while (pos < str.length) {\n        let next = codePointAt(str, pos);\n        if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {\n            pos += codePointSize(next);\n            prev = next;\n        }\n        else if (isRegionalIndicator(next)) {\n            let countBefore = 0, i = pos - 2;\n            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\n                countBefore++;\n                i -= 2;\n            }\n            if (countBefore % 2 == 0)\n                break;\n            else\n                pos += 2;\n        }\n        else {\n            break;\n        }\n    }\n    return pos;\n}\nfunction prevClusterBreak(str, pos) {\n    while (pos > 0) {\n        let found = nextClusterBreak(str, pos - 2);\n        if (found < pos)\n            return found;\n        pos--;\n    }\n    return 0;\n}\nfunction surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }\nfunction surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1))\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe first character that takes up two positions in a JavaScript\nstring. It is often useful to compare with this after calling\n`codePointAt`, to figure out whether your character takes up 1 or\n2 index positions.\n*/\nfunction codePointSize(code) { return code < 0x10000 ? 1 : 2; }\n\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/\nfunction countColumn(string, tabSize, to = string.length) {\n    let n = 0;\n    for (let i = 0; i < to;) {\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - (n % tabSize);\n            i++;\n        }\n        else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/\nfunction findColumn(string, col, tabSize, strict) {\n    for (let i = 0, n = 0;;) {\n        if (n >= col)\n            return i;\n        if (i == string.length)\n            break;\n        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;\n        i = findClusterBreak(string, i);\n    }\n    return strict === true ? -1 : string.length;\n}\n\n/**\nThe data structure for documents.\n*/\nclass Text {\n    /**\n    @internal\n    */\n    constructor() { }\n    /**\n    Get the line description around the given position.\n    */\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /**\n    Get the description for the given (1-based) line number.\n    */\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /**\n    Replace a range of the text with the given content.\n    */\n    replace(from, to, text) {\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* To */);\n        if (text.length)\n            text.decompose(0, text.length, parts, 1 /* From */ | 2 /* To */);\n        this.decompose(to, this.length, parts, 1 /* From */);\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /**\n    Append another document to this one.\n    */\n    append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /**\n    Retrieve the text between the given points.\n    */\n    slice(from, to = this.length) {\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /**\n    Test whether this text is equal to another instance.\n    */\n    eq(other) {\n        if (other == this)\n            return true;\n        if (other.length != this.length || other.lines != this.lines)\n            return false;\n        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for (let skip = start, pos = start;;) {\n            a.next(skip);\n            b.next(skip);\n            skip = 0;\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)\n                return false;\n            pos += a.value.length;\n            if (a.done || pos >= end)\n                return true;\n        }\n    }\n    /**\n    Iterate over the text. When `dir` is `-1`, iteration happens\n    from end to start. This will return lines and the breaks between\n    them as separate strings, and for long lines, might split lines\n    themselves into multiple chunks as well.\n    */\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /**\n    Iterate over a range of the text. When `from` > `to`, the\n    iterator will run in reverse.\n    */\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /**\n    Return a cursor that iterates over the given range of lines,\n    _without_ returning the line breaks between, and yielding empty\n    strings for empty lines.\n    \n    When `from` and `to` are given, they should be 1-based line numbers.\n    */\n    iterLines(from, to) {\n        let inner;\n        if (from == null) {\n            inner = this.iter();\n        }\n        else {\n            if (to == null)\n                to = this.lines + 1;\n            let start = this.line(from).from;\n            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n        }\n        return new LineCursor(inner);\n    }\n    /**\n    @internal\n    */\n    toString() { return this.sliceString(0); }\n    /**\n    Convert the document to an array of lines (which can be\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#text.Text^of)).\n    */\n    toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /**\n    Create a `Text` instance for the given array of lines.\n    */\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0])\n            return Text.empty;\n        return text.length <= 32 /* Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this\n            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* From */) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Branch */) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            }\n            else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        }\n        else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf))\n            return super.replace(from, to, text);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Branch */)\n            return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)\n            target.push(line);\n    }\n    scanIdentical() { return 0; }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text) {\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Branch */) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1)\n            target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)\n            this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target)\n                return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* From */ : 0) | (end >= to ? 2 /* To */ : 0));\n                if (pos >= from && end <= to && !childOpen)\n                    target.push(child);\n                else\n                    child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        if (text.lines < this.lines)\n            for (let i = 0, pos = 0; i < this.children.length; i++) {\n                let child = this.children[i], end = pos + child.length;\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                if (from >= pos && to <= end) {\n                    let updated = child.replace(from - pos, to - pos, text);\n                    let totalLines = this.lines - child.lines + updated.lines;\n                    if (updated.lines < (totalLines >> (5 /* BranchShift */ - 1)) &&\n                        updated.lines > (totalLines >> (5 /* BranchShift */ + 1))) {\n                        let copy = this.children.slice();\n                        copy[i] = updated;\n                        return new TextNode(copy, this.length - (to - from) + text.length);\n                    }\n                    return super.replace(pos, end, updated);\n                }\n                pos = end + 1;\n            }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)\n            child.flatten(target);\n    }\n    scanIdentical(other, dir) {\n        if (!(other instanceof TextNode))\n            return 0;\n        let length = 0;\n        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]\n            : [this.children.length - 1, other.children.length - 1, -1, -1];\n        for (;; iA += dir, iB += dir) {\n            if (iA == eA || iB == eB)\n                return length;\n            let chA = this.children[iA], chB = other.children[iB];\n            if (chA != chB)\n                return length + chA.scanIdentical(chB, dir);\n            length += chA.length + 1;\n        }\n    }\n    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)\n            lines += ch.lines;\n        if (lines < 32 /* Branch */) {\n            let flat = [];\n            for (let ch of children)\n                ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Branch */, lines >> 5 /* BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLines &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.lines + last.lines <= 32 /* Branch */) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            }\n            else {\n                if (currentLines + child.lines > chunk)\n                    flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = /*@__PURE__*/new TextLeaf([\"\"], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];\n    }\n    nextInner(skip, dir) {\n        this.done = this.lineBreak = false;\n        for (;;) {\n            let last = this.nodes.length - 1;\n            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (dir > 0 ? size : 0)) {\n                if (last == 0) {\n                    this.done = true;\n                    this.value = \"\";\n                    return this;\n                }\n                if (dir > 0)\n                    this.offsets[last - 1]++;\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n                this.offsets[last] += dir;\n                if (skip == 0) {\n                    this.lineBreak = true;\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            }\n            else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset + (dir < 0 ? -1 : 0)];\n                this.offsets[last] += dir;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else {\n                let next = top.children[offset + (dir < 0 ? -1 : 0)];\n                if (skip > next.length) {\n                    skip -= next.length;\n                    this.offsets[last] += dir;\n                }\n                else {\n                    if (dir < 0)\n                        this.offsets[last]--;\n                    this.nodes.push(next);\n                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n                }\n            }\n        }\n    }\n    next(skip = 0) {\n        if (skip < 0) {\n            this.nextInner(-skip, (-this.dir));\n            skip = this.value.length;\n        }\n        return this.nextInner(skip, this.dir);\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.done = false;\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        this.pos = start > end ? text.length : 0;\n        this.from = Math.min(start, end);\n        this.to = Math.max(start, end);\n    }\n    nextInner(skip, dir) {\n        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n            this.value = \"\";\n            this.done = true;\n            return this;\n        }\n        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n        if (skip > limit)\n            skip = limit;\n        limit -= skip;\n        let { value } = this.cursor.next(skip);\n        this.pos += (value.length + skip) * dir;\n        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n        this.done = !this.value;\n        return this;\n    }\n    next(skip = 0) {\n        if (skip < 0)\n            skip = Math.max(skip, this.from - this.pos);\n        else if (skip > 0)\n            skip = Math.min(skip, this.to - this.pos);\n        return this.nextInner(skip, this.cursor.dir);\n    }\n    get lineBreak() { return this.cursor.lineBreak && this.value != \"\"; }\n}\nclass LineCursor {\n    constructor(inner) {\n        this.inner = inner;\n        this.afterBreak = true;\n        this.value = \"\";\n        this.done = false;\n    }\n    next(skip = 0) {\n        let { done, lineBreak, value } = this.inner.next(skip);\n        if (done) {\n            this.done = true;\n            this.value = \"\";\n        }\n        else if (lineBreak) {\n            if (this.afterBreak) {\n                this.value = \"\";\n            }\n            else {\n                this.afterBreak = true;\n                this.next();\n            }\n        }\n        else {\n            this.value = value;\n            this.afterBreak = false;\n        }\n        return this;\n    }\n    get lineBreak() { return false; }\n}\nif (typeof Symbol != \"undefined\") {\n    Text.prototype[Symbol.iterator] = function () { return this.iter(); };\n    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =\n        LineCursor.prototype[Symbol.iterator] = function () { return this; };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#text.Text.lineAt).\n*/\nclass Line {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The position of the start of the line.\n    */\n    from, \n    /**\n    The position at the end of the line (_before_ the line break,\n    or at the end of document for the last line).\n    */\n    to, \n    /**\n    This line's line number (1-based).\n    */\n    number, \n    /**\n    The line's content.\n    */\n    text) {\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /**\n    The length of the line (not including any line break after it).\n    */\n    get length() { return this.to - this.from; }\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/text/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/tooltip/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@codemirror/tooltip/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hoverTooltip\": () => (/* binding */ hoverTooltip),\n/* harmony export */   \"showTooltip\": () => (/* binding */ showTooltip),\n/* harmony export */   \"tooltips\": () => (/* binding */ tooltips)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n\n\n\nvar _a;\nconst ios = typeof navigator != \"undefined\" &&\n    !/*@__PURE__*//Edge\\/(\\d+)/.exec(navigator.userAgent) && /*@__PURE__*//Apple Computer/.test(navigator.vendor) &&\n    (/*@__PURE__*//Mobile\\/\\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);\nconst Outside = \"-10000px\";\nclass TooltipViewManager {\n    constructor(view, facet, createTooltipView) {\n        this.facet = facet;\n        this.createTooltipView = createTooltipView;\n        this.input = view.state.facet(facet);\n        this.tooltips = this.input.filter(t => t);\n        this.tooltipViews = this.tooltips.map(createTooltipView);\n    }\n    update(update) {\n        let input = update.state.facet(this.facet);\n        let tooltips = input.filter(x => x);\n        if (input === this.input) {\n            for (let t of this.tooltipViews)\n                if (t.update)\n                    t.update(update);\n            return { shouldMeasure: false };\n        }\n        let tooltipViews = [];\n        for (let i = 0; i < tooltips.length; i++) {\n            let tip = tooltips[i], known = -1;\n            if (!tip)\n                continue;\n            for (let i = 0; i < this.tooltips.length; i++) {\n                let other = this.tooltips[i];\n                if (other && other.create == tip.create)\n                    known = i;\n            }\n            if (known < 0) {\n                tooltipViews[i] = this.createTooltipView(tip);\n            }\n            else {\n                let tooltipView = tooltipViews[i] = this.tooltipViews[known];\n                if (tooltipView.update)\n                    tooltipView.update(update);\n            }\n        }\n        for (let t of this.tooltipViews)\n            if (tooltipViews.indexOf(t) < 0)\n                t.dom.remove();\n        this.input = input;\n        this.tooltips = tooltips;\n        this.tooltipViews = tooltipViews;\n        return { shouldMeasure: true };\n    }\n}\n/**\nReturn an extension that configures tooltip behavior.\n*/\nfunction tooltips(config = {}) {\n    return tooltipConfig.of(config);\n}\nconst tooltipConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n    combine: values => {\n        var _a, _b;\n        return ({\n            position: ios ? \"absolute\" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n            parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null\n        });\n    }\n});\nconst tooltipPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.inView = true;\n        let config = view.state.facet(tooltipConfig);\n        this.position = config.position;\n        this.parent = config.parent;\n        this.classes = view.themeClasses;\n        this.createContainer();\n        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };\n        this.manager = new TooltipViewManager(view, showTooltip, t => this.createTooltip(t));\n        this.maybeMeasure();\n    }\n    createContainer() {\n        if (this.parent) {\n            this.container = document.createElement(\"div\");\n            this.container.style.position = \"relative\";\n            this.container.className = this.view.themeClasses;\n            this.parent.appendChild(this.container);\n        }\n        else {\n            this.container = this.view.dom;\n        }\n    }\n    update(update) {\n        let { shouldMeasure } = this.manager.update(update);\n        let newConfig = update.state.facet(tooltipConfig);\n        if (newConfig.position != this.position) {\n            this.position = newConfig.position;\n            for (let t of this.manager.tooltipViews)\n                t.dom.style.position = this.position;\n            shouldMeasure = true;\n        }\n        if (newConfig.parent != this.parent) {\n            if (this.parent)\n                this.container.remove();\n            this.parent = newConfig.parent;\n            this.createContainer();\n            for (let t of this.manager.tooltipViews)\n                this.container.appendChild(t.dom);\n            shouldMeasure = true;\n        }\n        else if (this.parent && this.view.themeClasses != this.classes) {\n            this.classes = this.container.className = this.view.themeClasses;\n        }\n        if (shouldMeasure)\n            this.maybeMeasure();\n    }\n    createTooltip(tooltip) {\n        let tooltipView = tooltip.create(this.view);\n        tooltipView.dom.classList.add(\"cm-tooltip\");\n        if (tooltip.arrow)\n            tooltipView.dom.classList.add(\"cm-tooltip-arrow\");\n        tooltipView.dom.style.position = this.position;\n        tooltipView.dom.style.top = Outside;\n        this.container.appendChild(tooltipView.dom);\n        if (tooltipView.mount)\n            tooltipView.mount(this.view);\n        return tooltipView;\n    }\n    destroy() {\n        for (let { dom } of this.manager.tooltipViews)\n            dom.remove();\n    }\n    readMeasure() {\n        let editor = this.view.dom.getBoundingClientRect();\n        return {\n            editor,\n            parent: this.parent ? this.container.getBoundingClientRect() : editor,\n            pos: this.manager.tooltips.map(t => this.view.coordsAtPos(t.pos)),\n            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),\n            innerWidth: window.innerWidth,\n            innerHeight: window.innerHeight\n        };\n    }\n    writeMeasure(measured) {\n        let { editor } = measured;\n        let others = [];\n        for (let i = 0; i < this.manager.tooltips.length; i++) {\n            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || pos.bottom <= editor.top || pos.top >= editor.bottom || pos.right <= editor.left || pos.left >= editor.right) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let arrow = !!tooltip.arrow, above = !!tooltip.above;\n            let width = size.right - size.left, height = size.bottom - size.top + (arrow ? 7 /* Size */ : 0);\n            let left = this.view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Direction.LTR\n                ? Math.min(pos.left - (arrow ? 14 /* Offset */ : 0), measured.innerWidth - width)\n                : Math.max(0, pos.left - width + (arrow ? 14 /* Offset */ : 0));\n            if (!tooltip.strictSide &&\n                (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight))\n                above = !above;\n            let top = above ? pos.top - height : pos.bottom + (arrow ? 7 /* Size */ : 0), right = left + width;\n            for (let r of others)\n                if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)\n                    top = above ? r.top - height : r.bottom;\n            if (this.position == \"absolute\") {\n                dom.style.top = (top - measured.parent.top) + \"px\";\n                dom.style.left = (left - measured.parent.left) + \"px\";\n            }\n            else {\n                dom.style.top = top + \"px\";\n                dom.style.left = left + \"px\";\n            }\n            others.push({ left, top, right, bottom: top + height });\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned)\n                tView.positioned();\n        }\n    }\n    maybeMeasure() {\n        if (this.manager.tooltips.length) {\n            if (this.view.inView)\n                this.view.requestMeasure(this.measureReq);\n            if (this.inView != this.view.inView) {\n                this.inView = this.view.inView;\n                if (!this.inView)\n                    for (let tv of this.manager.tooltipViews)\n                        tv.dom.style.top = Outside;\n            }\n        }\n    }\n}, {\n    eventHandlers: {\n        scroll() { this.maybeMeasure(); }\n    }\n});\nconst insetInlineStart = typeof document == 'undefined' || ((_a = document.body) === null || _a === void 0 ? void 0 : _a.style.insetInlineStart) != null\n    ? 'insetInlineStart' : 'left';\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-tooltip\": {\n        zIndex: 100\n    },\n    \"&light .cm-tooltip\": {\n        border: \"1px solid #bbb\",\n        backgroundColor: \"#f5f5f5\"\n    },\n    \"&light .cm-tooltip-section:not(:first-child)\": {\n        borderTop: \"1px solid #bbb\",\n    },\n    \"&dark .cm-tooltip\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tooltip.cm-tooltip-arrow:before, .cm-tooltip.cm-tooltip-arrow:after\": {\n        position: \"absolute\",\n        content: \"''\",\n        [insetInlineStart]: `${14 /* Offset */ - 7 /* Size */}px`,\n        width: 0,\n        height: 0,\n        borderLeft: `${7 /* Size */}px solid transparent`,\n        borderRight: `${7 /* Size */}px solid transparent`,\n        zIndex: -1\n    },\n    \".cm-tooltip-above.cm-tooltip-arrow:before\": {\n        borderTop: `${7 /* Size */}px solid #f5f5f5`,\n        bottom: `-${7 /* Size */ - 1}px`\n    },\n    \".cm-tooltip-below.cm-tooltip-arrow:before\": {\n        borderBottom: `${7 /* Size */}px solid #f5f5f5`,\n        top: `-${7 /* Size */ - 1}px`\n    },\n    \".cm-tooltip-above.cm-tooltip-arrow:after\": {\n        borderTop: `${7 /* Size */}px solid #bbb`,\n        bottom: `-${7 /* Size */}px`,\n        zIndex: -2\n    },\n    \".cm-tooltip-below.cm-tooltip-arrow:after\": {\n        borderBottom: `${7 /* Size */}px solid #bbb`,\n        top: `-${7 /* Size */}px`,\n        zIndex: -2\n    },\n    \"&dark .cm-tooltip.cm-tooltip-arrow:before\": {\n        borderTopColor: \"#333338\",\n        borderBottomColor: \"#333338\"\n    },\n    \"&dark .cm-tooltip.cm-tooltip-arrow:after\": {\n        borderTopColor: \"transparent\",\n        borderBottomColor: \"transparent\"\n    }\n});\n/**\nBehavior by which an extension can provide a tooltip to be shown.\n*/\nconst showTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n    enables: [tooltipPlugin, baseTheme]\n});\nconst showHoverTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();\nclass HoverTooltipHost {\n    constructor(view) {\n        this.view = view;\n        this.mounted = false;\n        this.dom = document.createElement(\"div\");\n        this.dom.classList.add(\"cm-tooltip-hover\");\n        this.manager = new TooltipViewManager(view, showHoverTooltip, t => this.createHostedView(t));\n    }\n    // Needs to be static so that host tooltip instances always match\n    static create(view) {\n        return new HoverTooltipHost(view);\n    }\n    createHostedView(tooltip) {\n        let hostedView = tooltip.create(this.view);\n        hostedView.dom.classList.add(\"cm-tooltip-section\");\n        this.dom.appendChild(hostedView.dom);\n        if (this.mounted && hostedView.mount)\n            hostedView.mount(this.view);\n        return hostedView;\n    }\n    mount(view) {\n        for (let hostedView of this.manager.tooltipViews) {\n            if (hostedView.mount)\n                hostedView.mount(view);\n        }\n        this.mounted = true;\n    }\n    positioned() {\n        for (let hostedView of this.manager.tooltipViews) {\n            if (hostedView.positioned)\n                hostedView.positioned();\n        }\n    }\n    update(update) {\n        this.manager.update(update);\n    }\n}\nconst showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {\n    let tooltips = state.facet(showHoverTooltip).filter(t => t);\n    if (tooltips.length === 0)\n        return null;\n    return {\n        pos: Math.min(...tooltips.map(t => t.pos)),\n        end: Math.max(...tooltips.filter(t => t.end != null).map(t => t.end)),\n        create: HoverTooltipHost.create,\n        above: tooltips[0].above,\n        arrow: tooltips.some(t => t.arrow),\n    };\n});\nclass HoverPlugin {\n    constructor(view, source, field, setHover, hoverTime) {\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.hoverTime = hoverTime;\n        this.lastMouseMove = null;\n        this.lastMoveTime = 0;\n        this.hoverTimeout = -1;\n        this.restartTimeout = -1;\n        this.pending = null;\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    update() {\n        if (this.pending) {\n            this.pending = null;\n            clearTimeout(this.restartTimeout);\n            this.restartTimeout = setTimeout(() => this.startHover(), 20);\n        }\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (this.active)\n            return;\n        let hovered = Date.now() - this.lastMoveTime;\n        if (hovered < this.hoverTime)\n            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);\n        else\n            this.startHover();\n    }\n    startHover() {\n        var _a;\n        clearTimeout(this.restartTimeout);\n        let lastMove = this.lastMouseMove;\n        let coords = { x: lastMove.clientX, y: lastMove.clientY };\n        let pos = this.view.contentDOM.contains(lastMove.target)\n            ? this.view.posAtCoords(coords) : null;\n        if (pos == null)\n            return;\n        let posCoords = this.view.coordsAtPos(pos);\n        if (posCoords == null || coords.y < posCoords.top || coords.y > posCoords.bottom ||\n            coords.x < posCoords.left - this.view.defaultCharacterWidth ||\n            coords.x > posCoords.right + this.view.defaultCharacterWidth)\n            return;\n        let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);\n        let rtl = bidi && bidi.dir == _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Direction.RTL ? -1 : 1;\n        let open = this.source(this.view, pos, (coords.x < posCoords.left ? -rtl : rtl));\n        if ((_a = open) === null || _a === void 0 ? void 0 : _a.then) {\n            let pending = this.pending = { pos };\n            open.then(result => {\n                if (this.pending == pending) {\n                    this.pending = null;\n                    if (result)\n                        this.view.dispatch({ effects: this.setHover.of(result) });\n                }\n            }, e => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.logException)(this.view.state, e, \"hover tooltip\"));\n        }\n        else if (open) {\n            this.view.dispatch({ effects: this.setHover.of(open) });\n        }\n    }\n    mousemove(event) {\n        var _a;\n        this.lastMouseMove = event;\n        this.lastMoveTime = Date.now();\n        if (this.hoverTimeout < 0)\n            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n        let tooltip = this.active;\n        if (tooltip && !isInTooltip(event.target) || this.pending) {\n            let { pos } = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;\n            if ((pos == end ? this.view.posAtCoords({ x: event.clientX, y: event.clientY }) != pos\n                : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6 /* MaxDist */))) {\n                this.view.dispatch({ effects: this.setHover.of(null) });\n                this.pending = null;\n            }\n        }\n    }\n    mouseleave() {\n        clearTimeout(this.hoverTimeout);\n        this.hoverTimeout = -1;\n        if (this.active)\n            this.view.dispatch({ effects: this.setHover.of(null) });\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nfunction isInTooltip(elt) {\n    for (let cur = elt; cur; cur = cur.parentNode)\n        if (cur.nodeType == 1 && cur.classList.contains(\"cm-tooltip\"))\n            return true;\n    return false;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n    let range = document.createRange();\n    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);\n    range.setEnd(toDOM.node, toDOM.offset);\n    range.setStart(fromDOM.node, fromDOM.offset);\n    let rects = range.getClientRects();\n    range.detach();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);\n        if (dist <= margin)\n            return true;\n    }\n    return false;\n}\n/**\nEnable a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos` return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer isit will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n*/\nfunction hoverTooltip(source, options = {}) {\n    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.define();\n    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({\n        create() { return null; },\n        update(value, tr) {\n            if (value && (options.hideOnChange && (tr.docChanged || tr.selection)))\n                return null;\n            for (let effect of tr.effects)\n                if (effect.is(setHover))\n                    return effect.value;\n            if (value && tr.docChanged) {\n                let newPos = tr.changes.mapPos(value.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackDel);\n                if (newPos == null)\n                    return null;\n                let copy = Object.assign(Object.create(null), value);\n                copy.pos = newPos;\n                if (value.end != null)\n                    copy.end = tr.changes.mapPos(value.end);\n                return copy;\n            }\n            return value;\n        },\n        provide: f => showHoverTooltip.from(f)\n    });\n    let hoverTime = options.hoverTime || 750 /* Time */;\n    return [\n        hoverState,\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, hoverTime)),\n        showHoverTooltipHost\n    ];\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/tooltip/dist/index.js?");

/***/ }),

/***/ "./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Range\": () => (/* reexport safe */ _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.Range),\n/* harmony export */   \"BidiSpan\": () => (/* binding */ BidiSpan),\n/* harmony export */   \"BlockInfo\": () => (/* binding */ BlockInfo),\n/* harmony export */   \"BlockType\": () => (/* binding */ BlockType),\n/* harmony export */   \"Decoration\": () => (/* binding */ Decoration),\n/* harmony export */   \"Direction\": () => (/* binding */ Direction),\n/* harmony export */   \"EditorView\": () => (/* binding */ EditorView),\n/* harmony export */   \"MatchDecorator\": () => (/* binding */ MatchDecorator),\n/* harmony export */   \"PluginField\": () => (/* binding */ PluginField),\n/* harmony export */   \"PluginFieldProvider\": () => (/* binding */ PluginFieldProvider),\n/* harmony export */   \"ViewPlugin\": () => (/* binding */ ViewPlugin),\n/* harmony export */   \"ViewUpdate\": () => (/* binding */ ViewUpdate),\n/* harmony export */   \"WidgetType\": () => (/* binding */ WidgetType),\n/* harmony export */   \"__test\": () => (/* binding */ __test),\n/* harmony export */   \"drawSelection\": () => (/* binding */ drawSelection),\n/* harmony export */   \"highlightActiveLine\": () => (/* binding */ highlightActiveLine),\n/* harmony export */   \"highlightSpecialChars\": () => (/* binding */ highlightSpecialChars),\n/* harmony export */   \"keymap\": () => (/* binding */ keymap),\n/* harmony export */   \"logException\": () => (/* binding */ logException),\n/* harmony export */   \"placeholder\": () => (/* binding */ placeholder),\n/* harmony export */   \"runScopeHandlers\": () => (/* binding */ runScopeHandlers),\n/* harmony export */   \"scrollPastEnd\": () => (/* binding */ scrollPastEnd)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/rangeset */ \"./node_modules/@codemirror/rangeset/dist/index.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! w3c-keyname */ \"./node_modules/w3c-keyname/index.es.js\");\n\n\n\n\n\n\n\nfunction getSelection(root) {\n    let target;\n    // Browsers differ on whether shadow roots have a getSelection\n    // method. If it exists, use that, otherwise, call it on the\n    // document.\n    if (root.nodeType == 11) { // Shadow root\n        target = root.getSelection ? root : root.ownerDocument;\n    }\n    else {\n        target = root;\n    }\n    return target.getSelection();\n}\nfunction contains(dom, node) {\n    return node ? dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\nfunction deepActiveElement() {\n    let elt = document.activeElement;\n    while (elt && elt.shadowRoot)\n        elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode)\n        return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return contains(dom, selection.anchorNode);\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3)\n        return textRange(dom, 0, dom.nodeValue.length).getClientRects();\n    else if (dom.nodeType == 1)\n        return dom.getClientRects();\n    else\n        return [];\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1)) : false;\n}\nfunction domIndex(node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\")\n                return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1)\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.nodeType == 1 && node.contentEditable == \"false\")\n                return false;\n            off = dir < 0 ? maxOffset(node) : 0;\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nconst Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };\nfunction flattenRect(rect, left) {\n    let x = left ? rect.left : rect.right;\n    return { left: x, right: x, top: rect.top, bottom: rect.bottom };\n}\nfunction windowRect(win) {\n    return { left: 0, right: win.innerWidth,\n        top: 0, bottom: win.innerHeight };\n}\nconst ScrollSpace = 5;\nfunction scrollRectIntoView(dom, rect, side) {\n    let doc = dom.ownerDocument, win = doc.defaultView;\n    for (let cur = dom.parentNode; cur;) {\n        if (cur.nodeType == 1) { // Element\n            let bounding, top = cur == doc.body;\n            if (top) {\n                bounding = windowRect(win);\n            }\n            else {\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = { left: rect.left, right: rect.left + cur.clientWidth,\n                    top: rect.top, bottom: rect.top + cur.clientHeight };\n            }\n            let moveX = 0, moveY = 0;\n            if (rect.top < bounding.top) {\n                moveY = -(bounding.top - rect.top + ScrollSpace);\n                if (side > 0 && rect.bottom > bounding.bottom + moveY)\n                    moveY = rect.bottom - bounding.bottom + moveY + ScrollSpace;\n            }\n            else if (rect.bottom > bounding.bottom) {\n                moveY = rect.bottom - bounding.bottom + ScrollSpace;\n                if (side < 0 && (rect.top - moveY) < bounding.top)\n                    moveY = -(bounding.top + moveY - rect.top + ScrollSpace);\n            }\n            if (rect.left < bounding.left) {\n                moveX = -(bounding.left - rect.left + ScrollSpace);\n                if (side > 0 && rect.right > bounding.right + moveX)\n                    moveX = rect.right - bounding.right + moveX + ScrollSpace;\n            }\n            else if (rect.right > bounding.right) {\n                moveX = rect.right - bounding.right + ScrollSpace;\n                if (side < 0 && rect.left < bounding.left + moveX)\n                    moveX = -(bounding.left + moveX - rect.left + ScrollSpace);\n            }\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                }\n                else {\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY;\n                        moveY = cur.scrollTop - start;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX;\n                        moveX = cur.scrollLeft - start;\n                    }\n                    rect = { left: rect.left - moveX, top: rect.top - moveY,\n                        right: rect.right - moveX, bottom: rect.bottom - moveY };\n                }\n            }\n            if (top)\n                break;\n            cur = cur.assignedSlot || cur.parentNode;\n        }\n        else if (cur.nodeType == 11) { // A shadow root\n            cur = cur.host;\n        }\n        else {\n            break;\n        }\n    }\n}\nclass DOMSelection {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&\n            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    set(domSel) {\n        this.anchorNode = domSel.anchorNode;\n        this.anchorOffset = domSel.anchorOffset;\n        this.focusNode = domSel.focusNode;\n        this.focusOffset = domSel.focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive)\n        return dom.setActive(); // in IE\n    if (preventScrollSupported)\n        return dom.focus(preventScrollSupported);\n    let stack = [];\n    for (let cur = dom; cur; cur = cur.parentNode) {\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\n        if (cur == cur.ownerDocument)\n            break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll() {\n            preventScrollSupported = { preventScroll: true };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for (let i = 0; i < stack.length;) {\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top)\n                elt.scrollTop = top;\n            if (elt.scrollLeft != left)\n                elt.scrollLeft = left;\n        }\n    }\n}\nlet scratchRange;\nfunction textRange(node, from, to = from) {\n    let range = scratchRange || (scratchRange = document.createRange());\n    range.setEnd(node, to);\n    range.setStart(node, from);\n    return range;\n}\nfunction dispatchKey(elt, name, code) {\n    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };\n    let down = new KeyboardEvent(\"keydown\", options);\n    down.synthetic = true;\n    elt.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    up.synthetic = true;\n    elt.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\nlet _plainTextSupported = null;\nfunction contentEditablePlainTextSupported() {\n    if (_plainTextSupported == null) {\n        _plainTextSupported = false;\n        let dummy = document.createElement(\"div\");\n        try {\n            dummy.contentEditable = \"plaintext-only\";\n            _plainTextSupported = dummy.contentEditable == \"plaintext-only\";\n        }\n        catch (_) { }\n    }\n    return _plainTextSupported;\n}\n\nclass DOMPos {\n    constructor(node, offset, precise = true) {\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }\n    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }\n}\nconst none$3 = [];\nclass ContentView {\n    constructor() {\n        this.parent = null;\n        this.dom = null;\n        this.dirty = 2 /* Node */;\n    }\n    get editorView() {\n        if (!this.parent)\n            throw new Error(\"Accessing view in orphan content view\");\n        return this.parent.editorView;\n    }\n    get overrideDOMText() { return null; }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children) {\n            if (child == view)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    // Will return a rectangle directly before (when side < 0), after\n    // (side > 0) or directly on (when the browser supports it) the\n    // given position.\n    coordsAt(_pos, _side) { return null; }\n    sync(track) {\n        var _a;\n        if (this.dirty & 2 /* Node */) {\n            let parent = this.dom, pos = null;\n            for (let child of this.children) {\n                if (child.dirty) {\n                    let next = pos ? pos.nextSibling : parent.firstChild;\n                    if (!child.dom && next && !((_a = ContentView.get(next)) === null || _a === void 0 ? void 0 : _a.parent))\n                        child.reuseDOM(next);\n                    child.sync(track);\n                    child.dirty = 0 /* Not */;\n                }\n                if (track && track.node == parent && pos != child.dom)\n                    track.written = true;\n                syncNodeInto(parent, pos, child.dom);\n                pos = child.dom;\n            }\n            let next = pos ? pos.nextSibling : parent.firstChild;\n            if (next && track && track.node == parent)\n                track.written = true;\n            while (next)\n                next = rm(next);\n        }\n        else if (this.dirty & 1 /* Child */) {\n            for (let child of this.children)\n                if (child.dirty) {\n                    child.sync(track);\n                    child.dirty = 0 /* Not */;\n                }\n        }\n    }\n    reuseDOM(_dom) { return false; }\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        }\n        else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for (;;) {\n                let parent = node.parentNode;\n                if (parent == this.dom)\n                    break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild)\n                        bias = -1;\n                    else\n                        bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0)\n                after = node;\n            else\n                after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild)\n            return 0;\n        while (after && !ContentView.get(after))\n            after = after.nextSibling;\n        if (!after)\n            return this.length;\n        for (let i = 0, pos = 0;; i++) {\n            let child = this.children[i];\n            if (child.dom == after)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to)\n                return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (pos > to && child.dom.parentNode == this.dom) {\n                toI = i;\n                toEnd = prevEnd;\n                break;\n            }\n            prevEnd = end;\n            pos = end + child.breakAfter;\n        }\n        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd,\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null };\n    }\n    markDirty(andParent = false) {\n        this.dirty |= 2 /* Node */;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for (let parent = this.parent; parent; parent = parent.parent) {\n            if (childList)\n                parent.dirty |= 2 /* Node */;\n            if (parent.dirty & 1 /* Child */)\n                return;\n            parent.dirty |= 1 /* Child */;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.dirty)\n                this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        if (this.dom)\n            this.dom.cmView = null;\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for (let v = this;;) {\n            let parent = v.parent;\n            if (!parent)\n                return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = none$3) {\n        this.markDirty();\n        for (let i = from; i < to; i++) {\n            let child = this.children[i];\n            if (child.parent == this)\n                child.parent = null;\n        }\n        this.children.splice(from, to - from, ...children);\n        for (let i = 0; i < children.length; i++)\n            children[i].setParent(this);\n    }\n    ignoreMutation(_rec) { return false; }\n    ignoreEvent(_event) { return false; }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" :\n            this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") +\n            (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) { return node.cmView; }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nfunction syncNodeInto(parent, after, dom) {\n    let next = after ? after.nextSibling : parent.firstChild;\n    if (dom.parentNode == parent)\n        while (next != dom)\n            next = rm(next);\n    else\n        parent.insertBefore(dom, next);\n}\nclass ChildCursor {\n    constructor(children, pos, i) {\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for (;;) {\n            if (pos > this.pos || pos == this.pos &&\n                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\n\nlet [nav, doc] = typeof navigator != \"undefined\"\n    ? [navigator, document]\n    : [{ userAgent: \"\", vendor: \"\", platform: \"\" }, { documentElement: { style: {} } }];\nconst ie_edge = /*@__PURE__*//Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /*@__PURE__*//MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /*@__PURE__*//Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /*@__PURE__*//gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /*@__PURE__*//Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\nconst safari = !ie && /*@__PURE__*//Apple Computer/.test(nav.vendor);\nvar browser = {\n    mac: /*@__PURE__*//Mac/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +(/*@__PURE__*//Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios: safari && (/*@__PURE__*//Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2),\n    android: /*@__PURE__*//Android\\b/.test(nav.userAgent),\n    webkit,\n    safari,\n    webkit_version: webkit ? +(/*@__PURE__*//\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\n\nconst none$2 = [];\nclass InlineView extends ContentView {\n    /**\n    Return true when this view is equivalent to `other` and can take\n    on its role.\n    */\n    become(_other) { return false; }\n    // When this is a zero-length view with a side, this should return a\n    // negative number to indicate it is before its position, or a\n    // positive number when after its position.\n    getSide() { return 0; }\n}\nInlineView.prototype.children = none$2;\nconst MaxJoinLen = 256;\nclass TextView extends InlineView {\n    constructor(text) {\n        super();\n        this.text = text;\n    }\n    get length() { return this.text.length; }\n    createDOM(textDOM) {\n        this.setDOM(textDOM || document.createTextNode(this.text));\n    }\n    sync(track) {\n        if (!this.dom)\n            this.createDOM();\n        if (this.dom.nodeValue != this.text) {\n            if (track && track.node == this.dom)\n                track.written = true;\n            this.dom.nodeValue = this.text;\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType != 3)\n            return false;\n        this.createDOM(dom);\n        return true;\n    }\n    merge(from, to, source) {\n        if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))\n            return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    slice(from) {\n        let result = new TextView(this.text.slice(from));\n        this.text = this.text.slice(0, from);\n        return result;\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.dom ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) { return new DOMPos(this.dom, pos); }\n    domBoundsAround(_from, _to, offset) {\n        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };\n    }\n    coordsAt(pos, side) {\n        return textCoords(this.dom, pos, side);\n    }\n}\nclass MarkView extends InlineView {\n    constructor(mark, children = [], length = 0) {\n        super();\n        this.mark = mark;\n        this.children = children;\n        this.length = length;\n        for (let ch of children)\n            ch.setParent(this);\n    }\n    createDOM() {\n        let dom = document.createElement(this.mark.tagName);\n        if (this.mark.class)\n            dom.className = this.mark.class;\n        if (this.mark.attrs)\n            for (let name in this.mark.attrs)\n                dom.setAttribute(name, this.mark.attrs[name]);\n        this.setDOM(dom);\n    }\n    sync(track) {\n        if (!this.dom || (this.dirty & 4 /* Attrs */))\n            this.createDOM();\n        super.sync(track);\n    }\n    merge(from, to, source, openStart, openEnd) {\n        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||\n            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))\n            return false;\n        mergeInlineChildren(this, from, to, source ? source.children : none$2, openStart - 1, openEnd - 1);\n        this.markDirty();\n        return true;\n    }\n    slice(from) {\n        let result = [], off = 0, detachFrom = -1, i = 0;\n        for (let elt of this.children) {\n            let end = off + elt.length;\n            if (end > from)\n                result.push(off < from ? elt.slice(from - off) : elt);\n            if (detachFrom < 0 && off >= from)\n                detachFrom = i;\n            off = end;\n            i++;\n        }\n        let length = this.length - from;\n        this.length = from;\n        if (detachFrom > -1)\n            this.replaceChildren(detachFrom, this.children.length);\n        return new MarkView(this.mark, result, length);\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this.dom, this.children, pos);\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n}\nfunction textCoords(text, pos, side) {\n    let length = text.nodeValue.length;\n    if (pos > length)\n        pos = length;\n    let from = pos, to = pos, flatten = 0;\n    if (pos == 0 && side < 0 || pos == length && side >= 0) {\n        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges\n            if (pos) {\n                from--;\n                flatten = 1;\n            } // FIXME this is wrong in RTL text\n            else {\n                to++;\n                flatten = -1;\n            }\n        }\n    }\n    else {\n        if (side < 0)\n            from--;\n        else\n            to++;\n    }\n    let rects = textRange(text, from, to).getClientRects();\n    if (!rects.length)\n        return Rect0;\n    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n    if (browser.safari && !flatten && rect.width == 0)\n        rect = Array.prototype.find.call(rects, r => r.width) || rect;\n    return flatten ? flattenRect(rect, flatten < 0) : rect;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends InlineView {\n    constructor(widget, length, side) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n    }\n    static create(widget, length, side) {\n        return new (widget.customView || WidgetView)(widget, length, side);\n    }\n    slice(from) {\n        let result = WidgetView.create(this.widget, this.length - from, this.side);\n        this.length -= from;\n        return result;\n    }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() { return this.side; }\n    merge(from, to, source, openStart, openEnd) {\n        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||\n            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))\n            return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    become(other) {\n        if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {\n            if (this.widget.constructor == other.widget.constructor) {\n                if (!this.widget.eq(other.widget))\n                    this.markDirty(true);\n                this.widget = other.widget;\n                return true;\n            }\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n    get overrideDOMText() {\n        if (this.length == 0)\n            return _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n        let top = this;\n        while (top.parent)\n            top = top.parent;\n        let view = top.editorView, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.slice(start, start + this.length) : _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() { return null; }\n    coordsAt(pos, side) {\n        let rects = this.dom.getClientRects(), rect = null;\n        if (!rects.length)\n            return Rect0;\n        for (let i = pos > 0 ? rects.length - 1 : 0;; i += (pos > 0 ? -1 : 1)) {\n            rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)\n                break;\n        }\n        return (pos == 0 && side > 0 || pos == this.length && side <= 0) ? rect : flattenRect(rect, pos == 0);\n    }\n}\nclass CompositionView extends WidgetView {\n    domAtPos(pos) { return new DOMPos(this.widget.text, pos); }\n    sync() { if (!this.dom)\n        this.setDOM(this.widget.toDOM()); }\n    localPosFromDOM(node, offset) {\n        return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;\n    }\n    ignoreMutation() { return false; }\n    get overrideDOMText() { return null; }\n    coordsAt(pos, side) { return textCoords(this.widget.text, pos, side); }\n}\nfunction mergeInlineChildren(parent, from, to, elts, openStart, openEnd) {\n    let cur = parent.childCursor();\n    let { i: toI, off: toOff } = cur.findPos(to, 1);\n    let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n    let dLen = from - to;\n    for (let view of elts)\n        dLen += view.length;\n    parent.length += dLen;\n    let { children } = parent;\n    // Both from and to point into the same child view\n    if (fromI == toI && fromOff) {\n        let start = children[fromI];\n        // Maybe just update that view and be done\n        if (elts.length == 1 && start.merge(fromOff, toOff, elts[0], openStart, openEnd))\n            return;\n        if (elts.length == 0) {\n            start.merge(fromOff, toOff, null, openStart, openEnd);\n            return;\n        }\n        // Otherwise split it, so that we don't have to worry about aliasing front/end afterwards\n        let after = start.slice(toOff);\n        if (after.merge(0, 0, elts[elts.length - 1], 0, openEnd))\n            elts[elts.length - 1] = after;\n        else\n            elts.push(after);\n        toI++;\n        openEnd = toOff = 0;\n    }\n    // Make sure start and end positions fall on node boundaries\n    // (fromOff/toOff are no longer used after this), and that if the\n    // start or end of the elts can be merged with adjacent nodes,\n    // this is done\n    if (toOff) {\n        let end = children[toI];\n        if (elts.length && end.merge(0, toOff, elts[elts.length - 1], 0, openEnd)) {\n            elts.pop();\n            openEnd = elts.length ? 0 : openStart;\n        }\n        else {\n            end.merge(0, toOff, null, 0, 0);\n        }\n    }\n    else if (toI < children.length && elts.length &&\n        children[toI].merge(0, 0, elts[elts.length - 1], 0, openEnd)) {\n        elts.pop();\n        openEnd = elts.length ? 0 : openStart;\n    }\n    if (fromOff) {\n        let start = children[fromI];\n        if (elts.length && start.merge(fromOff, start.length, elts[0], openStart, 0)) {\n            elts.shift();\n            openStart = elts.length ? 0 : openEnd;\n        }\n        else {\n            start.merge(fromOff, start.length, null, 0, 0);\n        }\n        fromI++;\n    }\n    else if (fromI && elts.length) {\n        let end = children[fromI - 1];\n        if (end.merge(end.length, end.length, elts[0], openStart, 0)) {\n            elts.shift();\n            openStart = elts.length ? 0 : openEnd;\n        }\n    }\n    // Then try to merge any mergeable nodes at the start and end of\n    // the changed range\n    while (fromI < toI && elts.length && children[toI - 1].become(elts[elts.length - 1])) {\n        elts.pop();\n        toI--;\n        openEnd = elts.length ? 0 : openStart;\n    }\n    while (fromI < toI && elts.length && children[fromI].become(elts[0])) {\n        elts.shift();\n        fromI++;\n        openStart = elts.length ? 0 : openEnd;\n    }\n    if (!elts.length && fromI && toI < children.length &&\n        children[toI].merge(0, 0, children[fromI - 1], openStart, openEnd))\n        fromI--;\n    // And if anything remains, splice the child array to insert the new elts\n    if (elts.length || fromI != toI)\n        parent.replaceChildren(fromI, toI, elts);\n}\nfunction inlineDOMAtPos(dom, children, pos) {\n    let i = 0;\n    for (let off = 0; i < children.length; i++) {\n        let child = children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0)\n            continue;\n        if (pos > off && pos < end && child.dom.parentNode == dom)\n            return child.domAtPos(pos - off);\n        if (pos <= off)\n            break;\n        off = end;\n    }\n    for (; i > 0; i--) {\n        let before = children[i - 1].dom;\n        if (before.parentNode == dom)\n            return DOMPos.after(before);\n    }\n    return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n    let last, { children } = parent;\n    if (open > 0 && view instanceof MarkView && children.length &&\n        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n        joinInlineInto(last, view.children[0], open - 1);\n    }\n    else {\n        children.push(view);\n        view.setParent(parent);\n    }\n    parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n    for (let off = 0, i = 0; i < view.children.length; i++) {\n        let child = view.children[i], end = off + child.length, next;\n        if ((side <= 0 || end == view.length || child.getSide() > 0 ? end >= pos : end > pos) &&\n            (pos < end || i + 1 == view.children.length || (next = view.children[i + 1]).length || next.getSide() > 0)) {\n            let flatten = 0;\n            if (end == off) {\n                if (child.getSide() <= 0)\n                    continue;\n                flatten = side = -child.getSide();\n            }\n            let rect = child.coordsAt(pos - off, side);\n            return flatten && rect ? flattenRect(rect, side < 0) : rect;\n        }\n        off = end;\n    }\n    let last = view.dom.lastChild;\n    if (!last)\n        return view.dom.getBoundingClientRect();\n    let rects = clientRectsFor(last);\n    return rects[rects.length - 1];\n}\n\nfunction combineAttrs(source, target) {\n    for (let name in source) {\n        if (name == \"class\" && target.class)\n            target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style)\n            target.style += \";\" + source.style;\n        else\n            target[name] = source[name];\n    }\n    return target;\n}\nfunction attrsEq(a, b) {\n    if (a == b)\n        return true;\n    if (!a || !b)\n        return false;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length != keysB.length)\n        return false;\n    for (let key of keysA) {\n        if (keysB.indexOf(key) == -1 || a[key] !== b[key])\n            return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    if (prev)\n        for (let name in prev)\n            if (!(attrs && name in attrs))\n                dom.removeAttribute(name);\n    if (attrs)\n        for (let name in attrs)\n            if (!(prev && prev[name] == attrs[name]))\n                dom.setAttribute(name, attrs[name]);\n}\n\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even when the decorations\nthat define them are recreated.\n*/\nclass WidgetType {\n    /**\n    Compare this instance to another instance of the same type.\n    (TypeScript can't express this, but only instances of the same\n    specific class will be passed to this method.) This is used to\n    avoid redrawing widgets when they are replaced by a new\n    decoration of the same type. The default implementation just\n    returns `false`, which will cause new instances of the widget to\n    always be redrawn.\n    */\n    eq(_widget) { return false; }\n    /**\n    Update a DOM element created by a widget of the same type (but\n    different, non-`eq` content) to reflect this widget. May return\n    true to indicate that it could update, false to indicate it\n    couldn't (in which case the widget will be redrawn). The default\n    implementation just returns false.\n    */\n    updateDOM(_dom) { return false; }\n    /**\n    @internal\n    */\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    The estimated height this widget will have, to be used when\n    estimating the height of content that hasn't been drawn. May\n    return -1 to indicate you don't know. The default implementation\n    returns -1.\n    */\n    get estimatedHeight() { return -1; }\n    /**\n    Can be used to configure which kinds of events inside the widget\n    should be ignored by the editor. The default is to ignore all\n    events.\n    */\n    ignoreEvent(_event) { return true; }\n    /**\n    @internal\n    */\n    get customView() { return null; }\n}\n/**\nThe different types of blocks that can occur in an editor view.\n*/\nvar BlockType = /*@__PURE__*/(function (BlockType) {\n    /**\n    A line of text.\n    */\n    BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /**\n    A block widget associated with the position after it.\n    */\n    BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /**\n    A block widget associated with the position before it.\n    */\n    BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /**\n    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n    */\n    BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\nreturn BlockType})(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range), which adds a start and end position.\n*/\nclass Decoration extends _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeValue {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    startSide, \n    /**\n    @internal\n    */\n    endSide, \n    /**\n    @internal\n    */\n    widget, \n    /**\n    The config object used to create this decoration. You can\n    include additional properties in there to store metadata about\n    your decoration.\n    */\n    spec) {\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /**\n    @internal\n    */\n    get heightRelevant() { return false; }\n    /**\n    Create a mark decoration, which influences the styling of the\n    content in its range. Nested mark decorations will cause nested\n    DOM elements to be created. Nesting order is determined by\n    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations) or\n    (below the facet-provided decorations) [view\n    plugin](https://codemirror.net/6/docs/ref/#view.PluginSpec.decorations). Such elements are split\n    on line boundaries and on the boundaries of higher-precedence\n    decorations.\n    */\n    static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /**\n    Create a widget decoration, which adds an element at the given\n    position.\n    */\n    static widget(spec) {\n        let side = spec.side || 0;\n        if (spec.block)\n            side += (200000000 /* BigBlock */ + 1) * (side > 0 ? 1 : -1);\n        return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);\n    }\n    /**\n    Create a replace decoration which replaces the given range with\n    a widget, or simply hides it.\n    */\n    static replace(spec) {\n        let block = !!spec.block;\n        let { start, end } = getInclusive(spec);\n        let startSide = block ? -200000000 /* BigBlock */ * (start ? 2 : 1) : 100000000 /* BigInline */ * (start ? -1 : 1);\n        let endSide = block ? 200000000 /* BigBlock */ * (end ? 2 : 1) : 100000000 /* BigInline */ * (end ? 1 : -1);\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /**\n    Create a line decoration, which can add DOM attributes to the\n    line starting at the given position.\n    */\n    static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /**\n    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n    decorated range or ranges. If the ranges aren't already sorted,\n    pass `true` for `sort` to make the library sort them for you.\n    */\n    static set(of, sort = false) {\n        return _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.of(of, sort);\n    }\n    /**\n    @internal\n    */\n    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }\n}\n/**\nThe empty set of decorations.\n*/\nDecoration.none = _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec) {\n        let { start, end } = getInclusive(spec);\n        super(100000000 /* BigInline */ * (start ? -1 : 1), 100000000 /* BigInline */ * (end ? 1 : -1), null, spec);\n        this.tagName = spec.tagName || \"span\";\n        this.class = spec.class || \"\";\n        this.attrs = spec.attributes || null;\n    }\n    eq(other) {\n        return this == other ||\n            other instanceof MarkDecoration &&\n                this.tagName == other.tagName &&\n                this.class == other.class &&\n                attrsEq(this.attrs, other.attrs);\n    }\n    range(from, to = from) {\n        if (from >= to)\n            throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n    constructor(spec) {\n        super(-100000000 /* BigInline */, -100000000 /* BigInline */, null, spec);\n    }\n    eq(other) {\n        return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from)\n            throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace) {\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.MapMode.TrackDel : startSide < 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.MapMode.TrackAfter;\n    }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide < this.endSide ? BlockType.WidgetRange\n            : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() { return this.block || !!this.widget && this.widget.estimatedHeight >= 5; }\n    eq(other) {\n        return other instanceof PointDecoration &&\n            widgetsEq(this.widget, other.widget) &&\n            this.block == other.block &&\n            this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide < 0)))\n            throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from)\n            throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null)\n        start = spec.inclusive;\n    if (end == null)\n        end = spec.inclusive;\n    return { start: start || false, end: end || false };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + margin > from)\n        ranges[last] = Math.max(ranges[last], to);\n    else\n        ranges.push(from, to);\n}\n\nclass LineView extends ContentView {\n    constructor() {\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, takeDeco, openStart, openEnd) {\n        if (source) {\n            if (!(source instanceof LineView))\n                return false;\n            if (!this.dom)\n                source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (takeDeco)\n            this.setDeco(source ? source.attrs : null);\n        mergeInlineChildren(this, from, to, source ? source.children : none$1, openStart, openEnd);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0)\n            return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].slice(off), 0);\n            this.children[i].merge(off, this.children[i].length, null, 0, 0);\n            i++;\n        }\n        for (let j = i; j < this.children.length; j++)\n            end.append(this.children[j], 0);\n        while (i > 0 && this.children[i - 1].length == 0) {\n            this.children[i - 1].parent = null;\n            i--;\n        }\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom)\n            return;\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    // Only called when building a line view in ContentBuilder\n    append(child, openStart) {\n        joinInlineInto(this, child, openStart);\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes;\n        if (attrs)\n            this.attrs = combineAttrs(attrs, this.attrs || {});\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this.dom, this.children, pos);\n    }\n    sync(track) {\n        if (!this.dom || (this.dirty & 4 /* Attrs */)) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(\"cm-line\");\n            this.prevAttrs = undefined;\n        }\n        super.sync(track);\n        let last = this.dom.lastChild;\n        while (last && ContentView.get(last) instanceof MarkView)\n            last = last.lastChild;\n        if (!last ||\n            last.nodeName != \"BR\" && ContentView.get(last) instanceof WidgetView &&\n                (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20)\n            return null;\n        let totalWidth = 0;\n        for (let child of this.children) {\n            if (!(child instanceof TextView))\n                return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1)\n                return null;\n            totalWidth += rects[0].width;\n        }\n        return { lineHeight: this.dom.getBoundingClientRect().height,\n            charWidth: totalWidth / this.length };\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n    match(_other) { return false; }\n    get type() { return BlockType.Text; }\n    static find(docView, pos) {\n        for (let i = 0, off = 0;; i++) {\n            let block = docView.children[i], end = off + block.length;\n            if (end >= pos) {\n                if (block instanceof LineView)\n                    return block;\n                if (block.length)\n                    return null;\n            }\n            off = end + block.breakAfter;\n        }\n    }\n}\nconst none$1 = [];\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, type) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.type = type;\n        this.breakAfter = 0;\n    }\n    merge(from, to, source, _takeDeco, openStart, openEnd) {\n        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||\n            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))\n            return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        return new BlockWidgetView(this.widget, len, this.type);\n    }\n    get children() { return none$1; }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n    }\n    domBoundsAround() { return null; }\n    match(other) {\n        if (other instanceof BlockWidgetView && other.type == this.type &&\n            other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.eq(this.widget))\n                this.markDirty(true);\n            this.widget = other.widget;\n            this.length = other.length;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n}\n\nclass ContentBuilder {\n    constructor(doc, pos, end) {\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.openStart = -1;\n        this.openEnd = -1;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0)\n            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\n    }\n    getLine() {\n        if (!this.curLine)\n            this.content.push(this.curLine = new LineView);\n        return this.curLine;\n    }\n    addWidget(view) {\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish() {\n        if (!this.posCovered())\n            this.getLine();\n    }\n    wrapMarks(view, active) {\n        for (let mark of active)\n            view = new MarkView(mark, [view], view.length);\n        return view;\n    }\n    buildText(length, active, openStart) {\n        while (length > 0) {\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done)\n                    throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered())\n                        this.getLine();\n                    if (this.content.length)\n                        this.content[this.content.length - 1].breakAfter = 1;\n                    else\n                        this.breakAtStart = 1;\n                    this.curLine = null;\n                    length--;\n                    continue;\n                }\n                else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length, 512 /* Chunk */);\n            this.getLine().append(this.wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n            this.textOff += take;\n            length -= take;\n            openStart = 0;\n        }\n    }\n    span(from, to, active, openStart) {\n        this.buildText(to - from, active, openStart);\n        this.pos = to;\n        if (this.openStart < 0)\n            this.openStart = openStart;\n    }\n    point(from, to, deco, active, openStart) {\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                let { type } = deco;\n                if (type == BlockType.WidgetAfter && !this.posCovered())\n                    this.getLine();\n                this.addWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type));\n            }\n            else {\n                let widget = this.wrapMarks(WidgetView.create(deco.widget || new NullWidget(\"span\"), len, deco.startSide), active);\n                this.getLine().append(widget, openStart);\n            }\n        }\n        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            }\n            else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n        if (this.openStart < 0)\n            this.openStart = openStart;\n    }\n    static build(text, from, to, decorations) {\n        let builder = new ContentBuilder(text, from, to);\n        builder.openEnd = _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.spans(decorations, from, to, builder);\n        if (builder.openStart < 0)\n            builder.openStart = builder.openEnd;\n        builder.finish();\n        return builder;\n    }\n}\nclass NullWidget extends WidgetType {\n    constructor(tag) {\n        super();\n        this.tag = tag;\n    }\n    eq(other) { return other.tag == this.tag; }\n    toDOM() { return document.createElement(this.tag); }\n    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }\n}\n\nconst none = [];\nconst clickAddsSelectionRange = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nconst dragMovesSelection$1 = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nconst mouseSelectionStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nconst exceptionSink = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nconst updateListener = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nconst inputHandler = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nconst scrollTo = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.StateEffect.define({\n    map: (range, changes) => range.map(changes)\n});\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/\nfunction logException(state, exception, context) {\n    let handler = state.facet(exceptionSink);\n    if (handler.length)\n        handler[0](exception);\n    else if (window.onerror)\n        window.onerror(String(exception), context, undefined, undefined, exception);\n    else if (context)\n        console.error(context + \":\", exception);\n    else\n        console.error(exception);\n}\nconst editable = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({ combine: values => values.length ? values[0] : true });\n/**\nUsed to [declare](https://codemirror.net/6/docs/ref/#view.PluginSpec.provide) which\n[fields](https://codemirror.net/6/docs/ref/#view.PluginValue) a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin)\nprovides.\n*/\nclass PluginFieldProvider {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    field, \n    /**\n    @internal\n    */\n    get) {\n        this.field = field;\n        this.get = get;\n    }\n}\n/**\nPlugin fields are a mechanism for allowing plugins to provide\nvalues that can be retrieved through the\n[`pluginField`](https://codemirror.net/6/docs/ref/#view.EditorView.pluginField) view method.\n*/\nclass PluginField {\n    /**\n    Create a [provider](https://codemirror.net/6/docs/ref/#view.PluginFieldProvider) for this field,\n    to use with a plugin's [provide](https://codemirror.net/6/docs/ref/#view.PluginSpec.provide)\n    option.\n    */\n    from(get) {\n        return new PluginFieldProvider(this, get);\n    }\n    /**\n    Define a new plugin field.\n    */\n    static define() { return new PluginField(); }\n}\n/**\nThis field can be used by plugins to provide\n[decorations](https://codemirror.net/6/docs/ref/#view.Decoration).\n\n**Note**: For reasons of data flow (plugins are only updated\nafter the viewport is computed), decorations produced by plugins\nare _not_ taken into account when predicting the vertical layout\nstructure of the editor. Thus, things like large widgets or big\nreplacements (i.e. code folding) should be provided through the\nstate-level [`decorations` facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations),\nnot this plugin field. Specifically, replacing decorations that\ncross line boundaries will break if provided through a plugin.\n*/\nPluginField.decorations = /*@__PURE__*/PluginField.define();\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/\nPluginField.atomicRanges = /*@__PURE__*/PluginField.define();\n/**\nPlugins can provide additional scroll margins (space around the\nsides of the scrolling element that should be considered\ninvisible) through this field. This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/\nPluginField.scrollMargins = /*@__PURE__*/PluginField.define();\nlet nextPluginID = 0;\nconst viewPlugin = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view.\n*/\nclass ViewPlugin {\n    constructor(\n    /**\n    @internal\n    */\n    id, \n    /**\n    @internal\n    */\n    create, \n    /**\n    @internal\n    */\n    fields) {\n        this.id = id;\n        this.create = create;\n        this.fields = fields;\n        this.extension = viewPlugin.of(this);\n    }\n    /**\n    Define a plugin from a constructor function that creates the\n    plugin's value, given an editor view.\n    */\n    static define(create, spec) {\n        let { eventHandlers, provide, decorations } = spec || {};\n        let fields = [];\n        if (provide)\n            for (let provider of Array.isArray(provide) ? provide : [provide])\n                fields.push(provider);\n        if (eventHandlers)\n            fields.push(domEventHandlers.from((value) => ({ plugin: value, handlers: eventHandlers })));\n        if (decorations)\n            fields.push(PluginField.decorations.from(decorations));\n        return new ViewPlugin(nextPluginID++, create, fields);\n    }\n    /**\n    Create a plugin for a class whose constructor takes a single\n    editor view as argument.\n    */\n    static fromClass(cls, spec) {\n        return ViewPlugin.define(view => new cls(view), spec);\n    }\n}\nconst domEventHandlers = /*@__PURE__*/PluginField.define();\nclass PluginInstance {\n    constructor(spec) {\n        this.spec = spec;\n        // When starting an update, all plugins have this field set to the\n        // update object, indicating they need to be updated. When finished\n        // updating, it is set to `false`. Retrieving a plugin that needs to\n        // be updated with `view.plugin` forces an eager update.\n        this.mustUpdate = null;\n        // This is null when the plugin is initially created, but\n        // initialized on the first update.\n        this.value = null;\n    }\n    takeField(type, target) {\n        for (let { field, get } of this.spec.fields)\n            if (field == type)\n                target.push(get(this.value));\n    }\n    update(view) {\n        if (!this.value) {\n            try {\n                this.value = this.spec.create(view);\n            }\n            catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n                return PluginInstance.dummy;\n            }\n        }\n        else if (this.mustUpdate) {\n            let update = this.mustUpdate;\n            this.mustUpdate = null;\n            if (!this.value.update)\n                return this;\n            try {\n                this.value.update(update);\n            }\n            catch (e) {\n                logException(update.state, e, \"CodeMirror plugin crashed\");\n                if (this.value.destroy)\n                    try {\n                        this.value.destroy();\n                    }\n                    catch (_) { }\n                return PluginInstance.dummy;\n            }\n        }\n        return this;\n    }\n    destroy(view) {\n        var _a;\n        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n            try {\n                this.value.destroy();\n            }\n            catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n            }\n        }\n    }\n}\nPluginInstance.dummy = /*@__PURE__*/new PluginInstance(/*@__PURE__*/ViewPlugin.define(() => ({})));\nconst editorAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\nconst contentAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\n// Provide decorations\nconst decorations = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nconst styleModule = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nclass ChangedRange {\n    constructor(fromA, toA, fromB, toB) {\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    addToSet(set) {\n        let i = set.length, me = this;\n        for (; i > 0; i--) {\n            let range = set[i - 1];\n            if (range.fromA > me.toA)\n                continue;\n            if (range.toA < me.fromA)\n                break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    static extendWithRanges(diff, ranges) {\n        if (ranges.length == 0)\n            return diff;\n        let result = [];\n        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\n            let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n            let end = next ? next.fromB : 1e9;\n            while (rI < ranges.length && ranges[rI] < end) {\n                let from = ranges[rI], to = ranges[rI + 1];\n                let fromB = Math.max(posB, from), toB = Math.min(end, to);\n                if (fromB <= toB)\n                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n                if (to > end)\n                    break;\n                else\n                    rI += 2;\n            }\n            if (!next)\n                return result;\n            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n            posA = next.toA;\n            posB = next.toB;\n        }\n    }\n}\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/\nclass ViewUpdate {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The editor view that the update is associated with.\n    */\n    view, \n    /**\n    The new editor state.\n    */\n    state, \n    /**\n    The transactions involved in the update. May be empty.\n    */\n    transactions = none) {\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /**\n        @internal\n        */\n        this.flags = 0;\n        this.startState = view.state;\n        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.ChangeSet.empty(this.startState.doc.length);\n        for (let tr of transactions)\n            this.changes = this.changes.compose(tr.changes);\n        let changedRanges = [];\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n        this.changedRanges = changedRanges;\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            view.inputState.notifiedFocused = focus;\n            this.flags |= 1 /* Focus */;\n        }\n        if (this.docChanged)\n            this.flags |= 2 /* Height */;\n    }\n    /**\n    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n    update.\n    */\n    get viewportChanged() {\n        return (this.flags & 4 /* Viewport */) > 0;\n    }\n    /**\n    Indicates whether the line height in the editor changed in this update.\n    */\n    get heightChanged() {\n        return (this.flags & 2 /* Height */) > 0;\n    }\n    /**\n    Returns true when the document changed or the size of the editor\n    or the lines or characters within it has changed.\n    */\n    get geometryChanged() {\n        return this.docChanged || (this.flags & (8 /* Geometry */ | 2 /* Height */)) > 0;\n    }\n    /**\n    True when this update indicates a focus change.\n    */\n    get focusChanged() {\n        return (this.flags & 1 /* Focus */) > 0;\n    }\n    /**\n    Whether the document changed in this update.\n    */\n    get docChanged() {\n        return this.transactions.some(tr => tr.docChanged);\n    }\n    /**\n    Whether the selection was explicitly set in this update.\n    */\n    get selectionSet() {\n        return this.transactions.some(tr => tr.selection);\n    }\n    /**\n    @internal\n    */\n    get empty() { return this.flags == 0 && this.transactions.length == 0; }\n}\n\nclass DocView extends ContentView {\n    constructor(view) {\n        super();\n        this.view = view;\n        this.compositionDeco = Decoration.none;\n        this.decorations = [];\n        // Track a minimum width for the editor. When measuring sizes in\n        // checkLayout, this is updated to point at the width of a given\n        // element and its extent in the document. When a change happens in\n        // that range, these are reset. That way, once we've seen a\n        // line/element of a given length, we keep the editor wide enough to\n        // fit at least that element, until it is changed, at which point we\n        // forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.setDOM(view.contentDOM);\n        this.children = [new LineView];\n        this.children[0].setParent(this);\n        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);\n    }\n    get root() { return this.view.root; }\n    get editorView() { return this.view; }\n    get length() { return this.view.state.doc.length; }\n    // Update the document view to a given state. scrollIntoView can be\n    // used as a hint to compute a new viewport that includes that\n    // position, if we know the editor is going to scroll that position\n    // into view.\n    update(update) {\n        let changedRanges = update.changedRanges;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = 0;\n            }\n            else {\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n            }\n        }\n        if (this.view.inputState.composing < 0)\n            this.compositionDeco = Decoration.none;\n        else if (update.transactions.length)\n            this.compositionDeco = computeCompositionDeco(this.view, update.changes);\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        let forceSelection = (browser.ie || browser.chrome) && !this.compositionDeco.size && update &&\n            update.state.doc.lines != update.startState.doc.lines;\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n        let pointerSel = update.transactions.some(tr => tr.isUserEvent(\"select.pointer\"));\n        if (this.dirty == 0 /* Not */ && changedRanges.length == 0 &&\n            !(update.flags & 4 /* Viewport */) &&\n            update.state.selection.main.from >= this.view.viewport.from &&\n            update.state.selection.main.to <= this.view.viewport.to) {\n            this.updateSelection(forceSelection, pointerSel);\n            return false;\n        }\n        else {\n            this.updateInner(changedRanges, deco, update.startState.doc.length, forceSelection, pointerSel);\n            return true;\n        }\n    }\n    // Used both by update and checkLayout do perform the actual DOM\n    // update\n    updateInner(changes, deco, oldLength, forceSelection = false, pointerSel = false) {\n        this.updateChildren(changes, deco, oldLength);\n        let { observer } = this.view;\n        observer.ignore(() => {\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.domHeight + \"px\";\n            this.dom.style.minWidth = this.minWidth ? this.minWidth + \"px\" : \"\";\n            // Chrome will sometimes, when DOM mutations occur directly\n            // around the selection, get confused and report a different\n            // selection from the one it displays (issue #218). This tries\n            // to detect that situation.\n            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;\n            this.sync(track);\n            this.dirty = 0 /* Not */;\n            if (track && (track.written || observer.selectionRange.focusNode != track.node))\n                forceSelection = true;\n            this.updateSelection(forceSelection, pointerSel);\n            this.dom.style.height = \"\";\n        });\n        let gaps = [];\n        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)\n            for (let child of this.children)\n                if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)\n                    gaps.push(child.dom);\n        observer.updateGaps(gaps);\n    }\n    updateChildren(changes, deco, oldLength) {\n        let cursor = this.childCursor(oldLength);\n        for (let i = changes.length - 1;; i--) {\n            let next = i >= 0 ? changes[i] : null;\n            if (!next)\n                break;\n            let { fromA, toA, fromB, toB } = next;\n            let { content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            this.replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n        }\n    }\n    replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd) {\n        let before = this.children[fromI], last = content.length ? content[content.length - 1] : null;\n        let breakAtEnd = last ? last.breakAfter : breakAtStart;\n        // Change within a single line\n        if (fromI == toI && !breakAtStart && !breakAtEnd && content.length < 2 &&\n            before.merge(fromOff, toOff, content.length ? last : null, fromOff == 0, openStart, openEnd))\n            return;\n        let after = this.children[toI];\n        // Make sure the end of the line after the update is preserved in `after`\n        if (toOff < after.length) {\n            // If we're splitting a line, separate part of the start line to\n            // avoid that being mangled when updating the start line.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n                content[content.length - 1] = after;\n            }\n            else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff)\n                    after.merge(0, toOff, null, false, 0, openEnd);\n                content.push(after);\n            }\n        }\n        else if (after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last)\n                last.breakAfter = 1;\n            else\n                breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && content.length && before.merge(fromOff, before.length, content[0], false, openStart, 0)) {\n                before.breakAfter = content.shift().breakAfter;\n            }\n            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false, openStart, 0);\n            }\n            fromI++;\n        }\n        // Try to merge widgets on the boundaries of the replacement\n        while (fromI < toI && content.length) {\n            if (this.children[toI - 1].match(content[content.length - 1]))\n                toI--, content.pop();\n            else if (this.children[fromI].match(content[0]))\n                fromI++, content.shift();\n            else\n                break;\n        }\n        if (fromI < toI || content.length)\n            this.replaceChildren(fromI, toI, content);\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(force = false, fromPointer = false) {\n        if (!(fromPointer || this.mayControlSelection()) ||\n            browser.ios && this.view.inputState.rapidCompositionStart)\n            return;\n        let main = this.view.state.selection.main;\n        // FIXME need to handle the case where the selection falls inside a block range\n        let anchor = this.domAtPos(main.anchor);\n        let head = main.empty ? anchor : this.domAtPos(main.head);\n        // Always reset on Firefox when next to an uneditable node to\n        // avoid invisible cursor bugs (#111)\n        if (browser.gecko && main.empty && betweenUneditable(anchor)) {\n            let dummy = document.createTextNode(\"\");\n            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n            anchor = head = new DOMPos(dummy, 0);\n            force = true;\n        }\n        let domSel = this.view.observer.selectionRange;\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force || !domSel.focusNode ||\n            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||\n            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n            this.view.observer.ignore(() => {\n                let rawSel = getSelection(this.root);\n                if (main.empty) {\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n                    if (browser.gecko) {\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\n                        if (nextTo && nextTo != (1 /* Before */ | 2 /* After */)) {\n                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* Before */ ? 1 : -1);\n                            if (text)\n                                anchor = new DOMPos(text, nextTo == 1 /* Before */ ? 0 : text.nodeValue.length);\n                        }\n                    }\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    if (main.bidiLevel != null && domSel.cursorBidiLevel != null)\n                        domSel.cursorBidiLevel = main.bidiLevel;\n                }\n                else if (rawSel.extend) {\n                    // Selection.extend can be used to create an 'inverted' selection\n                    // (one where the focus is before the anchor), but not all\n                    // browsers support it yet.\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    rawSel.extend(head.node, head.offset);\n                }\n                else {\n                    // Primitive (IE) way\n                    let range = document.createRange();\n                    if (main.anchor > main.head)\n                        [anchor, head] = [head, anchor];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    rawSel.removeAllRanges();\n                    rawSel.addRange(range);\n                }\n            });\n            this.view.observer.setSelectionRange(anchor, head);\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    enforceCursorAssoc() {\n        if (this.view.composing)\n            return;\n        let cursor = this.view.state.selection.main;\n        let sel = getSelection(this.root);\n        if (!cursor.empty || !cursor.assoc || !sel.modify)\n            return;\n        let line = LineView.find(this, cursor.head);\n        if (!line)\n            return;\n        let lineStart = line.posAtStart;\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length)\n            return;\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n        if (!before || !after || before.bottom > after.top)\n            return;\n        let dom = this.domAtPos(cursor.head + cursor.assoc);\n        sel.collapse(dom.node, dom.offset);\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n    }\n    mayControlSelection() {\n        return this.view.state.facet(editable) ? this.root.activeElement == this.dom\n            : hasSelection(this.dom, this.view.observer.selectionRange);\n    }\n    nearest(dom) {\n        for (let cur = dom; cur;) {\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this)\n                return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view)\n            throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for (; i < this.children.length - 1;) {\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView)\n                break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos, side) {\n        for (let off = this.length, i = this.children.length - 1;; i--) {\n            let child = this.children[i], start = off - child.breakAfter - child.length;\n            if (pos > start ||\n                (pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter &&\n                    (!i || side == 2 || this.children[i - 1].breakAfter ||\n                        (this.children[i - 1].type == BlockType.WidgetBefore && side > -2))))\n                return child.coordsAt(pos - start, side);\n            off = start;\n        }\n    }\n    measureVisibleLineHeights() {\n        let result = [], { from, to } = this.view.viewState.viewport;\n        let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        for (let pos = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (end > to)\n                break;\n            if (pos >= from) {\n                result.push(child.dom.getBoundingClientRect().height);\n                let width = child.dom.scrollWidth;\n                if (width > minWidth) {\n                    this.minWidth = minWidth = width;\n                    this.minWidthFrom = pos;\n                    this.minWidthTo = end;\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    measureTextSize() {\n        for (let child of this.children) {\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure)\n                    return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth;\n        dummy.className = \"cm-line\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(() => {\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            dummy.remove();\n        });\n        return { lineHeight, charWidth };\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i)\n            pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let deco = [], vs = this.view.viewState;\n        for (let pos = 0, i = 0;; i++) {\n            let next = i == vs.viewports.length ? null : vs.viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = vs.lineAt(end, 0).bottom - vs.lineAt(pos, 0).top;\n                deco.push(Decoration.replace({ widget: new BlockGapWidget(height), block: true, inclusive: true }).range(pos, end));\n            }\n            if (!next)\n                break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        return this.decorations = [\n            ...this.view.pluginField(PluginField.decorations),\n            ...this.view.state.facet(decorations),\n            this.compositionDeco,\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco\n        ];\n    }\n    scrollRangeIntoView(range) {\n        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;\n        if (!rect)\n            return;\n        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))\n            rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),\n                right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };\n        let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;\n        for (let margins of this.view.pluginField(PluginField.scrollMargins))\n            if (margins) {\n                let { left, right, top, bottom } = margins;\n                if (left != null)\n                    mLeft = Math.max(mLeft, left);\n                if (right != null)\n                    mRight = Math.max(mRight, right);\n                if (top != null)\n                    mTop = Math.max(mTop, top);\n                if (bottom != null)\n                    mBottom = Math.max(mBottom, bottom);\n            }\n        scrollRectIntoView(this.dom, {\n            left: rect.left - mLeft, top: rect.top - mTop,\n            right: rect.right + mRight, bottom: rect.bottom + mBottom\n        }, range.head < range.anchor ? -1 : 1);\n    }\n}\nfunction betweenUneditable(pos) {\n    return pos.node.nodeType == 1 && pos.node.firstChild &&\n        (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") &&\n        (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nclass BlockGapWidget extends WidgetType {\n    constructor(height) {\n        super();\n        this.height = height;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        this.updateDOM(elt);\n        return elt;\n    }\n    eq(other) { return other.height == this.height; }\n    updateDOM(elt) {\n        elt.style.height = this.height + \"px\";\n        return true;\n    }\n    get estimatedHeight() { return this.height; }\n}\nfunction computeCompositionDeco(view, changes) {\n    let sel = view.observer.selectionRange;\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n    if (!textNode)\n        return Decoration.none;\n    let cView = view.docView.nearest(textNode);\n    let from, to, topNode = textNode;\n    if (cView instanceof InlineView) {\n        while (cView.parent instanceof InlineView)\n            cView = cView.parent;\n        from = cView.posAtStart;\n        to = from + cView.length;\n        topNode = cView.dom;\n    }\n    else if (cView instanceof LineView) {\n        while (topNode.parentNode != cView.dom)\n            topNode = topNode.parentNode;\n        let prev = topNode.previousSibling;\n        while (prev && !ContentView.get(prev))\n            prev = prev.previousSibling;\n        from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;\n    }\n    else {\n        return Decoration.none;\n    }\n    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));\n    let text = textNode.nodeValue, { state } = view;\n    if (newTo - newFrom < text.length) {\n        if (state.sliceDoc(newFrom, Math.min(state.doc.length, newFrom + text.length)) == text)\n            newTo = newFrom + text.length;\n        else if (state.sliceDoc(Math.max(0, newTo - text.length), newTo) == text)\n            newFrom = newTo - text.length;\n        else\n            return Decoration.none;\n    }\n    else if (state.sliceDoc(newFrom, newTo) != text) {\n        return Decoration.none;\n    }\n    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(topNode, textNode) }).range(newFrom, newTo));\n}\nclass CompositionWidget extends WidgetType {\n    constructor(top, text) {\n        super();\n        this.top = top;\n        this.text = text;\n    }\n    eq(other) { return this.top == other.top && this.text == other.text; }\n    toDOM() { return this.top; }\n    ignoreEvent() { return false; }\n    get customView() { return CompositionView; }\n}\nfunction nearbyTextNode(node, offset, side) {\n    for (;;) {\n        if (node.nodeType == 3)\n            return node;\n        if (node.nodeType == 1 && offset > 0 && side <= 0) {\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        }\n        else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n        else {\n            return null;\n        }\n    }\n}\nfunction nextToUneditable(node, offset) {\n    if (node.nodeType != 1)\n        return 0;\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* Before */ : 0) |\n        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* After */ : 0);\n}\nclass DecorationComparator$1 {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange(from, to) { addRange(from, to, this.changes); }\n    comparePoint(from, to) { addRange(from, to, this.changes); }\n}\nfunction findChangedDeco(a, b, diff) {\n    let comp = new DecorationComparator$1;\n    _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\n\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/\nvar Direction = /*@__PURE__*/(function (Direction) {\n    // (These are chosen to match the base levels, in bidi algorithm\n    // terms, of spans in that direction.)\n    /**\n    Left-to-right.\n    */\n    Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n    /**\n    Right-to-left.\n    */\n    Direction[Direction[\"RTL\"] = 1] = \"RTL\";\nreturn Direction})(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n    let result = [];\n    for (let i = 0; i < str.length; i++)\n        result.push(1 << +str[i]);\n    return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = /*@__PURE__*/dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = /*@__PURE__*/dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nconst Brackets = /*@__PURE__*/Object.create(null), BracketStack = [];\n// There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\nfor (let p of [\"()\", \"[]\", \"{}\"]) {\n    let l = /*@__PURE__*/p.charCodeAt(0), r = /*@__PURE__*/p.charCodeAt(1);\n    Brackets[l] = r;\n    Brackets[r] = -l;\n}\nfunction charType(ch) {\n    return ch <= 0xf7 ? LowTypes[ch] :\n        0x590 <= ch && ch <= 0x5f4 ? 2 /* R */ :\n            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :\n                0x6ee <= ch && ch <= 0x8ac ? 4 /* AL */ :\n                    0x2000 <= ch && ch <= 0x200b ? 256 /* NI */ :\n                        ch == 0x200c ? 256 /* NI */ : 1 /* L */;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/\nclass BidiSpan {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start of the span (relative to the start of the line).\n    */\n    from, \n    /**\n    The end of the span.\n    */\n    to, \n    /**\n    The [\"bidi\n    level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n    of the span (in this context, 0 means\n    left-to-right, 1 means right-to-left, 2 means left-to-right\n    number inside right-to-left text).\n    */\n    level) {\n        this.from = from;\n        this.to = to;\n        this.level = level;\n    }\n    /**\n    The direction of this span.\n    */\n    get dir() { return this.level % 2 ? RTL : LTR; }\n    /**\n    @internal\n    */\n    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }\n    /**\n    @internal\n    */\n    static find(order, index, level, assoc) {\n        let maybe = -1;\n        for (let i = 0; i < order.length; i++) {\n            let span = order[i];\n            if (span.from <= index && span.to >= index) {\n                if (span.level == level)\n                    return i;\n                // When multiple spans match, if assoc != 0, take the one that\n                // covers that side, otherwise take the one with the minimum\n                // level.\n                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))\n                    maybe = i;\n            }\n        }\n        if (maybe < 0)\n            throw new RangeError(\"Index out of range\");\n        return maybe;\n    }\n}\n// Reused array of character types\nconst types = [];\nfunction computeOrder(line, direction) {\n    let len = line.length, outerType = direction == LTR ? 1 /* L */ : 2 /* R */, oppositeType = direction == LTR ? 2 /* R */ : 1 /* L */;\n    if (!line || outerType == 1 /* L */ && !BidiRE.test(line))\n        return trivialOrder(len);\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    // (Left after this: L, R, EN, AN, ET, CS, NI)\n    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n        let type = charType(line.charCodeAt(i));\n        if (type == 512 /* NSM */)\n            type = prev;\n        else if (type == 8 /* EN */ && prevStrong == 4 /* AL */)\n            type = 16 /* AN */;\n        types[i] = type == 4 /* AL */ ? 2 /* R */ : type;\n        if (type & 7 /* Strong */)\n            prevStrong = type;\n        prev = type;\n    }\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    // (Left after this: L, R, EN+AN, NI)\n    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n        let type = types[i];\n        if (type == 128 /* CS */) {\n            if (i < len - 1 && prev == types[i + 1] && (prev & 24 /* Num */))\n                type = types[i] = prev;\n            else\n                types[i] = 256 /* NI */;\n        }\n        else if (type == 64 /* ET */) {\n            let end = i + 1;\n            while (end < len && types[end] == 64 /* ET */)\n                end++;\n            let replace = (i && prev == 8 /* EN */) || (end < len && types[end] == 8 /* EN */) ? (prevStrong == 1 /* L */ ? 1 /* L */ : 8 /* EN */) : 256 /* NI */;\n            for (let j = i; j < end; j++)\n                types[j] = replace;\n            i = end - 1;\n        }\n        else if (type == 8 /* EN */ && prevStrong == 1 /* L */) {\n            types[i] = 1 /* L */;\n        }\n        prev = type;\n        if (type & 7 /* Strong */)\n            prevStrong = type;\n    }\n    // N0. Process bracket pairs in an isolating run sequence\n    // sequentially in the logical order of the text positions of the\n    // opening paired brackets using the logic given below. Within this\n    // scope, bidirectional types EN and AN are treated as R.\n    for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {\n        // Keeps [startIndex, type, strongSeen] triples for each open\n        // bracket on BracketStack.\n        if (br = Brackets[ch = line.charCodeAt(i)]) {\n            if (br < 0) { // Closing bracket\n                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {\n                    if (BracketStack[sJ + 1] == -br) {\n                        let flags = BracketStack[sJ + 2];\n                        let type = (flags & 2 /* EmbedInside */) ? outerType :\n                            !(flags & 4 /* OppositeInside */) ? 0 :\n                                (flags & 1 /* OppositeBefore */) ? oppositeType : outerType;\n                        if (type)\n                            types[i] = types[BracketStack[sJ]] = type;\n                        sI = sJ;\n                        break;\n                    }\n                }\n            }\n            else if (BracketStack.length == 189 /* MaxDepth */) {\n                break;\n            }\n            else {\n                BracketStack[sI++] = i;\n                BracketStack[sI++] = ch;\n                BracketStack[sI++] = context;\n            }\n        }\n        else if ((type = types[i]) == 2 /* R */ || type == 1 /* L */) {\n            let embed = type == outerType;\n            context = embed ? 0 : 1 /* OppositeBefore */;\n            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {\n                let cur = BracketStack[sJ + 2];\n                if (cur & 2 /* EmbedInside */)\n                    break;\n                if (embed) {\n                    BracketStack[sJ + 2] |= 2 /* EmbedInside */;\n                }\n                else {\n                    if (cur & 4 /* OppositeInside */)\n                        break;\n                    BracketStack[sJ + 2] |= 4 /* OppositeInside */;\n                }\n            }\n        }\n    }\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    // (Left after this: L, R, EN+AN)\n    for (let i = 0; i < len; i++) {\n        if (types[i] == 256 /* NI */) {\n            let end = i + 1;\n            while (end < len && types[end] == 256 /* NI */)\n                end++;\n            let beforeL = (i ? types[i - 1] : outerType) == 1 /* L */;\n            let afterL = (end < len ? types[end] : outerType) == 1 /* L */;\n            let replace = beforeL == afterL ? (beforeL ? 1 /* L */ : 2 /* R */) : outerType;\n            for (let j = i; j < end; j++)\n                types[j] = replace;\n            i = end - 1;\n        }\n    }\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    let order = [];\n    if (outerType == 1 /* L */) {\n        for (let i = 0; i < len;) {\n            let start = i, rtl = types[i++] != 1 /* L */;\n            while (i < len && rtl == (types[i] != 1 /* L */))\n                i++;\n            if (rtl) {\n                for (let j = i; j > start;) {\n                    let end = j, l = types[--j] != 2 /* R */;\n                    while (j > start && l == (types[j - 1] != 2 /* R */))\n                        j--;\n                    order.push(new BidiSpan(j, end, l ? 2 : 1));\n                }\n            }\n            else {\n                order.push(new BidiSpan(start, i, 0));\n            }\n        }\n    }\n    else {\n        for (let i = 0; i < len;) {\n            let start = i, rtl = types[i++] == 2 /* R */;\n            while (i < len && rtl == (types[i] == 2 /* R */))\n                i++;\n            order.push(new BidiSpan(start, i, rtl ? 1 : 2));\n        }\n    }\n    return order;\n}\nfunction trivialOrder(length) {\n    return [new BidiSpan(0, length, 0)];\n}\nlet movedOver = \"\";\nfunction moveVisually(line, order, dir, start, forward) {\n    var _a;\n    let startIndex = start.head - line.from, spanI = -1;\n    if (startIndex == 0) {\n        if (!forward || !line.length)\n            return null;\n        if (order[0].level != dir) {\n            startIndex = order[0].side(false, dir);\n            spanI = 0;\n        }\n    }\n    else if (startIndex == line.length) {\n        if (forward)\n            return null;\n        let last = order[order.length - 1];\n        if (last.level != dir) {\n            startIndex = last.side(true, dir);\n            spanI = order.length - 1;\n        }\n    }\n    if (spanI < 0)\n        spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n    let span = order[spanI];\n    // End of span. (But not end of line--that was checked for above.)\n    if (startIndex == span.side(forward, dir)) {\n        span = order[spanI += forward ? 1 : -1];\n        startIndex = span.side(!forward, dir);\n    }\n    let indexForward = forward == (span.dir == dir);\n    let nextIndex = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, startIndex, indexForward);\n    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n    if (nextIndex != span.side(forward, dir))\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n    if (!nextSpan && span.level != dir)\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);\n    if (nextSpan && nextSpan.level < span.level)\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);\n}\n\nfunction groupAt(state, pos, bias = 1) {\n    let categorize = state.charCategorizer(pos);\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\n    if (line.length == 0)\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos);\n    if (linePos == 0)\n        bias = 1;\n    else if (linePos == line.length)\n        bias = -1;\n    let from = linePos, to = linePos;\n    if (bias < 0)\n        from = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, linePos, false);\n    else\n        to = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, linePos);\n    let cat = categorize(line.text.slice(from, to));\n    while (from > 0) {\n        let prev = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, from, false);\n        if (categorize(line.text.slice(prev, from)) != cat)\n            break;\n        from = prev;\n    }\n    while (to < line.length) {\n        let next = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, to);\n        if (categorize(line.text.slice(to, next)) != cat)\n            break;\n        to = next;\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY;\n    let above, below, aboveRect, belowRect;\n    for (let child = parent.firstChild; child; child = child.nextSibling) {\n        let rects = clientRectsFor(child);\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect))\n                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0)\n                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                }\n                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            }\n            else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            }\n            else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    }\n    else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest)\n        return { node: parent, offset: 0 };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3)\n        return domPosInText(closest, clipX, y);\n    if (!closestX && closest.contentEditable == \"true\")\n        return domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +\n        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return { node: parent, offset };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length;\n    let closestOffset = -1, closestDY = 1e9, generalSide = 0;\n    for (let i = 0; i < len; i++) {\n        let rects = textRange(node, i, i + 1).getClientRects();\n        for (let j = 0; j < rects.length; j++) {\n            let rect = rects[j];\n            if (rect.top == rect.bottom)\n                continue;\n            if (!generalSide)\n                generalSide = x - rect.left;\n            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\n            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    let rectBefore = textRange(node, i).getBoundingClientRect();\n                    if (rectBefore.left == rect.right)\n                        after = !right;\n                }\n                if (dy <= 0)\n                    return { node, offset: i + (after ? 1 : 0) };\n                closestOffset = i + (after ? 1 : 0);\n                closestDY = dy;\n            }\n        }\n    }\n    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };\n}\nfunction posAtCoords(view, { x, y }, precise, bias = -1) {\n    let content = view.contentDOM.getBoundingClientRect(), block;\n    let halfLine = view.defaultLineHeight / 2;\n    for (let bounced = false;;) {\n        block = view.blockAtHeight(y, content.top);\n        if (block.top > y || block.bottom < y) {\n            bias = block.top > y ? -1 : 1;\n            y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));\n            if (bounced)\n                return precise ? null : 0;\n            else\n                bounced = true;\n        }\n        if (block.type == BlockType.Text)\n            break;\n        y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n    }\n    let lineStart = block.from;\n    // Clip x to the viewport sides\n    x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from)\n        return view.viewport.from == 0 ? 0 : posAtCoordsImprecise(view, content, block, x, y);\n    if (lineStart > view.viewport.to)\n        return view.viewport.to == view.state.doc.length ? view.state.doc.length : posAtCoordsImprecise(view, content, block, x, y);\n    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\n    let doc = view.dom.ownerDocument;\n    let element = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(x, y);\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {\n        if (doc.caretPositionFromPoint) {\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos)\n                ({ offsetNode: node, offset } = pos);\n        }\n        else if (doc.caretRangeFromPoint) {\n            let range = doc.caretRangeFromPoint(x, y);\n            if (range) {\n                ({ startContainer: node, startOffset: offset } = range);\n                if (browser.safari && isSuspiciousCaretResult(node, offset, x))\n                    node = undefined;\n            }\n        }\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node || !view.docView.dom.contains(node)) {\n        let line = LineView.find(view.docView, lineStart);\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    return view.docView.posFromDOM(node, offset);\n}\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n        let line = Math.floor((y - block.top) / view.defaultLineHeight);\n        into += line * view.viewState.heightOracle.lineLength;\n    }\n    let content = view.state.sliceDoc(block.from, block.to);\n    return block.from + (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findColumn)(content, into, view.state.tabSize);\n}\n// In case of a high line height, Safari's caretRangeFromPoint treats\n// the space between lines as belonging to the last character of the\n// line before. This is used to detect such a result so that it can be\n// ignored (issue #401).\nfunction isSuspiciousCaretResult(node, offset, x) {\n    let len;\n    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))\n        return false;\n    for (let next = node.nextSibling; next; next = next.nextSibling)\n        if (next.nodeType != 1 || next.nodeName != \"BR\")\n            return false;\n    return textRange(node, len - 1, len).getBoundingClientRect().left > x;\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n    let line = view.state.doc.lineAt(start.head);\n    let coords = !includeWrap || !view.lineWrapping ? null\n        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n    if (coords) {\n        let editorRect = view.dom.getBoundingClientRect();\n        let pos = view.posAtCoords({ x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n            y: (coords.top + coords.bottom) / 2 });\n        if (pos != null)\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos, forward ? -1 : 1);\n    }\n    let lineView = LineView.find(view.docView, start.head);\n    let end = lineView ? (forward ? lineView.posAtEnd : lineView.posAtStart) : (forward ? line.to : line.from);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(end, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n    for (let cur = start, check = null;;) {\n        let next = moveVisually(line, spans, view.textDirection, cur, forward), char = movedOver;\n        if (!next) {\n            if (line.number == (forward ? view.state.doc.lines : 1))\n                return cur;\n            char = \"\\n\";\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\n            spans = view.bidiSpans(line);\n            next = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(forward ? line.from : line.to);\n        }\n        if (!check) {\n            if (!by)\n                return next;\n            check = by(char);\n        }\n        else if (!check(char)) {\n            return cur;\n        }\n        cur = next;\n    }\n}\nfunction byGroup(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start);\n    return (next) => {\n        let nextCat = categorize(next);\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.CharCategory.Space)\n            cat = nextCat;\n        return cat == nextCat;\n    };\n}\nfunction moveVertically(view, start, forward, distance) {\n    let startPos = start.head, dir = forward ? 1 : -1;\n    if (startPos == (forward ? view.state.doc.length : 0))\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(startPos);\n    let goal = start.goalColumn, startY;\n    let rect = view.contentDOM.getBoundingClientRect();\n    let startCoords = view.coordsAtPos(startPos);\n    if (startCoords) {\n        if (goal == null)\n            goal = startCoords.left - rect.left;\n        startY = dir < 0 ? startCoords.top : startCoords.bottom;\n    }\n    else {\n        let line = view.viewState.lineAt(startPos, view.dom.getBoundingClientRect().top);\n        if (goal == null)\n            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n        startY = dir < 0 ? line.top : line.bottom;\n    }\n    let resolvedGoal = rect.left + goal;\n    let dist = distance !== null && distance !== void 0 ? distance : (view.defaultLineHeight >> 1);\n    for (let extra = 0;; extra += 10) {\n        let curY = startY + (dist + extra) * dir;\n        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);\n        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos, undefined, undefined, goal);\n    }\n}\nfunction skipAtoms(view, oldPos, pos) {\n    let atoms = view.pluginField(PluginField.atomicRanges);\n    for (;;) {\n        let moved = false;\n        for (let set of atoms) {\n            set.between(pos.from - 1, pos.from + 1, (from, to, value) => {\n                if (pos.from > from && pos.from < to) {\n                    pos = oldPos.from > pos.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(from, 1) : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(to, -1);\n                    moved = true;\n                }\n            });\n        }\n        if (!moved)\n            return pos;\n    }\n}\n\n// This will also be where dragging info and such goes\nclass InputState {\n    constructor(view) {\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.pendingIOSKey = null;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastEscPress = 0;\n        this.lastContextMenu = 0;\n        this.scrollHandlers = [];\n        this.registeredEvents = [];\n        this.customHandlers = [];\n        // -1 means not in a composition. Otherwise, this counts the number\n        // of changes made during the composition. The count is used to\n        // avoid treating the start state of the composition, before any\n        // changes have been made, as part of the composition.\n        this.composing = -1;\n        // Tracks whether the next change should be marked as starting the\n        // composition (null means no composition, true means next is the\n        // first, false means first has already been marked for this\n        // composition)\n        this.compositionFirstChange = null;\n        this.compositionEndedAt = 0;\n        this.rapidCompositionStart = false;\n        this.mouseSelection = null;\n        for (let type in handlers) {\n            let handler = handlers[type];\n            view.contentDOM.addEventListener(type, (event) => {\n                if (type == \"keydown\" && this.keydown(view, event))\n                    return;\n                if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))\n                    return;\n                if (this.mustFlushObserver(event))\n                    view.observer.forceFlush();\n                if (this.runCustomHandlers(type, view, event))\n                    event.preventDefault();\n                else\n                    handler(view, event);\n            });\n            this.registeredEvents.push(type);\n        }\n        this.notifiedFocused = view.hasFocus;\n        this.ensureHandlers(view);\n        // On Safari adding an input event handler somehow prevents an\n        // issue where the composition vanishes when you press enter.\n        if (browser.safari)\n            view.contentDOM.addEventListener(\"input\", () => null);\n    }\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    ensureHandlers(view) {\n        let handlers = this.customHandlers = view.pluginField(domEventHandlers);\n        for (let set of handlers) {\n            for (let type in set.handlers)\n                if (this.registeredEvents.indexOf(type) < 0 && type != \"scroll\") {\n                    this.registeredEvents.push(type);\n                    view.contentDOM.addEventListener(type, (event) => {\n                        if (!eventBelongsToEditor(view, event))\n                            return;\n                        if (this.runCustomHandlers(type, view, event))\n                            event.preventDefault();\n                    });\n                }\n        }\n    }\n    runCustomHandlers(type, view, event) {\n        for (let set of this.customHandlers) {\n            let handler = set.handlers[type], handled = false;\n            if (handler) {\n                try {\n                    handled = handler.call(set.plugin, event, view);\n                }\n                catch (e) {\n                    logException(view.state, e);\n                }\n                if (handled || event.defaultPrevented) {\n                    // Chrome for Android often applies a bunch of nonsensical\n                    // DOM changes after an enter press, even when\n                    // preventDefault-ed. This tries to ignore those.\n                    if (browser.android && type == \"keydown\" && event.keyCode == 13)\n                        view.observer.flushSoon();\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    runScrollHandlers(view, event) {\n        for (let set of this.customHandlers) {\n            let handler = set.handlers.scroll;\n            if (handler) {\n                try {\n                    handler.call(set.plugin, event, view);\n                }\n                catch (e) {\n                    logException(view.state, e);\n                }\n            }\n        }\n    }\n    keydown(view, event) {\n        // Must always run, even if a custom handler handled the event\n        this.lastKeyCode = event.keyCode;\n        this.lastKeyTime = Date.now();\n        if (this.screenKeyEvent(view, event))\n            return true;\n        // Prevent the default behavior of Enter on iOS makes the\n        // virtual keyboard get stuck in the wrong (lowercase)\n        // state. So we let it go through, and then, in\n        // applyDOMChange, notify key handlers of it and reset to\n        // the state they produce.\n        if (browser.ios && (event.keyCode == 13 || event.keyCode == 8) &&\n            !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {\n            this.pendingIOSKey = event.keyCode == 13 ? \"enter\" : \"backspace\";\n            setTimeout(() => this.flushIOSKey(view), 250);\n            return true;\n        }\n        return false;\n    }\n    flushIOSKey(view) {\n        if (!this.pendingIOSKey)\n            return false;\n        let dom = view.contentDOM, key = this.pendingIOSKey;\n        this.pendingIOSKey = null;\n        return key == \"enter\" ? dispatchKey(dom, \"Enter\", 13) : dispatchKey(dom, \"Backspace\", 8);\n    }\n    ignoreDuringComposition(event) {\n        if (!/^key/.test(event.type))\n            return false;\n        if (this.composing > 0)\n            return true;\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n        // On some input method editors (IMEs), the Enter key is used to\n        // confirm character selection. On Safari, when Enter is pressed,\n        // compositionend and keydown events are sometimes emitted in the\n        // wrong order. The key event should still be ignored, even when\n        // it happens after the compositionend event.\n        if (browser.safari && Date.now() - this.compositionEndedAt < 500) {\n            this.compositionEndedAt = 0;\n            return true;\n        }\n        return false;\n    }\n    screenKeyEvent(view, event) {\n        let protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2000;\n        if (event.keyCode == 27)\n            this.lastEscPress = Date.now();\n        else if (modifierCodes.indexOf(event.keyCode) < 0)\n            this.lastEscPress = 0;\n        return protectedTab;\n    }\n    mustFlushObserver(event) {\n        return (event.type == \"keydown\" && event.keyCode != 229) ||\n            event.type == \"compositionend\" && !browser.ios;\n    }\n    startMouseSelection(view, event, style) {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n        this.mouseSelection = new MouseSelection(this, view, event, style);\n    }\n    update(update) {\n        if (this.mouseSelection)\n            this.mouseSelection.update(update);\n        if (update.transactions.length)\n            this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n    }\n}\n// Key codes for modifier keys\nconst modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];\nclass MouseSelection {\n    constructor(inputState, view, startEvent, style) {\n        this.inputState = inputState;\n        this.view = view;\n        this.style = style;\n        this.lastEvent = startEvent;\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = startEvent.shiftKey;\n        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n        this.dragMove = dragMovesSelection(view, startEvent);\n        this.dragging = isInPrimarySelection(view, startEvent) ? null : false;\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) {\n            startEvent.preventDefault();\n            this.select(startEvent);\n        }\n    }\n    move(event) {\n        if (event.buttons == 0)\n            return this.destroy();\n        if (this.dragging !== false)\n            return;\n        this.select(this.lastEvent = event);\n    }\n    up(event) {\n        if (this.dragging == null)\n            this.select(this.lastEvent);\n        if (!this.dragging)\n            event.preventDefault();\n        this.destroy();\n    }\n    destroy() {\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.inputState.mouseSelection = null;\n    }\n    select(event) {\n        let selection = this.style.get(event, this.extend, this.multiple);\n        if (!selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)\n            this.view.dispatch({\n                selection,\n                userEvent: \"select.pointer\",\n                scrollIntoView: true\n            });\n    }\n    update(update) {\n        if (update.docChanged && this.dragging)\n            this.dragging = this.dragging.map(update.changes);\n        if (this.style.update(update))\n            setTimeout(() => this.select(this.lastEvent), 20);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n    let facet = view.state.facet(dragMovesSelection$1);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n    let { main } = view.state.selection;\n    if (main.empty)\n        return false;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (sel.rangeCount == 0)\n        return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX &&\n            rect.top <= event.clientY && rect.bottom >= event.clientY)\n            return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)\n        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))\n            return false;\n    return true;\n}\nconst handlers = /*@__PURE__*/Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard APIall the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\n    (browser.ios && browser.webkit_version < 604);\nfunction capturePaste(view) {\n    let parent = view.dom.parentNode;\n    if (!parent)\n        return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(() => {\n        view.focus();\n        target.remove();\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction doPaste(view, input) {\n    let { state } = view, changes, i = 1, text = state.toText(input);\n    let byLine = text.lines == state.selection.ranges.length;\n    let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();\n    if (linewise) {\n        let lastLine = -1;\n        changes = state.changeByRange(range => {\n            let line = state.doc.lineAt(range.from);\n            if (line.from == lastLine)\n                return { range };\n            lastLine = line.from;\n            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n            return { changes: { from: line.from, insert },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(range.from + insert.length) };\n        });\n    }\n    else if (byLine) {\n        changes = state.changeByRange(range => {\n            let line = text.line(i++);\n            return { changes: { from: range.from, to: range.to, insert: line.text },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(range.from + line.length) };\n        });\n    }\n    else {\n        changes = state.replaceSelection(text);\n    }\n    view.dispatch(changes, {\n        userEvent: \"input.paste\",\n        scrollIntoView: true\n    });\n}\nhandlers.keydown = (view, event) => {\n    view.inputState.setSelectionOrigin(\"select\");\n};\nlet lastTouch = 0;\nhandlers.touchstart = (view, e) => {\n    lastTouch = Date.now();\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.touchmove = view => {\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.mousedown = (view, event) => {\n    view.observer.flush();\n    if (lastTouch > Date.now() - 2000)\n        return; // Ignore touch interaction\n    let style = null;\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {\n        style = makeStyle(view, event);\n        if (style)\n            break;\n    }\n    if (!style && event.button == 0)\n        style = basicMouseSelection(view, event);\n    if (style) {\n        if (view.root.activeElement != view.contentDOM)\n            view.observer.ignore(() => focusPreventScroll(view.contentDOM));\n        view.inputState.startMouseSelection(view, event, style);\n    }\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) { // Single click\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos, bias);\n    }\n    else if (type == 2) { // Double click\n        return groupAt(view.state, pos, bias);\n    }\n    else { // Triple click\n        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;\n        if (to < view.state.doc.length && to == line.to)\n            to++;\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.range(from, to);\n    }\n}\nlet insideY = (y, rect) => y >= rect.top && y <= rect.bottom;\nlet inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n    let line = LineView.find(view.docView, pos);\n    if (!line)\n        return 1;\n    let off = pos - line.posAtStart;\n    // Line boundaries point into the line\n    if (off == 0)\n        return 1;\n    if (off == line.length)\n        return -1;\n    // Positions on top of an element point at that element\n    let before = line.coordsAt(off, -1);\n    if (before && inside(x, y, before))\n        return -1;\n    let after = line.coordsAt(off, 1);\n    if (after && inside(x, y, after))\n        return 1;\n    // This is probably a line wrap point. Pick before if the point is\n    // beside it.\n    return before && insideY(y, before) ? -1 : 1;\n}\nfunction queryPos(view, event) {\n    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);\n    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;\nfunction getClickType(event) {\n    if (!BadMouseDetail)\n        return event.detail;\n    let last = lastMouseDown, lastTime = lastMouseDownTime;\n    lastMouseDown = event;\n    lastMouseDownTime = Date.now();\n    return lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&\n        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n    let start = queryPos(view, event), type = getClickType(event);\n    let startSel = view.state.selection;\n    let last = start, lastEvent = event;\n    return {\n        update(update) {\n            if (update.changes) {\n                if (start)\n                    start.pos = update.changes.mapPos(start.pos);\n                startSel = startSel.map(update.changes);\n                lastEvent = null;\n            }\n        },\n        get(event, extend, multiple) {\n            let cur;\n            if (lastEvent && event.clientX == lastEvent.clientX && event.clientY == lastEvent.clientY)\n                cur = last;\n            else {\n                cur = last = queryPos(view, event);\n                lastEvent = event;\n            }\n            if (!cur || !start)\n                return startSel;\n            let range = rangeForClick(view, cur.pos, cur.bias, type);\n            if (start.pos != cur.pos && !extend) {\n                let startRange = rangeForClick(view, start.pos, start.bias, type);\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.range(to, from);\n            }\n            if (extend)\n                return startSel.replaceRange(startSel.main.extend(range.from, range.to));\n            else if (multiple)\n                return startSel.addRange(range);\n            else\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.create([range]);\n        }\n    };\n}\nhandlers.dragstart = (view, event) => {\n    let { selection: { main } } = view.state;\n    let { mouseSelection } = view.inputState;\n    if (mouseSelection)\n        mouseSelection.dragging = main;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", view.state.sliceDoc(main.from, main.to));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n};\nfunction dropText(view, event, text, direct) {\n    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    if (dropPos == null || !text)\n        return;\n    event.preventDefault();\n    let { mouseSelection } = view.inputState;\n    let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ?\n        { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;\n    let ins = { from: dropPos, insert: text };\n    let changes = view.state.changes(del ? [del, ins] : ins);\n    view.focus();\n    view.dispatch({\n        changes,\n        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },\n        userEvent: del ? \"move.drop\" : \"input.drop\"\n    });\n}\nhandlers.drop = (view, event) => {\n    if (!event.dataTransfer)\n        return;\n    if (view.state.readOnly)\n        return event.preventDefault();\n    let files = event.dataTransfer.files;\n    if (files && files.length) { // For a file drop, read the file's text.\n        event.preventDefault();\n        let text = Array(files.length), read = 0;\n        let finishFile = () => {\n            if (++read == files.length)\n                dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);\n        };\n        for (let i = 0; i < files.length; i++) {\n            let reader = new FileReader;\n            reader.onerror = finishFile;\n            reader.onload = () => {\n                if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result))\n                    text[i] = reader.result;\n                finishFile();\n            };\n            reader.readAsText(files[i]);\n        }\n    }\n    else {\n        dropText(view, event, event.dataTransfer.getData(\"Text\"), true);\n    }\n};\nhandlers.paste = (view, event) => {\n    if (view.state.readOnly)\n        return event.preventDefault();\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        doPaste(view, data.getData(\"text/plain\"));\n        event.preventDefault();\n    }\n    else {\n        capturePaste(view);\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let parent = view.dom.parentNode;\n    if (!parent)\n        return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(() => {\n        target.remove();\n        view.focus();\n    }, 50);\n}\nfunction copiedRange(state) {\n    let content = [], ranges = [], linewise = false;\n    for (let range of state.selection.ranges)\n        if (!range.empty) {\n            content.push(state.sliceDoc(range.from, range.to));\n            ranges.push(range);\n        }\n    if (!content.length) {\n        // Nothing selected, do a line-wise copy\n        let upto = -1;\n        for (let { from } of state.selection.ranges) {\n            let line = state.doc.lineAt(from);\n            if (line.number > upto) {\n                content.push(line.text);\n                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });\n            }\n            upto = line.number;\n        }\n        linewise = true;\n    }\n    return { text: content.join(state.lineBreak), ranges, linewise };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event) => {\n    let { text, ranges, linewise } = copiedRange(view.state);\n    if (!text && !linewise)\n        return;\n    lastLinewiseCopy = linewise ? text : null;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/plain\", text);\n    }\n    else {\n        captureCopy(view, text);\n    }\n    if (event.type == \"cut\" && !view.state.readOnly)\n        view.dispatch({\n            changes: ranges,\n            scrollIntoView: true,\n            userEvent: \"delete.cut\"\n        });\n};\nhandlers.focus = handlers.blur = view => {\n    setTimeout(() => {\n        if (view.hasFocus != view.inputState.notifiedFocused)\n            view.update([]);\n    }, 10);\n};\nhandlers.beforeprint = view => {\n    view.viewState.printing = true;\n    view.requestMeasure();\n    setTimeout(() => {\n        view.viewState.printing = false;\n        view.requestMeasure();\n    }, 2000);\n};\nfunction forceClearComposition(view, rapid) {\n    if (view.docView.compositionDeco.size) {\n        view.inputState.rapidCompositionStart = rapid;\n        try {\n            view.update([]);\n        }\n        finally {\n            view.inputState.rapidCompositionStart = false;\n        }\n    }\n}\nhandlers.compositionstart = handlers.compositionupdate = view => {\n    if (view.inputState.compositionFirstChange == null)\n        view.inputState.compositionFirstChange = true;\n    if (view.inputState.composing < 0) {\n        if (view.docView.compositionDeco.size) {\n            view.observer.flush();\n            forceClearComposition(view, true);\n        }\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = 0;\n    }\n};\nhandlers.compositionend = view => {\n    view.inputState.composing = -1;\n    view.inputState.compositionEndedAt = Date.now();\n    view.inputState.compositionFirstChange = null;\n    setTimeout(() => {\n        if (view.inputState.composing < 0)\n            forceClearComposition(view, false);\n    }, 50);\n};\nhandlers.contextmenu = view => {\n    view.inputState.lastContextMenu = Date.now();\n};\n\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\"];\nclass HeightOracle {\n    constructor() {\n        this.doc = _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n        this.lineWrapping = false;\n        this.direction = Direction.LTR;\n        this.heightSamples = {};\n        this.lineHeight = 14;\n        this.charWidth = 7;\n        this.lineLength = 30;\n        // Used to track, during updateHeight, if any actual heights changed\n        this.heightChanged = false;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping)\n            lines += Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength);\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping)\n            return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) { this.doc = doc; return this; }\n    mustRefresh(lineHeights, whiteSpace, direction) {\n        let newHeight = false;\n        for (let i = 0; i < lineHeights.length; i++) {\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            }\n            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight || (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping || this.direction != direction;\n    }\n    refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) ||\n            this.lineWrapping != lineWrapping ||\n            this.direction != direction;\n        this.lineWrapping = lineWrapping;\n        this.direction = direction;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for (let i = 0; i < knownHeights.length; i++) {\n                let h = knownHeights[i];\n                if (h < 0)\n                    i++;\n                else\n                    this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights) {\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() { return this.index < this.heights.length; }\n}\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/\nclass BlockInfo {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start of the element in the document.\n    */\n    from, \n    /**\n    The length of the element.\n    */\n    length, \n    /**\n    The top position of the element.\n    */\n    top, \n    /**\n    Its height.\n    */\n    height, \n    /**\n    The type of element this is. When querying lines, this may be\n    an array of all the blocks that make up the line.\n    */\n    type) {\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this.type = type;\n    }\n    /**\n    The end of the element as a document position.\n    */\n    get to() { return this.from + this.length; }\n    /**\n    The bottom position of the element.\n    */\n    get bottom() { return this.top + this.height; }\n    /**\n    @internal\n    */\n    join(other) {\n        let detail = (Array.isArray(this.type) ? this.type : [this])\n            .concat(Array.isArray(other.type) ? other.type : [other]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);\n    }\n}\nvar QueryType = /*@__PURE__*/(function (QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\nreturn QueryType})(QueryType || (QueryType = {}));\nconst Epsilon = 1e-4;\nclass HeightMap {\n    constructor(length, // The number of characters covered\n    height, // Height of this part of the document\n    flags = 2 /* Outdated */) {\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() { return (this.flags & 2 /* Outdated */) > 0; }\n    set outdated(value) { this.flags = (value ? 2 /* Outdated */ : 0) | (this.flags & ~2 /* Outdated */); }\n    setHeight(oracle, height) {\n        if (this.height != height) {\n            if (Math.abs(this.height - height) > Epsilon)\n                oracle.heightChanged = true;\n            this.height = height;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) { result.push(this); }\n    decomposeRight(_from, result) { result.push(this); }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this;\n        for (let i = changes.length - 1; i >= 0; i--) {\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while (i > 0 && start.from <= changes[i - 1].toA) {\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from)\n                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);\n            me = me.replace(fromA, toA, nodes);\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() { return new HeightMapText(0, 0); }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1)\n            return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for (;;) {\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break)\n                        nodes.splice(--i, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                }\n                else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break)\n                        nodes.splice(j, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (before < after) {\n                let next = nodes[i++];\n                if (next)\n                    before += next.size;\n            }\n            else {\n                let next = nodes[--j];\n                if (next)\n                    after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        }\n        else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, type) {\n        super(length, height);\n        this.type = type;\n    }\n    blockAt(_height, _doc, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.type);\n    }\n    lineAt(_value, _type, doc, top, offset) {\n        return this.blockAt(0, doc, top, offset);\n    }\n    forEachLine(_from, _to, doc, top, offset, f) {\n        f(this.blockAt(0, doc, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() { return `block(${this.length})`; }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height) {\n        super(length, height, BlockType.Text);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n    }\n    replace(_from, _to, nodes) {\n        let node = nodes[0];\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* SingleLine */)) &&\n            Math.abs(this.length - node.length) < 10) {\n            if (node instanceof HeightMapGap)\n                node = new HeightMapText(node.length, this.height);\n            else\n                node.height = this.height;\n            if (!this.outdated)\n                node.outdated = false;\n            return node;\n        }\n        else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        else if (force || this.outdated)\n            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length) { super(length, 0); }\n    lines(doc, offset) {\n        let firstLine = doc.lineAt(offset).number, lastLine = doc.lineAt(offset + this.length).number;\n        return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };\n    }\n    blockAt(height, doc, top, offset) {\n        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);\n        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));\n        let { from, length } = doc.line(firstLine + line);\n        return new BlockInfo(from, length, top + lineHeight * line, lineHeight, BlockType.Text);\n    }\n    lineAt(value, type, doc, top, offset) {\n        if (type == QueryType.ByHeight)\n            return this.blockAt(value, doc, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { from, to } = doc.lineAt(value);\n            return new BlockInfo(from, to - from, 0, 0, BlockType.Text);\n        }\n        let { firstLine, lineHeight } = this.lines(doc, offset);\n        let { from, length, number } = doc.lineAt(value);\n        return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let { firstLine, lineHeight } = this.lines(doc, offset);\n        for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end;) {\n            let line = doc.lineAt(pos);\n            if (pos == from)\n                top += lineHeight * (line.number - firstLine);\n            f(new BlockInfo(line.from, line.length, top, lineHeight, BlockType.Text));\n            top += lineHeight;\n            pos = line.to + 1;\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap)\n                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else\n                nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap)\n                nodes[0] = new HeightMapGap(from + first.length);\n            else\n                nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(new HeightMapGap(to - 1), null);\n    }\n    decomposeRight(from, result) {\n        result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from);\n            if (measured.from > offset)\n                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while (pos <= end && measured.more) {\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length)\n                    nodes.push(null);\n                let line = new HeightMapText(len, measured.heights[measured.index++]);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end)\n                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            oracle.heightChanged = true;\n            return HeightMap.of(nodes);\n        }\n        else if (force || this.outdated) {\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() { return `gap(${this.length})`; }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right) {\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Outdated */ : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() { return this.flags & 1 /* Break */; }\n    blockAt(height, doc, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc, top, offset)\n            : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, doc, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, doc, top, offset)\n            : this.right.lineAt(value, type, doc, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))\n            return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left)\n            return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));\n        else\n            return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset)\n                this.left.forEachLine(from, to, doc, top, offset, f);\n            if (to >= rightOffset)\n                this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);\n        }\n        else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);\n            if (from < mid.from)\n                this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);\n            if (mid.to >= from && mid.from <= to)\n                f(mid);\n            if (to > mid.to)\n                this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart)\n            return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length)\n            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0)\n            this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)\n            result.push(node);\n        if (from > 0)\n            mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left)\n            return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left)\n                result.push(null);\n        }\n        if (to > left)\n            this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right)\n            return this.right.decomposeRight(from - right, result);\n        if (from < left)\n            this.left.decomposeRight(from, result);\n        if (this.break && from < right)\n            result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size)\n            return HeightMap.of(this.break ? [left, null, right] : [left, right]);\n        this.left = left;\n        this.right = right;\n        this.height = left.height + right.height;\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more)\n            rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else\n            left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more)\n            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else\n            right.updateHeight(oracle, rightStart, force);\n        if (rebalance)\n            return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() { return this.left + (this.break ? \" \" : \"-\") + this.right; }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null &&\n        (before = nodes[around - 1]) instanceof HeightMapGap &&\n        (after = nodes[around + 1]) instanceof HeightMapGap)\n        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle) {\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText)\n                last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered)\n                this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco.type));\n            }\n            else if (len || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, len);\n            }\n        }\n        else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos)\n            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n    enterLine() {\n        if (this.lineStart > -1)\n            return;\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = from;\n        this.lineEnd = to;\n        if (this.writtenTo < from) {\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)\n                this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > from)\n            this.nodes.push(new HeightMapText(this.pos - from, -1));\n        this.writtenTo = this.pos;\n    }\n    blankContent(from, to) {\n        let gap = new HeightMapGap(to - from);\n        if (this.oracle.doc.lineAt(from).to == to)\n            gap.flags |= 4 /* SingleLine */;\n        return gap;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText)\n            return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        if (block.type == BlockType.WidgetAfter && !this.isCovered)\n            this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (block.type != BlockType.WidgetBefore)\n            this.covering = block;\n    }\n    addLineDeco(height, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)\n            this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null)\n            this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n        let pos = from;\n        for (let node of this.nodes) {\n            if (node instanceof HeightMapText)\n                node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.spans(decorations, from, to, builder, 0);\n        return builder.finish(from);\n    }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n    let comp = new DecorationComparator;\n    _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.compare(a, b, diff, comp, 0);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange() { }\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant)\n            addRange(from, to, this.changes, 5);\n    }\n}\n\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);\n    for (let parent = dom.parentNode; parent;) { // (Cast to any because TypeScript is useless with Node types)\n        if (parent.nodeType == 1) {\n            let style = window.getComputedStyle(parent);\n            if ((parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) &&\n                style.overflow != \"visible\") {\n                let parentRect = parent.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = Math.min(bottom, parentRect.bottom);\n            }\n            parent = style.position == \"absolute\" || style.position == \"fixed\" ? parent.offsetParent : parent.parentNode;\n        }\n        else if (parent.nodeType == 11) { // Shadow root\n            parent = parent.host;\n        }\n        else {\n            break;\n        }\n    }\n    return { left: left - rect.left, right: right - rect.left,\n        top: top - (rect.top + paddingTop), bottom: bottom - (rect.top + paddingTop) };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size) {\n        this.from = from;\n        this.to = to;\n        this.size = size;\n    }\n    static same(a, b) {\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++) {\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)\n                return false;\n        }\n        return true;\n    }\n    draw(wrapping) {\n        return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    constructor(size, vertical) {\n        super();\n        this.size = size;\n        this.vertical = vertical;\n    }\n    eq(other) { return other.size == this.size && other.vertical == this.vertical; }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.vertical) {\n            elt.style.height = this.size + \"px\";\n        }\n        else {\n            elt.style.width = this.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    get estimatedHeight() { return this.vertical ? this.size : -1; }\n}\nclass ViewState {\n    constructor(state) {\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };\n        this.inView = true;\n        this.paddingTop = 0;\n        this.paddingBottom = 0;\n        this.contentWidth = 0;\n        this.heightOracle = new HeightOracle;\n        // See VP.MaxDOMHeight\n        this.scaler = IdScaler;\n        this.scrollTo = null;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        this.visibleRanges = [];\n        // Cursor 'assoc' is only significant when the cursor is on a line\n        // wrap point, where it must stick to the character that it is\n        // associated with. Since browsers don't provide a reasonable\n        // interface to set or query this, when a selection is set that\n        // might cause this to be significant, this flag is set. The next\n        // measure phase will check whether the cursor is on a line-wrapping\n        // boundary and, if so, reset it to make sure it is positioned in\n        // the right place.\n        this.mustEnforceCursorAssoc = false;\n        this.heightMap = HeightMap.empty().applyChanges(state.facet(decorations), _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\n        this.viewport = this.getViewport(0, null);\n        this.updateForViewport();\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));\n        this.computeVisibleRanges();\n    }\n    updateForViewport() {\n        let viewports = [this.viewport], { main } = this.state.selection;\n        for (let i = 0; i <= 1; i++) {\n            let pos = i ? main.head : main.anchor;\n            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {\n                let { from, to } = this.lineAt(pos, 0);\n                viewports.push(new Viewport(from, to));\n            }\n        }\n        this.viewports = viewports.sort((a, b) => a.from - b.from);\n        this.scaler = this.heightMap.height <= 7000000 /* MaxDOMHeight */ ? IdScaler :\n            new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);\n    }\n    update(update, scrollTo = null) {\n        let prev = this.state;\n        this.state = update.state;\n        let newDeco = this.state.facet(decorations);\n        let contentChanges = update.changedRanges;\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.startState.facet(decorations), newDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.ChangeSet.empty(this.state.doc.length)));\n        let prevHeight = this.heightMap.height;\n        this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight)\n            update.flags |= 2 /* Height */;\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (scrollTo && (scrollTo.head < viewport.from || scrollTo.head > viewport.to) || !this.viewportIsAppropriate(viewport))\n            viewport = this.getViewport(0, scrollTo);\n        this.viewport = viewport;\n        this.updateForViewport();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)\n            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        update.flags |= this.computeVisibleRanges();\n        if (scrollTo)\n            this.scrollTo = scrollTo;\n        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&\n            update.state.selection.main.empty && update.state.selection.main.assoc)\n            this.mustEnforceCursorAssoc = true;\n    }\n    measure(docView, repeated) {\n        let dom = docView.dom, whiteSpace = \"\", direction = Direction.LTR;\n        let result = 0;\n        if (!repeated) {\n            // Vertical padding\n            let style = window.getComputedStyle(dom);\n            whiteSpace = style.whiteSpace, direction = (style.direction == \"rtl\" ? Direction.RTL : Direction.LTR);\n            let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;\n            if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n                result |= 8 /* Geometry */;\n                this.paddingTop = paddingTop;\n                this.paddingBottom = paddingBottom;\n            }\n        }\n        // Pixel viewport\n        let pixelViewport = this.printing ? { top: -1e8, bottom: 1e8, left: -1e8, right: 1e8 } : visiblePixelRange(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        this.inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n        if (!this.inView)\n            return 0;\n        let lineHeights = docView.measureVisibleLineHeights();\n        let refresh = false, bias = 0, oracle = this.heightOracle;\n        if (!repeated) {\n            let contentWidth = docView.dom.clientWidth;\n            if (oracle.mustRefresh(lineHeights, whiteSpace, direction) ||\n                oracle.lineWrapping && Math.abs(contentWidth - this.contentWidth) > oracle.charWidth) {\n                let { lineHeight, charWidth } = docView.measureTextSize();\n                refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);\n                if (refresh) {\n                    docView.minWidth = 0;\n                    result |= 8 /* Geometry */;\n                }\n            }\n            if (this.contentWidth != contentWidth) {\n                this.contentWidth = contentWidth;\n                result |= 8 /* Geometry */;\n            }\n            if (dTop > 0 && dBottom > 0)\n                bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0)\n                bias = Math.min(dTop, dBottom);\n        }\n        oracle.heightChanged = false;\n        this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));\n        if (oracle.heightChanged)\n            result |= 2 /* Height */;\n        if (!this.viewportIsAppropriate(this.viewport, bias) ||\n            this.scrollTo && (this.scrollTo.head < this.viewport.from || this.scrollTo.head > this.viewport.to))\n            this.viewport = this.getViewport(bias, this.scrollTo);\n        this.updateForViewport();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)\n            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));\n        result |= this.computeVisibleRanges();\n        if (this.mustEnforceCursorAssoc) {\n            this.mustEnforceCursorAssoc = false;\n            // This is done in the read stage, because moving the selection\n            // to a line end is going to trigger a layout anyway, so it\n            // can't be a pure write. It should be rare that it does any\n            // writing.\n            docView.enforceCursorAssoc();\n        }\n        return result;\n    }\n    get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top, 0); }\n    get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom, 0); }\n    getViewport(bias, scrollTo) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* Margin */ / 2));\n        let map = this.heightMap, doc = this.state.doc, { visibleTop, visibleBottom } = this;\n        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).to);\n        // If scrollTo is given, make sure the viewport includes that position\n        if (scrollTo) {\n            if (scrollTo.head < viewport.from) {\n                let { top: newTop } = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(map.lineAt(newTop - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newTop + (visibleBottom - visibleTop) + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n            else if (scrollTo.head > viewport.to) {\n                let { bottom: newBottom } = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(map.lineAt(newBottom - (visibleBottom - visibleTop) - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newBottom + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);\n    }\n    // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n    viewportIsAppropriate({ from, to }, bias = 0) {\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);\n        let { visibleTop, visibleBottom } = this;\n        return (from == 0 || top <= visibleTop - Math.max(10 /* MinCoverMargin */, Math.min(-bias, 250 /* MaxCoverMargin */))) &&\n            (to == this.state.doc.length ||\n                bottom >= visibleBottom + Math.max(10 /* MinCoverMargin */, Math.min(bias, 250 /* MaxCoverMargin */))) &&\n            (top > visibleTop - 2 * 1000 /* Margin */ && bottom < visibleBottom + 2 * 1000 /* Margin */);\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || changes.empty)\n            return gaps;\n        let mapped = [];\n        for (let gap of gaps)\n            if (!changes.touchesRange(gap.from, gap.to))\n                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current) {\n        let gaps = [];\n        // This won't work at all in predominantly right-to-left text.\n        if (this.heightOracle.direction != Direction.LTR)\n            return gaps;\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, line => {\n            if (line.length < 10000 /* Margin */)\n                return;\n            let structure = lineStructure(line.from, line.to, this.state);\n            if (structure.total < 10000 /* Margin */)\n                return;\n            let viewFrom, viewTo;\n            if (this.heightOracle.lineWrapping) {\n                if (line.from != this.viewport.from)\n                    viewFrom = line.from;\n                else\n                    viewFrom = findPosition(structure, (this.visibleTop - line.top) / line.height);\n                if (line.to != this.viewport.to)\n                    viewTo = line.to;\n                else\n                    viewTo = findPosition(structure, (this.visibleBottom - line.top) / line.height);\n            }\n            else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);\n                viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);\n            }\n            let sel = this.state.selection.main;\n            // Make sure the gap doesn't cover a selection end\n            if (sel.from <= viewFrom && sel.to >= line.from)\n                viewFrom = sel.from;\n            if (sel.from <= line.to && sel.to >= viewTo)\n                viewTo = sel.to;\n            let gapTo = viewFrom - 10000 /* Margin */, gapFrom = viewTo + 10000 /* Margin */;\n            if (gapTo > line.from + 5000 /* HalfMargin */)\n                gaps.push(find(current, gap => gap.from == line.from && gap.to > gapTo - 5000 /* HalfMargin */ && gap.to < gapTo + 5000 /* HalfMargin */) ||\n                    new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));\n            if (gapFrom < line.to - 5000 /* HalfMargin */)\n                gaps.push(find(current, gap => gap.to == line.to && gap.from > gapFrom - 5000 /* HalfMargin */ &&\n                    gap.from < gapFrom + 5000 /* HalfMargin */) ||\n                    new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));\n        });\n        return gaps;\n    }\n    gapSize(line, pos, start, structure) {\n        if (this.heightOracle.lineWrapping) {\n            let height = line.height * findFraction(structure, pos);\n            return start ? height : line.height - height;\n        }\n        else {\n            let ratio = findFraction(structure, pos);\n            return structure.total * this.heightOracle.charWidth * (start ? ratio : 1 - ratio);\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));\n        }\n    }\n    computeVisibleRanges() {\n        let deco = this.state.facet(decorations);\n        if (this.lineGaps.length)\n            deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span(from, to) { ranges.push({ from, to }); },\n            point() { }\n        }, 20);\n        let changed = ranges.length != this.visibleRanges.length ||\n            this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);\n        this.visibleRanges = ranges;\n        return changed ? 4 /* Viewport */ : 0;\n    }\n    lineAt(pos, editorTop) {\n        editorTop += this.paddingTop;\n        return scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop, 0), this.scaler, editorTop);\n    }\n    lineAtHeight(height, editorTop) {\n        editorTop += this.paddingTop;\n        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height, editorTop), QueryType.ByHeight, this.state.doc, editorTop, 0), this.scaler, editorTop);\n    }\n    blockAtHeight(height, editorTop) {\n        editorTop += this.paddingTop;\n        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height, editorTop), this.state.doc, editorTop, 0), this.scaler, editorTop);\n    }\n    forEachLine(from, to, f, editorTop) {\n        editorTop += this.paddingTop;\n        return this.heightMap.forEachLine(from, to, this.state.doc, editorTop, 0, this.scaler.scale == 1 ? f : b => f(scaleBlock(b, this.scaler, editorTop)));\n    }\n    get contentHeight() {\n        return this.domHeight + this.paddingTop + this.paddingBottom;\n    }\n    get domHeight() {\n        return this.scaler.toDOM(this.heightMap.height, this.paddingTop);\n    }\n}\nclass Viewport {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\nfunction lineStructure(from, to, state) {\n    let ranges = [], pos = from, total = 0;\n    _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.spans(state.facet(decorations), from, to, {\n        span() { },\n        point(from, to) {\n            if (from > pos) {\n                ranges.push({ from: pos, to: from });\n                total += from - pos;\n            }\n            pos = to;\n        }\n    }, 20); // We're only interested in collapsed ranges of a significant size\n    if (pos < to) {\n        ranges.push({ from: pos, to });\n        total += to - pos;\n    }\n    return { total, ranges };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0)\n        return ranges[0].from;\n    if (ratio >= 1)\n        return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for (let i = 0;; i++) {\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size)\n            return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges) {\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)\n        if (f(val))\n            return val;\n    return undefined;\n}\n// Don't scale when the document height is within the range of what\n// the DOM can handle.\nconst IdScaler = {\n    toDOM(n) { return n; },\n    fromDOM(n) { return n; },\n    scale: 1\n};\n// When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\nclass BigScaler {\n    constructor(doc, heightMap, viewports) {\n        let vpHeight = 0, base = 0, domBase = 0;\n        this.viewports = viewports.map(({ from, to }) => {\n            let top = heightMap.lineAt(from, QueryType.ByPos, doc, 0, 0).top;\n            let bottom = heightMap.lineAt(to, QueryType.ByPos, doc, 0, 0).bottom;\n            vpHeight += bottom - top;\n            return { from, to, top, bottom, domTop: 0, domBottom: 0 };\n        });\n        this.scale = (7000000 /* MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);\n        for (let obj of this.viewports) {\n            obj.domTop = domBase + (obj.top - base) * this.scale;\n            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n            base = obj.bottom;\n        }\n    }\n    toDOM(n, top) {\n        n -= top;\n        for (let i = 0, base = 0, domBase = 0;; i++) {\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.top)\n                return domBase + (n - base) * this.scale + top;\n            if (n <= vp.bottom)\n                return vp.domTop + (n - vp.top) + top;\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    fromDOM(n, top) {\n        n -= top;\n        for (let i = 0, base = 0, domBase = 0;; i++) {\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.domTop)\n                return base + (n - domBase) / this.scale + top;\n            if (n <= vp.domBottom)\n                return vp.top + (n - vp.domTop) + top;\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n}\nfunction scaleBlock(block, scaler, top) {\n    if (scaler.scale == 1)\n        return block;\n    let bTop = scaler.toDOM(block.top, top), bBottom = scaler.toDOM(block.bottom, top);\n    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map(b => scaleBlock(b, scaler, top)) : block.type);\n}\n\nconst theme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({ combine: strs => strs.join(\" \") });\nconst darkTheme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({ combine: values => values.indexOf(true) > -1 });\nconst baseThemeID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseLightID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseDarkID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nconst lightDarkIDs = { \"&light\": \".\" + baseLightID, \"&dark\": \".\" + baseDarkID };\nfunction buildTheme(main, spec, scopes) {\n    return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n        finish(sel) {\n            return /&/.test(sel) ? sel.replace(/&\\w*/, m => {\n                if (m == \"&\")\n                    return main;\n                if (!scopes || !scopes[m])\n                    throw new RangeError(`Unsupported selector: ${m}`);\n                return scopes[m];\n            }) : main + \" \" + sel;\n        }\n    });\n}\nconst baseTheme = /*@__PURE__*/buildTheme(\".\" + baseThemeID, {\n    \"&\": {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.cm-focused\": {\n            // Provide a simple default outline to make sure a focused\n            // editor is visually distinct. Can't leave the default behavior\n            // because that will apply to the content element, which is\n            // inside the scrollable container and doesn't include the\n            // gutters. We also can't use an 'auto' outline, since those\n            // are, for some reason, drawn behind the element content, which\n            // will cause things like the active line background to cover\n            // the outline (#297).\n            outline: \"1px dotted #212121\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    \".cm-scroller\": {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\",\n        position: \"relative\",\n        zIndex: 0\n    },\n    \".cm-content\": {\n        margin: 0,\n        flexGrow: 2,\n        minHeight: \"100%\",\n        display: \"block\",\n        whiteSpace: \"pre\",\n        wordWrap: \"normal\",\n        boxSizing: \"border-box\",\n        padding: \"4px 0\",\n        outline: \"none\"\n    },\n    \".cm-lineWrapping\": {\n        whiteSpace: \"pre-wrap\",\n        wordBreak: \"break-word\",\n        overflowWrap: \"anywhere\"\n    },\n    \"&light .cm-content\": { caretColor: \"black\" },\n    \"&dark .cm-content\": { caretColor: \"white\" },\n    \".cm-line\": {\n        display: \"block\",\n        padding: \"0 2px 0 4px\"\n    },\n    \".cm-selectionLayer\": {\n        zIndex: -1,\n        contain: \"size style\"\n    },\n    \".cm-selectionBackground\": {\n        position: \"absolute\",\n    },\n    \"&light .cm-selectionBackground\": {\n        background: \"#d9d9d9\"\n    },\n    \"&dark .cm-selectionBackground\": {\n        background: \"#222\"\n    },\n    \"&light.cm-focused .cm-selectionBackground\": {\n        background: \"#d7d4f0\"\n    },\n    \"&dark.cm-focused .cm-selectionBackground\": {\n        background: \"#233\"\n    },\n    \".cm-cursorLayer\": {\n        zIndex: 100,\n        contain: \"size style\",\n        pointerEvents: \"none\"\n    },\n    \"&.cm-focused .cm-cursorLayer\": {\n        animation: \"steps(1) cm-blink 1.2s infinite\"\n    },\n    // Two animations defined so that we can switch between them to\n    // restart the animation without forcing another style\n    // recomputation.\n    \"@keyframes cm-blink\": { \"0%\": {}, \"50%\": { visibility: \"hidden\" }, \"100%\": {} },\n    \"@keyframes cm-blink2\": { \"0%\": {}, \"50%\": { visibility: \"hidden\" }, \"100%\": {} },\n    \".cm-cursor\": {\n        position: \"absolute\",\n        borderLeft: \"1.2px solid black\",\n        marginLeft: \"-0.6px\",\n        pointerEvents: \"none\",\n        display: \"none\"\n    },\n    \"&dark .cm-cursor\": {\n        borderLeftColor: \"#444\"\n    },\n    \"&.cm-focused .cm-cursor\": {\n        display: \"block\"\n    },\n    \"&light .cm-activeLine\": { backgroundColor: \"#f3f9ff\" },\n    \"&dark .cm-activeLine\": { backgroundColor: \"#223039\" },\n    \"&light .cm-specialChar\": { color: \"red\" },\n    \"&dark .cm-specialChar\": { color: \"#f78\" },\n    \".cm-tab\": {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    },\n    \".cm-placeholder\": {\n        color: \"#888\",\n        display: \"inline-block\"\n    },\n    \".cm-button\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        padding: \".2em 1em\",\n        borderRadius: \"3px\"\n    },\n    \"&light .cm-button\": {\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n        }\n    },\n    \"&dark .cm-button\": {\n        backgroundImage: \"linear-gradient(#393939, #111)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#111, #333)\"\n        }\n    },\n    \".cm-textfield\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        border: \"1px solid silver\",\n        padding: \".2em .5em\"\n    },\n    \"&light .cm-textfield\": {\n        backgroundColor: \"white\"\n    },\n    \"&dark .cm-textfield\": {\n        border: \"1px solid #555\",\n        backgroundColor: \"inherit\"\n    }\n}, lightDarkIDs);\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    attributes: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view, onChange, onScrollChanged) {\n        this.view = view;\n        this.onChange = onChange;\n        this.onScrollChanged = onScrollChanged;\n        this.active = false;\n        this.ignoreSelection = new DOMSelection;\n        this.delayedFlush = -1;\n        this.queue = [];\n        this.lastFlush = 0;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.intersecting = false;\n        this.gapIntersection = null;\n        this.gaps = [];\n        // Used to work around a Safari Selection/shadow DOM bug (#414)\n        this._selectionRange = null;\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver(mutations => {\n            for (let mut of mutations)\n                this.queue.push(mut);\n            this._selectionRange = null;\n            // IE11 will sometimes (on typing over a selection or\n            // backspacing out a single character text node) call the\n            // observer callback before actually updating the DOM.\n            //\n            // Unrelatedly, iOS Safari will, when ending a composition,\n            // sometimes first clear it, deliver the mutations, and then\n            // reinsert the finished text. CodeMirror's handling of the\n            // deletion will prevent the reinsertion from happening,\n            // breaking composition.\n            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&\n                mutations.some(m => m.type == \"childList\" && m.removedNodes.length ||\n                    m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n                this.flushSoon();\n            else\n                this.flush();\n        });\n        if (useCharData)\n            this.onCharData = (event) => {\n                this.queue.push({ target: event.target,\n                    type: \"characterData\",\n                    oldValue: event.prevValue });\n                this.flushSoon();\n            };\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n        this.start();\n        this.onScroll = this.onScroll.bind(this);\n        window.addEventListener(\"scroll\", this.onScroll);\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver(entries => {\n                if (this.parentCheck < 0)\n                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    if (this.intersecting != this.view.inView)\n                        this.onScrollChanged(document.createEvent(\"Event\"));\n                }\n            }, {});\n            this.intersection.observe(this.dom);\n            this.gapIntersection = new IntersectionObserver(entries => {\n                if (entries[entries.length - 1].intersectionRatio > 0)\n                    this.onScrollChanged(document.createEvent(\"Event\"));\n            }, {});\n        }\n        this.listenForScroll();\n    }\n    onScroll(e) {\n        if (this.intersecting)\n            this.flush();\n        this.onScrollChanged(e);\n    }\n    updateGaps(gaps) {\n        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {\n            this.gapIntersection.disconnect();\n            for (let gap of gaps)\n                this.gapIntersection.observe(gap);\n            this.gaps = gaps;\n        }\n    }\n    onSelectionChange(event) {\n        if (this.lastFlush < Date.now() - 50)\n            this._selectionRange = null;\n        let { view } = this, sel = this.selectionRange;\n        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))\n            return;\n        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n        if (context && context.ignoreEvent(event))\n            return;\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        // (Selection.isCollapsed isn't reliable on IE)\n        if (browser.ie && browser.ie_version <= 11 && !view.state.selection.main.empty &&\n            sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n            this.flushSoon();\n        else\n            this.flush();\n    }\n    get selectionRange() {\n        if (!this._selectionRange) {\n            let { root } = this.view, sel = getSelection(root);\n            // The Selection object is broken in shadow roots in Safari. See\n            // https://github.com/codemirror/codemirror.next/issues/414\n            if (browser.safari && root.nodeType == 11 && deepActiveElement() == this.view.contentDOM)\n                sel = safariSelectionRangeHack(this.view) || sel;\n            this._selectionRange = sel;\n        }\n        return this._selectionRange;\n    }\n    setSelectionRange(anchor, head) {\n        var _a;\n        if (!((_a = this._selectionRange) === null || _a === void 0 ? void 0 : _a.type))\n            this._selectionRange = { anchorNode: anchor.node, anchorOffset: anchor.offset,\n                focusNode: head.node, focusOffset: head.offset };\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for (let dom = this.dom; dom;) {\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)\n                    i++;\n                else if (!changed)\n                    changed = this.scrollTargets.slice(0, i);\n                if (changed)\n                    changed.push(dom);\n                dom = dom.assignedSlot || dom.parentNode;\n            }\n            else if (dom.nodeType == 11) { // Shadow root\n                dom = dom.host;\n            }\n            else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed)\n            changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)\n                dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)\n                dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active)\n            return f();\n        try {\n            this.stop();\n            return f();\n        }\n        finally {\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active)\n            return;\n        this.observer.observe(this.dom, observeOptions);\n        this.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active)\n            return;\n        this.active = false;\n        this.observer.disconnect();\n        this.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    clearSelection() {\n        this.ignoreSelection.set(this.selectionRange);\n    }\n    // Throw away any pending changes\n    clear() {\n        this.observer.takeRecords();\n        this.queue.length = 0;\n        this.clearSelection();\n    }\n    flushSoon() {\n        if (this.delayedFlush < 0)\n            this.delayedFlush = window.setTimeout(() => { this.delayedFlush = -1; this.flush(); }, 20);\n    }\n    forceFlush() {\n        if (this.delayedFlush >= 0) {\n            window.clearTimeout(this.delayedFlush);\n            this.delayedFlush = -1;\n            this.flush();\n        }\n    }\n    // Apply pending changes, if any\n    flush() {\n        if (this.delayedFlush >= 0)\n            return;\n        this.lastFlush = Date.now();\n        let records = this.queue;\n        for (let mut of this.observer.takeRecords())\n            records.push(mut);\n        if (records.length)\n            this.queue = [];\n        let selection = this.selectionRange;\n        let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);\n        if (records.length == 0 && !newSel)\n            return;\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records) {\n            let range = this.readMutation(record);\n            if (!range)\n                continue;\n            if (range.typeOver)\n                typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            }\n            else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        let startState = this.view.state;\n        if (from > -1 || newSel)\n            this.onChange(from, to, typeOver);\n        if (this.view.state == startState) { // The view wasn't updated\n            if (this.view.docView.dirty) {\n                this.ignore(() => this.view.docView.sync());\n                this.view.docView.dirty = 0 /* Not */;\n            }\n            if (newSel)\n                this.view.docView.updateSelection();\n        }\n        this.clearSelection();\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec))\n            return null;\n        cView.markDirty(rec.type == \"attributes\");\n        if (rec.type == \"attributes\")\n            cView.dirty |= 4 /* Attrs */;\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };\n        }\n        else if (rec.type == \"characterData\") {\n            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };\n        }\n        else {\n            return null;\n        }\n    }\n    destroy() {\n        this.stop();\n        if (this.intersection)\n            this.intersection.disconnect();\n        if (this.gapIntersection)\n            this.gapIntersection.disconnect();\n        for (let dom of this.scrollTargets)\n            dom.removeEventListener(\"scroll\", this.onScroll);\n        window.removeEventListener(\"scroll\", this.onScroll);\n        clearTimeout(this.parentCheck);\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while (dom) {\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView)\n            return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\nfunction safariSelectionRangeHack(view) {\n    let found = null;\n    // Because Safari (at least in 2018-2021) doesn't provide regular\n    // access to the selection inside a shadowroot, we have to perform a\n    // ridiculous hack to get at itusing `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    view.contentDOM.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n    if (!found)\n        return null;\n    let anchorNode = found.startContainer, anchorOffset = found.startOffset;\n    let focusNode = found.endContainer, focusOffset = found.endOffset;\n    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))\n        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n    return { anchorNode, anchorOffset, focusNode, focusOffset };\n}\n\nfunction applyDOMChange(view, start, end, typeOver) {\n    let change, newSel;\n    let sel = view.state.selection.main, bounds;\n    if (start > -1 && !view.state.readOnly && (bounds = view.docView.domBoundsAround(start, end, 0))) {\n        let { from, to } = bounds;\n        let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);\n        let reader = new DOMReader(selPoints, view);\n        reader.readRange(bounds.startDOM, bounds.endDOM);\n        newSel = selectionFromPoints(selPoints, from);\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed (or, on\n        // Android, when something was deleted)\n        if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 ||\n            browser.android && reader.text.length < to - from) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.sliceDoc(from, to), reader.text, preferredPos - from, preferredSide);\n        if (diff)\n            change = { from: from + diff.from, to: from + diff.toA,\n                insert: view.state.toText(reader.text.slice(diff.from, diff.toB)) };\n    }\n    else if (view.hasFocus || !view.state.facet(editable)) {\n        let domSel = view.observer.selectionRange;\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||\n            !contains(view.contentDOM, domSel.focusNode)\n            ? view.state.selection.main.head\n            : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||\n            !contains(view.contentDOM, domSel.anchorNode)\n            ? view.state.selection.main.anchor\n            : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n        if (head != sel.head || anchor != sel.anchor)\n            newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.single(anchor, head);\n    }\n    if (!change && !newSel)\n        return;\n    // Heuristic to notice typing over a selected character\n    if (!change && typeOver && !sel.empty && newSel && newSel.main.empty)\n        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };\n    // If the change is inside the selection and covers most of it,\n    // assume it is a selection replace (with identical characters at\n    // the start/end not included in the diff)\n    else if (change && change.from >= sel.from && change.to <= sel.to &&\n        (change.from != sel.from || change.to != sel.to) &&\n        (sel.to - sel.from) - (change.to - change.from) <= 4)\n        change = {\n            from: sel.from, to: sel.to,\n            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n        };\n    if (change) {\n        let startState = view.state;\n        // Android browsers don't fire reasonable key events for enter,\n        // backspace, or delete. So this detects changes that look like\n        // they're caused by those keys, and reinterprets them as key\n        // events.\n        if (browser.android &&\n            ((change.from == sel.from && change.to == sel.to &&\n                change.insert.length == 1 && change.insert.lines == 2 &&\n                dispatchKey(view.contentDOM, \"Enter\", 13)) ||\n                (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 &&\n                    dispatchKey(view.contentDOM, \"Backspace\", 8)) ||\n                (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&\n                    dispatchKey(view.contentDOM, \"Delete\", 46))) ||\n            browser.ios && view.inputState.flushIOSKey(view))\n            return;\n        let text = change.insert.toString();\n        if (view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text)))\n            return;\n        if (view.inputState.composing >= 0)\n            view.inputState.composing++;\n        let tr;\n        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&\n            (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length)) {\n            let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n            let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n            tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) +\n                after));\n        }\n        else {\n            let changes = startState.changes(change);\n            tr = {\n                changes,\n                selection: newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength\n                    ? startState.selection.replaceRange(newSel.main) : undefined\n            };\n        }\n        let userEvent = \"input.type\";\n        if (view.composing) {\n            userEvent += \".compose\";\n            if (view.inputState.compositionFirstChange) {\n                userEvent += \".start\";\n                view.inputState.compositionFirstChange = false;\n            }\n        }\n        view.dispatch(tr, { scrollIntoView: true, userEvent });\n    }\n    else if (newSel && !newSel.main.eq(sel)) {\n        let scrollIntoView = false, userEvent = \"select\";\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"select\")\n                scrollIntoView = true;\n            userEvent = view.inputState.lastSelectionOrigin;\n        }\n        view.dispatch({ selection: newSel, scrollIntoView, userEvent });\n    }\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))\n        from++;\n    if (from == minLen && a.length == b.length)\n        return null;\n    let toA = a.length, toB = b.length;\n    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    }\n    else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return { from, toA, toB };\n}\nclass DOMReader {\n    constructor(points, view) {\n        this.points = points;\n        this.view = view;\n        this.text = \"\";\n        this.lineBreak = view.state.lineBreak;\n    }\n    readRange(start, end) {\n        if (!start)\n            return;\n        let parent = start.parentNode;\n        for (let cur = start;;) {\n            this.findPointBefore(parent, cur);\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end)\n                break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if (view && nextView ? view.breakAfter :\n                (view ? view.breakAfter : isBlockElement(cur)) ||\n                    (isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore)))\n                this.text += this.lineBreak;\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n    }\n    readNode(node) {\n        if (node.cmIgnore)\n            return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        let text;\n        if (fromView != null)\n            text = fromView.sliceString(0, undefined, this.lineBreak);\n        else if (node.nodeType == 3)\n            text = node.nodeValue;\n        else if (node.nodeName == \"BR\")\n            text = node.nextSibling ? this.lineBreak : \"\";\n        else if (node.nodeType == 1)\n            this.readRange(node.firstChild, null);\n        if (text != null) {\n            this.findPointIn(node, text.length);\n            this.text += text;\n            // Chrome inserts two newlines when pressing shift-enter at the\n            // end of a line. This drops one of those.\n            if (browser.chrome && this.view.inputState.lastKeyCode == 13 && !node.nextSibling && /\\n\\n$/.test(this.text))\n                this.text = this.text.slice(0, -1);\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)\n            if (point.node == node && node.childNodes[point.offset] == next)\n                point.pos = this.text.length;\n    }\n    findPointIn(node, maxLen) {\n        for (let point of this.points)\n            if (point.node == node)\n                point.pos = this.text.length + Math.min(point.offset, maxLen);\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n    constructor(node, offset) {\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nfunction selectionPoints(view) {\n    let result = [];\n    if (view.root.activeElement != view.contentDOM)\n        return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset)\n            result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0)\n        return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.single(anchor + base, head + base) : null;\n}\n\n// The editor's update state machine looks something like this:\n//\n//     Idle  Updating  Idle (unchecked)  Measuring  Idle\n//                                               \n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/\nclass EditorView {\n    /**\n    Construct a new view. You'll usually want to put `view.dom` into\n    your document after creating a view, so that the user can see\n    it.\n    */\n    constructor(\n    /**\n    Initialization options.\n    */\n    config = {}) {\n        this.plugins = [];\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.bidiCache = [];\n        this.destroyed = false;\n        /**\n        @internal\n        */\n        this.updateState = 2 /* Updating */;\n        /**\n        @internal\n        */\n        this.measureScheduled = -1;\n        /**\n        @internal\n        */\n        this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.tabIndex = -1;\n        this.scrollDOM.className = \"cm-scroller\";\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.announceDOM = document.createElement(\"div\");\n        this.announceDOM.style.cssText = \"position: absolute; top: -10000px\";\n        this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.announceDOM);\n        this.dom.appendChild(this.scrollDOM);\n        this._dispatch = config.dispatch || ((tr) => this.update([tr]));\n        this.dispatch = this.dispatch.bind(this);\n        this.root = (config.root || document);\n        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorState.create());\n        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec).update(this));\n        this.observer = new DOMObserver(this, (from, to, typeOver) => {\n            applyDOMChange(this, from, to, typeOver);\n        }, event => {\n            this.inputState.runScrollHandlers(this, event);\n            if (this.observer.intersecting)\n                this.measure();\n        });\n        this.inputState = new InputState(this);\n        this.docView = new DocView(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* Idle */;\n        ensureGlobalHandler();\n        this.requestMeasure();\n        if (config.parent)\n            config.parent.appendChild(this.dom);\n    }\n    /**\n    The current editor state.\n    */\n    get state() { return this.viewState.state; }\n    /**\n    To be able to display large documents without consuming too much\n    memory or overloading the browser, CodeMirror only draws the\n    code that is visible (plus a margin around it) to the DOM. This\n    property tells you the extent of the current drawn viewport, in\n    document positions.\n    */\n    get viewport() { return this.viewState.viewport; }\n    /**\n    When there are, for example, large collapsed ranges in the\n    viewport, its size can be a lot bigger than the actual visible\n    content. Thus, if you are doing something like styling the\n    content in the viewport, it is preferable to only do so for\n    these ranges, which are the subset of the viewport that is\n    actually drawn.\n    */\n    get visibleRanges() { return this.viewState.visibleRanges; }\n    /**\n    Returns false when the editor is entirely scrolled out of view\n    or otherwise hidden.\n    */\n    get inView() { return this.viewState.inView; }\n    /**\n    Indicates whether the user is currently composing text via\n    [IME](https://en.wikipedia.org/wiki/Input_method).\n    */\n    get composing() { return this.inputState.composing > 0; }\n    dispatch(...input) {\n        this._dispatch(input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Transaction ? input[0]\n            : this.state.update(...input));\n    }\n    /**\n    Update the view for the given array of transactions. This will\n    update the visible document and selection to match the state\n    produced by the transactions, and notify view plugins of the\n    change. You should usually call\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n    as a primitive.\n    */\n    update(transactions) {\n        if (this.updateState != 0 /* Idle */)\n            throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        let redrawn = false, update;\n        let state = this.state;\n        for (let tr of transactions) {\n            if (tr.startState != state)\n                throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n            state = tr.state;\n        }\n        if (this.destroyed) {\n            this.viewState.state = state;\n            return;\n        }\n        // When the phrases change, redraw the editor\n        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorState.phrases))\n            return this.setState(state);\n        update = new ViewUpdate(this, state, transactions);\n        let scrollPos = null;\n        try {\n            this.updateState = 2 /* Updating */;\n            for (let tr of transactions) {\n                if (scrollPos)\n                    scrollPos = scrollPos.map(tr.changes);\n                if (tr.scrollIntoView) {\n                    let { main } = tr.state.selection;\n                    scrollPos = main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1);\n                }\n                for (let e of tr.effects)\n                    if (e.is(scrollTo))\n                        scrollPos = e.value;\n            }\n            this.viewState.update(update, scrollPos);\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n            if (!update.empty) {\n                this.updatePlugins(update);\n                this.inputState.update(update);\n            }\n            redrawn = this.docView.update(update);\n            if (this.state.facet(styleModule) != this.styleModules)\n                this.mountStyles();\n            this.updateAttrs();\n            this.showAnnouncements(transactions);\n        }\n        finally {\n            this.updateState = 0 /* Idle */;\n        }\n        if (redrawn || scrollPos || this.viewState.mustEnforceCursorAssoc)\n            this.requestMeasure();\n        if (!update.empty)\n            for (let listener of this.state.facet(updateListener))\n                listener(update);\n    }\n    /**\n    Reset the view to the given state. (This will cause the entire\n    document to be redrawn and all view plugins to be reinitialized,\n    so you should probably only use it when the new state isn't\n    derived from the old state. Otherwise, use\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n    */\n    setState(newState) {\n        if (this.updateState != 0 /* Idle */)\n            throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n        if (this.destroyed) {\n            this.viewState.state = newState;\n            return;\n        }\n        this.updateState = 2 /* Updating */;\n        try {\n            for (let plugin of this.plugins)\n                plugin.destroy(this);\n            this.viewState = new ViewState(newState);\n            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec).update(this));\n            this.docView = new DocView(this);\n            this.inputState.ensureHandlers(this);\n            this.mountStyles();\n            this.updateAttrs();\n            this.bidiCache = [];\n        }\n        finally {\n            this.updateState = 0 /* Idle */;\n        }\n        this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [];\n            for (let spec of specs) {\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(new PluginInstance(spec));\n                }\n                else {\n                    let plugin = this.plugins[found];\n                    plugin.mustUpdate = update;\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)\n                if (plugin.mustUpdate != update)\n                    plugin.destroy(this);\n            this.plugins = newPlugins;\n            this.inputState.ensureHandlers(this);\n        }\n        else {\n            for (let p of this.plugins)\n                p.mustUpdate = update;\n        }\n        for (let i = 0; i < this.plugins.length; i++)\n            this.plugins[i] = this.plugins[i].update(this);\n    }\n    /**\n    @internal\n    */\n    measure(flush = true) {\n        if (this.destroyed)\n            return;\n        if (this.measureScheduled > -1)\n            cancelAnimationFrame(this.measureScheduled);\n        this.measureScheduled = -1; // Prevent requestMeasure calls from scheduling another animation frame\n        if (flush)\n            this.observer.flush();\n        let updated = null;\n        try {\n            for (let i = 0;; i++) {\n                this.updateState = 1 /* Measuring */;\n                let oldViewport = this.viewport;\n                let changed = this.viewState.measure(this.docView, i > 0);\n                if (!changed && !this.measureRequests.length && this.viewState.scrollTo == null)\n                    break;\n                if (i > 5) {\n                    console.warn(\"Viewport failed to stabilize\");\n                    break;\n                }\n                let measuring = [];\n                // Only run measure requests in this cycle when the viewport didn't change\n                if (!(changed & 4 /* Viewport */))\n                    [this.measureRequests, measuring] = [measuring, this.measureRequests];\n                let measured = measuring.map(m => {\n                    try {\n                        return m.read(this);\n                    }\n                    catch (e) {\n                        logException(this.state, e);\n                        return BadMeasure;\n                    }\n                });\n                let update = new ViewUpdate(this, this.state);\n                update.flags |= changed;\n                if (!updated)\n                    updated = update;\n                else\n                    updated.flags |= changed;\n                this.updateState = 2 /* Updating */;\n                if (!update.empty) {\n                    this.updatePlugins(update);\n                    this.inputState.update(update);\n                }\n                this.updateAttrs();\n                if (changed)\n                    this.docView.update(update);\n                for (let i = 0; i < measuring.length; i++)\n                    if (measured[i] != BadMeasure) {\n                        try {\n                            measuring[i].write(measured[i], this);\n                        }\n                        catch (e) {\n                            logException(this.state, e);\n                        }\n                    }\n                if (this.viewState.scrollTo) {\n                    this.docView.scrollRangeIntoView(this.viewState.scrollTo);\n                    this.viewState.scrollTo = null;\n                }\n                if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && this.measureRequests.length == 0)\n                    break;\n            }\n        }\n        finally {\n            this.updateState = 0 /* Idle */;\n        }\n        this.measureScheduled = -1;\n        if (updated && !updated.empty)\n            for (let listener of this.state.facet(updateListener))\n                listener(updated);\n    }\n    /**\n    Get the CSS classes for the currently active editor themes.\n    */\n    get themeClasses() {\n        return baseThemeID + \" \" +\n            (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" +\n            this.state.facet(theme);\n    }\n    updateAttrs() {\n        let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {\n            class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n        });\n        updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n        this.editorAttrs = editorAttrs;\n        let contentAttrs = {\n            spellcheck: \"false\",\n            autocorrect: \"off\",\n            autocapitalize: \"off\",\n            contenteditable: !this.state.facet(editable) ? \"false\" : contentEditablePlainTextSupported() ? \"plaintext-only\" : \"true\",\n            class: \"cm-content\",\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\n            role: \"textbox\",\n            \"aria-multiline\": \"true\"\n        };\n        if (this.state.readOnly)\n            contentAttrs[\"aria-readonly\"] = \"true\";\n        combineAttrs(this.state.facet(contentAttributes), contentAttrs);\n        updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n        this.contentAttrs = contentAttrs;\n    }\n    showAnnouncements(trs) {\n        let first = true;\n        for (let tr of trs)\n            for (let effect of tr.effects)\n                if (effect.is(EditorView.announce)) {\n                    if (first)\n                        this.announceDOM.textContent = \"\";\n                    first = false;\n                    let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n                    div.textContent = effect.value;\n                }\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* Updating */)\n            throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* Idle */ && this.measureScheduled > -1)\n            this.measure(false);\n    }\n    /**\n    Schedule a layout measurement, optionally providing callbacks to\n    do custom DOM measuring followed by a DOM write phase. Using\n    this is preferable reading DOM layout directly from, for\n    example, an event handler, because it'll make sure measuring and\n    drawing done by other components is synchronized, avoiding\n    unnecessary DOM layout computations.\n    */\n    requestMeasure(request) {\n        if (this.measureScheduled < 0)\n            this.measureScheduled = requestAnimationFrame(() => this.measure());\n        if (request) {\n            if (request.key != null)\n                for (let i = 0; i < this.measureRequests.length; i++) {\n                    if (this.measureRequests[i].key === request.key) {\n                        this.measureRequests[i] = request;\n                        return;\n                    }\n                }\n            this.measureRequests.push(request);\n        }\n    }\n    /**\n    Collect all values provided by the active plugins for a given\n    field.\n    */\n    pluginField(field) {\n        let result = [];\n        for (let plugin of this.plugins)\n            plugin.update(this).takeField(field, result);\n        return result;\n    }\n    /**\n    Get the value of a specific plugin, if present. Note that\n    plugins that crash can be dropped from a view, so even when you\n    know you registered a given plugin, it is recommended to check\n    the return value of this method.\n    */\n    plugin(plugin) {\n        for (let inst of this.plugins)\n            if (inst.spec == plugin)\n                return inst.update(this).value;\n        return null;\n    }\n    /**\n    Find the line or block widget at the given vertical position.\n    \n    By default, this position is interpreted as a screen position,\n    meaning `docTop` is set to the DOM top position of the editor\n    content (forcing a layout). You can pass a different `docTop`\n    valuefor example 0 to interpret `height` as a document-relative\n    position, or a precomputed document top\n    (`view.contentDOM.getBoundingClientRect().top`) to limit layout\n    queries.\n    */\n    blockAtHeight(height, docTop) {\n        this.readMeasured();\n        return this.viewState.blockAtHeight(height, ensureTop(docTop, this.contentDOM));\n    }\n    /**\n    Find information for the visual line (see\n    [`visualLineAt`](https://codemirror.net/6/docs/ref/#view.EditorView.visualLineAt)) at the given\n    vertical position. The resulting block info might hold another\n    array of block info structs in its `type` field if this line\n    consists of more than one block.\n    \n    Defaults to treating `height` as a screen position. See\n    [`blockAtHeight`](https://codemirror.net/6/docs/ref/#view.EditorView.blockAtHeight) for the\n    interpretation of the `docTop` parameter.\n    */\n    visualLineAtHeight(height, docTop) {\n        this.readMeasured();\n        return this.viewState.lineAtHeight(height, ensureTop(docTop, this.contentDOM));\n    }\n    /**\n    Iterate over the height information of the visual lines in the\n    viewport. The heights of lines are reported relative to the\n    given document top, which defaults to the screen position of the\n    document (forcing a layout).\n    */\n    viewportLines(f, docTop) {\n        let { from, to } = this.viewport;\n        this.viewState.forEachLine(from, to, f, ensureTop(docTop, this.contentDOM));\n    }\n    /**\n    Find the extent and height of the visual line (a range delimited\n    on both sides by either non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^range)\n    line breaks, or the start/end of the document) at the given position.\n    \n    Vertical positions are computed relative to the `docTop`\n    argument, which defaults to 0 for this method. You can pass\n    `view.contentDOM.getBoundingClientRect().top` here to get screen\n    coordinates.\n    */\n    visualLineAt(pos, docTop = 0) {\n        return this.viewState.lineAt(pos, docTop);\n    }\n    /**\n    The editor's total content height.\n    */\n    get contentHeight() {\n        return this.viewState.contentHeight;\n    }\n    /**\n    Move a cursor position by [grapheme\n    cluster](https://codemirror.net/6/docs/ref/#text.findClusterBreak). `forward` determines whether\n    the motion is away from the line start, or towards it. Motion in\n    bidirectional text is in visual order, in the editor's [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). When the start\n    position was the last one on the line, the returned position\n    will be across the line break. If there is no further line, the\n    original position is returned.\n    \n    By default, this method moves over a single cluster. The\n    optional `by` argument can be used to move across more. It will\n    be called with the first cluster as argument, and should return\n    a predicate that determines, for each subsequent cluster,\n    whether it should also be moved over.\n    */\n    moveByChar(start, forward, by) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, by));\n    }\n    /**\n    Move a cursor position across the next group of either\n    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n    non-whitespace characters.\n    */\n    moveByGroup(start, forward) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));\n    }\n    /**\n    Move to the next line boundary in the given direction. If\n    `includeWrap` is true, line wrapping is on, and there is a\n    further wrap point on the current line, the wrap point will be\n    returned. Otherwise this function will return the start or end\n    of the line.\n    */\n    moveToLineBoundary(start, forward, includeWrap = true) {\n        return moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /**\n    Move a cursor position vertically. When `distance` isn't given,\n    it defaults to moving to the next line (including wrapped\n    lines). Otherwise, `distance` should provide a positive distance\n    in pixels.\n    \n    When `start` has a\n    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n    motion will use that as a target horizontal position. Otherwise,\n    the cursor's own horizontal position is used. The returned\n    cursor will have its goal column set to whichever column was\n    used.\n    */\n    moveVertically(start, forward, distance) {\n        return skipAtoms(this, start, moveVertically(this, start, forward, distance));\n    }\n    /**\n    Scroll the given document position into view.\n    */\n    scrollPosIntoView(pos) {\n        this.viewState.scrollTo = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos);\n        this.requestMeasure();\n    }\n    /**\n    Find the DOM parent node and offset (child offset if `node` is\n    an element, character offset when it is a text node) at the\n    given document position.\n    */\n    domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /**\n    Find the document position at the given DOM node. Can be useful\n    for associating positions with DOM events. Will raise an error\n    when `node` isn't part of the editor content.\n    */\n    posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    posAtCoords(coords, precise = true) {\n        this.readMeasured();\n        return posAtCoords(this, coords, precise);\n    }\n    /**\n    Get the screen coordinates at the given document position.\n    `side` determines whether the coordinates are based on the\n    element before (-1) or after (1) the position (if no element is\n    available on the given side, the method will transparently use\n    another strategy to get reasonable coordinates).\n    */\n    coordsAtPos(pos, side = 1) {\n        this.readMeasured();\n        let rect = this.docView.coordsAt(pos, side);\n        if (!rect || rect.left == rect.right)\n            return rect;\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n        return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));\n    }\n    /**\n    The default width of a character in the editor. May not\n    accurately reflect the width of all characters (given variable\n    width fonts or styling of invididual ranges).\n    */\n    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }\n    /**\n    The default height of a line in the editor. May not be accurate\n    for all lines.\n    */\n    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }\n    /**\n    The text direction\n    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n    CSS property) of the editor.\n    */\n    get textDirection() { return this.viewState.heightOracle.direction; }\n    /**\n    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n    (as determined by the\n    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n    CSS property of its content element).\n    */\n    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }\n    /**\n    Returns the bidirectional text structure of the given line\n    (which should be in the current document) as an array of span\n    objects. The order of these spans matches the [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is\n    left-to-right, the leftmost spans come first, otherwise the\n    rightmost spans come first.\n    */\n    bidiSpans(line) {\n        if (line.length > MaxBidiLine)\n            return trivialOrder(line.length);\n        let dir = this.textDirection;\n        for (let entry of this.bidiCache)\n            if (entry.from == line.from && entry.dir == dir)\n                return entry.order;\n        let order = computeOrder(line.text, this.textDirection);\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));\n        return order;\n    }\n    /**\n    Check whether the editor has focus.\n    */\n    get hasFocus() {\n        var _a;\n        // Safari return false for hasFocus when the context menu is open\n        // or closing, which leads us to ignore selection changes from the\n        // context menu because it looks like the editor isn't focused.\n        // This kludges around that.\n        return (document.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) &&\n            this.root.activeElement == this.contentDOM;\n    }\n    /**\n    Put focus on the editor.\n    */\n    focus() {\n        this.observer.ignore(() => {\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /**\n    Clean up this editor view, removing its element from the\n    document, unregistering event handlers, and notifying\n    plugins. The view instance can no longer be used after\n    calling this.\n    */\n    destroy() {\n        for (let plugin of this.plugins)\n            plugin.destroy(this);\n        this.plugins = [];\n        this.inputState.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1)\n            cancelAnimationFrame(this.measureScheduled);\n        this.destroyed = true;\n    }\n    /**\n    Facet that can be used to add DOM event handlers. The value\n    should be an object mapping event names to handler functions. The\n    first such function to return true will be assumed to have handled\n    that event, and no other handlers or built-in behavior will be\n    activated for it.\n    These are registered on the [content\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except for `scroll`\n    handlers, which will be called any time the editor's [scroll\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of its parent nodes\n    is scrolled.\n    */\n    static domEventHandlers(handlers) {\n        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });\n    }\n    /**\n    Create a theme extension. The first argument can be a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    style spec providing the styles for the theme. These will be\n    prefixed with a generated class for the style.\n    \n    Because the selectors will be prefixed with a scope class, rule\n    that directly match the editor's [wrapper\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be\n    addedneed to be explicitly differentiated by adding an `&` to\n    the selector for that elementfor example\n    `&.cm-focused`.\n    \n    When `dark` is set to true, the theme will be marked as dark,\n    which will cause the `&dark` rules from [base\n    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n    `&light` when a light theme is active).\n    */\n    static theme(spec, options) {\n        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];\n        if (options && options.dark)\n            result.push(darkTheme.of(true));\n        return result;\n    }\n    /**\n    Create an extension that adds styles to the base theme. Like\n    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n    place of the editor wrapper element when directly targeting\n    that. You can also use `&dark` or `&light` instead to only\n    target editors with a dark or light theme.\n    */\n    static baseTheme(spec) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Prec.fallback(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n    }\n}\n/**\nEffect that can be [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a\ntransaction to make it scroll the given range into view.\n*/\nEditorView.scrollTo = scrollTo;\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/\nEditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n*/\nEditorView.inputHandler = inputHandler;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/\nEditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/\nEditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot longer have its `contenteditable` attribute set. (Note that\nthis doesn't affect API calls that change the editor content,\neven when those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/\nEditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/\nEditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/\nEditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds\na new range to the existing selection or replaces it entirely.\n*/\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. See also [view\nplugins](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), which have a separate\nmechanism for providing decorations.\n*/\nEditorView.decorations = decorations;\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/\nEditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/\nEditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/\nEditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({ \"class\": \"cm-lineWrapping\" });\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/\nEditorView.announce = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.StateEffect.define();\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nfunction ensureTop(given, dom) {\n    return given == null ? dom.getBoundingClientRect().top : given;\n}\nlet resizeDebounce = -1;\nfunction ensureGlobalHandler() {\n    window.addEventListener(\"resize\", () => {\n        if (resizeDebounce == -1)\n            resizeDebounce = setTimeout(handleResize, 50);\n    });\n}\nfunction handleResize() {\n    resizeDebounce = -1;\n    let found = document.querySelectorAll(\".cm-content\");\n    for (let i = 0; i < found.length; i++) {\n        let docView = ContentView.get(found[i]);\n        if (docView)\n            docView.editorView.requestMeasure();\n    }\n}\nconst BadMeasure = {};\nclass CachedOrder {\n    constructor(from, to, dir, order) {\n        this.from = from;\n        this.to = to;\n        this.dir = dir;\n        this.order = order;\n    }\n    static update(cache, changes) {\n        if (changes.empty)\n            return cache;\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {\n            let entry = cache[i];\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))\n                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));\n        }\n        return result;\n    }\n}\n\nconst currentPlatform = typeof navigator == \"undefined\" ? \"key\"\n    : /*@__PURE__*//Mac/.test(navigator.platform) ? \"mac\"\n        : /*@__PURE__*//Win/.test(navigator.platform) ? \"win\"\n            : /*@__PURE__*//Linux|X11/.test(navigator.platform) ? \"linux\"\n                : \"key\";\nfunction normalizeKeyName(name, platform) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; ++i) {\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (platform == \"mac\")\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\nconst handleKeyEvents = /*@__PURE__*/EditorView.domEventHandlers({\n    keydown(event, view) {\n        return runHandlers(getKeymap(view.state), event, view, \"editor\");\n    }\n});\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/\nconst keymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({ enables: handleKeyEvents });\nconst Keymaps = /*@__PURE__*/new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n    let bindings = state.facet(keymap);\n    let map = Keymaps.get(bindings);\n    if (!map)\n        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));\n    return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/\nfunction runScopeHandlers(view, event, scope) {\n    return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n    let bound = Object.create(null);\n    let isPrefix = Object.create(null);\n    let checkPrefix = (name, is) => {\n        let current = isPrefix[name];\n        if (current == null)\n            isPrefix[name] = is;\n        else if (current != is)\n            throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n    };\n    let add = (scope, key, command, preventDefault) => {\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));\n        for (let i = 1; i < parts.length; i++) {\n            let prefix = parts.slice(0, i).join(\" \");\n            checkPrefix(prefix, true);\n            if (!scopeObj[prefix])\n                scopeObj[prefix] = {\n                    preventDefault: true,\n                    commands: [(view) => {\n                            let ourObj = storedPrefix = { view, prefix, scope };\n                            setTimeout(() => { if (storedPrefix == ourObj)\n                                storedPrefix = null; }, PrefixTimeout);\n                            return true;\n                        }]\n                };\n        }\n        let full = parts.join(\" \");\n        checkPrefix(full, false);\n        let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, commands: [] });\n        binding.commands.push(command);\n        if (preventDefault)\n            binding.preventDefault = true;\n    };\n    for (let b of bindings) {\n        let name = b[platform] || b.key;\n        if (!name)\n            continue;\n        for (let scope of b.scope ? b.scope.split(\" \") : [\"editor\"]) {\n            add(scope, name, b.run, b.preventDefault);\n            if (b.shift)\n                add(scope, \"Shift-\" + name, b.shift, b.preventDefault);\n        }\n    }\n    return bound;\n}\nfunction runHandlers(map, event, view, scope) {\n    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_2__.keyName)(event), isChar = name.length == 1 && name != \" \";\n    let prefix = \"\", fallthrough = false;\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n        prefix = storedPrefix.prefix + \" \";\n        if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)\n            storedPrefix = null;\n    }\n    let runFor = (binding) => {\n        if (binding) {\n            for (let cmd of binding.commands)\n                if (cmd(view))\n                    return true;\n            if (binding.preventDefault)\n                fallthrough = true;\n        }\n        return false;\n    };\n    let scopeObj = map[scope], baseName;\n    if (scopeObj) {\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)]))\n            return true;\n        if (isChar && (event.shiftKey || event.altKey || event.metaKey) &&\n            (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_2__.base[event.keyCode]) && baseName != name) {\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))\n                return true;\n        }\n        else if (isChar && event.shiftKey) {\n            if (runFor(scopeObj[prefix + modifiers(name, event, true)]))\n                return true;\n        }\n    }\n    return fallthrough;\n}\n\nconst CanHidePrimary = !browser.ios; // FIXME test IE\nconst selectionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({\n    combine(configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.combineConfig)(configs, {\n            cursorBlinkRate: 1200,\n            drawRangeCursor: true\n        }, {\n            cursorBlinkRate: (a, b) => Math.min(a, b),\n            drawRangeCursor: (a, b) => a || b\n        });\n    }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/\nfunction drawSelection(config = {}) {\n    return [\n        selectionConfig.of(config),\n        drawSelectionPlugin,\n        hideNativeSelection\n    ];\n}\nclass Piece {\n    constructor(left, top, width, height, className) {\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n        this.className = className;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        if (this.width >= 0)\n            elt.style.width = this.width + \"px\";\n        elt.style.height = this.height + \"px\";\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&\n            this.className == p.className;\n    }\n}\nconst drawSelectionPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.rangePieces = [];\n        this.cursors = [];\n        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };\n        this.selectionLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.selectionLayer.className = \"cm-selectionLayer\";\n        this.selectionLayer.setAttribute(\"aria-hidden\", \"true\");\n        this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.cursorLayer.className = \"cm-cursorLayer\";\n        this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n        view.requestMeasure(this.measureReq);\n        this.setBlinkRate();\n    }\n    setBlinkRate() {\n        this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n    }\n    update(update) {\n        let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n        if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)\n            this.view.requestMeasure(this.measureReq);\n        if (update.transactions.some(tr => tr.scrollIntoView))\n            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        if (confChanged)\n            this.setBlinkRate();\n    }\n    readPos() {\n        let { state } = this.view, conf = state.facet(selectionConfig);\n        let rangePieces = state.selection.ranges.map(r => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));\n        let cursors = [];\n        for (let r of state.selection.ranges) {\n            let prim = r == state.selection.main;\n            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n                let piece = measureCursor(this.view, r, prim);\n                if (piece)\n                    cursors.push(piece);\n            }\n        }\n        return { rangePieces, cursors };\n    }\n    drawSel({ rangePieces, cursors }) {\n        if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {\n            this.selectionLayer.textContent = \"\";\n            for (let p of rangePieces)\n                this.selectionLayer.appendChild(p.draw());\n            this.rangePieces = rangePieces;\n        }\n        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {\n            let oldCursors = this.cursorLayer.children;\n            if (oldCursors.length !== cursors.length) {\n                this.cursorLayer.textContent = \"\";\n                for (const c of cursors)\n                    this.cursorLayer.appendChild(c.draw());\n            }\n            else {\n                cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));\n            }\n            this.cursors = cursors;\n        }\n    }\n    destroy() {\n        this.selectionLayer.remove();\n        this.cursorLayer.remove();\n    }\n});\nconst themeSpec = {\n    \".cm-line\": {\n        \"& ::selection\": { backgroundColor: \"transparent !important\" },\n        \"&::selection\": { backgroundColor: \"transparent !important\" }\n    }\n};\nif (CanHidePrimary)\n    themeSpec[\".cm-line\"].caretColor = \"transparent !important\";\nconst hideNativeSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Prec.override(/*@__PURE__*/EditorView.theme(themeSpec));\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\n    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };\n}\nfunction wrappedLine(view, pos, inside) {\n    let range = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos);\n    return { from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),\n        type: BlockType.Text };\n}\nfunction blockAt(view, pos) {\n    let line = view.visualLineAt(pos);\n    if (Array.isArray(line.type))\n        for (let l of line.type) {\n            if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))\n                return l;\n        }\n    return line;\n}\nfunction measureRange(view, range) {\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to)\n        return [];\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n    let ltr = view.textDirection == Direction.LTR;\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n    let lineStyle = window.getComputedStyle(content.firstChild);\n    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft);\n    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);\n    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);\n    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n    if (view.lineWrapping) {\n        if (visualStart)\n            visualStart = wrappedLine(view, from, visualStart);\n        if (visualEnd)\n            visualEnd = wrappedLine(view, to, visualEnd);\n    }\n    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {\n        return pieces(drawForLine(range.from, range.to, visualStart));\n    }\n    else {\n        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n        let between = [];\n        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)\n            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\n        else if (top.bottom < bottom.top && blockAt(view, (top.bottom + bottom.top) / 2).type == BlockType.Text)\n            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n        return pieces(top).concat(between).concat(pieces(bottom));\n    }\n    function piece(left, top, right, bottom) {\n        return new Piece(left - base.left, top - base.top, right - left, bottom - top, \"cm-selectionBackground\");\n    }\n    function pieces({ top, bottom, horizontal }) {\n        let pieces = [];\n        for (let i = 0; i < horizontal.length; i += 2)\n            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n        return pieces;\n    }\n    // Gets passed from/to in line-local positions\n    function drawForLine(from, to, line) {\n        let top = 1e9, bottom = -1e9, horizontal = [];\n        function addSpan(from, fromOpen, to, toOpen, dir) {\n            // Passing 2/-2 is a kludge to force the view to return\n            // coordinates on the proper side of block widgets, since\n            // normalizing the side there, though appropriate for most\n            // coordsAtPos queries, would break selection drawing.\n            let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));\n            let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));\n            top = Math.min(fromCoords.top, toCoords.top, top);\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n            if (dir == Direction.LTR)\n                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\n            else\n                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n        }\n        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;\n        // Split the range by visible range and document line\n        for (let r of view.visibleRanges)\n            if (r.to > start && r.from < end) {\n                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {\n                    let docLine = view.state.doc.lineAt(pos);\n                    for (let span of view.bidiSpans(docLine)) {\n                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n                        if (spanFrom >= endPos)\n                            break;\n                        if (spanTo > pos)\n                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n                    }\n                    pos = docLine.to + 1;\n                    if (pos >= endPos)\n                        break;\n                }\n            }\n        if (horizontal.length == 0)\n            addSpan(start, from == null, end, to == null, view.textDirection);\n        return { top, bottom, horizontal };\n    }\n    function drawForWidget(block, top) {\n        let y = contentRect.top + (top ? block.top : block.bottom);\n        return { top: y, bottom: y, horizontal: [] };\n    }\n}\nfunction measureCursor(view, cursor, primary) {\n    let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);\n    if (!pos)\n        return null;\n    let base = getBase(view);\n    return new Piece(pos.left - base.left, pos.top - base.top, -1, pos.bottom - pos.top, primary ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\");\n}\n\nfunction iterMatches(doc, re, from, to, f) {\n    re.lastIndex = 0;\n    for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {\n        if (!cursor.lineBreak)\n            while (m = re.exec(cursor.value))\n                f(pos + m.index, pos + m.index + m[0].length, m);\n    }\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/\nclass MatchDecorator {\n    /**\n    Create a decorator.\n    */\n    constructor(config) {\n        let { regexp, decoration, boundary } = config;\n        if (!regexp.global)\n            throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n        this.regexp = regexp;\n        this.getDeco = typeof decoration == \"function\" ? decoration : () => decoration;\n        this.boundary = boundary;\n    }\n    /**\n    Compute the full set of decorations for matches in the given\n    view's viewport. You'll want to call this when initializing your\n    plugin.\n    */\n    createDeco(view) {\n        let build = new _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges)\n            iterMatches(view.state.doc, this.regexp, from, to, (a, b, m) => build.add(a, b, this.getDeco(m, view, a)));\n        return build.finish();\n    }\n    /**\n    Update a set of decorations for a view update. `deco` _must_ be\n    the set of decorations produced by _this_ `MatchDecorator` for\n    the view state before the update.\n    */\n    updateDeco(update, deco) {\n        let changeFrom = 1e9, changeTo = -1;\n        if (update.docChanged)\n            update.changes.iterChanges((_f, _t, from, to) => {\n                if (to > update.view.viewport.from && from < update.view.viewport.to) {\n                    changeFrom = Math.min(from, changeFrom);\n                    changeTo = Math.max(to, changeTo);\n                }\n            });\n        if (update.viewportChanged || changeTo - changeFrom > 1000)\n            return this.createDeco(update.view);\n        if (changeTo > -1)\n            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n        return deco;\n    }\n    updateRange(view, deco, updateFrom, updateTo) {\n        for (let r of view.visibleRanges) {\n            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);\n            if (to > from) {\n                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);\n                if (this.boundary) {\n                    for (; from > fromLine.from; from--)\n                        if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n                            start = from;\n                            break;\n                        }\n                    for (; to < toLine.to; to++)\n                        if (this.boundary.test(toLine.text[to - toLine.from])) {\n                            end = to;\n                            break;\n                        }\n                }\n                let ranges = [], m;\n                if (fromLine == toLine) {\n                    this.regexp.lastIndex = start - fromLine.from;\n                    while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) {\n                        let pos = m.index + fromLine.from;\n                        ranges.push(this.getDeco(m, view, pos).range(pos, pos + m[0].length));\n                    }\n                }\n                else {\n                    iterMatches(view.state.doc, this.regexp, start, end, (from, to, m) => ranges.push(this.getDeco(m, view, from).range(from, to)));\n                }\n                deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) => from < start || to > end, add: ranges });\n            }\n        }\n        return deco;\n    }\n}\n\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst Specials = /*@__PURE__*/new RegExp(\"[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]\", UnicodeRegexpSupport);\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n    var _a;\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n        let styles = document.body.style;\n        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n    }\n    return _supportsTabSize || false;\n}\nconst specialCharConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({\n    combine(configs) {\n        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.combineConfig)(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        if (config.replaceTabs = !supportsTabSize())\n            config.specialChars = new RegExp(\"\\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n        if (config.addSpecialChars)\n            config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n        return config;\n    }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/\nfunction highlightSpecialChars(\n/**\nConfiguration options.\n*/\nconfig = {}) {\n    return [specialCharConfig.of(config), specialCharPlugin()];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n    return _plugin || (_plugin = ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.view = view;\n            this.decorations = Decoration.none;\n            this.decorationCache = Object.create(null);\n            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n            this.decorations = this.decorator.createDeco(view);\n        }\n        makeDecorator(conf) {\n            return new MatchDecorator({\n                regexp: conf.specialChars,\n                decoration: (m, view, pos) => {\n                    let { doc } = view.state;\n                    let code = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(m[0], 0);\n                    if (code == 9) {\n                        let line = doc.lineAt(pos);\n                        let size = view.state.tabSize, col = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, size, pos - line.from);\n                        return Decoration.replace({ widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth) });\n                    }\n                    return this.decorationCache[code] ||\n                        (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));\n                },\n                boundary: conf.replaceTabs ? undefined : /[^]/\n            });\n        }\n        update(update) {\n            let conf = update.state.facet(specialCharConfig);\n            if (update.startState.facet(specialCharConfig) != conf) {\n                this.decorator = this.makeDecorator(conf);\n                this.decorations = this.decorator.createDeco(update.view);\n            }\n            else {\n                this.decorations = this.decorator.updateDeco(update, this.decorations);\n            }\n        }\n    }, {\n        decorations: v => v.decorations\n    }));\n}\nconst DefaultPlaceholder = \"\\u2022\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder$1(code) {\n    if (code >= 32)\n        return DefaultPlaceholder;\n    if (code == 10)\n        return \"\\u2424\";\n    return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code) {\n        super();\n        this.options = options;\n        this.code = code;\n    }\n    eq(other) { return other.code == this.code; }\n    toDOM(view) {\n        let ph = placeholder$1(this.code);\n        let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\n        if (custom)\n            return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.className = \"cm-specialChar\";\n        return span;\n    }\n    ignoreEvent() { return false; }\n}\nclass TabWidget extends WidgetType {\n    constructor(width) {\n        super();\n        this.width = width;\n    }\n    eq(other) { return other.width == this.width; }\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\\t\";\n        span.className = \"cm-tab\";\n        span.style.width = this.width + \"px\";\n        return span;\n    }\n    ignoreEvent() { return false; }\n}\n\nconst plugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.height = -1;\n        this.measure = {\n            read: view => Math.max(0, view.scrollDOM.clientHeight - view.defaultLineHeight),\n            write: (value, view) => {\n                if (Math.abs(value - this.height) > 1) {\n                    this.height = value;\n                    view.contentDOM.style.paddingBottom = value + \"px\";\n                }\n            }\n        };\n        view.requestMeasure(this.measure);\n    }\n    update(update) {\n        if (update.geometryChanged)\n            update.view.requestMeasure(this.measure);\n    }\n});\n/**\nReturns a plugin that makes sure the content has a bottom margin\nequivalent to the height of the editor, minus one line height, so\nthat every line in the document can be scrolled to the top of the\neditor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/\nfunction scrollPastEnd() {\n    return plugin;\n}\n\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/\nfunction highlightActiveLine() {\n    return activeLineHighlighter;\n}\nconst lineDeco = /*@__PURE__*/Decoration.line({ attributes: { class: \"cm-activeLine\" } });\nconst activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.docChanged || update.selectionSet)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let lastLineStart = -1, deco = [];\n        for (let r of view.state.selection.ranges) {\n            if (!r.empty)\n                return Decoration.none;\n            let line = view.visualLineAt(r.head);\n            if (line.from > lastLineStart) {\n                deco.push(lineDeco.range(line.from));\n                lastLineStart = line.from;\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\n\nclass Placeholder extends WidgetType {\n    constructor(content) {\n        super();\n        this.content = content;\n    }\n    toDOM() {\n        let wrap = document.createElement(\"span\");\n        wrap.className = \"cm-placeholder\";\n        wrap.style.pointerEvents = \"none\";\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n        if (typeof this.content == \"string\")\n            wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);\n        else\n            wrap.setAttribute(\"aria-hidden\", \"true\");\n        return wrap;\n    }\n    ignoreEvent() { return false; }\n}\n/**\nExtension that enables a placeholdera piece of example content\nto show when the editor is empty.\n*/\nfunction placeholder(content) {\n    return ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.view = view;\n            this.placeholder = Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)]);\n        }\n        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }\n    }, { decorations: v => v.decorations });\n}\n\n/**\n@internal\n*/\nconst __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@codemirror/view/dist/index.js?");

/***/ }),

/***/ "./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultBufferLength\": () => (/* binding */ DefaultBufferLength),\n/* harmony export */   \"MountedTree\": () => (/* binding */ MountedTree),\n/* harmony export */   \"NodeProp\": () => (/* binding */ NodeProp),\n/* harmony export */   \"NodeSet\": () => (/* binding */ NodeSet),\n/* harmony export */   \"NodeType\": () => (/* binding */ NodeType),\n/* harmony export */   \"Parser\": () => (/* binding */ Parser),\n/* harmony export */   \"Tree\": () => (/* binding */ Tree),\n/* harmony export */   \"TreeBuffer\": () => (/* binding */ TreeBuffer),\n/* harmony export */   \"TreeCursor\": () => (/* binding */ TreeCursor),\n/* harmony export */   \"TreeFragment\": () => (/* binding */ TreeFragment),\n/* harmony export */   \"parseMixed\": () => (/* binding */ parseMixed)\n/* harmony export */ });\n// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node (1024).\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type.\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    /// prop values for each node type in the set. Takes a [match\n    /// object](#common.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages.\nNodeProp.mounted = new NodeProp({ perNode: true });\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n    constructor(\n    /// The inner tree.\n    tree, \n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    overlay, \n    /// The parser used to create this subtree.\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |\n            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method should be created with\n    /// [`NodeProp.add`](#common.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap();\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    constructor(\n    /// The type of the top node.\n    type, \n    /// This node's child nodes.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length, \n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /// @internal\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /// @internal\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When\n    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)\n    /// to the given position and side.\n    cursor(pos, side = 0) {\n        let scope = (pos != null && CachedNode.get(this)) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        if (pos != null) {\n            cursor.moveTo(pos, side);\n            CachedNode.set(this, cursor._tree);\n        }\n        return cursor;\n    }\n    /// Get a [tree cursor](#common.TreeCursor) that, unlike regular\n    /// cursors, doesn't skip through\n    /// [anonymous](#common.NodeType.isAnonymous) nodes.\n    fullCursor() {\n        return new TreeCursor(this.topNode, 1 /* Full */);\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    resolve(pos, side = 0) {\n        return this.cursor(pos, side).node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n    resolveInner(pos, side = 0) {\n        let result = this.topNode;\n        for (;;) {\n            let inner = result.enter(pos, side);\n            if (!inner)\n                return result;\n            result = inner;\n        }\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor(), get = () => c.node;;) {\n            let mustLeave = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {\n                if (c.firstChild())\n                    continue;\n                if (!c.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(c.type, c.from, c.to, get);\n                mustLeave = c.type.isAnonymous;\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n    balance(config = {}) {\n        return this.children.length <= 8 /* BranchFactor */ ? this :\n            balanceRange(this.type, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nclass TreeBuffer {\n    /// Create a tree buffer.\n    constructor(\n    /// The buffer's content.\n    buffer, \n    /// The total length of the group of nodes in the buffer.\n    length, \n    /// The node set used in this buffer.\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /// @internal\n    get type() { return NodeType.none; }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /// @internal\n    slice(startI, endI, from, to) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI);\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n        }\n        return new TreeBuffer(copy, to - from, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Before */: return from < pos;\n        case -1 /* AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Around */: return from < pos && to > pos;\n        case 1 /* AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* After */: return to > pos;\n        case 4 /* DontCare */: return true;\n    }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n    let scan = node.childBefore(pos);\n    while (scan) {\n        let last = scan.lastChild;\n        if (!last || last.to != scan.to)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            node = scan;\n            scan = last.prevSibling;\n        }\n        else {\n            scan = last;\n        }\n    }\n    return node;\n}\nclass TreeNode {\n    constructor(node, _from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this.node = node;\n        this._from = _from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this.node.type; }\n    get name() { return this.node.type.name; }\n    get from() { return this._from; }\n    get to() { return this._from + this.node.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent._from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & 2 /* NoEnterBuffer */)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & 1 /* Full */) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & 1 /* Full */) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & 1 /* Full */) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent.node.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }\n    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos, -2 /* Before */); }\n    enter(pos, side, overlays = true, buffers = true) {\n        let mounted;\n        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, buffers ? 0 : 2 /* NoEnterBuffer */);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;\n    }\n    get cursor() { return new TreeCursor(this); }\n    get tree() { return this.node; }\n    toTree() { return this.node; }\n    resolve(pos, side = 0) {\n        return this.cursor.moveTo(pos, side).node;\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this.node.toString(); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor, result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }\n    enter(pos, side, overlays, buffers = true) {\n        if (!buffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n    }\n    get cursor() { return new TreeCursor(this); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];\n            children.push(buffer.slice(startI, endI, from, to));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return this.cursor.moveTo(pos, side).node;\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// @internal\n    constructor(node, \n    /// @internal\n    mode = 0) {\n        this.mode = mode;\n        this.buffer = null;\n        this.stack = [];\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }\n    /// Move the cursor to the first child that ends after `pos`.\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }\n    /// Move to the last child that starts before `pos`.\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n    enter(pos, side, overlays = true, buffers = true) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, overlays, buffers));\n        return buffers ? this.enterChild(1, pos, side) : false;\n    }\n    /// Move the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & 1 /* Full */) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & 1 /* Full */) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n                    let child = parent.node.children[i];\n                    if ((this.mode & 1 /* Full */) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n    next(enter = true) { return this.move(1, enter); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev(enter = true) { return this.move(-1, enter); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree.node;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = node.children.reduce((s, ch) => s + nodeSize(balanceType, ch), 1);\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type to tag the resulting tree with. Will also be used for\n// internal nodes when it is an anonymous type\ntype, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(type, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(type, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(type, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom];\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(type, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n    /// Construct a tree fragment.\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);\n    }\n    /// Whether the start of the fragment represents the start of a\n    /// parse, or the end of a change. (In the second case, it may not\n    /// be safe to reuse some nodes at the start, depending on the\n    /// parsing algorithm.)\n    get openStart() { return (this.open & 1 /* Start */) > 0; }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n    get openEnd() { return (this.open & 2 /* End */) > 0; }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\n///\n/// The nesting function is passed a cursor to provide context for a\n/// node, but _should not_ move that cursor, only inspect its\n/// properties and optionally access its\n/// [node object](#common.TreeCursor.node).\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n        }\n        if (this.innerDone == this.inner.length)\n            return this.baseTree;\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let next = this.inner[this.innerDone];\n        return next ? next.parse.parsedPos : this.input.length;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1 /* Full */);\n        scan: for (let nest, isCovered;;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to)\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Full */;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target));\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;\n    }\n    return 0 /* None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];\n        nodes.push(buf.slice(startI, endI, from, to));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let isTarget = b[i + 1] + off == node.from && b[i + 2] + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], b[i + 1]));\n        positions.push(b[i + 1] - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        let last = children.length - 1;\n        return new Tree(type, children, positions, positions[last] + children[last].length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.fullCursor();\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        this.fragments = fragments;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curFrag.to)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curFrag.to >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));\n        }\n    }\n    return result;\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@lezer/common/dist/index.js?");

/***/ }),

/***/ "./node_modules/@lezer/lr/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContextTracker\": () => (/* binding */ ContextTracker),\n/* harmony export */   \"ExternalTokenizer\": () => (/* binding */ ExternalTokenizer),\n/* harmony export */   \"InputStream\": () => (/* binding */ InputStream),\n/* harmony export */   \"LRParser\": () => (/* binding */ LRParser),\n/* harmony export */   \"Stack\": () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// The parse that this stack is part of @internal\n    p, \n    /// Holds state, input pos, buffer index triplets for all but the\n    /// top state @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    /// @internal\n    curContext, \n    /// @internal\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /// The stack's current [context](#lr.ContextTracker) value, if\n    /// any. Its type will depend on the context tracker's type\n    /// parameter, or it will be `null` if there is no context\n    /// tracker.\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            // Zero-depth reductions are a special casethey add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        let start = this.stack[base - 2];\n        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        let start = this.pos;\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(next, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = nextEnd;\n            this.shiftContext(next, start);\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer. @internal\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Delete */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.pushState(s, this.pos);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.score -= 200 /* Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        let { parser } = this.p;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)\n                return false;\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Reduce */;\n        }\n        this.reduce(reduce);\n        return true;\n    }\n    /// @internal\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&\n            !parser.stateSlot(this.state, 4 /* DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.p.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /// @internal\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);\n    }\n    /// @internal\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /// @internal\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /// @internal\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Insert\"] = 200] = \"Insert\";\n    Recover[Recover[\"Delete\"] = 190] = \"Delete\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/// [Tokenizers](#lr.ExternalTokenizer) interact with the input\n/// through this interface. It presents the input as a stream of\n/// characters, tracking lookahead and hiding the complexity of\n/// [ranges](#common.Parser.parse^ranges) from tokenizer code.\nclass InputStream {\n    /// @internal\n    constructor(\n    /// @internal\n    input, \n    /// @internal\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /// @internal\n        this.chunk = \"\";\n        /// @internal\n        this.chunkOff = 0;\n        /// Backup chunk\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /// The character code of the next code unit in the input, or -1\n        /// when the stream is at the end of the input.\n        this.next = -1;\n        /// @internal\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /// Look at a code unit near the stream position. `.peek(0)` equals\n    /// `.next`, `.peek(-1)` gives you the previous character, and so\n    /// on.\n    ///\n    /// Note that looking around during tokenizing creates dependencies\n    /// on potentially far-away content, which may reduce the\n    /// effectiveness incremental parsingwhen looking forwardor even\n    /// cause invalid reparses when looking backward more than 25 code\n    /// units, since the library does not track lookbehind.\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos > this.token.lookAhead)\n            this.token.lookAhead = pos;\n        return result;\n    }\n    /// Accept a token. By default, the end of the token is set to the\n    /// current stream position, but you can pass an offset (relative to\n    /// the stream position) to change that.\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /// Move the stream forward N (defaults to 1) code units. Returns\n    /// the new value of [`next`](#lr.InputStream.next).\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos > this.token.lookAhead)\n            this.token.lookAhead = this.pos;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /// @internal\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = token.lookAhead = pos;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /// @internal\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) { readToken(this.data, input, stack, this.id); }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// `@external tokens` declarations in the grammar should resolve to\n/// an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream, scans for the types of tokens it\n    /// recognizes at the stream's position, and calls\n    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    /// one.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data, input, stack, group) {\n    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        // Do a binary search on the state's edges\n        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            let digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// FIXME find some way to reduce recovery work done when the input\n// doesn't match the grammar at all.\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nvar Safety;\n(function (Safety) {\n    Safety[Safety[\"Margin\"] = 25] = \"Margin\";\n})(Safety || (Safety = {}));\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.fullCursor();\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        tokenizer.token(this.stream.reset(stack.pos, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Err */;\n            token.end = Math.min(stack.p.stream.end, stack.pos + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {\n                if (data[i] == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Other */)\n                            index = this.putAction(pair(data, i + 1), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    Rec[Rec[\"MinBufferLengthPrune\"] = 200] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n})(Rec || (Rec = {}));\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654;\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 200 /* MinBufferLengthPrune */ && other.buffer.length > 200 /* MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);\n            return true;\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\n///\n/// The export used in a `@context` declaration should be of this\n/// type.\nclass ContextTracker {\n    /// Define a context tracker.\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nclass LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /// @internal\n    constructor(spec) {\n        super();\n        /// @internal\n        this.wrappers = [];\n        if (spec.version != 13 /* Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        this.strict = false;\n        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);\n        this.specializers = [];\n        if (spec.specialized)\n            for (let i = 0; i < spec.specialized.length; i++) {\n                this.specialized[i] = spec.specialized[i].term;\n                this.specializers[i] = spec.specialized[i].get;\n            }\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    }\n    /// @internal\n    validAction(state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    return false;\n            }\n            if (action == pair(this.data, i + 1))\n                return true;\n        }\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /// @internal\n    overrides(token, prev) {\n        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// The type of top node produced by the parser.\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /// (used by the output of the parser generator) @internal\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\n\n\n\n\n//# sourceURL=webpack://bundle/./node_modules/@lezer/lr/dist/index.js?");

/***/ }),

/***/ "./node_modules/crelt/index.es.js":
/*!****************************************!*\
  !*** ./node_modules/crelt/index.es.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ crelt)\n/* harmony export */ });\nfunction crelt() {\n  var elt = arguments[0]\n  if (typeof elt == \"string\") elt = document.createElement(elt)\n  var i = 1, next = arguments[1]\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name]\n      if (typeof value == \"string\") elt.setAttribute(name, value)\n      else if (value != null) elt[name] = value\n    }\n    i++\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i])\n  return elt\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child))\n  } else if (child == null) {\n  } else if (child.nodeType != null) {\n    elt.appendChild(child)\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child)\n  }\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/crelt/index.es.js?");

/***/ }),

/***/ "./node_modules/style-mod/src/style-mod.js":
/*!*************************************************!*\
  !*** ./node_modules/style-mod/src/style-mod.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StyleModule\": () => (/* binding */ StyleModule)\n/* harmony export */ });\nconst C = \"\\u037c\"\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C)\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\")\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}\n\n// :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nclass StyleModule {\n  // :: (Object<Style>, ?{finish: ?(string)  string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  constructor(spec, options) {\n    this.rules = []\n    let {finish} = options || {}\n\n    function splitSelector(selector) {\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/)\n    }\n\n    function render(selectors, spec, target, isKeyframes) {\n      let local = [], isAt = /^@(\\w+)\\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == \"keyframes\"\n      if (isAt && spec == null) return target.push(selectors[0] + \";\")\n      for (let prop in spec) {\n        let value = spec[prop]\n        if (/&/.test(prop)) {\n          render(prop.split(/,\\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),\n                 value, target)\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n          render(splitSelector(prop), value, local, keyframes)\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\")\n        }\n      }\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") +\n                    \" {\" + local.join(\" \") + \"}\")\n      }\n    }\n\n    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)\n  }\n\n  // :: ()  string\n  // Returns a string containing the module's CSS rules.\n  getRules() { return this.rules.join(\"\\n\") }\n\n  // :: ()  string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let id = top[COUNT] || 1\n    top[COUNT] = id + 1\n    return C + id.toString(36)\n  }\n\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  static mount(root, modules) {\n    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules])\n  }\n}\n\nlet adoptedSet = null\n\nclass StyleSet {\n  constructor(root) {\n    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != \"undefined\") {\n      if (adoptedSet) {\n        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets)\n        return root[SET] = adoptedSet\n      }\n      this.sheet = new CSSStyleSheet\n      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets)\n      adoptedSet = this\n    } else {\n      this.styleTag = (root.ownerDocument || root).createElement(\"style\")\n      let target = root.head || root\n      target.insertBefore(this.styleTag, target.firstChild)\n    }\n    this.modules = []\n    root[SET] = this\n  }\n\n  mount(modules) {\n    let sheet = this.sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (sheet) for (let k = 0; k < mod.rules.length; k++)\n          sheet.insertRule(mod.rules[k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length\n        pos += mod.rules.length\n        j++\n      }\n    }\n\n    if (!sheet) {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i].getRules() + \"\\n\"\n      this.styleTag.textContent = text\n    }\n  }\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-casethe library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n\n\n//# sourceURL=webpack://bundle/./node_modules/style-mod/src/style-mod.js?");

/***/ }),

/***/ "./node_modules/w3c-keyname/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/w3c-keyname/index.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"base\": () => (/* binding */ base),\n/* harmony export */   \"shift\": () => (/* binding */ shift),\n/* harmony export */   \"keyName\": () => (/* binding */ keyName)\n/* harmony export */ });\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\n\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor)\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nfunction keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n\n\n//# sourceURL=webpack://bundle/./node_modules/w3c-keyname/index.es.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app.js");
/******/ 	bundle = __webpack_exports__;
/******/ 	
/******/ })()
;