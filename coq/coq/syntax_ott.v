Set Warnings "-notation-overridden,-parsing,-deprecated-hint-without-locality".
From Coq Require Import Strings.String.
Require Import List LibTactics Lia.

(* generated by Ott 0.33, locally-nameless lngen from: ../spec/rules.ott ../spec/target.ott *)
Require Import Metalib.Metatheory.
(** syntax *)
Definition lit : Set := nat.
Definition label : Set := string.

Unset Elimination Schemes.
Inductive tindex : Set :=  (*r type index *)
 | ti_bot : tindex (*r bottom type *)
 | ti_base : tindex (*r base type *)
 | ti_arrow (A:tindex) (B:tindex) (*r function types *)
 | ti_rcd (l:label) (A:tindex) (*r record *)
 | ti_list (a:list tindex).
Set Elimination Schemes.

Section tindex_ind.

  Variable P : tindex -> Prop.

  Hypothesis ti_bot_case : P ti_bot.

  Hypothesis ti_base_case : P ti_base.

  Hypothesis ti_arrow_case : forall (ti1 ti2 : tindex),
      P ti1 -> P ti2 -> P (ti_arrow ti1 ti2).

  Hypothesis ti_rcd_case : forall (l : label) (ti : tindex),
      P ti -> P (ti_rcd l ti).

  Hypothesis ti_list_case : forall (ls : list tindex),
      Forall P ls -> P (ti_list ls).

  Fixpoint tindex_ind (ti : tindex) : P ti :=
    match ti with
    | ti_bot => ti_bot_case
    | ti_base => ti_base_case
    | ti_arrow ti1 ti2 => ti_arrow_case ti1 ti2 (tindex_ind ti1) (tindex_ind ti2)
    | ti_rcd l ti => ti_rcd_case l ti (tindex_ind ti)
    | ti_list ls => ti_list_case ls
                      ((fix list_ti_list_ind (ls : list tindex) : Forall P ls :=
                          match ls with
                          | nil => Forall_nil _
                          | cons ti ls => Forall_cons _ (tindex_ind ti) (list_ti_list_ind ls)
                          end) ls)
    end.

End tindex_ind.

(*
Section tindex_ind''.

  Variable P : tindex -> Prop.

  Hypothesis ti_bot_case : P ti_bot.

  Hypothesis ti_base_case : P ti_base.

  Hypothesis ti_arrow_case : forall (ti1 ti2 : tindex),
      P ti1 -> P ti2 -> P (ti_arrow ti1 ti2).

  Hypothesis ti_rcd_case : forall (l : label) (ti : tindex),
      P ti -> P (ti_rcd l ti).

  Hypothesis ti_list_nil_case : P (ti_list nil).

  Hypothesis ti_list_cons_case : forall (c : tindex) (ls : list tindex),
      P c -> P (ti_list ls) -> P (ti_list (c::ls)).

  Fixpoint tindex_ind'' (ti : tindex) : P ti :=
    match ti with
    | ti_bot => ti_bot_case
    | ti_base => ti_base_case
    | ti_arrow ti1 ti2 => ti_arrow_case ti1 ti2 (tindex_ind'' ti1) (tindex_ind'' ti2)
    | ti_rcd l ti => ti_rcd_case l ti (tindex_ind'' ti)
    | ti_list ls => ti_list_ind ls
    end
  with ti_list_ind (l : list tindex) : P (ti_list l) :=
           match l with
           | nil => ti_list_nil_case
           (* | c::nil => ti_list_cons_case c nil  (tindex_ind'' c) ti_list_nil_case *)
           | c::ls => ti_list_cons_case c ls (tindex_ind'' c) (ti_list_ind ls)
           end.

End tindex_ind''. *)

Lemma ti_list_ind : forall (P: tindex -> Prop),
    P (ti_list nil) ->
    (forall c ls, P c -> P (ti_list ls) -> P (ti_list (c::ls))) ->
    (forall ls, Forall P ls -> P (ti_list ls)).
Proof.
  introv IP1 IP2 IH. induction* ls.
  - inverts IH. applys* IP2.
Qed.

Section All.
  Context {T : Set}.
  Variable P : T -> Set.

  Inductive All : list T -> Set :=
  | All_nil : All nil
  | All_cons : forall {x : T} {l : list T}, P x -> All l -> All (x :: l).
End All.

Section tindex_rec'.

  Variable P : tindex -> Set.

  Hypothesis ti_bot_case : P ti_bot.

  Hypothesis ti_base_case : P ti_base.

  Hypothesis ti_arrow_case : forall (ti1 ti2 : tindex),
      P ti1 -> P ti2 -> P (ti_arrow ti1 ti2).

  Hypothesis ti_rcd_case : forall (l : label) (ti : tindex),
      P ti -> P (ti_rcd l ti).

  Hypothesis ti_list_case : forall (ls : list tindex),
      All P ls -> P (ti_list ls).

  Fixpoint tindex_rec' (ti : tindex) : P ti :=
    match ti with
    | ti_bot => ti_bot_case
    | ti_base => ti_base_case
    | ti_arrow ti1 ti2 => ti_arrow_case ti1 ti2 (tindex_rec' ti1) (tindex_rec' ti2)
    | ti_rcd l ti => ti_rcd_case l ti (tindex_rec' ti)
    | ti_list ls => ti_list_case ls
                      ((fix list_ti_list_ind (ls : list tindex) : All P ls :=
                          match ls with
                          | nil => All_nil _
                          | cons ti ls' => All_cons _ (tindex_rec' ti) (list_ti_list_ind ls')
                          end) ls)
    end.

End tindex_rec'.

Inductive typ : Set :=  (*r types *)
 | typ_top : typ (*r top type *)
 | typ_bot : typ (*r bottom type *)
 | typ_base : typ (*r base type *)
 | typ_arrow (A:typ) (B:typ) (*r function types *)
 | typ_and (A:typ) (B:typ) (*r intersection *)
 | typ_rcd (l:label) (A:typ) (*r record *).

Inductive ttyp : Set :=  (*r types *)
 | ttyp_top : ttyp (*r top type *)
 | ttyp_bot : ttyp (*r bottom type *)
 | ttyp_base : ttyp (*r base type *)
 | ttyp_arrow (At:ttyp) (Bt:ttyp) (*r function types *)
 | ttyp_rcd (ll:tindex) (At:ttyp) (Bt:ttyp) (*r record *).

Fixpoint check_toplike (A : typ) :=
  match A with
  | typ_top => true
  | typ_bot => false  | typ_base => false
  | typ_arrow _ B => check_toplike B
  | typ_rcd l B => check_toplike B
  | typ_and A B => (check_toplike A) && (check_toplike B)
  end.

Require Import List.

Fixpoint size_tindex (A1 : tindex) {struct A1} : nat :=
  match A1 with
  | ti_bot => 1
  | ti_base => 1
  | ti_arrow A2 B1 => 1 + (size_tindex A2) + (size_tindex B1)
  | ti_rcd l1 A2 => 1 + (size_tindex A2)
  | ti_list a => 1 + fold_left Nat.add (map size_tindex a) 0
  end.

Lemma size_foldl_add : forall l n,
    fold_left Nat.add l n = fold_left Nat.add l 0 + n.
Proof.
  introv. gen n. induction* l; intros.
  pose proof IHl (n+a). pose proof IHl a.
  unfold fold_left in *. rewrite H. simpl. rewrite H0. simpl. lia.
Qed.

Lemma size_tindex_min : forall t, 1 <= size_tindex t.
Proof.
  introv. induction* t; simpl; try lia.
Qed.

Lemma size_list_decrease : forall a l,
    size_tindex (ti_list (a::l)) = size_tindex a + size_tindex (ti_list l).
Proof.
  introv. simpl.
  rewrite size_foldl_add. lia.
Qed.

Ltac apply_to_every t f :=
  repeat progress lazymatch goal with
    | [ h : t |- _ ] => generalize dependent h
    end;
  repeat progress lazymatch goal with
    | [ |- forall _ : t,  _ ] => let T:= fresh "T" in intro T; f T
    | _ => intro
    end.

Ltac apply_size_tindex_list_min :=
  apply_to_every tindex ltac:(fun x => forwards: size_tindex_min x).

Ltac elia :=
  try solve [ apply_size_tindex_list_min;
              repeat rewrite size_list_decrease in *;
              simpl in *; simpl;
              try lia ].

  Ltac solve_by_inverts n :=
  match goal with | H : ?T |- _ =>
  match type of T with Prop =>
    solve [
      inversion H;
      match n with S (S (?n')) => subst; solve_by_inverts (S n') end ]
  end end.

Ltac solve_by_invert :=
  solve_by_inverts 1.

Lemma tindex_dec : forall t1 t2 : tindex, {t1 = t2} + {t1 <> t2}.
Proof.
  remember ( fun (t:tindex) => forall t2 : tindex, {t = t2} + {t <> t2} ) as P.
  cut (forall t, P t). { intros HP. subst*. }
  applys~ tindex_rec' P; subst; intros; destruct* t2.
  all: try solve [right; intro HF; inverts HF].
  - destruct (H t2_1); destruct (H0 t2_2); subst*.
    all: try solve [right; intro HF; applys n; inverts~ HF].
  - destruct (string_dec l l0); destruct (H t2); subst*.
    all: try solve [right; intro HF; applys n; inverts~ HF].
  - gen a. induction H; intros; destruct* a.
    all: try solve [right; intro HF; inverts~ HF].
    forwards [|]: p t; forwards [|]: IHAll a; subst*.
    all: try solve [right; intro HF; inverts~ HF].
    inverts* e0.
Defined.

From Coq Require Import String Ascii Arith.
From Coq Require Import OrderedType OrderedTypeEx.
From StructTact Require Import StructTactics.


Inductive lex_lt: string -> string -> Prop :=
| lex_lt_lt : forall (c1 c2 : ascii) (s1 s2 : string),
    nat_of_ascii c1 < nat_of_ascii c2 ->
    lex_lt (String c1 s1) (String c2 s2)
| lex_lt_eq : forall (c : ascii) (s1 s2 : string),
    lex_lt s1 s2 ->
    lex_lt (String c s1) (String c s2)
| lex_lt_empty : forall (c : ascii) (s : string),
    lex_lt EmptyString (String c s).

Inductive ti_lex_lt: tindex -> tindex -> Prop :=
| ti_lex_lt_bot_base :
    ti_lex_lt ti_bot ti_base
| ti_lex_lt_bot_arrow : forall (ti1 ti2 : tindex),
    ti_lex_lt ti_bot (ti_arrow ti1 ti2)
| ti_lex_lt_bot_rcd : forall (l : label) (ti : tindex),
    ti_lex_lt ti_bot (ti_rcd l ti)
| ti_lex_lt_bot_list : forall (s : list tindex),
    ti_lex_lt ti_bot (ti_list s)
| ti_lex_lt_base_arrow : forall (ti1 ti2 : tindex),
    ti_lex_lt ti_base (ti_arrow ti1 ti2)
| ti_lex_lt_base_rcd : forall (l : label) (ti : tindex),
    ti_lex_lt ti_base (ti_rcd l ti)
| ti_lex_lt_base_list : forall (s : list tindex),
    ti_lex_lt ti_base (ti_list s)
| ti_lex_lt_arrow_arrow : forall (t1_1 t1_2 t2_1 t2_2 : tindex),
    ti_lex_lt t1_1 t2_1 ->
    ti_lex_lt (ti_arrow t1_1 t1_2) (ti_arrow t2_1 t2_2)
| ti_lex_lt_arrow_eql : forall (t_1 t1_2 t2_2 : tindex),
    ti_lex_lt t1_2 t2_2 ->
    ti_lex_lt (ti_arrow t_1 t1_2) (ti_arrow t_1 t2_2)
(* | ti_lex_lt_arrow_eqr : forall (t1_1 t2_1 t_2 : tindex),
    ti_lex_lt t1_1 t2_1 ->
    ti_lex_lt (ti_arrow t1_1 t_2) (ti_arrow t2_1 t_2) *)
| ti_lex_lt_arrow_rcd : forall (ti1 ti2 : tindex) (l : label) (ti : tindex),
    ti_lex_lt (ti_arrow ti1 ti2) (ti_rcd l ti)
| ti_lex_lt_arrow_list : forall (ti1 ti2 : tindex) (s : list tindex),
    ti_lex_lt (ti_arrow ti1 ti2) (ti_list s)
| ti_lex_lt_rcd_rcd : forall (l1 l2 : label) (t1 t2 : tindex),
    lex_lt l1 l2 ->
    ti_lex_lt (ti_rcd l1 t1) (ti_rcd l2 t2)
| ti_lex_lt_rcd_eql : forall (l : label) (t1 t2 : tindex),
    ti_lex_lt t1 t2 ->
    ti_lex_lt (ti_rcd l t1) (ti_rcd l t2)
(* | ti_lex_lt_rcd_eqr : forall (l1 l2 : label) (t : tindex),
    lex_lt l1 l2 ->
    ti_lex_lt (ti_rcd l1 t) (ti_rcd l2 t) *)
| ti_lex_lt_rcd_list : forall (l : label) (ti : tindex) (s : list tindex),
    ti_lex_lt (ti_rcd l ti) (ti_list s)
| ti_lex_lt_ls_head : forall (c1 c2 : tindex) (s1 s2 : list tindex),
    ti_lex_lt c1 c2 ->
    ti_lex_lt (ti_list (c1::s1)) (ti_list (c2::s2))
| ti_lex_lt_ls_eq : forall (c : tindex) (s1 s2 : list tindex),
    ti_lex_lt (ti_list s1) (ti_list s2) ->
    ti_lex_lt (ti_list (c::s1)) (ti_list (c::s2))
| ti_lex_lt_ls_empty : forall (c:tindex) (s : list tindex),
    ti_lex_lt (ti_list nil) (ti_list (c::s)).

Theorem lex_lt_trans : forall s0 s1 s2,
    lex_lt s0 s1 -> lex_lt s1 s2 -> lex_lt s0 s2.
Proof.
induction s0.
- intros.
  inversion H; subst.
  inversion H0; subst.
  * apply lex_lt_empty.
  * apply lex_lt_empty.
- intros.
  inversion H; subst; inversion H0; subst.
  * apply lex_lt_lt.
    eauto with arith.
  * apply lex_lt_lt.
    assumption.
  * apply lex_lt_lt.
    assumption.
  * apply lex_lt_eq.
    eapply IHs0; eauto.
Qed.

Theorem ti_lex_lt_trans : forall s0 s1 s2,
    ti_lex_lt s0 s1 -> ti_lex_lt s1 s2 -> ti_lex_lt s0 s2.
Proof.
  introv HA HB. gen s2.
  induction* HA; intros; try solve [inverts~ HB; econstructor; eauto];
    inductions HB; try solve [econstructor; eauto using lex_lt_trans].
Qed.

Theorem lex_lt_not_eq : forall s0 s1,
    lex_lt s0 s1 -> s0 <> s1.
Proof.
  induction s0.
  - intros.
    inversion H; subst.
    congruence.
  - intros.
    inversion H; subst.
    * intro H_eq.
      find_injection.
      contradict H3.
      auto with arith.
    * intro H_eq.
      find_injection.
      specialize (IHs0 s3).
      concludes.
      auto.
Qed.


Theorem ti_lex_lt_not_eq : forall s0 s1,
    ti_lex_lt s0 s1 -> s0 <> s1.
Proof.
  induction s0 using tindex_ind; intros;
    try solve [inverts H; intro HF; inverts* HF].
  - (* rcd *) inverts H; try solve [intro HF; inverts* HF].
    forwards*: lex_lt_not_eq H3.
    intro HF. find_injection.
    applys* H.
  - applys~ ti_list_ind H.
    + introv HL; inverts HL; try solve [intro HF; inverts* HF].
    + introv HP1 HP2 HL.
      destruct s0; try solve [intro HF; inverts* HF].
      destruct a; try solve [intro HF; inverts* HF].
      intro HF; find_injection; subst.
      inverts* HL.
Qed.

Lemma nat_of_ascii_injective:
  forall c1 c2, nat_of_ascii c1 = nat_of_ascii c2 -> c1 = c2.
Proof.
  intros; simpl.
  assert (ascii_of_nat (nat_of_ascii c1) =
          ascii_of_nat (nat_of_ascii c2))
      as Hinvol. auto.
  repeat rewrite ascii_nat_embedding in Hinvol.
  trivial.
Qed.

Fixpoint string_compare_lex_compat (s0 s1 : string) : Compare lex_lt eq s0 s1.
refine
  (match s0 as ss0, s1 as ss1 return (_ = ss0 -> _ = ss1 -> _) with
   | EmptyString, EmptyString => fun H_eq H_eq' => EQ _
   | EmptyString, String c' s'1 => fun H_eq H_eq' => LT _
   | String c s'0, EmptyString => fun H_eq H_eq' => GT _
   | String c s'0, String c' s'1 => fun H_eq H_eq' =>
     match Nat.compare (nat_of_ascii c) (nat_of_ascii c') as cmp return (_ = cmp -> _) with
     | Lt => fun H_eq_cmp => LT _
     | Eq => fun H_eq_cmp =>
       match string_compare_lex_compat s'0 s'1 with
       | LT H_lt => LT _
       | EQ H_eq_lex => EQ _
       | GT H_gt => GT _
       end
     | Gt => fun H_eq_cmp => GT _
     end (refl_equal _)
   end (refl_equal _) (refl_equal _)); try (rewrite H_eq; rewrite H_eq'); auto.
- apply lex_lt_empty.
- apply lex_lt_empty.
- apply nat_compare_eq in H_eq_cmp.
  apply nat_of_ascii_injective in H_eq_cmp.
  rewrite H_eq_cmp.
  apply lex_lt_eq.
  assumption.
- apply nat_compare_eq in H_eq_cmp.
  apply nat_of_ascii_injective in H_eq_cmp.
  subst.
  reflexivity.
- apply nat_compare_eq in H_eq_cmp.
  apply nat_of_ascii_injective in H_eq_cmp.
  rewrite H_eq_cmp.
  apply lex_lt_eq.
  assumption.
- apply nat_compare_lt in H_eq_cmp.
  apply lex_lt_lt.
  assumption.
- apply nat_compare_gt in H_eq_cmp.
  apply lex_lt_lt.
  auto with arith.
Defined.

Fixpoint sum (ls : list nat) : nat :=
  match ls with
    | nil => O
    | cons h t => plus h (sum t)
  end.

Fixpoint tindexSize (t : tindex) : nat :=
  match t with
  | ti_list l => S (sum (map tindexSize l))
  | _ => 1
  end.

From Coq Require Import List.
Import ListNotations.
Set Implicit Arguments.

Definition tindexOrder (t1 t2 : tindex) :=
  tindexSize t1 < tindexSize t2.

Search Acc.
Hint Constructors Acc.


Theorem tindexOrder_wf : well_founded tindexOrder.
  red; intro. induction a.
  all: try solve [ applys Acc_intro; introv H';
                   unfolds in H'; destruct y; simpl in H';
                   lia ].
  - applys~ ti_list_ind.
    + applys Acc_intro; introv H';
      unfolds in H'; destruct y; simpl in H';
        lia.
    + introv IH1 IH2.
      applys Acc_intro; introv H'; unfolds in H'; simpl in H'.
Abort.

Fixpoint tindexSize' (t : tindex) : nat :=
  match t with
  | ti_list l => length l
  | _ => 0
  end.

Definition tindexOrder' (t1 t2 : tindex) :=
  tindexSize' t1 < tindexSize' t2.

Theorem tindexOrder_wf : well_founded tindexOrder'.
  red; intro. induction a using tindex_ind.
  all: try solve [ applys Acc_intro; introv H';
                   unfolds in H'; destruct y; simpl in H';
                   lia ].
  - applys~ ti_list_ind.
    + applys Acc_intro; introv H';
      unfolds in H'; destruct y; simpl in H';
        lia.
    + introv IH1 IH2.
      applys Acc_intro; introv H'.
      destruct y.
      all: try solve [ applys Acc_intro; introv H'';
                       unfolds in H''; destruct y; simpl in H'';
                       lia ].
      inverts H'.
      * applys Acc_intro. introv H''.
        destruct y.
        all: try solve [ applys Acc_intro; introv H''';
                       unfolds in H'''; destruct y; simpl in H''';
                         lia ].
        applys Acc_inv IH2. unfolds. simpl.
        unfolds in H''. simpl in H''. rewrite H1 in H''.
        lia.
      * applys Acc_intro. introv H''.
        destruct y.
        all: try solve [ applys Acc_intro; introv H''';
                       unfolds in H'''; destruct y; simpl in H''';
                         lia ].
        applys Acc_inv IH2. unfolds. simpl.
        unfolds in H''. simpl in H''.
        simpl in H1. lia.
Defined.

Fixpoint tindexSize'' (t : tindex) : nat :=
  match t with
  | ti_arrow A B => tindexSize'' A + tindexSize'' B
  | ti_rcd l A => S (tindexSize'' A)
  | ti_list l => S (sum (map tindexSize'' l))
  | _ => 1
  end.

Fixpoint tindex_compare_lex_compat (s0 s1 : tindex) : Compare ti_lex_lt eq s0 s1.
Proof.
  refine (
  match s0 as ss0, s1 as ss1 return (s0 = ss0 -> s1 = ss1 -> _) with
  | ti_bot, ti_bot => fun _ _  => EQ _
  | ti_bot, _  => fun H_eq : s0 = ti_bot => fun H_eq' : s1 = _ => LT _
  | ti_base, ti_bot => fun H_eq : s0 = ti_base => fun H_eq' => GT _
  | ti_base, ti_base => fun H_eq : s0 = ti_base => fun H_eq' => EQ _
  | ti_base, _  => fun H_eq : s0 = ti_base => fun H_eq' => LT _
  | ti_arrow _ _, ti_bot => fun H_eq H_eq' => GT _
  | ti_arrow _ _, ti_base => fun H_eq H_eq' => GT _
  | ti_arrow A1 B1, ti_arrow A2 B2 => fun H_eq H_eq' =>
     match tindex_compare_lex_compat A1 A2 with
     | LT H_lt => LT _
     | EQ H_eq_lex => match tindex_compare_lex_compat B1 B2 with
                      | LT H_lt => LT _
                      | EQ H_eq_lex => EQ _
                      | GT H_gt => GT _
                      end
     | GT H_gt => GT _
     end
   | ti_arrow _ _, _ => fun H_eq H_eq' => LT _
   | ti_rcd _ _, ti_bot => fun H_eq H_eq' => GT _
   | ti_rcd _ _, ti_base => fun H_eq H_eq' => GT _
   | ti_rcd _ _, ti_arrow _ _ => fun H_eq H_eq' => GT _
   | ti_rcd l A, ti_rcd r B => fun H_eq H_eq' =>
     match string_compare_lex_compat l r with
     | LT H_lt => LT _
     | EQ H_eq_lex => match tindex_compare_lex_compat A B with
                      | LT H_lt => LT _
                      | EQ H_eq_lex => EQ _
                      | GT H_gt => GT _
                      end
     | GT H_gt => GT _
     end
  | ti_rcd _ _, _ => fun H_eq H_eq' => LT _
  | ti_list nil, ti_list nil => fun H_eq H_eq' => EQ _
   | ti_list nil, ti_list _ => fun H_eq H_eq' => LT _
   | ti_list (c1::l1), ti_list (c2::l2) =>
     match tindex_compare_lex_compat c1 c2 with
     | LT H_lt => fun H_eq H_eq' => LT _
     | EQ H_eq_lex => fun H_eq H_eq' =>
         match tindex_compare_lex_compat (ti_list l1) (ti_list l2) with
         | LT H_lt => LT _
         | EQ H_eq_lex => EQ _
         | GT H_gt => GT _
         end
     | GT H_gt => fun H_eq H_eq' => GT _
     end
  | ti_list _, _ => fun H_eq H_eq' => GT _
  end (refl_equal _) (refl_equal _)).
  all: try solve [clear tindex_compare_lex_compat; try find_injection; subst; try econstructor; eauto].
Abort.

Program Fixpoint tindex_compare_lex_compat (s0 s1 : tindex) { measure (size_tindex s0 + size_tindex s1) }: Compare ti_lex_lt eq s0 s1 :=
  match s0 as ss0, s1 as ss1 return (s0 = ss0 -> s1 = ss1 -> _) with
  | ti_bot, ti_bot => fun _ _ => EQ _
  | ti_bot, _  => fun H_eq H_eq' => LT _
  | ti_base, ti_bot => fun H_eq H_eq' => GT _
  | ti_base, ti_base => fun H_eq H_eq' => EQ _
  | ti_base, _  => fun H_eq H_eq' => LT _
  | ti_arrow _ _, ti_bot => fun H_eq H_eq' => GT _
  | ti_arrow _ _, ti_base => fun H_eq H_eq' => GT _
  | ti_arrow A1 B1, ti_arrow A2 B2 => fun H_eq H_eq' =>
     match tindex_compare_lex_compat A1 A2 with
     | LT H_lt => LT _
     | EQ H_eq_lex => match tindex_compare_lex_compat B1 B2 with
                      | LT H_lt => LT _
                      | EQ H_eq_lex' => EQ _
                      | GT H_gt => GT _
                      end
     | GT H_gt => GT _
     end
  | ti_arrow _ _, _ => fun H_eq H_eq' => LT _
  | ti_rcd _ _, ti_bot => fun H_eq H_eq' => GT _
  | ti_rcd _ _, ti_base => fun H_eq H_eq' => GT _
  | ti_rcd _ _, ti_arrow _ _ => fun H_eq H_eq' => GT _
  | ti_rcd l A, ti_rcd r B => fun H_eq H_eq' =>
     match string_compare_lex_compat l r with
     | LT H_lt => LT _
     | EQ H_eq_lex => match tindex_compare_lex_compat A B with
                      | LT H_lt => LT _
                      | EQ H_eq_lex => EQ _
                      | GT H_gt => GT _
                      end
     | GT H_gt => GT _
     end
  | ti_rcd _ _, _ => fun H_eq H_eq' => LT _
  (*
  | ti_list l1, ti_list l2 => match l1, l2 with
                              | nil, nil => fun H_eq H_eq' => EQ _
                              | nil, _ => fun H_eq H_eq' => LT _
                              | (c1::l1), (c2::l2) => fun H_eq H_eq' =>
                                  match tindex_compare_lex_compat c1 c2 as cmp1,
                                          tindex_compare_lex_compat (ti_list l1) (ti_list l2) as cmp2
                                  with
                                  | LT H_lt, _ => LT _
                                  | EQ H_eq_lex, LT H_lt => LT _
                                  | EQ H_eq_lex, EQ H_eq_lex' => EQ _
                                  | EQ H_eq_lex, GT H_gt => GT _
                                  | GT H_gt, _ => GT _
                                  end
                              | _, _ => fun H_eq H_eq' => GT _
                              end
  | ti_list _, _ => fun H_eq H_eq' => GT _ *)

  | ti_list nil, ti_list nil => fun H_eq H_eq' => EQ _
  | ti_list nil, ti_list _ => fun H_eq H_eq' => LT _
  | ti_list (c1::l1), ti_list (c2::l2) => fun H_eq H_eq' =>
      match tindex_compare_lex_compat c1 c2 as cmp1,
              tindex_compare_lex_compat (ti_list l1) (ti_list l2) as cmp2
      with
      | LT H_lt, _ => LT _
      | EQ H_eq_lex, LT H_lt => LT _
      | EQ H_eq_lex, EQ H_eq_lex' => EQ _
      | EQ H_eq_lex, GT H_gt => GT _
      | GT H_gt, _ => GT _
     end
  | ti_list _, _ => fun H_eq H_eq' => GT _
  end (refl_equal _) (refl_equal _).
Obligation Tactic :=
  intros; subst; elia;
  try solve [try find_injection; subst; try econstructor; eauto].
Solve All Obligations.
Next Obligation.
  inverts~ H_eq_lex'.
Defined.

(*
Fixpoint zipWith (f : tindex->tindex->nat) (s0 s1: list tindex) : list nat :=
  match s0, s1 with
  | c1::l1, c2::l2 => (f c1 c2) :: zipWith f l1 l2
  | _, _ => nil
  end.

Fixpoint f (s0 s1: tindex) : nat :=
  match s0, s1 with
  | ti_list l1, ti_list l2 => fold_left (plus) (zipWith f l1 l2) 0
  | _ , _ => 1
  end.

  | ti_list (c1::l1) , ti_list (c2::l2) =>
      let f' := fun x => f (fst x) (snd x) in
      fold_left (plus) (map f' (combine l1 l2)) 0
Print zip.
Fixpoint tindex_compare_lex_compat (s0 s1 : tindex) : Compare ti_lex_lt eq s0 s1.
refine
  (match s0 as ss0, s1 as ss1 return (_ = ss0 -> _ = ss1 -> _) with
   | ti_bot, ti_bot => fun H_eq H_eq' => EQ _
   | ti_bot, _  => fun H_eq H_eq' => LT _
   | ti_base, ti_bot => fun H_eq H_eq' => GT _
   | ti_base, ti_base => fun H_eq H_eq' => EQ _
   | ti_base, _  => fun H_eq H_eq' => LT _
   | ti_arrow _ _, ti_bot => fun H_eq H_eq' => GT _
   | ti_arrow _ _, ti_base => fun H_eq H_eq' => GT _
   | ti_arrow A1 B1, ti_arrow A2 B2 => fun H_eq H_eq' =>
     match tindex_compare_lex_compat A1 A2 with
     | LT H_lt => LT _
     | EQ H_eq_lex => match tindex_compare_lex_compat B1 B2 with
                      | LT H_lt => LT _
                      | EQ H_eq_lex => EQ _
                      | GT H_gt => GT _
                      end
     | GT H_gt => GT _
     end
   | ti_arrow _ _, _ => fun H_eq H_eq' => LT _
   | ti_rcd _ _, ti_bot => fun H_eq H_eq' => GT _
   | ti_rcd _ _, ti_base => fun H_eq H_eq' => GT _
   | ti_rcd _ _, ti_arrow _ _ => fun H_eq H_eq' => GT _
   | ti_rcd l A, ti_rcd r B => fun H_eq H_eq' =>
     match string_compare_lex_compat l r with
     | LT H_lt => LT _
     | EQ H_eq_lex => match tindex_compare_lex_compat A B with
                      | LT H_lt => LT _
                      | EQ H_eq_lex => EQ _
                      | GT H_gt => GT _
                      end
     | GT H_gt => GT _
     end
   | ti_rcd _ _, _ => fun H_eq H_eq' => LT _
   | ti_list _, ti_list _ =>
       (fix tindex_list_compare_lex_compact (l1 l2: list tindex) : Compare ti_lex_lt eq (ti_list l1) (ti_list l2) :=
          match l1 as ll1, l2 as ll2 return (_ = ll1 -> _ = ll2 -> _) with
          | nil, nil => fun H_eq H_eq' => EQ _
          | nil, _ => fun H_eq H_eq' => LT _
          | _, nil => fun H_eq H_eq' => GT _
          | (c1::l1'), (c2::l2') =>
              match tindex_compare_lex_compat c1 c2 with
              | LT H_lt => fun H_eq H_eq' => LT _
              | EQ H_eq_lex => fun H_eq H_eq' =>
                                 match tindex_list_compare_lex_compact l1 l2 with
                                 | LT H_lt => LT _
                                 | EQ H_eq_lex => EQ _
                                 | GT H_gt => GT _
                                 end
              | GT H_gt => fun H_eq H_eq' => GT _
              end
          end (refl_equal _) (refl_equal _) )
   | ti_list _, _ => fun H_eq H_eq' => GT _
   end (refl_equal _) (refl_equal _));
  try solve [try find_injection; subst; econstructor; eauto].
Defined.
applys ti_lex_lt_arrow_arrow.
Check nat_compare_eq.
*)

Module tindex_lex_as_OT_compat <: UsualOrderedType.
  Definition t := tindex.
  Definition eq := @eq tindex.
  Definition lt := ti_lex_lt.
  Definition eq_refl := @eq_refl tindex.
  Definition eq_sym := @eq_sym tindex.
  Definition eq_trans := @eq_trans tindex.
  Definition lt_trans := ti_lex_lt_trans.
  Definition lt_not_eq := ti_lex_lt_not_eq.
  Definition compare := tindex_compare_lex_compat.
  Definition eq_dec := tindex_dec.
End tindex_lex_as_OT_compat.

From Coq Require Import Orders.

Lemma lex_lt_irrefl : Irreflexive ti_lex_lt.
Proof.
  intros s0 H_lt.
  apply ti_lex_lt_not_eq in H_lt.
  auto.
Qed.

Theorem lex_lt_strorder : StrictOrder ti_lex_lt.
Proof.
  exact (Build_StrictOrder _ lex_lt_irrefl ti_lex_lt_trans).
Qed.

Theorem lex_lt_lt_compat : Proper (eq ==> eq ==> iff) ti_lex_lt.
Proof.
  intros s0 s1 H_eq s2 s3 H_eq'.
  split; intro H_imp; subst; auto.
Qed.
Fixpoint string_compare_lex (s0 s1 : string) : { cmp : comparison | CompSpec eq lex_lt s0 s1 cmp }.
refine
  (match s0 as ss0, s1 as ss1 return (_ = ss0 -> _ = ss1 -> _) with
   | EmptyString, EmptyString => fun H_eq H_eq' => exist _ Eq _
   | EmptyString, String c' s'1 => fun H_eq H_eq' => exist _ Lt _
   | String c s'0, EmptyString => fun H_eq H_eq' => exist _ Gt _
   | String c s'0, String c' s'1 => fun H_eq H_eq' =>
     match Nat.compare (nat_of_ascii c) (nat_of_ascii c') as cmp0 return (_ = cmp0 -> _)  with
     | Lt => fun H_eq_cmp0 => exist _ Lt _
     | Eq => fun H_eq_cmp0 =>
       match string_compare_lex s'0 s'1 with
       | exist _ cmp H_cmp' =>
         match cmp as cmp1 return (cmp = cmp1 -> _) with
         | Lt => fun H_eq_cmp1 => exist _ Lt _
         | Eq => fun H_eq_cmp1 => exist _ Eq _
         | Gt => fun H_eq_cmp1 => exist _ Gt _
         end (refl_equal _)
       end
     | Gt => fun H_eq_cmp0 => exist _ Gt _
     end (refl_equal _)
   end (refl_equal _) (refl_equal _)); try (rewrite H_eq; rewrite H_eq').
- apply CompEq; auto.
- apply CompLt.
  apply lex_lt_empty.
- apply CompGt.
  apply lex_lt_empty.
- apply nat_compare_eq in H_eq_cmp0.
  apply nat_of_ascii_injective in H_eq_cmp0.
  rewrite H_eq_cmp1 in H_cmp'.
  inversion H_cmp'; subst.
  apply CompEq.
  reflexivity.
- apply nat_compare_eq in H_eq_cmp0.
  apply nat_of_ascii_injective in H_eq_cmp0.
  rewrite H_eq_cmp1 in H_cmp'.
  inversion H_cmp'.
  subst.
  apply CompLt.
  apply lex_lt_eq.
  assumption.
- apply nat_compare_eq in H_eq_cmp0.
  apply nat_of_ascii_injective in H_eq_cmp0.
  rewrite H_eq_cmp1 in H_cmp'.
  subst.
  inversion H_cmp'.
  apply CompGt.
  apply lex_lt_eq.
  assumption.
- apply nat_compare_lt in H_eq_cmp0.
  apply CompLt.
  apply lex_lt_lt.
  assumption.
- apply nat_compare_gt in H_eq_cmp0.
  apply CompGt.
  apply lex_lt_lt.
  auto with arith.
Defined.

Program Fixpoint tindex_compare_lex (s0 s1 : tindex) { measure (size_tindex s0 + size_tindex s1) } : { cmp : comparison | CompSpec eq ti_lex_lt s0 s1 cmp } :=
  match s0 as ss0, s1 as ss1 return (s0 = ss0 -> s1 = ss1 -> _) with
  | ti_bot, ti_bot => fun H_eq H_eq' => exist _ Eq _
  | ti_bot, _  => fun H_eq H_eq' => exist _ Lt _
  | ti_base, ti_bot => fun H_eq H_eq' => exist _ Gt _
  | ti_base, ti_base => fun H_eq H_eq' => exist _ Eq _
  | ti_base, _  => fun H_eq H_eq' => exist _ Lt _
  | ti_arrow _ _, ti_bot => fun H_eq H_eq' => exist _ Gt _
  | ti_arrow _ _, ti_base => fun H_eq H_eq' => exist _ Gt _
  | ti_arrow A1 B1, ti_arrow A2 B2 => fun H_eq H_eq' =>
     match tindex_compare_lex A1 A2 as cmp return (_ = cmp -> _) with
     | Lt => fun H_eq_cmp => exist _ Lt _
     | Eq => fun H_eq_cmp => match tindex_compare_lex B1 B2 with
             | Lt => exist _ Lt _
             | Eq => exist _ Eq _
             | Gt => exist _ Gt _
             end
     | Gt => fun H_eq_cmp => exist _ Gt _
     end (refl_equal _)
  | ti_arrow _ _, _ => fun H_eq H_eq' => exist _ Lt _
  | ti_rcd _ _, ti_bot => fun H_eq H_eq' => exist _ Gt _
  | ti_rcd _ _, ti_base => fun H_eq H_eq' => exist _ Gt _
  | ti_rcd _ _, ti_arrow _ _ => fun H_eq H_eq' => exist _ Gt _
  | ti_rcd l A, ti_rcd r B => fun H_eq H_eq' =>
                                match string_compare_lex l r as cmp return (_ = cmp -> _) with
                                | Lt => fun H_eq_cmp' => exist _ Lt _
                                | Eq => fun H_eq_cmp => match tindex_compare_lex A B as cmp' return (_ = cmp' -> _) with
                                                        | Lt => fun H_eq_cmp' => exist _ Lt _
                                                        | Eq => fun H_eq_cmp' => exist _ Eq _
                                                        | Gt => fun H_eq_cmp' => exist _ Gt _
                                                        end (refl_equal _)
                                | Gt => fun H_eq_cmp =>exist _ Gt _
                                end (refl_equal _)
  | ti_rcd _ _, _ => fun H_eq H_eq' => exist _ Lt _
  | ti_list nil, ti_list nil => fun H_eq H_eq' => exist _ Eq _
  | ti_list nil, ti_list _ => fun H_eq H_eq' => exist _ Lt _
  | ti_list (c1::l1), ti_list (c2::l2) => fun H_eq H_eq' =>
    match tindex_compare_lex c1 c2 as cmp1, tindex_compare_lex (ti_list l1) (ti_list l2) as cmp2
          return (_ = cmp1 -> _ = cmp2 -> _) with
    | Lt, _ => fun Hc Hc' => exist _ Lt _
    | Eq, Lt => fun Hc Hc' => exist _ Lt _
    | Eq, Eq => fun Hc Hc' => exist _ Eq _
    | Eq, Gt => fun Hc Hc' => exist _ Gt _
    | Gt, _ => fun Hc Hc' => exist _ Gt _
    end (refl_equal _) (refl_equal _)
   | ti_list _, _ => fun H_eq H_eq' => exist _ Gt _
   end (refl_equal _) (refl_equal _).
Obligation Tactic :=
  intros;
  try solve [
      lazymatch goal with
      | [ tindex_compare_lex : forall s0 s1: tindex, _ |- _ ] =>
          try lazymatch goal with
            | |- (fun cmp : comparison => CompSpec eq ti_lex_lt (ti_rcd ?l ?A) (ti_rcd ?r ?B) cmp) _ => destruct (string_compare_lex l r)
                                                                                                                 (* | |- (fun cmp : comparison => CompSpec eq ti_lex_lt (ti_arrow ?A1 ?B1) (ti_arrow ?A2 ?B2) cmp) _ => *)
                                                                                                                 (*     let cmp := fresh "cmp" in *)
                                                                                                                 (*     forwards cmp: (tindex_compare_lex A1 A2); subst; elia; inverts cmp *)
                                                                                                                 (* | |- CompSpec eq ti_lex_lt (ti_arrow ?A ?B1) (ti_arrow ?A ?B2) Gt => *)
                                                                                                                 (*     let cmp := fresh "cmp" in *)
                                                                                                                 (*     forwards cmp: (tindex_compare_lex B1 B2); subst; elia; inverts cmp *)
            end;
          try solve [ subst; elia ];
          try lazymatch goal with
            | [ h : proj1_sig ?s = _ |- _ ] => let c := fresh "c" in
                                                 lets c: proj2_sig s;
                                                 rewrite h in c;
                                                 inverts c;
                                                 try clear h
          end;
          try lazymatch goal with
            | [ h : proj1_sig ?s = _ |- _ ] => let c := fresh "c" in
                                                 lets c: proj2_sig s;
                                                 rewrite h in c;
                                                 inverts c
            | [ h : CompSpec eq _ _ _ _ |- _ ] => inversion h; subst
            | [ h : _ = _ |- _ ] => inverts h
          end; subst;
          try lazymatch goal with
            | [ h := proj1_sig ?s |- _ ] => destruct (proj2_sig s); subst
          end;
          simpl in *; subst; try solve_by_invert;
          try solve [ applys CompEq; econstructor; eauto ];
          try solve [ applys CompLt; econstructor; eauto ];
          try solve [ applys CompGt; econstructor; eauto ]
      end
    ].
Solve All Obligations.
Next Obligation.
  inverts Hc. inverts Hc'. subst.
  destruct (proj2_sig
              (tindex_compare_lex c1 c2
                 (tindex_compare_lex_func_obligation_43 tindex_compare_lex eq_refl eq_refl)));
    try solve_by_invert.
  repeat econstructor. auto.
Defined.
Next Obligation.
  inverts Hc. inverts Hc'. subst.
  destruct (proj2_sig
              (tindex_compare_lex c1 c2
                 (tindex_compare_lex_func_obligation_43 tindex_compare_lex eq_refl eq_refl)));
    try solve_by_invert.
  repeat econstructor. auto.
Defined.
Next Obligation.
  inverts Hc. inverts Hc'. subst.
  destruct (proj2_sig
              (tindex_compare_lex c1 c2
                 (tindex_compare_lex_func_obligation_43 tindex_compare_lex eq_refl eq_refl)));
    try solve_by_invert; subst.
  destruct (proj2_sig
         (tindex_compare_lex (ti_list l1) (ti_list l2)
            (tindex_compare_lex_func_obligation_44 tindex_compare_lex eq_refl eq_refl)));
    try find_injection; try solve_by_invert; repeat econstructor.
Defined.

(*
Fixpoint tindex_compare_lex (s0 s1 : tindex) : { cmp : comparison | CompSpec eq ti_lex_lt s0 s1 cmp }.
refine
  (match s0 as ss0, s1 as ss1 return (_ = ss0 -> _ = ss1 -> _) with
   | ti_bot, ti_bot => fun H_eq H_eq' => exist _ Eq _
   | ti_bot, _  => fun H_eq H_eq' => exist _ Lt _
   | ti_base, ti_bot => fun H_eq H_eq' => exist _ Gt _
   | ti_base, ti_base => fun H_eq H_eq' => exist _ Eq _
   | ti_base, _  => fun H_eq H_eq' => exist _ Lt _
   | ti_arrow _ _, ti_bot => fun H_eq H_eq' => exist _ Gt _
   | ti_arrow _ _, ti_base => fun H_eq H_eq' => exist _ Gt _
   | ti_arrow A1 B1, ti_arrow A2 B2 => fun H_eq H_eq' =>
     match tindex_compare_lex A1 A2 with
     | exist _ cmp H_cmp => match cmp as cmp1 return (cmp = cmp1 -> _) with
                             | Lt => fun H_eq_cmp1 => exist _ Lt _
                             | Eq => fun H_eq_cmp1 => match tindex_compare_lex B1 B2 with
                                    | exist _ cmp' H_cmp' =>
                                        match cmp' as cmp2
                                              return (cmp' = cmp2 -> _)
                                        with
                                        | Lt => fun H_eq_cmp2 => exist _ Lt _
                                        | Eq => fun H_eq_cmp2 => exist _ Eq _
                                        | Gt => fun H_eq_cmp2 => exist _ Gt _
                                        end (refl_equal _)
                                    end
                            | Gt => fun H_eq_cmp1 => exist _ Gt _
                            end (refl_equal _)
     end
  | ti_arrow _ _, _ => fun H_eq H_eq' => exist _ Lt _
  | ti_rcd _ _, ti_bot => fun H_eq H_eq' => exist _ Gt _
  | ti_rcd _ _, ti_base => fun H_eq H_eq' => exist _ Gt _
  | ti_rcd _ _, ti_arrow _ _ => fun H_eq H_eq' => exist _ Gt _
  | ti_rcd l A, ti_rcd r B => fun H_eq H_eq' =>
     match string_compare_lex l r with
     | exist _ cmp H_cmp => match cmp as cmp1 return (cmp = cmp1 -> _) with
                            | Lt => fun H_eq_cmp1 => exist _ Lt _
                            | Eq => fun H_eq_cmp1 => match tindex_compare_lex A B with
                                                     | exist _ cmp' H_cmp' =>
                                                         match cmp' as cmp2
                                                               return (cmp' = cmp2 -> _)
                                                         with
                                                         | Lt => fun H_eq_cmp2 => exist _ Lt _
                                                         | Eq => fun H_eq_cmp2 => exist _ Eq _
                                                         | Gt => fun H_eq_cmp2 => exist _ Gt _
                                                         end (refl_equal _)
                                                     end
                            | Gt => fun H_eq_cmp1 => exist _ Gt _
                            end (refl_equal _)
     end
   | ti_rcd _ _, _ => fun H_eq H_eq' => exist _ Lt _
   | ti_list nil, ti_list nil => fun H_eq H_eq' => exist _ Eq _
   | ti_list nil, ti_list _ => fun H_eq H_eq' => exist _ Lt _
   | ti_list (c1::l1), ti_list (c2::l2) => fun H_eq H_eq' =>
                                             match tindex_compare_lex c1 c2 with
                                             | exist _ cmp H_cmp =>
                                                   match tindex_compare_lex (ti_list l1) (ti_list l2) with
                                                   | exist _ cmp' H_cmp' =>
                                                       match cmp as cmp1, cmp' as cmp2
                                                             return (cmp = cmp1 -> cmp' = cmp2 -> _) with
                                                       | Lt, _ => fun H_eq_cmp1 H_eq_cmp2 => exist _ Lt _
                                                       | Eq, Lt => fun H_eq_cmp1 H_eq_cmp2 => exist _ Lt _
                                                       | Eq, Eq => fun H_eq_cmp1 H_eq_cmp2 => exist _ Eq _
                                                       | Eq, Gt => fun H_eq_cmp1 H_eq_cmp2 => exist _ Gt _
                                                       | Gt, _ => fun H_eq_cmp1 H_eq_cmp2 => exist _ Gt _
                                                       end (refl_equal _) (refl_equal _)
                                                   end
                                             end
   | ti_list _, _ => fun H_eq H_eq' => exist _ Gt _

   end (refl_equal _) (refl_equal _)); try (rewrite H_eq; rewrite H_eq').
all: try solve [
         repeat progress (repeat lazymatch goal with
           | [ h : CompSpec eq _ _ _ _ |- _ ] => inverts h
           | [ h : _ = _ |- _ ] => inverts h
                            end; subst);
         try solve [ applys CompEq; econstructor; eauto ];
         try solve [ applys CompLt; econstructor; eauto ];
         try solve [ applys CompGt; econstructor; eauto ] ].
Defined.
Obligation Tactic :=
  intros; subst; elia;
try solve [try find_injection; subst; try econstructor; eauto].
*)

Module tindex_lex_as_OT <: UsualOrderedType.
  Definition t := tindex.
  Definition eq := @eq tindex.
  Definition eq_equiv := @eq_equivalence tindex.
  Definition lt := ti_lex_lt.
  Definition lt_strorder := lex_lt_strorder.
  Definition lt_compat := lex_lt_lt_compat.
  Definition compare := fun x y => proj1_sig (tindex_compare_lex x y).
  Definition compare_spec := fun x y => proj2_sig (tindex_compare_lex x y).
  Definition eq_dec := tindex_dec.
End tindex_lex_as_OT.

Require Import Sorting.Sorted.
Require Import Sorting.Mergesort.
Require Import List Setoid Permutation Sorted Orders OrdersEx.

Module NOTF := OT_to_Full tindex_lex_as_OT.
Module NTTLB := OTF_to_TTLB NOTF.
Module Export NSort := Sort NTTLB.

Open Scope string_scope.
Check merge.
Fixpoint styp2tindex (A: typ) : list tindex :=
  if (check_toplike A) then nil
  else
    match A with
    | typ_top => nil
    | typ_bot => [ ti_bot ]
    | typ_base => [ ti_base ]
    | typ_arrow A1 A2 => [ ti_arrow (ti_list (styp2tindex A1)) (ti_list (styp2tindex A2)) ]
    | typ_rcd l A' => [ ti_rcd  l (ti_list (styp2tindex A')) ]
    | typ_and A1 A2 => nodup tindex_dec (merge (styp2tindex A1) (styp2tindex A2))
    end.

Inductive texp : Set :=  (*r target term *)
 | texp_var_b (_:nat) (*r variable *)
 | texp_var_f (x:var) (*r variable *)
 | texp_base (b:lit) (*r base value *)
 | texp_abs (t:texp) (*r abstractions *)
 | texp_fixpoint (t:texp) (*r fixpoint *)
 | texp_app (t1:texp) (t2:texp) (*r applications *)
 | texp_nil : texp (*r empty record *)
 | texp_cons (ll:tindex) (t1':texp) (t2:texp)
 | texp_proj (t1:texp) (ll:tindex) (*r projection *)
 | texp_concat (t1:texp) (t2:texp) (*r concatenation *).

Inductive dirflag : Set :=  (*r checking direction *)
 | Inf : dirflag
 | Chk : dirflag.

Inductive exp : Set :=  (*r expressions *)
 | exp_top : exp (*r top value *)
 | exp_base (b:lit) (*r base literal *)
 | exp_var_b (_:nat) (*r variables *)
 | exp_var_f (x:var) (*r variables *)
 | exp_abs (A:typ) (e:exp) (B:typ) (*r abstractions *)
 | exp_fixpoint (A:typ) (e:exp) (*r fixpoint *)
 | exp_app (e1:exp) (e2:exp) (*r applications *)
 | exp_merge (e1:exp) (e2:exp) (*r merge *)
 | exp_anno (e:exp) (A:typ) (*r annotation *)
 | exp_rcd (l:label) (e:exp) (*r record *)
 | exp_proj (e:exp) (l:label) (*r projection *).

Definition tctx : Set := list ( atom * ttyp ).

Definition ctx : Set := list ( atom * typ ).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_texp_wrt_texp_rec (k:nat) (t_5:texp) (t__6:texp) {struct t__6}: texp :=
  match t__6 with
  | (texp_var_b nat) =>
      match lt_eq_lt_dec nat k with
        | inleft (left _) => texp_var_b nat
        | inleft (right _) => t_5
        | inright _ => texp_var_b (nat - 1)
      end
  | (texp_var_f x) => texp_var_f x
  | (texp_base b) => texp_base b
  | (texp_abs t) => texp_abs (open_texp_wrt_texp_rec (S k) t_5 t)
  | (texp_fixpoint t) => texp_fixpoint (open_texp_wrt_texp_rec (S k) t_5 t)
  | (texp_app t1 t2) => texp_app (open_texp_wrt_texp_rec k t_5 t1) (open_texp_wrt_texp_rec k t_5 t2)
  | texp_nil => texp_nil
  | (texp_cons ll t1' t2) => texp_cons ll (open_texp_wrt_texp_rec k t_5 t1') (open_texp_wrt_texp_rec k t_5 t2)
  | (texp_proj t1 ll) => texp_proj (open_texp_wrt_texp_rec k t_5 t1) ll
  | (texp_concat t1 t2) => texp_concat (open_texp_wrt_texp_rec k t_5 t1) (open_texp_wrt_texp_rec k t_5 t2)
end.

Fixpoint open_exp_wrt_exp_rec (k:nat) (e_5:exp) (e__6:exp) {struct e__6}: exp :=
  match e__6 with
  | exp_top => exp_top
  | (exp_base b) => exp_base b
  | (exp_var_b nat) =>
      match lt_eq_lt_dec nat k with
        | inleft (left _) => exp_var_b nat
        | inleft (right _) => e_5
        | inright _ => exp_var_b (nat - 1)
      end
  | (exp_var_f x) => exp_var_f x
  | (exp_abs A e B) => exp_abs A (open_exp_wrt_exp_rec (S k) e_5 e) B
  | (exp_fixpoint A e) => exp_fixpoint A (open_exp_wrt_exp_rec (S k) e_5 e)
  | (exp_app e1 e2) => exp_app (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | (exp_merge e1 e2) => exp_merge (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | (exp_anno e A) => exp_anno (open_exp_wrt_exp_rec k e_5 e) A
  | (exp_rcd l e) => exp_rcd l (open_exp_wrt_exp_rec k e_5 e)
  | (exp_proj e l) => exp_proj (open_exp_wrt_exp_rec k e_5 e) l
end.

Definition open_texp_wrt_texp t_5 t__6 := open_texp_wrt_texp_rec 0 t__6 t_5.

Definition open_exp_wrt_exp e_5 e__6 := open_exp_wrt_exp_rec 0 e__6 e_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_texp *)
Inductive lc_texp : texp -> Prop :=    (* defn lc_texp *)
 | lc_texp_var_f : forall (x:var),
     (lc_texp (texp_var_f x))
 | lc_texp_base : forall (b:lit),
     (lc_texp (texp_base b))
 | lc_texp_abs : forall (t:texp),
      ( forall x , lc_texp  ( open_texp_wrt_texp t (texp_var_f x) )  )  ->
     (lc_texp (texp_abs t))
 | lc_texp_fixpoint : forall (t:texp),
      ( forall x , lc_texp  ( open_texp_wrt_texp t (texp_var_f x) )  )  ->
     (lc_texp (texp_fixpoint t))
 | lc_texp_app : forall (t1 t2:texp),
     (lc_texp t1) ->
     (lc_texp t2) ->
     (lc_texp (texp_app t1 t2))
 | lc_texp_nil :
     (lc_texp texp_nil)
 | lc_texp_cons : forall (ll:tindex) (t1' t2:texp),
     (lc_texp t1') ->
     (lc_texp t2) ->
     (lc_texp (texp_cons ll t1' t2))
 | lc_texp_proj : forall (t1:texp) (ll:tindex),
     (lc_texp t1) ->
     (lc_texp (texp_proj t1 ll))
 | lc_texp_concat : forall (t1 t2:texp),
     (lc_texp t1) ->
     (lc_texp t2) ->
     (lc_texp (texp_concat t1 t2)).

(* defns LC_exp *)
Inductive lc_exp : exp -> Prop :=    (* defn lc_exp *)
 | lc_exp_top :
     (lc_exp exp_top)
 | lc_exp_base : forall (b:lit),
     (lc_exp (exp_base b))
 | lc_exp_var_f : forall (x:var),
     (lc_exp (exp_var_f x))
 | lc_exp_abs : forall (A:typ) (e:exp) (B:typ),
      ( forall x , lc_exp  ( open_exp_wrt_exp e (exp_var_f x) )  )  ->
     (lc_exp (exp_abs A e B))
 | lc_exp_fixpoint : forall (A:typ) (e:exp),
      ( forall x , lc_exp  ( open_exp_wrt_exp e (exp_var_f x) )  )  ->
     (lc_exp (exp_fixpoint A e))
 | lc_exp_app : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (exp_app e1 e2))
 | lc_exp_merge : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (exp_merge e1 e2))
 | lc_exp_anno : forall (e:exp) (A:typ),
     (lc_exp e) ->
     (lc_exp (exp_anno e A))
 | lc_exp_rcd : forall (l:label) (e:exp),
     (lc_exp e) ->
     (lc_exp (exp_rcd l e))
 | lc_exp_proj : forall (e:exp) (l:label),
     (lc_exp e) ->
     (lc_exp (exp_proj e l)).
(** free variables *)
Fixpoint fv_texp (t_5:texp) : vars :=
  match t_5 with
  | (texp_var_b nat) => {}
  | (texp_var_f x) => {{x}}
  | (texp_base b) => {}
  | (texp_abs t) => (fv_texp t)
  | (texp_fixpoint t) => (fv_texp t)
  | (texp_app t1 t2) => (fv_texp t1) \u (fv_texp t2)
  | texp_nil => {}
  | (texp_cons ll t1' t2) => (fv_texp t1') \u (fv_texp t2)
  | (texp_proj t1 ll) => (fv_texp t1)
  | (texp_concat t1 t2) => (fv_texp t1) \u (fv_texp t2)
end.

Fixpoint fv_exp (e_5:exp) : vars :=
  match e_5 with
  | exp_top => {}
  | (exp_base b) => {}
  | (exp_var_b nat) => {}
  | (exp_var_f x) => {{x}}
  | (exp_abs A e B) => (fv_exp e)
  | (exp_fixpoint A e) => (fv_exp e)
  | (exp_app e1 e2) => (fv_exp e1) \u (fv_exp e2)
  | (exp_merge e1 e2) => (fv_exp e1) \u (fv_exp e2)
  | (exp_anno e A) => (fv_exp e)
  | (exp_rcd l e) => (fv_exp e)
  | (exp_proj e l) => (fv_exp e)
end.

(** substitutions *)
Fixpoint subst_texp (t_5:texp) (x5:var) (t__6:texp) {struct t__6} : texp :=
  match t__6 with
  | (texp_var_b nat) => texp_var_b nat
  | (texp_var_f x) => (if eq_var x x5 then t_5 else (texp_var_f x))
  | (texp_base b) => texp_base b
  | (texp_abs t) => texp_abs (subst_texp t_5 x5 t)
  | (texp_fixpoint t) => texp_fixpoint (subst_texp t_5 x5 t)
  | (texp_app t1 t2) => texp_app (subst_texp t_5 x5 t1) (subst_texp t_5 x5 t2)
  | texp_nil => texp_nil
  | (texp_cons ll t1' t2) => texp_cons ll (subst_texp t_5 x5 t1') (subst_texp t_5 x5 t2)
  | (texp_proj t1 ll) => texp_proj (subst_texp t_5 x5 t1) ll
  | (texp_concat t1 t2) => texp_concat (subst_texp t_5 x5 t1) (subst_texp t_5 x5 t2)
end.

Fixpoint esubst_exp (e_5:exp) (x5:var) (e__6:exp) {struct e__6} : exp :=
  match e__6 with
  | exp_top => exp_top
  | (exp_base b) => exp_base b
  | (exp_var_b nat) => exp_var_b nat
  | (exp_var_f x) => (if eq_var x x5 then e_5 else (exp_var_f x))
  | (exp_abs A e B) => exp_abs A (esubst_exp e_5 x5 e) B
  | (exp_fixpoint A e) => exp_fixpoint A (esubst_exp e_5 x5 e)
  | (exp_app e1 e2) => exp_app (esubst_exp e_5 x5 e1) (esubst_exp e_5 x5 e2)
  | (exp_merge e1 e2) => exp_merge (esubst_exp e_5 x5 e1) (esubst_exp e_5 x5 e2)
  | (exp_anno e A) => exp_anno (esubst_exp e_5 x5 e) A
  | (exp_rcd l e) => exp_rcd l (esubst_exp e_5 x5 e)
  | (exp_proj e l) => exp_proj (esubst_exp e_5 x5 e) l
end.


Require Import Strings.String.
Require Import Sorting.Sorted.
Require Import Sorting.Mergesort.
Require Import List Setoid Permutation Sorted Orders OrdersEx.
Require Import StructTact.StringOrders.

Module NOTF := OT_to_Full string_lex_as_OT.
Module NTTLB := OTF_to_TTLB NOTF.
Module Export NSort := Sort NTTLB.

Open Scope string_scope.

Definition LS := list string.

(* dedup => fold_left append (nodup string_dec l) "". *)
Definition list_string_2_string (l : LS) : string :=
  fold_left append l "".

Coercion list_string_2_string : LS >-> string.

Fixpoint stype2string (A: typ) : LS :=
  if (check_toplike A) then nil
  else
    match A with
    | typ_top => nil
    | typ_bot => [ "Bot" ]
    | typ_base => [ "Base" ]
    | typ_arrow A1 A2 => [ ( "(" ++ (stype2string A1) ++ "->" ++ (stype2string A2) ++ ")" ) ]
    | typ_rcd l A' => ["{" ++  l ++ "=>" ++ (stype2string A') ++ "}"]
    | typ_and A1 A2 => nodup string_dec (merge (stype2string A1) (stype2string A2))
    end.

Notation "|| A ||" := (stype2string A) (at level 50, A at next level). (* 1 is too high *)

Fixpoint ttyp_concat_simpl (A: ttyp) (B: ttyp) :=
  match A with
  | ttyp_top => B
  | ttyp_rcd l At Bt => ttyp_rcd l At (ttyp_concat_simpl Bt B)
  | _ => ttyp_top
  end.

Reserved Notation "|[ A ]|" (at level 5, A at next level).
Fixpoint styp2ttyp (A: typ) : ttyp :=
  if (check_toplike A) then ttyp_top
  else match A with
  | typ_top => ttyp_top
  | typ_bot => ttyp_rcd (|| A ||) ttyp_bot ttyp_top
  | typ_base => ttyp_rcd (|| A ||) ttyp_base ttyp_top
  | typ_arrow B1 B2 => ttyp_rcd (|| A ||) ( ttyp_arrow (|[ B1 ]|) (|[ B2 ]|)) ttyp_top
  | typ_rcd l A' => ttyp_rcd (|| A ||) (|[ A' ]|) ttyp_top
  | typ_and A1 A2 => ttyp_concat_simpl (|[ A1 ]|) (|[ A2 ]|)
  end
where "|[ A ]|" := (styp2ttyp A).

Definition string_eq_dec : forall (x y : string), { x = y } + { x <> y }.
Proof.
  repeat decide equality.
Defined.

Fixpoint tlookup (i:string) (tr:texp) : option texp :=
  match tr with
  | texp_cons ti t tr' => if string_eq_dec i ti then Some t else tlookup i tr'
  | _ => None
  end.

Fixpoint Tlookup (i:string) (T:ttyp) : option ttyp :=
  match T with
  | ttyp_rcd ti At Bt => if string_eq_dec i ti then Some At else Tlookup i Bt
  | _ => None
  end.

Inductive subTarget : ttyp -> ttyp -> Prop :=
 | ST_refl : forall At,
     subTarget At At
| ST_arrow: forall At Bt At' Bt',
    subTarget At At' -> subTarget At' At -> subTarget Bt Bt' -> subTarget Bt' Bt -> subTarget (ttyp_arrow At Bt) (ttyp_arrow At' Bt')
 | ST_rcd : forall At Bt,
     rec_typ At -> rec_typ Bt ->
     (forall l Ct, Tlookup l At = Some Ct -> exists Ct', Tlookup l Bt = Some Ct' /\ subTarget Ct' Ct /\ subTarget Ct Ct') ->
     subTarget Bt At.

#[export] Hint Constructors subTarget : core.


(** definitions *)

(* defns TopLikeType *)
Inductive toplike : typ -> Prop :=    (* defn toplike *)
 | TL_top :
     toplike typ_top
 | TL_and : forall (A B:typ),
     toplike A ->
     toplike B ->
     toplike (typ_and A B)
 | TL_arr : forall (A B:typ),
     toplike B ->
     toplike (typ_arrow A B)
 | TL_rcd : forall (l:label) (B:typ),
     toplike B ->
     toplike (typ_rcd l B).

(* defns SplitType *)
Inductive spl : typ -> typ -> typ -> Prop :=    (* defn spl *)
 | Sp_and : forall (A B:typ),
     spl  (typ_and A B)   A   B
 | Sp_arrow : forall (A B B1 B2:typ),
     spl B B1 B2 ->
     spl  (typ_arrow A B)   (typ_arrow A B1)   (typ_arrow A B2)
 | Sp_rcd : forall (l:label) (B B1 B2:typ),
     spl B B1 B2 ->
     spl (typ_rcd l B) (typ_rcd l B1) (typ_rcd l B2).

(* defns OrdinaryType *)
Inductive ord : typ -> Prop :=    (* defn ord *)
 | O_top :
     ord typ_top
 | O_int :
     ord typ_base
 | O_arrow : forall (A B:typ),
     ord B ->
     ord (typ_arrow A B)
 | O_rcd : forall (l:label) (B:typ),
     ord B ->
     ord (typ_rcd l B).

(* defns Disjoint *)
Inductive disjoint : typ -> typ -> Prop :=    (* defn disjoint *)
 | D_topL : forall (A:typ),
     disjoint typ_top A
 | D_topR : forall (A:typ),
     disjoint A typ_top
 | D_andL : forall (A1 A2 B:typ),
     disjoint A1 B ->
     disjoint A2 B ->
     disjoint (typ_and A1 A2) B
 | D_andR : forall (A B1 B2:typ),
     disjoint A B1 ->
     disjoint A B2 ->
     disjoint A (typ_and B1 B2)
 | D_BaseArr : forall (A1 A2:typ),
     disjoint typ_base (typ_arrow A1 A2)
 | D_ArrBase : forall (A1 A2:typ),
     disjoint (typ_arrow A1 A2) typ_base
 | D_ArrArr : forall (A1 A2 B1 B2:typ),
     disjoint A2 B2 ->
     disjoint (typ_arrow A1 A2) (typ_arrow B1 B2)
 | D_rcdEq : forall (l:label) (A B:typ),
     disjoint A B ->
     disjoint (typ_rcd l A) (typ_rcd l B)
 | D_rcdNeq : forall (l1:label) (A:typ) (l2:label) (B:typ),
      l1  <>  l2  ->
     disjoint (typ_rcd l1 A) (typ_rcd l2 B)
 | D_BaseRcd : forall (l:label) (A:typ),
     disjoint typ_base (typ_rcd l A)
 | D_RcdBase : forall (l:label) (A:typ),
     disjoint (typ_rcd l A) typ_base
 | D_ArrRcd : forall (A1 A2:typ) (l:label) (A:typ),
     disjoint (typ_arrow A1 A2) (typ_rcd l A)
 | D_RcdArr : forall (l:label) (A A1 A2:typ),
     disjoint (typ_rcd l A) (typ_arrow A1 A2).

(* defns CoMerge *)
Inductive comerge : texp -> typ -> typ -> texp -> typ -> texp -> Prop :=    (* defn comerge *)
 | M_Top : forall (t1:texp) (A C:typ) (t2:texp) (B:typ),
     lc_texp t1 ->
     lc_texp t2 ->
     toplike C ->
     spl C A B ->
     comerge t1 A C t2 B texp_nil
 | M_And : forall (t1:texp) (A B:typ) (t2:texp),
     lc_texp t1 ->
     lc_texp t2 ->
      not ( toplike (typ_and A B) )  ->
     comerge t1 A (typ_and A B) t2 B (texp_concat t1 t2)
 | M_Arrow : forall (L:vars) (t1:texp) (A B1 B:typ) (t2:texp) (B2:typ) (t:texp),
      not ( toplike B1 )  ->
      not ( toplike B2 )  ->
      ( forall x , x \notin  L  -> comerge (texp_app  (texp_proj t1  (styp2typeindex ( (typ_arrow A B1) )) )  (texp_var_f x)) B1 B (texp_app  (texp_proj t2  (styp2typeindex ( (typ_arrow A B2) )) )  (texp_var_f x)) B2  ( open_texp_wrt_texp t (texp_var_f x) )  )  ->
     comerge t1 (typ_arrow A B1) (typ_arrow A B) t2 (typ_arrow A B2)  (texp_cons   (styp2typeindex ( (typ_arrow A B) ))    (texp_abs t)  texp_nil)
 | M_ArrowL : forall (L:vars) (t1:texp) (A B1 B:typ) (t2:texp) (B2:typ) (t:texp),
     lc_texp t2 ->
      not ( toplike B1 )  ->
     toplike B2 ->
      ( forall x , x \notin  L  -> comerge (texp_app  (texp_proj t1  (styp2typeindex ( (typ_arrow A B1) )) )  (texp_var_f x)) B1 B texp_nil B2  ( open_texp_wrt_texp t (texp_var_f x) )  )  ->
     comerge t1 (typ_arrow A B1) (typ_arrow A B) t2 (typ_arrow A B2)  (texp_cons   (styp2typeindex ( (typ_arrow A B) ))    (texp_abs t)  texp_nil)
 | M_ArrowR : forall (L:vars) (t1:texp) (A B1 B:typ) (t2:texp) (B2:typ) (t:texp),
     lc_texp t1 ->
     toplike B1 ->
      not ( toplike B2 )  ->
      ( forall x , x \notin  L  -> comerge texp_nil B1 B (texp_app  (texp_proj t2  (styp2typeindex ( (typ_arrow A B2) )) )  (texp_var_f x)) B2  ( open_texp_wrt_texp t (texp_var_f x) )  )  ->
     comerge t1 (typ_arrow A B1) (typ_arrow A B) t2 (typ_arrow A B2)  (texp_cons   (styp2typeindex ( (typ_arrow A B) ))    (texp_abs t)  texp_nil)
 | M_Rcd : forall (t1:texp) (l:label) (A1 A:typ) (t2:texp) (A2:typ) (t:texp),
      not ( toplike A1 )  ->
      not ( toplike A2 )  ->
     comerge (texp_proj t1  (styp2typeindex ( (typ_rcd l A1) )) ) A1 A (texp_proj t2  (styp2typeindex ( (typ_rcd l A2) )) ) A2 t ->
     comerge t1 (typ_rcd l A1) (typ_rcd l A) t2 (typ_rcd l A2)  (texp_cons   (styp2typeindex ( (typ_rcd l A) ))    t  texp_nil)
 | M_RcdL : forall (t1:texp) (l:label) (A1 A:typ) (t2:texp) (A2:typ) (t:texp),
     lc_texp t2 ->
      not ( toplike A1 )  ->
     toplike A2 ->
     comerge (texp_proj t1  (styp2typeindex ( (typ_rcd l A1) )) ) A1 A texp_nil A2 t ->
     comerge t1 (typ_rcd l A1) (typ_rcd l A) t2 (typ_rcd l A2)  (texp_cons   (styp2typeindex ( (typ_rcd l A) ))    t  texp_nil)
 | M_RcdR : forall (t1:texp) (l:label) (A1 A:typ) (t2:texp) (A2:typ) (t:texp),
     lc_texp t1 ->
     toplike A1 ->
      not ( toplike A2 )  ->
     comerge texp_nil A1 A (texp_proj t2  (styp2typeindex ( (typ_rcd l A2) )) ) A2 t ->
     comerge t1 (typ_rcd l A1) (typ_rcd l A) t2 (typ_rcd l A2)  (texp_cons   (styp2typeindex ( (typ_rcd l A) ))    t  texp_nil) .

(* defns CoSubtyping *)
Inductive cosub : texp -> typ -> typ -> texp -> Prop :=    (* defn cosub *)
 | S_Top : forall (t:texp) (A B:typ),
     lc_texp t ->
     ord B ->
     toplike B ->
     cosub t A B texp_nil
 | S_Bot : forall (t:texp) (B:typ) (x:var),
     lc_texp t ->
     ord B ->
      not ( toplike B )  ->
     cosub t typ_bot B  (texp_cons   (styp2typeindex ( B ))    (texp_fixpoint (texp_var_b 0))  texp_nil)
 | S_Base : forall (t:texp),
     lc_texp t ->
     cosub t typ_base typ_base  (texp_cons   (styp2typeindex ( typ_base ))    (texp_proj t  (styp2typeindex ( typ_base )) )  texp_nil)
 | S_Arrow : forall (L:vars) (t:texp) (A1 A2 B1 B2:typ) (t2 t1:texp),
     ord B2 ->
      not ( toplike B2 )  ->
      ( forall x , x \notin  L  ->  ( cosub (texp_var_f x) B1 A1 t1  /\  cosub (texp_app  (texp_proj t  (styp2typeindex ( (typ_arrow A1 A2) )) )  t1) A2 B2  ( open_texp_wrt_texp t2 (texp_var_f x) )  )  )  ->
     cosub t (typ_arrow A1 A2) (typ_arrow B1 B2)  (texp_cons   (styp2typeindex ( (typ_arrow B1 B2) ))    (texp_abs t2)  texp_nil)
 | S_Rcd : forall (t:texp) (l:label) (A B:typ) (t2:texp),
     ord B ->
      not ( toplike B )  ->
     cosub (texp_proj t  (styp2typeindex ( (typ_rcd l A) )) ) A B t2 ->
     cosub t (typ_rcd l A) (typ_rcd l B)  (texp_cons   (styp2typeindex ( (typ_rcd l B) ))    t2  texp_nil)
 | S_AndL : forall (t:texp) (A B C:typ) (t':texp),
     ord C ->
     cosub t A C t' ->
     cosub t (typ_and A B) C t'
 | S_AndR : forall (t:texp) (A B C:typ) (t':texp),
     ord C ->
     cosub t B C t' ->
     cosub t (typ_and A B) C t'
 | S_Split : forall (t:texp) (A B:typ) (t3:texp) (B1 B2:typ) (t1 t2:texp),
     spl B B1 B2 ->
     cosub t A B1 t1 ->
     cosub t A B2 t2 ->
     comerge t1 B1 B t2 B2 t3 ->
     cosub t A B t3.

(* defns Subtyping *)
Inductive sub : typ -> typ -> Prop :=    (* defn sub *)
 | S_z :
     sub typ_base typ_base
 | S_top : forall (A B:typ),
     toplike B ->
     sub A B
 | S_bot :
     sub typ_bot typ_bot
 | S_arr : forall (A1 A2 B1 B2:typ),
     sub B1 A1 ->
     sub A1 B1 ->
     sub A2 B2 ->
     sub B2 A2 ->
     sub (typ_arrow A1 A2) (typ_arrow B1 B2)
 | S_rcd : forall (l:label) (A B:typ),
     sub A B ->
     sub B A ->
     sub (typ_rcd l A) (typ_rcd l B)
 | S_andl1 : forall (A1 A2 A3:typ),
     sub A1 A3 ->
     sub (typ_and A1 A2) A3
 | S_andl2 : forall (A1 A2 A3:typ),
     sub A2 A3 ->
     sub (typ_and A1 A2) A3
 | S_andr : forall (A1 A2 A3:typ),
     sub A1 A2 ->
     sub A1 A3 ->
     sub A1 (typ_and A2 A3).

(* defns Projection *)
Inductive proj : texp -> typ -> label -> texp -> typ -> Prop :=    (* defn proj *)
 | P_Top : forall (t1:texp) (A:typ) (l:label),
     lc_texp t1 ->
     toplike A ->
     proj t1 A l texp_nil typ_top
 | P_RcdEq : forall (t:texp) (l:label) (A:typ),
     lc_texp t ->
      not ( toplike A )  ->
     proj t (typ_rcd l A) l (texp_proj t  (styp2typeindex ( (typ_rcd l A) )) ) A
 | P_RcdNeq : forall (t:texp) (l1:label) (A:typ) (l2:label),
     lc_texp t ->
      not ( toplike A )  ->
      l1  <>  l2  ->
     proj t (typ_rcd l1 A) l2 texp_nil typ_top
 | P_And : forall (t1:texp) (A B:typ) (l:label) (t3 t4:texp) (A' B':typ),
     proj t1 A l t3 A' ->
     proj t1 B l t4 B' ->
     proj t1 (typ_and A B) l (texp_concat t3 t4) (typ_and A' B').

(* defns DistributiveApplication *)
Inductive distapp : texp -> typ -> texp -> typ -> texp -> typ -> Prop :=    (* defn distapp *)
 | A_Top : forall (t1:texp) (A:typ) (t2:texp) (B:typ),
     lc_texp t1 ->
     lc_texp t2 ->
     toplike A ->
     distapp t1 A t2 B texp_nil typ_top
 | A_Arrow : forall (t1:texp) (A B:typ) (t2:texp) (C:typ) (t3:texp),
     lc_texp t1 ->
      not ( toplike B )  ->
     cosub t2 C A t3 ->
     distapp t1 (typ_arrow A B) t2 C (texp_app  (texp_proj t1  (styp2typeindex ( (typ_arrow A B) )) )  t3) B
 | A_And : forall (t1:texp) (A B:typ) (t2:texp) (C:typ) (t3 t4:texp) (A' B':typ),
     distapp t1 A t2 C t3 A' ->
     distapp t1 B t2 C t4 B' ->
     distapp t1 (typ_and A B) t2 C (texp_concat t3 t4) (typ_and A' B').

(* defns Elaboration *)
Inductive elaboration : ctx -> exp -> dirflag -> typ -> texp -> Prop :=    (* defn elaboration *)
 | Ela_Top : forall (G:ctx),
      uniq  G  ->
     elaboration G exp_top Inf typ_top texp_nil
 | Ela_TopAbs : forall (G:ctx) (A:typ) (e:exp) (B:typ),
     lc_exp (exp_abs A e B) ->
      uniq  G  ->
     toplike B ->
     elaboration G (exp_abs A e B) Inf (typ_arrow A B) texp_nil
 | Ela_TopRcd : forall (G:ctx) (l:label) (e:exp) (A:typ) (t:texp),
     elaboration G e Inf A t ->
     toplike A ->
     elaboration G (exp_rcd l e) Inf (typ_rcd l A) texp_nil
 | Ela_Base : forall (G:ctx) (b:lit),
      uniq  G  ->
     elaboration G (exp_base b) Inf typ_base  (texp_cons   (styp2typeindex ( typ_base ))    (texp_base b)  texp_nil)
 | Ela_Var : forall (G:ctx) (x:var) (A:typ),
      uniq  G  ->
      binds  x A G  ->
     elaboration G (exp_var_f x) Inf A (texp_var_f x)
 | Ela_Fix : forall (L:vars) (G:ctx) (A:typ) (e:exp) (t:texp),
      ( forall x , x \notin  L  -> elaboration  (cons ( x , A )  G )   ( open_exp_wrt_exp e (exp_var_f x) )  Chk A  ( open_texp_wrt_texp t (texp_var_f x) )  )  ->
     elaboration G (exp_fixpoint A e) Inf A (texp_fixpoint t)
 | Ela_Abs : forall (L:vars) (G:ctx) (A:typ) (e:exp) (B:typ) (t:texp),
      not ( toplike B )  ->
      ( forall x , x \notin  L  -> elaboration  (cons ( x , A )  G )   ( open_exp_wrt_exp e (exp_var_f x) )  Chk B  ( open_texp_wrt_texp t (texp_var_f x) )  )  ->
     elaboration G (exp_abs A e B) Inf (typ_arrow A B)  (texp_cons   (styp2typeindex ( (typ_arrow A B) ))    (texp_abs t)  texp_nil)
 | Ela_App : forall (G:ctx) (e1 e2:exp) (C:typ) (t3:texp) (A:typ) (t1:texp) (B':typ) (t2:texp),
     elaboration G e1 Inf A t1 ->
     elaboration G e2 Inf B' t2 ->
     distapp t1 A t2 B' t3 C ->
     elaboration G (exp_app e1 e2) Inf C t3
 | Ela_Rcd : forall (G:ctx) (l:label) (e:exp) (A:typ) (t:texp),
      not ( toplike A )  ->
     elaboration G e Inf A t ->
     elaboration G (exp_rcd l e) Inf (typ_rcd l A)  (texp_cons   (styp2typeindex ( (typ_rcd l A) ))    t  texp_nil)
 | Ela_Proj : forall (G:ctx) (e:exp) (l:label) (B:typ) (t2:texp) (A:typ) (t1:texp),
     elaboration G e Inf A t1 ->
     proj t1 A l t2 B ->
     elaboration G (exp_proj e l) Inf B t2
 | Ela_Merge : forall (G:ctx) (e1 e2:exp) (A B:typ) (t1 t2:texp),
     elaboration G e1 Inf A t1 ->
     elaboration G e2 Inf B t2 ->
     disjoint A B ->
     elaboration G (exp_merge e1 e2) Inf (typ_and A B) (texp_concat t1 t2)
 | Ela_Anno : forall (G:ctx) (e:exp) (A:typ) (t:texp),
     elaboration G e Chk A t ->
     elaboration G (exp_anno e A) Inf A t
 | Ela_Sub : forall (G:ctx) (e:exp) (B:typ) (t2:texp) (A:typ) (t1:texp),
     elaboration G e Inf A t1 ->
     cosub t1 A B t2 ->
     elaboration G e Chk B t2.

(* defns Values *)
Inductive value : texp -> Prop :=    (* defn value *)
 | value_unit :
     value texp_nil
 | value_lit : forall (b:lit),
     value (texp_base b)
 | value_abs : forall (t:texp),
     lc_texp (texp_abs t) ->
     value (texp_abs t)
 | value_merge : forall (ll:tindex) (tv1 tv2:texp),
     value tv1 ->
     value tv2 ->
     value (texp_cons ll tv1 tv2).

(* defns TargetStep *)
Inductive target_step : texp -> texp -> Prop :=    (* defn target_step *)
 | TS_Proj1 : forall (t:texp) (ll:tindex) (t':texp),
     target_step t t' ->
     target_step (texp_proj t ll) (texp_proj t' ll)
 | TS_AppL : forall (t t2 t':texp),
     lc_texp t2 ->
     target_step t t' ->
     target_step (texp_app t t2) (texp_app t' t2)
 | TS_AppR : forall (tv t t':texp),
     value tv ->
     target_step t t' ->
     target_step (texp_app tv t) (texp_app tv t')
 | TS_MergeL : forall (t t2 t':texp),
     lc_texp t2 ->
     target_step t t' ->
     target_step (texp_concat t t2) (texp_concat t' t2)
 | TS_MergeR : forall (tv t t':texp),
     value tv ->
     target_step t t' ->
     target_step (texp_concat tv t) (texp_concat tv t')
 | TS_RcdHead : forall (ll:tindex) (t t2 t':texp),
     lc_texp t2 ->
     target_step t t' ->
     target_step (texp_cons ll t t2) (texp_cons ll t' t2)
 | TS_RcdTail : forall (ll:tindex) (tv t t':texp),
     value tv ->
     target_step t t' ->
     target_step (texp_cons ll tv t) (texp_cons ll tv t')
 | TS_MergeEmpty : forall (tv:texp),
     value tv ->
     target_step (texp_concat texp_nil tv) tv
 | TS_MergeRcd : forall (ll:tindex) (tv1 tv2 tv3:texp),
     value tv1 ->
     value tv2 ->
     value tv3 ->
     target_step (texp_concat  (texp_cons ll tv1 tv2)  tv3) (texp_cons ll tv1  (texp_concat tv2 tv3) )
 | TS_ProjRcd : forall (tv:texp) (ll:tindex) (t:texp),
     value tv ->
      tlookup  ll   tv  = Some  t  ->
     target_step (texp_proj tv ll) t
 | TS_AppAbs : forall (t tv:texp),
     lc_texp (texp_abs t) ->
     lc_texp tv ->
     target_step (texp_app  (texp_abs t)  tv)  (open_texp_wrt_texp  t tv )
 | TS_Fixpoint : forall (t:texp),
     lc_texp (texp_fixpoint t) ->
     target_step (texp_fixpoint t)  (open_texp_wrt_texp  t (texp_fixpoint t) ) .

(* defns RecordTypes *)
Inductive rec_typ : ttyp -> Prop :=    (* defn rec_typ *)
 | RT_Nil :
     rec_typ ttyp_top
 | RT_Rcd : forall (ll:tindex) (At Bt:ttyp),
     rec_typ Bt ->
     rec_typ (ttyp_rcd ll At Bt).

(* defns ConcatTypes *)
Inductive concat_typ : ttyp -> ttyp -> ttyp -> Prop :=    (* defn concat_typ *)
 | CT_Nil : forall (Bt:ttyp),
     rec_typ Bt ->
     concat_typ ttyp_top Bt Bt
 | CT_Rcd : forall (ll:tindex) (At Bt1 Bt2 Ct At':ttyp),
      (   (  Tlookup  ll   Bt2  = Some  At'   /\   subTarget  At'   At  /\ subTarget  At   At'  )    \/   Tlookup  ll   Bt2  = None  )  ->
     concat_typ Bt1 Bt2 Ct ->
     concat_typ  (ttyp_rcd ll At Bt1)  Bt2 (ttyp_rcd ll At Ct).

(* defns ContainedByRecTyp *)
Inductive contained_by_rec_typ : ttyp -> tindex -> ttyp -> Prop :=    (* defn contained_by_rec_typ *)
 | CRT_Head : forall (ll1:tindex) (At Bt:ttyp),
     contained_by_rec_typ  (ttyp_rcd ll1 At Bt)  ll1 At
 | CRT_Tail : forall (ll1:tindex) (At Bt:ttyp) (ll2:tindex) (Ct:ttyp),
     contained_by_rec_typ Bt ll2 Ct ->
     contained_by_rec_typ  (ttyp_rcd ll1 At Bt)  ll2 Ct.

(* defns WelformedTypes *)
Inductive wf_typ : ttyp -> Prop :=    (* defn wf_typ *)
 | WF_Nil :
     wf_typ ttyp_top
 | WF_Bot :
     wf_typ ttyp_bot
 | WF_Base :
     wf_typ ttyp_base
 | WF_Rcd : forall (ll:tindex) (At Bt At':ttyp),
     wf_typ At ->
     wf_typ Bt ->
     rec_typ Bt ->
      (   (  Tlookup  ll   Bt  = Some  At'   /\   subTarget  At'   At  /\ subTarget  At   At'  )    \/   Tlookup  ll   Bt  = None  )  ->
     wf_typ (ttyp_rcd ll At Bt)
 | WF_Arrow : forall (At Bt:ttyp),
     wf_typ At ->
     wf_typ Bt ->
     wf_typ (ttyp_arrow At Bt).

(* defns WelformedCtx *)
Inductive wf_ctx : tctx -> Prop :=    (* defn wf_ctx *)
 | WFC_Nil :
     wf_ctx  nil
 | WFC_Cons : forall (Gt:tctx) (x:var) (At:ttyp),
     wf_typ At ->
     wf_ctx Gt ->
     wf_ctx  (cons ( x , At )  Gt ) .

(* defns TargetSubtype *)
Inductive SubtypeTarget : ttyp -> ttyp -> Prop :=    (* defn SubtypeTarget *)
 | TS_top : forall (At:ttyp),
     wf_typ At ->
     SubtypeTarget At ttyp_top
 | TS_refl : forall (At:ttyp),
     wf_typ At ->
     SubtypeTarget At At
 | TS_arrow : forall (At1 Bt1 At2 Bt2:ttyp),
     SubtypeTarget At1 At2 ->
     SubtypeTarget Bt1 Bt2 ->
     SubtypeTarget (ttyp_arrow At1 Bt1) (ttyp_arrow At2 Bt2)
 | TS_rcd : forall (Ct:ttyp) (ll:tindex) (At Ct' Bt At':ttyp),
     rec_typ Ct' ->
      Tlookup  ll   Ct  = Some  Bt  ->
     SubtypeTarget Bt At ->
      (   (  Tlookup  ll   Ct'  = Some  At'   /\   subTarget  At'   At  /\ subTarget  At   At'  )    \/   Tlookup  ll   Ct'  = None  )  ->
     SubtypeTarget Ct Ct' ->
     SubtypeTarget Ct (ttyp_rcd ll At Ct').

(* defns TargetTyping *)
Inductive target_typing : tctx -> texp -> ttyp -> Prop :=    (* defn target_typing *)
 | TTyping_Base : forall (Gt:tctx) (b:lit),
      uniq  Gt  ->
     wf_ctx Gt ->
     target_typing Gt (texp_base b) ttyp_base
 | TTyping_Var : forall (Gt:tctx) (x:var) (At:ttyp),
      uniq  Gt  ->
     wf_ctx Gt ->
      binds  x At Gt  ->
     target_typing Gt (texp_var_f x) At
 | TTyping_Abs : forall (L:vars) (Gt:tctx) (t:texp) (At Bt:ttyp),
      ( forall x , x \notin  L  -> target_typing  (cons ( x , At )  Gt )   ( open_texp_wrt_texp t (texp_var_f x) )  Bt )  ->
     target_typing Gt (texp_abs t) (ttyp_arrow At Bt)
 | TTyping_Fix : forall (L:vars) (Gt:tctx) (t:texp) (At Bt:ttyp),
      ( forall x , x \notin  L  -> target_typing  (cons ( x , Bt )  Gt )   ( open_texp_wrt_texp t (texp_var_f x) )  At )  ->
      subTarget  At   Bt  /\ subTarget  Bt   At  ->
     target_typing Gt (texp_fixpoint t) At
 | TTyping_App : forall (Gt:tctx) (t1 t2:texp) (Bt At At':ttyp),
     target_typing Gt t1 (ttyp_arrow At Bt) ->
     target_typing Gt t2 At' ->
      subTarget  At   At'  /\ subTarget  At'   At  ->
     target_typing Gt (texp_app t1 t2) Bt
 | TTyping_RcdNil : forall (Gt:tctx),
      uniq  Gt  ->
     wf_ctx Gt ->
     target_typing Gt texp_nil ttyp_top
 | TTyping_RcdCons : forall (Gt:tctx) (ll:tindex) (t1 t2:texp) (At Bt At':ttyp),
     rec_typ Bt ->
      (   (  Tlookup  ll   Bt  = Some  At'   /\   subTarget  At'   At  /\ subTarget  At   At'  )    \/   Tlookup  ll   Bt  = None  )  ->
     target_typing Gt t1 At ->
     target_typing Gt t2 Bt ->
     target_typing Gt  (texp_cons ll t1 t2)   (ttyp_rcd ll At Bt)
 | TTyping_RcdProj : forall (Gt:tctx) (t:texp) (ll:tindex) (Bt At:ttyp),
     target_typing Gt t At ->
      Tlookup  ll   At  = Some  Bt  ->
     target_typing Gt (texp_proj t ll) Bt
 | TTyping_RcdMerge : forall (Gt:tctx) (t1 t2:texp) (Ct At Bt:ttyp),
     rec_typ At ->
     rec_typ Bt ->
     target_typing Gt t1 At ->
     target_typing Gt t2 Bt ->
     concat_typ At Bt Ct ->
     target_typing Gt (texp_concat t1 t2) Ct.


(** infrastructure *)
Hint Constructors toplike spl ord disjoint comerge cosub sub proj distapp elaboration value target_step rec_typ concat_typ contained_by_rec_typ wf_typ wf_ctx SubtypeTarget target_typing lc_texp lc_exp : core.
